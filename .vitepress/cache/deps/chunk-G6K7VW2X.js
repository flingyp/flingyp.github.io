import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  customRef,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  h,
  isVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  openBlock,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  toRef,
  toValue,
  unref,
  useAttrs,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives
} from "./chunk-ZNML7WN5.js";
import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/.pnpm/vitepress-plugin-legend@1.0.4_jiti@1.21.7_markmap-common@0.18.9_typescript@5.4.3_yaml@2.8.0/node_modules/vitepress-plugin-legend/dist/component-B8iEnLsv.js
var MC = "npm2url/dist/index.cjs";
var BC = {
  jsdelivr: (t15) => `https://cdn.jsdelivr.net/npm/${t15}`,
  unpkg: (t15) => `https://unpkg.com/${t15}`
};
async function LC(t15, e) {
  const r = await fetch(t15, {
    signal: e
  });
  if (!r.ok)
    throw r;
  await r.text();
}
var DC = class {
  constructor() {
    this.providers = { ...BC }, this.provider = "jsdelivr";
  }
  /**
   * Get the fastest provider name.
   * If none of the providers returns a valid response within `timeout`, an error will be thrown.
   */
  async getFastestProvider(e = 5e3, r = MC) {
    const n = new AbortController();
    let i = 0;
    try {
      return await new Promise((s, o) => {
        Promise.all(
          Object.entries(this.providers).map(async ([a, l]) => {
            try {
              await LC(l(r), n.signal), s(a);
            } catch {
            }
          })
        ).then(() => o(new Error("All providers failed"))), i = setTimeout(o, e, new Error("Timed out"));
      });
    } finally {
      n.abort(), clearTimeout(i);
    }
  }
  /**
   * Set the current provider to the fastest provider found by `getFastestProvider`.
   */
  async findFastestProvider(e, r) {
    return this.provider = await this.getFastestProvider(e, r), this.provider;
  }
  setProvider(e, r) {
    r ? this.providers[e] = r : delete this.providers[e];
  }
  getFullUrl(e, r = this.provider) {
    if (e.includes("://"))
      return e;
    const n = this.providers[r];
    if (!n)
      throw new Error(`Provider ${r} not found`);
    return n(e);
  }
};
var Ja = class {
  constructor() {
    this.listeners = [];
  }
  tap(e) {
    return this.listeners.push(e), () => this.revoke(e);
  }
  revoke(e) {
    const r = this.listeners.indexOf(e);
    r >= 0 && this.listeners.splice(r, 1);
  }
  revokeAll() {
    this.listeners.splice(0);
  }
  call(...e) {
    for (const r of this.listeners)
      r(...e);
  }
};
var FC = Math.random().toString(36).slice(2, 8);
var Yy = 0;
function NC() {
  return Yy += 1, `mm-${FC}-${Yy}`;
}
function Bo() {
}
function tl(t15, e) {
  const r = (n, i) => e(
    n,
    () => {
      var s;
      return (s = n.children) == null ? void 0 : s.map((o) => r(o, n));
    },
    i
  );
  return r(t15);
}
function IC(t15, ...e) {
  const r = (t15 || "").split(" ").filter(Boolean);
  return e.forEach((n) => {
    n && r.indexOf(n) < 0 && r.push(n);
  }), r.join(" ");
}
function Ky(t15, e) {
  return (...r) => e(t15, ...r);
}
function OC() {
  const t15 = {};
  return t15.promise = new Promise((e, r) => {
    t15.resolve = e, t15.reject = r;
  }), t15;
}
function zC(t15) {
  const e = {};
  return function(...r) {
    const n = `${r[0]}`;
    let i = e[n];
    return i || (i = {
      value: t15(...r)
    }, e[n] = i), i.value;
  };
}
function qC(t15, e) {
  const r = {
    timer: 0
  };
  function n() {
    r.timer && (window.clearTimeout(r.timer), r.timer = 0);
  }
  function i() {
    n(), r.args && (r.result = t15(...r.args));
  }
  return function(...s) {
    return n(), r.args = s, r.timer = window.setTimeout(i, e), r.result;
  };
}
var D5 = 1;
var F5 = 2;
var RC = "http://www.w3.org/2000/svg";
var Ld = "http://www.w3.org/1999/xlink";
var PC = {
  show: Ld,
  actuate: Ld,
  href: Ld
};
var jC = (t15) => typeof t15 == "string" || typeof t15 == "number";
var WC = (t15) => (t15 == null ? void 0 : t15.vtype) === D5;
var HC = (t15) => (t15 == null ? void 0 : t15.vtype) === F5;
function UC(t15, e, ...r) {
  return e = Object.assign({}, e, {
    children: r.length === 1 ? r[0] : r
  }), VC(t15, e);
}
function VC(t15, e) {
  let r;
  if (typeof t15 == "string") r = D5;
  else if (typeof t15 == "function") r = F5;
  else throw new Error("Invalid VNode type");
  return {
    vtype: r,
    type: t15,
    props: e
  };
}
function GC(t15) {
  return t15.children;
}
var XC = {
  isSvg: false
};
function Zy(t15, e) {
  Array.isArray(e) || (e = [e]), e = e.filter(Boolean), e.length && t15.append(...e);
}
function YC(t15, e, r) {
  for (const n in e)
    if (!(n === "key" || n === "children" || n === "ref"))
      if (n === "dangerouslySetInnerHTML")
        t15.innerHTML = e[n].__html;
      else if (n === "innerHTML" || n === "textContent" || n === "innerText" || n === "value" && ["textarea", "select"].includes(t15.tagName)) {
        const i = e[n];
        i != null && (t15[n] = i);
      } else n.startsWith("on") ? t15[n.toLowerCase()] = e[n] : ZC(t15, n, e[n], r.isSvg);
}
var KC = {
  className: "class",
  labelFor: "for"
};
function ZC(t15, e, r, n) {
  if (e = KC[e] || e, r === true)
    t15.setAttribute(e, "");
  else if (r === false)
    t15.removeAttribute(e);
  else {
    const i = n ? PC[e] : void 0;
    i !== void 0 ? t15.setAttributeNS(i, e, r) : t15.setAttribute(e, r);
  }
}
function QC(t15) {
  return t15.reduce((e, r) => e.concat(r), []);
}
function Yp(t15, e) {
  return Array.isArray(t15) ? QC(t15.map((r) => Yp(r, e))) : D1(t15, e);
}
function D1(t15, e = XC) {
  if (t15 == null || typeof t15 == "boolean")
    return null;
  if (t15 instanceof Node)
    return t15;
  if (HC(t15)) {
    const {
      type: r,
      props: n
    } = t15;
    if (r === GC) {
      const s = document.createDocumentFragment();
      if (n.children) {
        const o = Yp(n.children, e);
        Zy(s, o);
      }
      return s;
    }
    const i = r(n);
    return D1(i, e);
  }
  if (jC(t15))
    return document.createTextNode(`${t15}`);
  if (WC(t15)) {
    let r;
    const {
      type: n,
      props: i
    } = t15;
    if (!e.isSvg && n === "svg" && (e = Object.assign({}, e, {
      isSvg: true
    })), e.isSvg ? r = document.createElementNS(RC, n) : r = document.createElement(n), YC(r, i, e), i.children) {
      let o = e;
      e.isSvg && n === "foreignObject" && (o = Object.assign({}, o, {
        isSvg: false
      }));
      const a = Yp(i.children, o);
      a != null && Zy(r, a);
    }
    const {
      ref: s
    } = i;
    return typeof s == "function" && s(r), r;
  }
  throw new Error("mount: Invalid Vnode!");
}
function JC(t15) {
  return D1(t15);
}
function N5(...t15) {
  return JC(UC(...t15));
}
var tS = zC((t15) => {
  document.head.append(
    N5("link", {
      rel: "preload",
      as: "script",
      href: t15
    })
  );
});
var Qy = {};
async function eS(t15, e) {
  var r;
  const n = t15.type === "script" && ((r = t15.data) == null ? void 0 : r.src) || "";
  if (t15.loaded || (t15.loaded = Qy[n]), !t15.loaded) {
    const i = OC();
    if (t15.loaded = i.promise, t15.type === "script" && (document.head.append(
      N5("script", {
        ...t15.data,
        onLoad: () => i.resolve(),
        onError: i.reject
      })
    ), n ? Qy[n] = t15.loaded : i.resolve()), t15.type === "iife") {
      const { fn: s, getParams: o } = t15.data;
      s(...(o == null ? void 0 : o(e)) || []), i.resolve();
    }
  }
  await t15.loaded;
}
async function I5(t15, e) {
  t15.forEach((r) => {
    var n;
    r.type === "script" && (n = r.data) != null && n.src && tS(r.data.src);
  }), e = {
    getMarkmap: () => window.markmap,
    ...e
  };
  for (const r of t15)
    await eS(r, e);
}
function F1(t15) {
  return {
    type: "script",
    data: {
      src: t15
    }
  };
}
function O5(t15) {
  return {
    type: "stylesheet",
    data: {
      href: t15
    }
  };
}
var rS = {
  _useHtmlParser2: false
};
function Kp(t15, e) {
  if (!t15)
    return e ?? rS;
  const r = {
    _useHtmlParser2: !!t15.xmlMode,
    ...e,
    ...t15
  };
  return t15.xml ? (r._useHtmlParser2 = true, r.xmlMode = true, t15.xml !== true && Object.assign(r, t15.xml)) : t15.xmlMode && (r._useHtmlParser2 = true), r;
}
var ge;
(function(t15) {
  t15.Root = "root", t15.Text = "text", t15.Directive = "directive", t15.Comment = "comment", t15.Script = "script", t15.Style = "style", t15.Tag = "tag", t15.CDATA = "cdata", t15.Doctype = "doctype";
})(ge || (ge = {}));
function nS(t15) {
  return t15.type === ge.Tag || t15.type === ge.Script || t15.type === ge.Style;
}
var iS = ge.Root;
var sS = ge.Text;
var oS = ge.Directive;
var aS = ge.Comment;
var lS = ge.Script;
var cS = ge.Style;
var hS = ge.Tag;
var uS = ge.CDATA;
var dS = ge.Doctype;
var z5 = class {
  constructor() {
    this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(e) {
    this.parent = e;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(e) {
    this.prev = e;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(e) {
    this.next = e;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(e = false) {
    return Sl(this, e);
  }
};
var N1 = class extends z5 {
  /**
   * @param data The content of the data node
   */
  constructor(e) {
    super(), this.data = e;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(e) {
    this.data = e;
  }
};
var Xh = class extends N1 {
  constructor() {
    super(...arguments), this.type = ge.Text;
  }
  get nodeType() {
    return 3;
  }
};
var q5 = class extends N1 {
  constructor() {
    super(...arguments), this.type = ge.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var R5 = class extends N1 {
  constructor(e, r) {
    super(r), this.name = e, this.type = ge.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var I1 = class extends z5 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(e) {
    super(), this.children = e;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var e;
    return (e = this.children[0]) !== null && e !== void 0 ? e : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(e) {
    this.children = e;
  }
};
var P5 = class extends I1 {
  constructor() {
    super(...arguments), this.type = ge.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Cl = class extends I1 {
  constructor() {
    super(...arguments), this.type = ge.Root;
  }
  get nodeType() {
    return 9;
  }
};
var j5 = class extends I1 {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(e, r, n = [], i = e === "script" ? ge.Script : e === "style" ? ge.Style : ge.Tag) {
    super(n), this.name = e, this.attribs = r, this.type = i;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(e) {
    this.name = e;
  }
  get attributes() {
    return Object.keys(this.attribs).map((e) => {
      var r, n;
      return {
        name: e,
        value: this.attribs[e],
        namespace: (r = this["x-attribsNamespace"]) === null || r === void 0 ? void 0 : r[e],
        prefix: (n = this["x-attribsPrefix"]) === null || n === void 0 ? void 0 : n[e]
      };
    });
  }
};
function Xt(t15) {
  return nS(t15);
}
function Qu(t15) {
  return t15.type === ge.CDATA;
}
function Ys(t15) {
  return t15.type === ge.Text;
}
function O1(t15) {
  return t15.type === ge.Comment;
}
function pS(t15) {
  return t15.type === ge.Directive;
}
function oo(t15) {
  return t15.type === ge.Root;
}
function lr(t15) {
  return Object.prototype.hasOwnProperty.call(t15, "children");
}
function Sl(t15, e = false) {
  let r;
  if (Ys(t15))
    r = new Xh(t15.data);
  else if (O1(t15))
    r = new q5(t15.data);
  else if (Xt(t15)) {
    const n = e ? Dd(t15.children) : [], i = new j5(t15.name, { ...t15.attribs }, n);
    n.forEach((s) => s.parent = i), t15.namespace != null && (i.namespace = t15.namespace), t15["x-attribsNamespace"] && (i["x-attribsNamespace"] = { ...t15["x-attribsNamespace"] }), t15["x-attribsPrefix"] && (i["x-attribsPrefix"] = { ...t15["x-attribsPrefix"] }), r = i;
  } else if (Qu(t15)) {
    const n = e ? Dd(t15.children) : [], i = new P5(n);
    n.forEach((s) => s.parent = i), r = i;
  } else if (oo(t15)) {
    const n = e ? Dd(t15.children) : [], i = new Cl(n);
    n.forEach((s) => s.parent = i), t15["x-mode"] && (i["x-mode"] = t15["x-mode"]), r = i;
  } else if (pS(t15)) {
    const n = new R5(t15.name, t15.data);
    t15["x-name"] != null && (n["x-name"] = t15["x-name"], n["x-publicId"] = t15["x-publicId"], n["x-systemId"] = t15["x-systemId"]), r = n;
  } else
    throw new Error(`Not implemented yet: ${t15.type}`);
  return r.startIndex = t15.startIndex, r.endIndex = t15.endIndex, t15.sourceCodeLocation != null && (r.sourceCodeLocation = t15.sourceCodeLocation), r;
}
function Dd(t15) {
  const e = t15.map((r) => Sl(r, true));
  for (let r = 1; r < e.length; r++)
    e[r].prev = e[r - 1], e[r - 1].next = e[r];
  return e;
}
var Jy = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var fS = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(e, r, n) {
    this.dom = [], this.root = new Cl(this.dom), this.done = false, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof r == "function" && (n = r, r = Jy), typeof e == "object" && (r = e, e = void 0), this.callback = e ?? null, this.options = r ?? Jy, this.elementCB = n ?? null;
  }
  onparserinit(e) {
    this.parser = e;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [], this.root = new Cl(this.dom), this.done = false, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    this.done || (this.done = true, this.parser = null, this.handleCallback(null));
  }
  onerror(e) {
    this.handleCallback(e);
  }
  onclosetag() {
    this.lastNode = null;
    const e = this.tagStack.pop();
    this.options.withEndIndices && (e.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(e);
  }
  onopentag(e, r) {
    const n = this.options.xmlMode ? ge.Tag : void 0, i = new j5(e, r, void 0, n);
    this.addNode(i), this.tagStack.push(i);
  }
  ontext(e) {
    const { lastNode: r } = this;
    if (r && r.type === ge.Text)
      r.data += e, this.options.withEndIndices && (r.endIndex = this.parser.endIndex);
    else {
      const n = new Xh(e);
      this.addNode(n), this.lastNode = n;
    }
  }
  oncomment(e) {
    if (this.lastNode && this.lastNode.type === ge.Comment) {
      this.lastNode.data += e;
      return;
    }
    const r = new q5(e);
    this.addNode(r), this.lastNode = r;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const e = new Xh(""), r = new P5([e]);
    this.addNode(r), e.parent = r, this.lastNode = e;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(e, r) {
    const n = new R5(e, r);
    this.addNode(n);
  }
  handleCallback(e) {
    if (typeof this.callback == "function")
      this.callback(e, this.dom);
    else if (e)
      throw e;
  }
  addNode(e) {
    const r = this.tagStack[this.tagStack.length - 1], n = r.children[r.children.length - 1];
    this.options.withStartIndices && (e.startIndex = this.parser.startIndex), this.options.withEndIndices && (e.endIndex = this.parser.endIndex), r.children.push(e), n && (e.prev = n, n.next = e), e.parent = r, this.lastNode = null;
  }
};
var W5 = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((t15) => t15.charCodeAt(0))
);
var H5 = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((t15) => t15.charCodeAt(0))
);
var Fd;
var mS = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var Zp = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Fd = String.fromCodePoint) !== null && Fd !== void 0 ? Fd : function(t15) {
    let e = "";
    return t15 > 65535 && (t15 -= 65536, e += String.fromCharCode(t15 >>> 10 & 1023 | 55296), t15 = 56320 | t15 & 1023), e += String.fromCharCode(t15), e;
  }
);
function gS(t15) {
  var e;
  return t15 >= 55296 && t15 <= 57343 || t15 > 1114111 ? 65533 : (e = mS.get(t15)) !== null && e !== void 0 ? e : t15;
}
var sr;
(function(t15) {
  t15[t15.NUM = 35] = "NUM", t15[t15.SEMI = 59] = "SEMI", t15[t15.EQUALS = 61] = "EQUALS", t15[t15.ZERO = 48] = "ZERO", t15[t15.NINE = 57] = "NINE", t15[t15.LOWER_A = 97] = "LOWER_A", t15[t15.LOWER_F = 102] = "LOWER_F", t15[t15.LOWER_X = 120] = "LOWER_X", t15[t15.LOWER_Z = 122] = "LOWER_Z", t15[t15.UPPER_A = 65] = "UPPER_A", t15[t15.UPPER_F = 70] = "UPPER_F", t15[t15.UPPER_Z = 90] = "UPPER_Z";
})(sr || (sr = {}));
var yS = 32;
var rs;
(function(t15) {
  t15[t15.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t15[t15.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t15[t15.JUMP_TABLE = 127] = "JUMP_TABLE";
})(rs || (rs = {}));
function Qp(t15) {
  return t15 >= sr.ZERO && t15 <= sr.NINE;
}
function bS(t15) {
  return t15 >= sr.UPPER_A && t15 <= sr.UPPER_F || t15 >= sr.LOWER_A && t15 <= sr.LOWER_F;
}
function xS(t15) {
  return t15 >= sr.UPPER_A && t15 <= sr.UPPER_Z || t15 >= sr.LOWER_A && t15 <= sr.LOWER_Z || Qp(t15);
}
function wS(t15) {
  return t15 === sr.EQUALS || xS(t15);
}
var rr;
(function(t15) {
  t15[t15.EntityStart = 0] = "EntityStart", t15[t15.NumericStart = 1] = "NumericStart", t15[t15.NumericDecimal = 2] = "NumericDecimal", t15[t15.NumericHex = 3] = "NumericHex", t15[t15.NamedEntity = 4] = "NamedEntity";
})(rr || (rr = {}));
var Vn;
(function(t15) {
  t15[t15.Legacy = 0] = "Legacy", t15[t15.Strict = 1] = "Strict", t15[t15.Attribute = 2] = "Attribute";
})(Vn || (Vn = {}));
var U5 = class {
  constructor(e, r, n) {
    this.decodeTree = e, this.emitCodePoint = r, this.errors = n, this.state = rr.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Vn.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = rr.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, r) {
    switch (this.state) {
      case rr.EntityStart:
        return e.charCodeAt(r) === sr.NUM ? (this.state = rr.NumericStart, this.consumed += 1, this.stateNumericStart(e, r + 1)) : (this.state = rr.NamedEntity, this.stateNamedEntity(e, r));
      case rr.NumericStart:
        return this.stateNumericStart(e, r);
      case rr.NumericDecimal:
        return this.stateNumericDecimal(e, r);
      case rr.NumericHex:
        return this.stateNumericHex(e, r);
      case rr.NamedEntity:
        return this.stateNamedEntity(e, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, r) {
    return r >= e.length ? -1 : (e.charCodeAt(r) | yS) === sr.LOWER_X ? (this.state = rr.NumericHex, this.consumed += 1, this.stateNumericHex(e, r + 1)) : (this.state = rr.NumericDecimal, this.stateNumericDecimal(e, r));
  }
  addToNumericResult(e, r, n, i) {
    if (r !== n) {
      const s = n - r;
      this.result = this.result * Math.pow(i, s) + parseInt(e.substr(r, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (Qp(i) || bS(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, n, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (Qp(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, n, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, r) {
    var n;
    if (this.consumed <= r)
      return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === sr.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Vn.Strict)
      return 0;
    return this.emitCodePoint(gS(this.result), this.consumed), this.errors && (e !== sr.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, r) {
    const { decodeTree: n } = this;
    let i = n[this.treeIndex], s = (i & rs.VALUE_LENGTH) >> 14;
    for (; r < e.length; r++, this.excess++) {
      const o = e.charCodeAt(r);
      if (this.treeIndex = kS(n, i, this.treeIndex + Math.max(1, s), o), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Vn.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        wS(o)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = n[this.treeIndex], s = (i & rs.VALUE_LENGTH) >> 14, s !== 0) {
        if (o === sr.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== Vn.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: r, decodeTree: n } = this, i = (n[r] & rs.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, r, n) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(r === 1 ? i[e] & ~rs.VALUE_LENGTH : i[e + 1], n), r === 3 && this.emitCodePoint(i[e + 2], n), n;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case rr.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Vn.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case rr.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case rr.NumericHex:
        return this.emitNumericEntity(0, 3);
      case rr.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case rr.EntityStart:
        return 0;
    }
  }
};
function V5(t15) {
  let e = "";
  const r = new U5(t15, (n) => e += Zp(n));
  return function(n, i) {
    let s = 0, o = 0;
    for (; (o = n.indexOf("&", o)) >= 0; ) {
      e += n.slice(s, o), r.startEntity(i);
      const l = r.write(
        n,
        // Skip the "&"
        o + 1
      );
      if (l < 0) {
        s = o + r.end();
        break;
      }
      s = o + l, o = l === 0 ? s + 1 : s;
    }
    const a = e + n.slice(s);
    return e = "", a;
  };
}
function kS(t15, e, r, n) {
  const i = (e & rs.BRANCH_LENGTH) >> 7, s = e & rs.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && n === s ? r : -1;
  if (s) {
    const l = n - s;
    return l < 0 || l >= i ? -1 : t15[r + l] - 1;
  }
  let o = r, a = o + i - 1;
  for (; o <= a; ) {
    const l = o + a >>> 1, c = t15[l];
    if (c < n)
      o = l + 1;
    else if (c > n)
      a = l - 1;
    else
      return t15[l + i];
  }
  return -1;
}
V5(W5);
V5(H5);
var t2 = /["&'<>$\x80-\uFFFF]/g;
var vS = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var _S = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (t15, e) => t15.codePointAt(e) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (t15, e) => (t15.charCodeAt(e) & 64512) === 55296 ? (t15.charCodeAt(e) - 55296) * 1024 + t15.charCodeAt(e + 1) - 56320 + 65536 : t15.charCodeAt(e)
  )
);
function G5(t15) {
  let e = "", r = 0, n;
  for (; (n = t2.exec(t15)) !== null; ) {
    const i = n.index, s = t15.charCodeAt(i), o = vS.get(s);
    o !== void 0 ? (e += t15.substring(r, i) + o, r = i + 1) : (e += `${t15.substring(r, i)}&#x${_S(t15, i).toString(16)};`, r = t2.lastIndex += +((s & 64512) === 55296));
  }
  return e + t15.substr(r);
}
function X5(t15, e) {
  return function(r) {
    let n, i = 0, s = "";
    for (; n = t15.exec(r); )
      i !== n.index && (s += r.substring(i, n.index)), s += e.get(n[0].charCodeAt(0)), i = n.index + 1;
    return s + r.substring(i);
  };
}
var CS = X5(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var SS = X5(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
var TS = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((t15) => [t15.toLowerCase(), t15]));
var AS = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((t15) => [t15.toLowerCase(), t15]));
var $S = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function ES(t15) {
  return t15.replace(/"/g, "&quot;");
}
function MS(t15, e) {
  var r;
  if (!t15)
    return;
  const n = ((r = e.encodeEntities) !== null && r !== void 0 ? r : e.decodeEntities) === false ? ES : e.xmlMode || e.encodeEntities !== "utf8" ? G5 : CS;
  return Object.keys(t15).map((i) => {
    var s, o;
    const a = (s = t15[i]) !== null && s !== void 0 ? s : "";
    return e.xmlMode === "foreign" && (i = (o = AS.get(i)) !== null && o !== void 0 ? o : i), !e.emptyAttrs && !e.xmlMode && a === "" ? i : `${i}="${n(a)}"`;
  }).join(" ");
}
var e2 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function Ju(t15, e = {}) {
  const r = "length" in t15 ? t15 : [t15];
  let n = "";
  for (let i = 0; i < r.length; i++)
    n += BS(r[i], e);
  return n;
}
function BS(t15, e) {
  switch (t15.type) {
    case iS:
      return Ju(t15.children, e);
    case dS:
    case oS:
      return NS(t15);
    case aS:
      return zS(t15);
    case uS:
      return OS(t15);
    case lS:
    case cS:
    case hS:
      return FS(t15, e);
    case sS:
      return IS(t15, e);
  }
}
var LS = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var DS = /* @__PURE__ */ new Set(["svg", "math"]);
function FS(t15, e) {
  var r;
  e.xmlMode === "foreign" && (t15.name = (r = TS.get(t15.name)) !== null && r !== void 0 ? r : t15.name, t15.parent && LS.has(t15.parent.name) && (e = { ...e, xmlMode: false })), !e.xmlMode && DS.has(t15.name) && (e = { ...e, xmlMode: "foreign" });
  let n = `<${t15.name}`;
  const i = MS(t15.attribs, e);
  return i && (n += ` ${i}`), t15.children.length === 0 && (e.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    e.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    e.selfClosingTags && e2.has(t15.name)
  )) ? (e.xmlMode || (n += " "), n += "/>") : (n += ">", t15.children.length > 0 && (n += Ju(t15.children, e)), (e.xmlMode || !e2.has(t15.name)) && (n += `</${t15.name}>`)), n;
}
function NS(t15) {
  return `<${t15.data}>`;
}
function IS(t15, e) {
  var r;
  let n = t15.data || "";
  return ((r = e.encodeEntities) !== null && r !== void 0 ? r : e.decodeEntities) !== false && !(!e.xmlMode && t15.parent && $S.has(t15.parent.name)) && (n = e.xmlMode || e.encodeEntities !== "utf8" ? G5(n) : SS(n)), n;
}
function OS(t15) {
  return `<![CDATA[${t15.children[0].data}]]>`;
}
function zS(t15) {
  return `<!--${t15.data}-->`;
}
function Y5(t15, e) {
  return Ju(t15, e);
}
function qS(t15, e) {
  return lr(t15) ? t15.children.map((r) => Y5(r, e)).join("") : "";
}
function xh(t15) {
  return Array.isArray(t15) ? t15.map(xh).join("") : Xt(t15) ? t15.name === "br" ? `
` : xh(t15.children) : Qu(t15) ? xh(t15.children) : Ys(t15) ? t15.data : "";
}
function Ho(t15) {
  return Array.isArray(t15) ? t15.map(Ho).join("") : lr(t15) && !O1(t15) ? Ho(t15.children) : Ys(t15) ? t15.data : "";
}
function Yh(t15) {
  return Array.isArray(t15) ? t15.map(Yh).join("") : lr(t15) && (t15.type === ge.Tag || Qu(t15)) ? Yh(t15.children) : Ys(t15) ? t15.data : "";
}
function t0(t15) {
  return lr(t15) ? t15.children : [];
}
function K5(t15) {
  return t15.parent || null;
}
function Z5(t15) {
  const e = K5(t15);
  if (e != null)
    return t0(e);
  const r = [t15];
  let { prev: n, next: i } = t15;
  for (; n != null; )
    r.unshift(n), { prev: n } = n;
  for (; i != null; )
    r.push(i), { next: i } = i;
  return r;
}
function RS(t15, e) {
  var r;
  return (r = t15.attribs) === null || r === void 0 ? void 0 : r[e];
}
function PS(t15, e) {
  return t15.attribs != null && Object.prototype.hasOwnProperty.call(t15.attribs, e) && t15.attribs[e] != null;
}
function jS(t15) {
  return t15.name;
}
function z1(t15) {
  let { next: e } = t15;
  for (; e !== null && !Xt(e); )
    ({ next: e } = e);
  return e;
}
function q1(t15) {
  let { prev: e } = t15;
  for (; e !== null && !Xt(e); )
    ({ prev: e } = e);
  return e;
}
function ao(t15) {
  if (t15.prev && (t15.prev.next = t15.next), t15.next && (t15.next.prev = t15.prev), t15.parent) {
    const e = t15.parent.children, r = e.lastIndexOf(t15);
    r >= 0 && e.splice(r, 1);
  }
  t15.next = null, t15.prev = null, t15.parent = null;
}
function WS(t15, e) {
  const r = e.prev = t15.prev;
  r && (r.next = e);
  const n = e.next = t15.next;
  n && (n.prev = e);
  const i = e.parent = t15.parent;
  if (i) {
    const s = i.children;
    s[s.lastIndexOf(t15)] = e, t15.parent = null;
  }
}
function HS(t15, e) {
  if (ao(e), e.next = null, e.parent = t15, t15.children.push(e) > 1) {
    const r = t15.children[t15.children.length - 2];
    r.next = e, e.prev = r;
  } else
    e.prev = null;
}
function US(t15, e) {
  ao(e);
  const { parent: r } = t15, n = t15.next;
  if (e.next = n, e.prev = t15, t15.next = e, e.parent = r, n) {
    if (n.prev = e, r) {
      const i = r.children;
      i.splice(i.lastIndexOf(n), 0, e);
    }
  } else r && r.children.push(e);
}
function VS(t15, e) {
  if (ao(e), e.parent = t15, e.prev = null, t15.children.unshift(e) !== 1) {
    const r = t15.children[1];
    r.prev = e, e.next = r;
  } else
    e.next = null;
}
function GS(t15, e) {
  ao(e);
  const { parent: r } = t15;
  if (r) {
    const n = r.children;
    n.splice(n.indexOf(t15), 0, e);
  }
  t15.prev && (t15.prev.next = e), e.parent = r, e.prev = t15.prev, e.next = t15, t15.prev = e;
}
function e0(t15, e, r = true, n = 1 / 0) {
  return R1(t15, Array.isArray(e) ? e : [e], r, n);
}
function R1(t15, e, r, n) {
  const i = [], s = [e], o = [0];
  for (; ; ) {
    if (o[0] >= s[0].length) {
      if (o.length === 1)
        return i;
      s.shift(), o.shift();
      continue;
    }
    const a = s[0][o[0]++];
    if (t15(a) && (i.push(a), --n <= 0))
      return i;
    r && lr(a) && a.children.length > 0 && (o.unshift(0), s.unshift(a.children));
  }
}
function XS(t15, e) {
  return e.find(t15);
}
function P1(t15, e, r = true) {
  let n = null;
  for (let i = 0; i < e.length && !n; i++) {
    const s = e[i];
    if (Xt(s))
      t15(s) ? n = s : r && s.children.length > 0 && (n = P1(t15, s.children, true));
    else continue;
  }
  return n;
}
function Q5(t15, e) {
  return e.some((r) => Xt(r) && (t15(r) || Q5(t15, r.children)));
}
function YS(t15, e) {
  const r = [], n = [e], i = [0];
  for (; ; ) {
    if (i[0] >= n[0].length) {
      if (n.length === 1)
        return r;
      n.shift(), i.shift();
      continue;
    }
    const s = n[0][i[0]++];
    Xt(s) && (t15(s) && r.push(s), s.children.length > 0 && (i.unshift(0), n.unshift(s.children)));
  }
}
var Kh = {
  tag_name(t15) {
    return typeof t15 == "function" ? (e) => Xt(e) && t15(e.name) : t15 === "*" ? Xt : (e) => Xt(e) && e.name === t15;
  },
  tag_type(t15) {
    return typeof t15 == "function" ? (e) => t15(e.type) : (e) => e.type === t15;
  },
  tag_contains(t15) {
    return typeof t15 == "function" ? (e) => Ys(e) && t15(e.data) : (e) => Ys(e) && e.data === t15;
  }
};
function J5(t15, e) {
  return typeof e == "function" ? (r) => Xt(r) && e(r.attribs[t15]) : (r) => Xt(r) && r.attribs[t15] === e;
}
function KS(t15, e) {
  return (r) => t15(r) || e(r);
}
function tx(t15) {
  const e = Object.keys(t15).map((r) => {
    const n = t15[r];
    return Object.prototype.hasOwnProperty.call(Kh, r) ? Kh[r](n) : J5(r, n);
  });
  return e.length === 0 ? null : e.reduce(KS);
}
function ZS(t15, e) {
  const r = tx(t15);
  return r ? r(e) : true;
}
function QS(t15, e, r, n = 1 / 0) {
  const i = tx(t15);
  return i ? e0(i, e, r, n) : [];
}
function JS(t15, e, r = true) {
  return Array.isArray(e) || (e = [e]), P1(J5("id", t15), e, r);
}
function la(t15, e, r = true, n = 1 / 0) {
  return e0(Kh.tag_name(t15), e, r, n);
}
function tT(t15, e, r = true, n = 1 / 0) {
  return e0(Kh.tag_type(t15), e, r, n);
}
function eT(t15) {
  let e = t15.length;
  for (; --e >= 0; ) {
    const r = t15[e];
    if (e > 0 && t15.lastIndexOf(r, e - 1) >= 0) {
      t15.splice(e, 1);
      continue;
    }
    for (let n = r.parent; n; n = n.parent)
      if (t15.includes(n)) {
        t15.splice(e, 1);
        break;
      }
  }
  return t15;
}
var fn;
(function(t15) {
  t15[t15.DISCONNECTED = 1] = "DISCONNECTED", t15[t15.PRECEDING = 2] = "PRECEDING", t15[t15.FOLLOWING = 4] = "FOLLOWING", t15[t15.CONTAINS = 8] = "CONTAINS", t15[t15.CONTAINED_BY = 16] = "CONTAINED_BY";
})(fn || (fn = {}));
function ex(t15, e) {
  const r = [], n = [];
  if (t15 === e)
    return 0;
  let i = lr(t15) ? t15 : t15.parent;
  for (; i; )
    r.unshift(i), i = i.parent;
  for (i = lr(e) ? e : e.parent; i; )
    n.unshift(i), i = i.parent;
  const s = Math.min(r.length, n.length);
  let o = 0;
  for (; o < s && r[o] === n[o]; )
    o++;
  if (o === 0)
    return fn.DISCONNECTED;
  const a = r[o - 1], l = a.children, c = r[o], h10 = n[o];
  return l.indexOf(c) > l.indexOf(h10) ? a === e ? fn.FOLLOWING | fn.CONTAINED_BY : fn.FOLLOWING : a === t15 ? fn.PRECEDING | fn.CONTAINS : fn.PRECEDING;
}
function ca(t15) {
  return t15 = t15.filter((e, r, n) => !n.includes(e, r + 1)), t15.sort((e, r) => {
    const n = ex(e, r);
    return n & fn.PRECEDING ? -1 : n & fn.FOLLOWING ? 1 : 0;
  }), t15;
}
function rT(t15) {
  const e = Zh(aT, t15);
  return e ? e.name === "feed" ? nT(e) : iT(e) : null;
}
function nT(t15) {
  var e;
  const r = t15.children, n = {
    type: "atom",
    items: la("entry", r).map((o) => {
      var a;
      const { children: l } = o, c = { media: rx(l) };
      Rr(c, "id", "id", l), Rr(c, "title", "title", l);
      const h10 = (a = Zh("link", l)) === null || a === void 0 ? void 0 : a.attribs.href;
      h10 && (c.link = h10);
      const p = ns("summary", l) || ns("content", l);
      p && (c.description = p);
      const m = ns("updated", l);
      return m && (c.pubDate = new Date(m)), c;
    })
  };
  Rr(n, "id", "id", r), Rr(n, "title", "title", r);
  const i = (e = Zh("link", r)) === null || e === void 0 ? void 0 : e.attribs.href;
  i && (n.link = i), Rr(n, "description", "subtitle", r);
  const s = ns("updated", r);
  return s && (n.updated = new Date(s)), Rr(n, "author", "email", r, true), n;
}
function iT(t15) {
  var e, r;
  const n = (r = (e = Zh("channel", t15.children)) === null || e === void 0 ? void 0 : e.children) !== null && r !== void 0 ? r : [], i = {
    type: t15.name.substr(0, 3),
    id: "",
    items: la("item", t15.children).map((o) => {
      const { children: a } = o, l = { media: rx(a) };
      Rr(l, "id", "guid", a), Rr(l, "title", "title", a), Rr(l, "link", "link", a), Rr(l, "description", "description", a);
      const c = ns("pubDate", a) || ns("dc:date", a);
      return c && (l.pubDate = new Date(c)), l;
    })
  };
  Rr(i, "title", "title", n), Rr(i, "link", "link", n), Rr(i, "description", "description", n);
  const s = ns("lastBuildDate", n);
  return s && (i.updated = new Date(s)), Rr(i, "author", "managingEditor", n, true), i;
}
var sT = ["url", "type", "lang"];
var oT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function rx(t15) {
  return la("media:content", t15).map((e) => {
    const { attribs: r } = e, n = {
      medium: r.medium,
      isDefault: !!r.isDefault
    };
    for (const i of sT)
      r[i] && (n[i] = r[i]);
    for (const i of oT)
      r[i] && (n[i] = parseInt(r[i], 10));
    return r.expression && (n.expression = r.expression), n;
  });
}
function Zh(t15, e) {
  return la(t15, e, true, 1)[0];
}
function ns(t15, e, r = false) {
  return Ho(la(t15, e, r, 1)).trim();
}
function Rr(t15, e, r, n, i = false) {
  const s = ns(r, n, i);
  s && (t15[e] = s);
}
function aT(t15) {
  return t15 === "rss" || t15 === "feed" || t15 === "rdf:RDF";
}
var r0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  get DocumentPosition() {
    return fn;
  },
  append: US,
  appendChild: HS,
  compareDocumentPosition: ex,
  existsOne: Q5,
  filter: e0,
  find: R1,
  findAll: YS,
  findOne: P1,
  findOneChild: XS,
  getAttributeValue: RS,
  getChildren: t0,
  getElementById: JS,
  getElements: QS,
  getElementsByTagName: la,
  getElementsByTagType: tT,
  getFeed: rT,
  getInnerHTML: qS,
  getName: jS,
  getOuterHTML: Y5,
  getParent: K5,
  getSiblings: Z5,
  getText: xh,
  hasAttrib: PS,
  hasChildren: lr,
  innerText: Yh,
  isCDATA: Qu,
  isComment: O1,
  isDocument: oo,
  isTag: Xt,
  isText: Ys,
  nextElementSibling: z1,
  prepend: GS,
  prependChild: VS,
  prevElementSibling: q1,
  removeElement: ao,
  removeSubsets: eT,
  replaceElement: WS,
  testElement: ZS,
  textContent: Ho,
  uniqueSort: ca
}, Symbol.toStringTag, { value: "Module" }));
function nx(t15, e, r) {
  return t15 ? t15(e ?? t15._root.children, null, void 0, r).toString() : "";
}
function lT(t15, e) {
  return typeof t15 == "object" && t15 != null && !("length" in t15) && !("type" in t15);
}
function cT(t15, e) {
  const r = lT(t15) ? (e = t15, void 0) : t15, n = {
    ...this === null || this === void 0 ? void 0 : this._options,
    ...Kp(e)
  };
  return nx(this, r, n);
}
function hT(t15) {
  const e = { ...this._options, xmlMode: true };
  return nx(this, t15, e);
}
function Tl(t15) {
  const e = t15 ?? (this ? this.root() : []);
  let r = "";
  for (let n = 0; n < e.length; n++)
    r += Ho(e[n]);
  return r;
}
function uT(t15, e, r = typeof e == "boolean" ? e : false) {
  if (!t15 || typeof t15 != "string")
    return null;
  typeof e == "boolean" && (r = e);
  const n = this.load(t15, this._options, false);
  return r || n("script").remove(), [...n.root()[0].children];
}
function dT() {
  return this(this._root);
}
function ix(t15, e) {
  if (e === t15)
    return false;
  let r = e;
  for (; r && r !== r.parent; )
    if (r = r.parent, r === t15)
      return true;
  return false;
}
function pT(t15) {
  return this.root().extract(t15);
}
function fT(t15, e) {
  if (!r2(t15) || !r2(e))
    return;
  let r = t15.length;
  const n = +e.length;
  for (let i = 0; i < n; i++)
    t15[r++] = e[i];
  return t15.length = r, t15;
}
function r2(t15) {
  if (Array.isArray(t15))
    return true;
  if (typeof t15 != "object" || t15 === null || !("length" in t15) || typeof t15.length != "number" || t15.length < 0)
    return false;
  for (let e = 0; e < t15.length; e++)
    if (!(e in t15))
      return false;
  return true;
}
var mT = Object.freeze(Object.defineProperty({
  __proto__: null,
  contains: ix,
  extract: pT,
  html: cT,
  merge: fT,
  parseHTML: uT,
  root: dT,
  text: Tl,
  xml: hT
}, Symbol.toStringTag, { value: "Module" }));
function Mi(t15) {
  return t15.cheerio != null;
}
function gT(t15) {
  return t15.replace(/[._-](\w|$)/g, (e, r) => r.toUpperCase());
}
function yT(t15) {
  return t15.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function Oe(t15, e) {
  const r = t15.length;
  for (let n = 0; n < r; n++)
    e(t15[n], n);
  return t15;
}
var Os;
(function(t15) {
  t15[t15.LowerA = 97] = "LowerA", t15[t15.LowerZ = 122] = "LowerZ", t15[t15.UpperA = 65] = "UpperA", t15[t15.UpperZ = 90] = "UpperZ", t15[t15.Exclamation = 33] = "Exclamation";
})(Os || (Os = {}));
function Jp(t15) {
  const e = t15.indexOf("<");
  if (e < 0 || e > t15.length - 3)
    return false;
  const r = t15.charCodeAt(e + 1);
  return (r >= Os.LowerA && r <= Os.LowerZ || r >= Os.UpperA && r <= Os.UpperZ || r === Os.Exclamation) && t15.includes(">", e + 2);
}
var Al = Object.prototype.hasOwnProperty;
var $l = /\s+/;
var tf = "data-";
var j1 = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
var bT = /^{[^]*}$|^\[[^]*]$/;
function Qh(t15, e, r) {
  var n;
  if (!(!t15 || !Xt(t15))) {
    if ((n = t15.attribs) !== null && n !== void 0 || (t15.attribs = {}), !e)
      return t15.attribs;
    if (Al.call(t15.attribs, e))
      return !r && j1.test(e) ? e : t15.attribs[e];
    if (t15.name === "option" && e === "value")
      return Tl(t15.children);
    if (t15.name === "input" && (t15.attribs.type === "radio" || t15.attribs.type === "checkbox") && e === "value")
      return "on";
  }
}
function Io(t15, e, r) {
  r === null ? ox(t15, e) : t15.attribs[e] = `${r}`;
}
function xT(t15, e) {
  if (typeof t15 == "object" || e !== void 0) {
    if (typeof e == "function") {
      if (typeof t15 != "string")
        throw new Error("Bad combination of arguments.");
      return Oe(this, (r, n) => {
        Xt(r) && Io(r, t15, e.call(r, n, r.attribs[t15]));
      });
    }
    return Oe(this, (r) => {
      if (Xt(r))
        if (typeof t15 == "object")
          for (const n of Object.keys(t15)) {
            const i = t15[n];
            Io(r, n, i);
          }
        else
          Io(r, t15, e);
    });
  }
  return arguments.length > 1 ? this : Qh(this[0], t15, this.options.xmlMode);
}
function n2(t15, e, r) {
  return e in t15 ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    t15[e]
  ) : !r && j1.test(e) ? Qh(t15, e, false) !== void 0 : Qh(t15, e, r);
}
function Nd(t15, e, r, n) {
  e in t15 ? t15[e] = r : Io(t15, e, !n && j1.test(e) ? r ? "" : null : `${r}`);
}
function wT(t15, e) {
  var r;
  if (typeof t15 == "string" && e === void 0) {
    const n = this[0];
    if (!n || !Xt(n))
      return;
    switch (t15) {
      case "style": {
        const i = this.css(), s = Object.keys(i);
        for (let o = 0; o < s.length; o++)
          i[o] = s[o];
        return i.length = s.length, i;
      }
      case "tagName":
      case "nodeName":
        return n.name.toUpperCase();
      case "href":
      case "src": {
        const i = (r = n.attribs) === null || r === void 0 ? void 0 : r[t15];
        return typeof URL < "u" && (t15 === "href" && (n.tagName === "a" || n.tagName === "link") || t15 === "src" && (n.tagName === "img" || n.tagName === "iframe" || n.tagName === "audio" || n.tagName === "video" || n.tagName === "source")) && i !== void 0 && this.options.baseURI ? new URL(i, this.options.baseURI).href : i;
      }
      case "innerText":
        return Yh(n);
      case "textContent":
        return Ho(n);
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return n2(n, t15, this.options.xmlMode);
    }
  }
  if (typeof t15 == "object" || e !== void 0) {
    if (typeof e == "function") {
      if (typeof t15 == "object")
        throw new TypeError("Bad combination of arguments.");
      return Oe(this, (n, i) => {
        Xt(n) && Nd(n, t15, e.call(n, i, n2(n, t15, this.options.xmlMode)), this.options.xmlMode);
      });
    }
    return Oe(this, (n) => {
      if (Xt(n))
        if (typeof t15 == "object")
          for (const i of Object.keys(t15)) {
            const s = t15[i];
            Nd(n, i, s, this.options.xmlMode);
          }
        else
          Nd(n, t15, e, this.options.xmlMode);
    });
  }
}
function i2(t15, e, r) {
  var n;
  (n = t15.data) !== null && n !== void 0 || (t15.data = {}), typeof e == "object" ? Object.assign(t15.data, e) : typeof e == "string" && r !== void 0 && (t15.data[e] = r);
}
function kT(t15) {
  for (const e of Object.keys(t15.attribs)) {
    if (!e.startsWith(tf))
      continue;
    const r = gT(e.slice(tf.length));
    Al.call(t15.data, r) || (t15.data[r] = sx(t15.attribs[e]));
  }
  return t15.data;
}
function vT(t15, e) {
  const r = tf + yT(e), n = t15.data;
  if (Al.call(n, e))
    return n[e];
  if (Al.call(t15.attribs, r))
    return n[e] = sx(t15.attribs[r]);
}
function sx(t15) {
  if (t15 === "null")
    return null;
  if (t15 === "true")
    return true;
  if (t15 === "false")
    return false;
  const e = Number(t15);
  if (t15 === String(e))
    return e;
  if (bT.test(t15))
    try {
      return JSON.parse(t15);
    } catch {
    }
  return t15;
}
function _T(t15, e) {
  var r;
  const n = this[0];
  if (!n || !Xt(n))
    return;
  const i = n;
  return (r = i.data) !== null && r !== void 0 || (i.data = {}), t15 == null ? kT(i) : typeof t15 == "object" || e !== void 0 ? (Oe(this, (s) => {
    Xt(s) && (typeof t15 == "object" ? i2(s, t15) : i2(s, t15, e));
  }), this) : vT(i, t15);
}
function CT(t15) {
  const e = arguments.length === 0, r = this[0];
  if (!r || !Xt(r))
    return e ? void 0 : this;
  switch (r.name) {
    case "textarea":
      return this.text(t15);
    case "select": {
      const n = this.find("option:selected");
      if (!e) {
        if (this.attr("multiple") == null && typeof t15 == "object")
          return this;
        this.find("option").removeAttr("selected");
        const i = typeof t15 == "object" ? t15 : [t15];
        for (const s of i)
          this.find(`option[value="${s}"]`).attr("selected", "");
        return this;
      }
      return this.attr("multiple") ? n.toArray().map((i) => Tl(i.children)) : n.attr("value");
    }
    case "input":
    case "option":
      return e ? this.attr("value") : this.attr("value", t15);
  }
}
function ox(t15, e) {
  !t15.attribs || !Al.call(t15.attribs, e) || delete t15.attribs[e];
}
function Jh(t15) {
  return t15 ? t15.trim().split($l) : [];
}
function ST(t15) {
  const e = Jh(t15);
  for (const r of e)
    Oe(this, (n) => {
      Xt(n) && ox(n, r);
    });
  return this;
}
function TT(t15) {
  return this.toArray().some((e) => {
    const r = Xt(e) && e.attribs.class;
    let n = -1;
    if (r && t15.length > 0)
      for (; (n = r.indexOf(t15, n + 1)) > -1; ) {
        const i = n + t15.length;
        if ((n === 0 || $l.test(r[n - 1])) && (i === r.length || $l.test(r[i])))
          return true;
      }
    return false;
  });
}
function ax(t15) {
  if (typeof t15 == "function")
    return Oe(this, (n, i) => {
      if (Xt(n)) {
        const s = n.attribs.class || "";
        ax.call([n], t15.call(n, i, s));
      }
    });
  if (!t15 || typeof t15 != "string")
    return this;
  const e = t15.split($l), r = this.length;
  for (let n = 0; n < r; n++) {
    const i = this[n];
    if (!Xt(i))
      continue;
    const s = Qh(i, "class", false);
    if (s) {
      let o = ` ${s} `;
      for (const a of e) {
        const l = `${a} `;
        o.includes(` ${l}`) || (o += l);
      }
      Io(i, "class", o.trim());
    } else
      Io(i, "class", e.join(" ").trim());
  }
  return this;
}
function lx(t15) {
  if (typeof t15 == "function")
    return Oe(this, (i, s) => {
      Xt(i) && lx.call([i], t15.call(i, s, i.attribs.class || ""));
    });
  const e = Jh(t15), r = e.length, n = arguments.length === 0;
  return Oe(this, (i) => {
    if (Xt(i))
      if (n)
        i.attribs.class = "";
      else {
        const s = Jh(i.attribs.class);
        let o = false;
        for (let a = 0; a < r; a++) {
          const l = s.indexOf(e[a]);
          l >= 0 && (s.splice(l, 1), o = true, a--);
        }
        o && (i.attribs.class = s.join(" "));
      }
  });
}
function cx(t15, e) {
  if (typeof t15 == "function")
    return Oe(this, (o, a) => {
      Xt(o) && cx.call([o], t15.call(o, a, o.attribs.class || "", e), e);
    });
  if (!t15 || typeof t15 != "string")
    return this;
  const r = t15.split($l), n = r.length, i = typeof e == "boolean" ? e ? 1 : -1 : 0, s = this.length;
  for (let o = 0; o < s; o++) {
    const a = this[o];
    if (!Xt(a))
      continue;
    const l = Jh(a.attribs.class);
    for (let c = 0; c < n; c++) {
      const h10 = l.indexOf(r[c]);
      i >= 0 && h10 < 0 ? l.push(r[c]) : i <= 0 && h10 >= 0 && l.splice(h10, 1);
    }
    a.attribs.class = l.join(" ");
  }
  return this;
}
var AT = Object.freeze(Object.defineProperty({
  __proto__: null,
  addClass: ax,
  attr: xT,
  data: _T,
  hasClass: TT,
  prop: wT,
  removeAttr: ST,
  removeClass: lx,
  toggleClass: cx,
  val: CT
}, Symbol.toStringTag, { value: "Module" }));
var Rt;
(function(t15) {
  t15.Attribute = "attribute", t15.Pseudo = "pseudo", t15.PseudoElement = "pseudo-element", t15.Tag = "tag", t15.Universal = "universal", t15.Adjacent = "adjacent", t15.Child = "child", t15.Descendant = "descendant", t15.Parent = "parent", t15.Sibling = "sibling", t15.ColumnCombinator = "column-combinator";
})(Rt || (Rt = {}));
var Ye;
(function(t15) {
  t15.Any = "any", t15.Element = "element", t15.End = "end", t15.Equals = "equals", t15.Exists = "exists", t15.Hyphen = "hyphen", t15.Not = "not", t15.Start = "start";
})(Ye || (Ye = {}));
var s2 = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var $T = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var ET = /* @__PURE__ */ new Map([
  [126, Ye.Element],
  [94, Ye.Start],
  [36, Ye.End],
  [42, Ye.Any],
  [33, Ye.Not],
  [124, Ye.Hyphen]
]);
var MT = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function ml(t15) {
  switch (t15.type) {
    case Rt.Adjacent:
    case Rt.Child:
    case Rt.Descendant:
    case Rt.Parent:
    case Rt.Sibling:
    case Rt.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
var BT = /* @__PURE__ */ new Set(["contains", "icontains"]);
function LT(t15, e, r) {
  const n = parseInt(e, 16) - 65536;
  return n !== n || r ? e : n < 0 ? (
    // BMP codepoint
    String.fromCharCode(n + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(n >> 10 | 55296, n & 1023 | 56320)
  );
}
function Fa(t15) {
  return t15.replace($T, LT);
}
function Id(t15) {
  return t15 === 39 || t15 === 34;
}
function o2(t15) {
  return t15 === 32 || t15 === 9 || t15 === 10 || t15 === 12 || t15 === 13;
}
function n0(t15) {
  const e = [], r = hx(e, `${t15}`, 0);
  if (r < t15.length)
    throw new Error(`Unmatched selector: ${t15.slice(r)}`);
  return e;
}
function hx(t15, e, r) {
  let n = [];
  function i(m) {
    const g = e.slice(r + m).match(s2);
    if (!g)
      throw new Error(`Expected name, found ${e.slice(r)}`);
    const [y] = g;
    return r += m + y.length, Fa(y);
  }
  function s(m) {
    for (r += m; r < e.length && o2(e.charCodeAt(r)); )
      r++;
  }
  function o() {
    r += 1;
    const m = r;
    let g = 1;
    for (; g > 0 && r < e.length; r++)
      e.charCodeAt(r) === 40 && !a(r) ? g++ : e.charCodeAt(r) === 41 && !a(r) && g--;
    if (g)
      throw new Error("Parenthesis not matched");
    return Fa(e.slice(m, r - 1));
  }
  function a(m) {
    let g = 0;
    for (; e.charCodeAt(--m) === 92; )
      g++;
    return (g & 1) === 1;
  }
  function l() {
    if (n.length > 0 && ml(n[n.length - 1]))
      throw new Error("Did not expect successive traversals.");
  }
  function c(m) {
    if (n.length > 0 && n[n.length - 1].type === Rt.Descendant) {
      n[n.length - 1].type = m;
      return;
    }
    l(), n.push({ type: m });
  }
  function h10(m, g) {
    n.push({
      type: Rt.Attribute,
      name: m,
      action: g,
      value: i(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function p() {
    if (n.length && n[n.length - 1].type === Rt.Descendant && n.pop(), n.length === 0)
      throw new Error("Empty sub-selector");
    t15.push(n);
  }
  if (s(0), e.length === r)
    return r;
  t: for (; r < e.length; ) {
    const m = e.charCodeAt(r);
    switch (m) {
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        (n.length === 0 || n[0].type !== Rt.Descendant) && (l(), n.push({ type: Rt.Descendant })), s(1);
        break;
      }
      case 62: {
        c(Rt.Child), s(1);
        break;
      }
      case 60: {
        c(Rt.Parent), s(1);
        break;
      }
      case 126: {
        c(Rt.Sibling), s(1);
        break;
      }
      case 43: {
        c(Rt.Adjacent), s(1);
        break;
      }
      case 46: {
        h10("class", Ye.Element);
        break;
      }
      case 35: {
        h10("id", Ye.Equals);
        break;
      }
      case 91: {
        s(1);
        let g, y = null;
        e.charCodeAt(r) === 124 ? g = i(1) : e.startsWith("*|", r) ? (y = "*", g = i(2)) : (g = i(0), e.charCodeAt(r) === 124 && e.charCodeAt(r + 1) !== 61 && (y = g, g = i(1))), s(0);
        let x = Ye.Exists;
        const k = ET.get(e.charCodeAt(r));
        if (k) {
          if (x = k, e.charCodeAt(r + 1) !== 61)
            throw new Error("Expected `=`");
          s(2);
        } else e.charCodeAt(r) === 61 && (x = Ye.Equals, s(1));
        let C = "", _ = null;
        if (x !== "exists") {
          if (Id(e.charCodeAt(r))) {
            const B = e.charCodeAt(r);
            let q = r + 1;
            for (; q < e.length && (e.charCodeAt(q) !== B || a(q)); )
              q += 1;
            if (e.charCodeAt(q) !== B)
              throw new Error("Attribute value didn't end");
            C = Fa(e.slice(r + 1, q)), r = q + 1;
          } else {
            const B = r;
            for (; r < e.length && (!o2(e.charCodeAt(r)) && e.charCodeAt(r) !== 93 || a(r)); )
              r += 1;
            C = Fa(e.slice(B, r));
          }
          s(0);
          const L = e.charCodeAt(r) | 32;
          L === 115 ? (_ = false, s(1)) : L === 105 && (_ = true, s(1));
        }
        if (e.charCodeAt(r) !== 93)
          throw new Error("Attribute selector didn't terminate");
        r += 1;
        const $ = {
          type: Rt.Attribute,
          name: g,
          action: x,
          value: C,
          namespace: y,
          ignoreCase: _
        };
        n.push($);
        break;
      }
      case 58: {
        if (e.charCodeAt(r + 1) === 58) {
          n.push({
            type: Rt.PseudoElement,
            name: i(2).toLowerCase(),
            data: e.charCodeAt(r) === 40 ? o() : null
          });
          continue;
        }
        const g = i(1).toLowerCase();
        let y = null;
        if (e.charCodeAt(r) === 40)
          if (MT.has(g)) {
            if (Id(e.charCodeAt(r + 1)))
              throw new Error(`Pseudo-selector ${g} cannot be quoted`);
            if (y = [], r = hx(y, e, r + 1), e.charCodeAt(r) !== 41)
              throw new Error(`Missing closing parenthesis in :${g} (${e})`);
            r += 1;
          } else {
            if (y = o(), BT.has(g)) {
              const x = y.charCodeAt(0);
              x === y.charCodeAt(y.length - 1) && Id(x) && (y = y.slice(1, -1));
            }
            y = Fa(y);
          }
        n.push({ type: Rt.Pseudo, name: g, data: y });
        break;
      }
      case 44: {
        p(), n = [], s(1);
        break;
      }
      default: {
        if (e.startsWith("/*", r)) {
          const x = e.indexOf("*/", r + 2);
          if (x < 0)
            throw new Error("Comment was not terminated");
          r = x + 2, n.length === 0 && s(0);
          break;
        }
        let g = null, y;
        if (m === 42)
          r += 1, y = "*";
        else if (m === 124) {
          if (y = "", e.charCodeAt(r + 1) === 124) {
            c(Rt.ColumnCombinator), s(2);
            break;
          }
        } else if (s2.test(e.slice(r)))
          y = i(0);
        else
          break t;
        e.charCodeAt(r) === 124 && e.charCodeAt(r + 1) !== 124 && (g = y, e.charCodeAt(r + 1) === 42 ? (y = "*", r += 2) : y = i(1)), n.push(y === "*" ? { type: Rt.Universal, namespace: g } : { type: Rt.Tag, name: y, namespace: g });
      }
    }
  }
  return p(), r;
}
function DT(t15) {
  return t15 && t15.__esModule && Object.prototype.hasOwnProperty.call(t15, "default") ? t15.default : t15;
}
var a2;
var l2;
function FT() {
  return l2 || (l2 = 1, a2 = {
    trueFunc: function() {
      return true;
    },
    falseFunc: function() {
      return false;
    }
  }), a2;
}
var tu = FT();
var re = DT(tu);
var ux = /* @__PURE__ */ new Map([
  [Rt.Universal, 50],
  [Rt.Tag, 30],
  [Rt.Attribute, 1],
  [Rt.Pseudo, 0]
]);
function W1(t15) {
  return !ux.has(t15.type);
}
var NT = /* @__PURE__ */ new Map([
  [Ye.Exists, 10],
  [Ye.Equals, 8],
  [Ye.Not, 7],
  [Ye.Start, 6],
  [Ye.End, 6],
  [Ye.Any, 5]
]);
function IT(t15) {
  const e = t15.map(dx);
  for (let r = 1; r < t15.length; r++) {
    const n = e[r];
    if (!(n < 0))
      for (let i = r - 1; i >= 0 && n < e[i]; i--) {
        const s = t15[i + 1];
        t15[i + 1] = t15[i], t15[i] = s, e[i + 1] = e[i], e[i] = n;
      }
  }
}
function dx(t15) {
  var e, r;
  let n = (e = ux.get(t15.type)) !== null && e !== void 0 ? e : -1;
  return t15.type === Rt.Attribute ? (n = (r = NT.get(t15.action)) !== null && r !== void 0 ? r : 4, t15.action === Ye.Equals && t15.name === "id" && (n = 9), t15.ignoreCase && (n >>= 1)) : t15.type === Rt.Pseudo && (t15.data ? t15.name === "has" || t15.name === "contains" ? n = 0 : Array.isArray(t15.data) ? (n = Math.min(...t15.data.map((i) => Math.min(...i.map(dx)))), n < 0 && (n = 0)) : n = 2 : n = 3), n;
}
var OT = /[-[\]{}()*+?.,\\^$|#\s]/g;
function c2(t15) {
  return t15.replace(OT, "\\$&");
}
var zT = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function As(t15, e) {
  return typeof t15.ignoreCase == "boolean" ? t15.ignoreCase : t15.ignoreCase === "quirks" ? !!e.quirksMode : !e.xmlMode && zT.has(t15.name);
}
var qT = {
  equals(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    return As(e, r) ? (s = s.toLowerCase(), (o) => {
      const a = n.getAttributeValue(o, i);
      return a != null && a.length === s.length && a.toLowerCase() === s && t15(o);
    }) : (o) => n.getAttributeValue(o, i) === s && t15(o);
  },
  hyphen(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    const o = s.length;
    return As(e, r) ? (s = s.toLowerCase(), function(a) {
      const l = n.getAttributeValue(a, i);
      return l != null && (l.length === o || l.charAt(o) === "-") && l.substr(0, o).toLowerCase() === s && t15(a);
    }) : function(a) {
      const l = n.getAttributeValue(a, i);
      return l != null && (l.length === o || l.charAt(o) === "-") && l.substr(0, o) === s && t15(a);
    };
  },
  element(t15, e, r) {
    const { adapter: n } = r, { name: i, value: s } = e;
    if (/\s/.test(s))
      return re.falseFunc;
    const o = new RegExp(`(?:^|\\s)${c2(s)}(?:$|\\s)`, As(e, r) ? "i" : "");
    return function(a) {
      const l = n.getAttributeValue(a, i);
      return l != null && l.length >= s.length && o.test(l) && t15(a);
    };
  },
  exists(t15, { name: e }, { adapter: r }) {
    return (n) => r.hasAttrib(n, e) && t15(n);
  },
  start(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    const o = s.length;
    return o === 0 ? re.falseFunc : As(e, r) ? (s = s.toLowerCase(), (a) => {
      const l = n.getAttributeValue(a, i);
      return l != null && l.length >= o && l.substr(0, o).toLowerCase() === s && t15(a);
    }) : (a) => {
      var l;
      return !!(!((l = n.getAttributeValue(a, i)) === null || l === void 0) && l.startsWith(s)) && t15(a);
    };
  },
  end(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    const o = -s.length;
    return o === 0 ? re.falseFunc : As(e, r) ? (s = s.toLowerCase(), (a) => {
      var l;
      return ((l = n.getAttributeValue(a, i)) === null || l === void 0 ? void 0 : l.substr(o).toLowerCase()) === s && t15(a);
    }) : (a) => {
      var l;
      return !!(!((l = n.getAttributeValue(a, i)) === null || l === void 0) && l.endsWith(s)) && t15(a);
    };
  },
  any(t15, e, r) {
    const { adapter: n } = r, { name: i, value: s } = e;
    if (s === "")
      return re.falseFunc;
    if (As(e, r)) {
      const o = new RegExp(c2(s), "i");
      return function(a) {
        const l = n.getAttributeValue(a, i);
        return l != null && l.length >= s.length && o.test(l) && t15(a);
      };
    }
    return (o) => {
      var a;
      return !!(!((a = n.getAttributeValue(o, i)) === null || a === void 0) && a.includes(s)) && t15(o);
    };
  },
  not(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    return s === "" ? (o) => !!n.getAttributeValue(o, i) && t15(o) : As(e, r) ? (s = s.toLowerCase(), (o) => {
      const a = n.getAttributeValue(o, i);
      return (a == null || a.length !== s.length || a.toLowerCase() !== s) && t15(o);
    }) : (o) => n.getAttributeValue(o, i) !== s && t15(o);
  }
};
var RT = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var h2 = 48;
var PT = 57;
function jT(t15) {
  if (t15 = t15.trim().toLowerCase(), t15 === "even")
    return [2, 0];
  if (t15 === "odd")
    return [2, 1];
  let e = 0, r = 0, n = s(), i = o();
  if (e < t15.length && t15.charAt(e) === "n" && (e++, r = n * (i ?? 1), a(), e < t15.length ? (n = s(), a(), i = o()) : n = i = 0), i === null || e < t15.length)
    throw new Error(`n-th rule couldn't be parsed ('${t15}')`);
  return [r, n * i];
  function s() {
    return t15.charAt(e) === "-" ? (e++, -1) : (t15.charAt(e) === "+" && e++, 1);
  }
  function o() {
    const l = e;
    let c = 0;
    for (; e < t15.length && t15.charCodeAt(e) >= h2 && t15.charCodeAt(e) <= PT; )
      c = c * 10 + (t15.charCodeAt(e) - h2), e++;
    return e === l ? null : c;
  }
  function a() {
    for (; e < t15.length && RT.has(t15.charCodeAt(e)); )
      e++;
  }
}
function WT(t15) {
  const e = t15[0], r = t15[1] - 1;
  if (r < 0 && e <= 0)
    return re.falseFunc;
  if (e === -1)
    return (s) => s <= r;
  if (e === 0)
    return (s) => s === r;
  if (e === 1)
    return r < 0 ? re.trueFunc : (s) => s >= r;
  const n = Math.abs(e), i = (r % n + n) % n;
  return e > 1 ? (s) => s >= r && s % n === i : (s) => s <= r && s % n === i;
}
function Hc(t15) {
  return WT(jT(t15));
}
function Uc(t15, e) {
  return (r) => {
    const n = e.getParent(r);
    return n != null && e.isTag(n) && t15(r);
  };
}
var ef = {
  contains(t15, e, { adapter: r }) {
    return function(n) {
      return t15(n) && r.getText(n).includes(e);
    };
  },
  icontains(t15, e, { adapter: r }) {
    const n = e.toLowerCase();
    return function(i) {
      return t15(i) && r.getText(i).toLowerCase().includes(n);
    };
  },
  // Location specific methods
  "nth-child"(t15, e, { adapter: r, equals: n }) {
    const i = Hc(e);
    return i === re.falseFunc ? re.falseFunc : i === re.trueFunc ? Uc(t15, r) : function(s) {
      const o = r.getSiblings(s);
      let a = 0;
      for (let l = 0; l < o.length && !n(s, o[l]); l++)
        r.isTag(o[l]) && a++;
      return i(a) && t15(s);
    };
  },
  "nth-last-child"(t15, e, { adapter: r, equals: n }) {
    const i = Hc(e);
    return i === re.falseFunc ? re.falseFunc : i === re.trueFunc ? Uc(t15, r) : function(s) {
      const o = r.getSiblings(s);
      let a = 0;
      for (let l = o.length - 1; l >= 0 && !n(s, o[l]); l--)
        r.isTag(o[l]) && a++;
      return i(a) && t15(s);
    };
  },
  "nth-of-type"(t15, e, { adapter: r, equals: n }) {
    const i = Hc(e);
    return i === re.falseFunc ? re.falseFunc : i === re.trueFunc ? Uc(t15, r) : function(s) {
      const o = r.getSiblings(s);
      let a = 0;
      for (let l = 0; l < o.length; l++) {
        const c = o[l];
        if (n(s, c))
          break;
        r.isTag(c) && r.getName(c) === r.getName(s) && a++;
      }
      return i(a) && t15(s);
    };
  },
  "nth-last-of-type"(t15, e, { adapter: r, equals: n }) {
    const i = Hc(e);
    return i === re.falseFunc ? re.falseFunc : i === re.trueFunc ? Uc(t15, r) : function(s) {
      const o = r.getSiblings(s);
      let a = 0;
      for (let l = o.length - 1; l >= 0; l--) {
        const c = o[l];
        if (n(s, c))
          break;
        r.isTag(c) && r.getName(c) === r.getName(s) && a++;
      }
      return i(a) && t15(s);
    };
  },
  // TODO determine the actual root element
  root(t15, e, { adapter: r }) {
    return (n) => {
      const i = r.getParent(n);
      return (i == null || !r.isTag(i)) && t15(n);
    };
  },
  scope(t15, e, r, n) {
    const { equals: i } = r;
    return !n || n.length === 0 ? ef.root(t15, e, r) : n.length === 1 ? (s) => i(n[0], s) && t15(s) : (s) => n.includes(s) && t15(s);
  },
  hover: Od("isHovered"),
  visited: Od("isVisited"),
  active: Od("isActive")
};
function Od(t15) {
  return function(e, r, { adapter: n }) {
    const i = n[t15];
    return typeof i != "function" ? re.falseFunc : function(s) {
      return i(s) && e(s);
    };
  };
}
var u2 = {
  empty(t15, { adapter: e }) {
    return !e.getChildren(t15).some((r) => (
      // FIXME: `getText` call is potentially expensive.
      e.isTag(r) || e.getText(r) !== ""
    ));
  },
  "first-child"(t15, { adapter: e, equals: r }) {
    if (e.prevElementSibling)
      return e.prevElementSibling(t15) == null;
    const n = e.getSiblings(t15).find((i) => e.isTag(i));
    return n != null && r(t15, n);
  },
  "last-child"(t15, { adapter: e, equals: r }) {
    const n = e.getSiblings(t15);
    for (let i = n.length - 1; i >= 0; i--) {
      if (r(t15, n[i]))
        return true;
      if (e.isTag(n[i]))
        break;
    }
    return false;
  },
  "first-of-type"(t15, { adapter: e, equals: r }) {
    const n = e.getSiblings(t15), i = e.getName(t15);
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      if (r(t15, o))
        return true;
      if (e.isTag(o) && e.getName(o) === i)
        break;
    }
    return false;
  },
  "last-of-type"(t15, { adapter: e, equals: r }) {
    const n = e.getSiblings(t15), i = e.getName(t15);
    for (let s = n.length - 1; s >= 0; s--) {
      const o = n[s];
      if (r(t15, o))
        return true;
      if (e.isTag(o) && e.getName(o) === i)
        break;
    }
    return false;
  },
  "only-of-type"(t15, { adapter: e, equals: r }) {
    const n = e.getName(t15);
    return e.getSiblings(t15).every((i) => r(t15, i) || !e.isTag(i) || e.getName(i) !== n);
  },
  "only-child"(t15, { adapter: e, equals: r }) {
    return e.getSiblings(t15).every((n) => r(t15, n) || !e.isTag(n));
  }
};
function d2(t15, e, r, n) {
  if (r === null) {
    if (t15.length > n)
      throw new Error(`Pseudo-class :${e} requires an argument`);
  } else if (t15.length === n)
    throw new Error(`Pseudo-class :${e} doesn't have any arguments`);
}
var HT = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
var px = {};
function UT(t15, e) {
  return t15 === re.falseFunc ? re.falseFunc : (r) => e.isTag(r) && t15(r);
}
function fx(t15, e) {
  const r = e.getSiblings(t15);
  if (r.length <= 1)
    return [];
  const n = r.indexOf(t15);
  return n < 0 || n === r.length - 1 ? [] : r.slice(n + 1).filter(e.isTag);
}
function rf(t15) {
  return {
    xmlMode: !!t15.xmlMode,
    lowerCaseAttributeNames: !!t15.lowerCaseAttributeNames,
    lowerCaseTags: !!t15.lowerCaseTags,
    quirksMode: !!t15.quirksMode,
    cacheResults: !!t15.cacheResults,
    pseudos: t15.pseudos,
    adapter: t15.adapter,
    equals: t15.equals
  };
}
var zd = (t15, e, r, n, i) => {
  const s = i(e, rf(r), n);
  return s === re.trueFunc ? t15 : s === re.falseFunc ? re.falseFunc : (o) => s(o) && t15(o);
};
var qd = {
  is: zd,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: zd,
  where: zd,
  not(t15, e, r, n, i) {
    const s = i(e, rf(r), n);
    return s === re.falseFunc ? t15 : s === re.trueFunc ? re.falseFunc : (o) => !s(o) && t15(o);
  },
  has(t15, e, r, n, i) {
    const { adapter: s } = r, o = rf(r);
    o.relativeSelector = true;
    const a = e.some((h10) => h10.some(W1)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [px]
    ) : void 0, l = i(e, o, a);
    if (l === re.falseFunc)
      return re.falseFunc;
    const c = UT(l, s);
    if (a && l !== re.trueFunc) {
      const { shouldTestNextSiblings: h10 = false } = l;
      return (p) => {
        if (!t15(p))
          return false;
        a[0] = p;
        const m = s.getChildren(p), g = h10 ? [...m, ...fx(p, s)] : m;
        return s.existsOne(c, g);
      };
    }
    return (h10) => t15(h10) && s.existsOne(c, s.getChildren(h10));
  }
};
function VT(t15, e, r, n, i) {
  var s;
  const { name: o, data: a } = e;
  if (Array.isArray(a)) {
    if (!(o in qd))
      throw new Error(`Unknown pseudo-class :${o}(${a})`);
    return qd[o](t15, a, r, n, i);
  }
  const l = (s = r.pseudos) === null || s === void 0 ? void 0 : s[o], c = typeof l == "string" ? l : HT[o];
  if (typeof c == "string") {
    if (a != null)
      throw new Error(`Pseudo ${o} doesn't have any arguments`);
    const h10 = n0(c);
    return qd.is(t15, h10, r, n, i);
  }
  if (typeof l == "function")
    return d2(l, o, a, 1), (h10) => l(h10, a) && t15(h10);
  if (o in ef)
    return ef[o](t15, a, r, n);
  if (o in u2) {
    const h10 = u2[o];
    return d2(h10, o, a, 2), (p) => h10(p, r, a) && t15(p);
  }
  throw new Error(`Unknown pseudo-class :${o}`);
}
function Rd(t15, e) {
  const r = e.getParent(t15);
  return r && e.isTag(r) ? r : null;
}
function GT(t15, e, r, n, i) {
  const { adapter: s, equals: o } = r;
  switch (e.type) {
    case Rt.PseudoElement:
      throw new Error("Pseudo-elements are not supported by css-select");
    case Rt.ColumnCombinator:
      throw new Error("Column combinators are not yet supported by css-select");
    case Rt.Attribute: {
      if (e.namespace != null)
        throw new Error("Namespaced attributes are not yet supported by css-select");
      return (!r.xmlMode || r.lowerCaseAttributeNames) && (e.name = e.name.toLowerCase()), qT[e.action](t15, e, r);
    }
    case Rt.Pseudo:
      return VT(t15, e, r, n, i);
    case Rt.Tag: {
      if (e.namespace != null)
        throw new Error("Namespaced tag names are not yet supported by css-select");
      let { name: a } = e;
      return (!r.xmlMode || r.lowerCaseTags) && (a = a.toLowerCase()), function(l) {
        return s.getName(l) === a && t15(l);
      };
    }
    case Rt.Descendant: {
      if (r.cacheResults === false || typeof WeakSet > "u")
        return function(l) {
          let c = l;
          for (; c = Rd(c, s); )
            if (t15(c))
              return true;
          return false;
        };
      const a = /* @__PURE__ */ new WeakSet();
      return function(l) {
        let c = l;
        for (; c = Rd(c, s); )
          if (!a.has(c)) {
            if (s.isTag(c) && t15(c))
              return true;
            a.add(c);
          }
        return false;
      };
    }
    case "_flexibleDescendant":
      return function(a) {
        let l = a;
        do
          if (t15(l))
            return true;
        while (l = Rd(l, s));
        return false;
      };
    case Rt.Parent:
      return function(a) {
        return s.getChildren(a).some((l) => s.isTag(l) && t15(l));
      };
    case Rt.Child:
      return function(a) {
        const l = s.getParent(a);
        return l != null && s.isTag(l) && t15(l);
      };
    case Rt.Sibling:
      return function(a) {
        const l = s.getSiblings(a);
        for (let c = 0; c < l.length; c++) {
          const h10 = l[c];
          if (o(a, h10))
            break;
          if (s.isTag(h10) && t15(h10))
            return true;
        }
        return false;
      };
    case Rt.Adjacent:
      return s.prevElementSibling ? function(a) {
        const l = s.prevElementSibling(a);
        return l != null && t15(l);
      } : function(a) {
        const l = s.getSiblings(a);
        let c;
        for (let h10 = 0; h10 < l.length; h10++) {
          const p = l[h10];
          if (o(a, p))
            break;
          s.isTag(p) && (c = p);
        }
        return !!c && t15(c);
      };
    case Rt.Universal: {
      if (e.namespace != null && e.namespace !== "*")
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      return t15;
    }
  }
}
function mx(t15) {
  return t15.type === Rt.Pseudo && (t15.name === "scope" || Array.isArray(t15.data) && t15.data.some((e) => e.some(mx)));
}
var XT = { type: Rt.Descendant };
var YT = {
  type: "_flexibleDescendant"
};
var KT = {
  type: Rt.Pseudo,
  name: "scope",
  data: null
};
function ZT(t15, { adapter: e }, r) {
  const n = !!(r == null ? void 0 : r.every((i) => {
    const s = e.isTag(i) && e.getParent(i);
    return i === px || s && e.isTag(s);
  }));
  for (const i of t15) {
    if (!(i.length > 0 && W1(i[0]) && i[0].type !== Rt.Descendant)) if (n && !i.some(mx))
      i.unshift(XT);
    else
      continue;
    i.unshift(KT);
  }
}
function gx(t15, e, r) {
  var n;
  t15.forEach(IT), r = (n = e.context) !== null && n !== void 0 ? n : r;
  const i = Array.isArray(r), s = r && (Array.isArray(r) ? r : [r]);
  if (e.relativeSelector !== false)
    ZT(t15, e, s);
  else if (t15.some((l) => l.length > 0 && W1(l[0])))
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  let o = false;
  const a = t15.map((l) => {
    if (l.length >= 2) {
      const [c, h10] = l;
      c.type !== Rt.Pseudo || c.name !== "scope" || (i && h10.type === Rt.Descendant ? l[1] = YT : (h10.type === Rt.Adjacent || h10.type === Rt.Sibling) && (o = true));
    }
    return QT(l, e, s);
  }).reduce(JT, re.falseFunc);
  return a.shouldTestNextSiblings = o, a;
}
function QT(t15, e, r) {
  var n;
  return t15.reduce((i, s) => i === re.falseFunc ? re.falseFunc : GT(i, s, e, r, gx), (n = e.rootFunc) !== null && n !== void 0 ? n : re.trueFunc);
}
function JT(t15, e) {
  return e === re.falseFunc || t15 === re.trueFunc ? t15 : t15 === re.falseFunc || e === re.trueFunc ? e : function(r) {
    return t15(r) || e(r);
  };
}
var yx = (t15, e) => t15 === e;
var tA = {
  adapter: r0,
  equals: yx
};
function eA(t15) {
  var e, r, n, i;
  const s = t15 ?? tA;
  return (e = s.adapter) !== null && e !== void 0 || (s.adapter = r0), (r = s.equals) !== null && r !== void 0 || (s.equals = (i = (n = s.adapter) === null || n === void 0 ? void 0 : n.equals) !== null && i !== void 0 ? i : yx), s;
}
function rA(t15) {
  return function(e, r, n) {
    const i = eA(r);
    return t15(e, i, n);
  };
}
var H1 = rA(gx);
function bx(t15, e, r = false) {
  return r && (t15 = nA(t15, e)), Array.isArray(t15) ? e.removeSubsets(t15) : e.getChildren(t15);
}
function nA(t15, e) {
  const r = Array.isArray(t15) ? t15.slice(0) : [t15], n = r.length;
  for (let i = 0; i < n; i++) {
    const s = fx(r[i], e);
    r.push(...s);
  }
  return r;
}
var iA = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function eu(t15) {
  return t15.type !== "pseudo" ? false : iA.has(t15.name) ? true : t15.name === "not" && Array.isArray(t15.data) ? t15.data.some((e) => e.some(eu)) : false;
}
function sA(t15, e, r) {
  const n = e != null ? parseInt(e, 10) : NaN;
  switch (t15) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(n) ? n >= 0 ? n + 1 : 1 / 0 : 0;
    case "lt":
      return isFinite(n) ? n >= 0 ? Math.min(n, r) : 1 / 0 : 0;
    case "gt":
      return isFinite(n) ? 1 / 0 : 0;
    case "odd":
      return 2 * r;
    case "even":
      return 2 * r - 1;
    case "last":
    case "not":
      return 1 / 0;
  }
}
function oA(t15) {
  for (; t15.parent; )
    t15 = t15.parent;
  return t15;
}
function U1(t15) {
  const e = [], r = [];
  for (const n of t15)
    n.some(eu) ? e.push(n) : r.push(n);
  return [r, e];
}
var aA = {
  type: Rt.Universal,
  namespace: null
};
var lA = {
  type: Rt.Pseudo,
  name: "scope",
  data: null
};
function xx(t15, e, r = {}) {
  return wx([t15], e, r);
}
function wx(t15, e, r = {}) {
  if (typeof e == "function")
    return t15.some(e);
  const [n, i] = U1(n0(e));
  return n.length > 0 && t15.some(H1(n, r)) || i.some((s) => _x(s, t15, r).length > 0);
}
function cA(t15, e, r, n) {
  const i = typeof r == "string" ? parseInt(r, 10) : NaN;
  switch (t15) {
    case "first":
    case "lt":
      return e;
    case "last":
      return e.length > 0 ? [e[e.length - 1]] : e;
    case "nth":
    case "eq":
      return isFinite(i) && Math.abs(i) < e.length ? [i < 0 ? e[e.length + i] : e[i]] : [];
    case "gt":
      return isFinite(i) ? e.slice(i + 1) : [];
    case "even":
      return e.filter((s, o) => o % 2 === 0);
    case "odd":
      return e.filter((s, o) => o % 2 === 1);
    case "not": {
      const s = new Set(vx(r, e, n));
      return e.filter((o) => !s.has(o));
    }
  }
}
function kx(t15, e, r = {}) {
  return vx(n0(t15), e, r);
}
function vx(t15, e, r) {
  if (e.length === 0)
    return [];
  const [n, i] = U1(t15);
  let s;
  if (n.length) {
    const o = sf(e, n, r);
    if (i.length === 0)
      return o;
    o.length && (s = new Set(o));
  }
  for (let o = 0; o < i.length && (s == null ? void 0 : s.size) !== e.length; o++) {
    const a = i[o];
    if ((s ? e.filter((c) => Xt(c) && !s.has(c)) : e).length === 0)
      break;
    const l = _x(a, e, r);
    if (l.length)
      if (s)
        l.forEach((c) => s.add(c));
      else {
        if (o === i.length - 1)
          return l;
        s = new Set(l);
      }
  }
  return typeof s < "u" ? s.size === e.length ? e : (
    // Filter elements to preserve order
    e.filter((o) => s.has(o))
  ) : [];
}
function _x(t15, e, r) {
  var n;
  if (t15.some(ml)) {
    const i = (n = r.root) !== null && n !== void 0 ? n : oA(e[0]), s = { ...r, context: e, relativeSelector: false };
    return t15.push(lA), ru(i, t15, s, true, e.length);
  }
  return ru(e, t15, r, false, e.length);
}
function hA(t15, e, r = {}, n = 1 / 0) {
  if (typeof t15 == "function")
    return Cx(e, t15);
  const [i, s] = U1(n0(t15)), o = s.map((a) => ru(e, a, r, true, n));
  return i.length && o.push(nf(e, i, r, n)), o.length === 0 ? [] : o.length === 1 ? o[0] : ca(o.reduce((a, l) => [...a, ...l]));
}
function ru(t15, e, r, n, i) {
  const s = e.findIndex(eu), o = e.slice(0, s), a = e[s], l = e.length - 1 === s ? i : 1 / 0, c = sA(a.name, a.data, l);
  if (c === 0)
    return [];
  const h10 = (o.length === 0 && !Array.isArray(t15) ? t0(t15).filter(Xt) : o.length === 0 ? (Array.isArray(t15) ? t15 : [t15]).filter(Xt) : n || o.some(ml) ? nf(t15, [o], r, c) : sf(t15, [o], r)).slice(0, c);
  let p = cA(a.name, h10, a.data, r);
  if (p.length === 0 || e.length === s + 1)
    return p;
  const m = e.slice(s + 1), g = m.some(ml);
  if (g) {
    if (ml(m[0])) {
      const { type: y } = m[0];
      (y === Rt.Sibling || y === Rt.Adjacent) && (p = bx(p, r0, true)), m.unshift(aA);
    }
    r = {
      ...r,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (y) => p.includes(y)
    };
  } else r.rootFunc && r.rootFunc !== tu.trueFunc && (r = { ...r, rootFunc: tu.trueFunc });
  return m.some(eu) ? ru(p, m, r, false, i) : g ? (
    // Query existing elements to resolve traversal.
    nf(p, [m], r, i)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    sf(p, [m], r)
  );
}
function nf(t15, e, r, n) {
  const i = H1(e, r, t15);
  return Cx(t15, i, n);
}
function Cx(t15, e, r = 1 / 0) {
  const n = bx(t15, r0, e.shouldTestNextSiblings);
  return R1((i) => Xt(i) && e(i), n, true, r);
}
function sf(t15, e, r) {
  const n = (Array.isArray(t15) ? t15 : [t15]).filter(Xt);
  if (n.length === 0)
    return n;
  const i = H1(e, r);
  return i === tu.trueFunc ? n : n.filter(i);
}
var uA = /^\s*[+~]/;
function dA(t15) {
  if (!t15)
    return this._make([]);
  if (typeof t15 != "string") {
    const e = Mi(t15) ? t15.toArray() : [t15], r = this.toArray();
    return this._make(e.filter((n) => r.some((i) => ix(i, n))));
  }
  return this._findBySelector(t15, Number.POSITIVE_INFINITY);
}
function pA(t15, e) {
  var r;
  const n = this.toArray(), i = uA.test(t15) ? n : this.children().toArray(), s = {
    context: n,
    root: (r = this._root) === null || r === void 0 ? void 0 : r[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(hA(t15, i, s, e));
}
function V1(t15) {
  return function(e, ...r) {
    return function(n) {
      var i;
      let s = t15(e, this);
      return n && (s = Y1(s, n, this.options.xmlMode, (i = this._root) === null || i === void 0 ? void 0 : i[0])), this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && s.length > 1 ? r.reduce((o, a) => a(o), s) : s
      );
    };
  };
}
var Zl = V1((t15, e) => {
  let r = [];
  for (let n = 0; n < e.length; n++) {
    const i = t15(e[n]);
    i.length > 0 && (r = r.concat(i));
  }
  return r;
});
var G1 = V1((t15, e) => {
  const r = [];
  for (let n = 0; n < e.length; n++) {
    const i = t15(e[n]);
    i !== null && r.push(i);
  }
  return r;
});
function X1(t15, ...e) {
  let r = null;
  const n = V1((i, s) => {
    const o = [];
    return Oe(s, (a) => {
      for (let l; (l = i(a)) && !(r == null ? void 0 : r(l, o.length)); a = l)
        o.push(l);
    }), o;
  })(t15, ...e);
  return function(i, s) {
    r = typeof i == "string" ? (a) => xx(a, i, this.options) : i ? Ql(i) : null;
    const o = n.call(this, s);
    return r = null, o;
  };
}
function ha(t15) {
  return t15.length > 1 ? Array.from(new Set(t15)) : t15;
}
var fA = G1(({ parent: t15 }) => t15 && !oo(t15) ? t15 : null, ha);
var mA = Zl((t15) => {
  const e = [];
  for (; t15.parent && !oo(t15.parent); )
    e.push(t15.parent), t15 = t15.parent;
  return e;
}, ca, (t15) => t15.reverse());
var gA = X1(({ parent: t15 }) => t15 && !oo(t15) ? t15 : null, ca, (t15) => t15.reverse());
function yA(t15) {
  var e;
  const r = [];
  if (!t15)
    return this._make(r);
  const n = {
    xmlMode: this.options.xmlMode,
    root: (e = this._root) === null || e === void 0 ? void 0 : e[0]
  }, i = typeof t15 == "string" ? (s) => xx(s, t15, n) : Ql(t15);
  return Oe(this, (s) => {
    for (s && !oo(s) && !Xt(s) && (s = s.parent); s && Xt(s); ) {
      if (i(s, 0)) {
        r.includes(s) || r.push(s);
        break;
      }
      s = s.parent;
    }
  }), this._make(r);
}
var bA = G1((t15) => z1(t15));
var xA = Zl((t15) => {
  const e = [];
  for (; t15.next; )
    t15 = t15.next, Xt(t15) && e.push(t15);
  return e;
}, ha);
var wA = X1((t15) => z1(t15), ha);
var kA = G1((t15) => q1(t15));
var vA = Zl((t15) => {
  const e = [];
  for (; t15.prev; )
    t15 = t15.prev, Xt(t15) && e.push(t15);
  return e;
}, ha);
var _A = X1((t15) => q1(t15), ha);
var CA = Zl((t15) => Z5(t15).filter((e) => Xt(e) && e !== t15), ca);
var SA = Zl((t15) => t0(t15).filter(Xt), ha);
function TA() {
  const t15 = this.toArray().reduce((e, r) => lr(r) ? e.concat(r.children) : e, []);
  return this._make(t15);
}
function AA(t15) {
  let e = 0;
  const r = this.length;
  for (; e < r && t15.call(this[e], e, this[e]) !== false; )
    ++e;
  return this;
}
function $A(t15) {
  let e = [];
  for (let r = 0; r < this.length; r++) {
    const n = this[r], i = t15.call(n, r, n);
    i != null && (e = e.concat(i));
  }
  return this._make(e);
}
function Ql(t15) {
  return typeof t15 == "function" ? (e, r) => t15.call(e, r, e) : Mi(t15) ? (e) => Array.prototype.includes.call(t15, e) : function(e) {
    return t15 === e;
  };
}
function EA(t15) {
  var e;
  return this._make(Y1(this.toArray(), t15, this.options.xmlMode, (e = this._root) === null || e === void 0 ? void 0 : e[0]));
}
function Y1(t15, e, r, n) {
  return typeof e == "string" ? kx(e, t15, { xmlMode: r, root: n }) : t15.filter(Ql(e));
}
function MA(t15) {
  const e = this.toArray();
  return typeof t15 == "string" ? wx(e.filter(Xt), t15, this.options) : t15 ? e.some(Ql(t15)) : false;
}
function BA(t15) {
  let e = this.toArray();
  if (typeof t15 == "string") {
    const r = new Set(kx(t15, e, this.options));
    e = e.filter((n) => !r.has(n));
  } else {
    const r = Ql(t15);
    e = e.filter((n, i) => !r(n, i));
  }
  return this._make(e);
}
function LA(t15) {
  return this.filter(typeof t15 == "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${t15})`
  ) : (e, r) => this._make(r).find(t15).length > 0);
}
function DA() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function FA() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function NA(t15) {
  var e;
  return t15 = +t15, t15 === 0 && this.length <= 1 ? this : (t15 < 0 && (t15 = this.length + t15), this._make((e = this[t15]) !== null && e !== void 0 ? e : []));
}
function IA(t15) {
  return t15 == null ? this.toArray() : this[t15 < 0 ? this.length + t15 : t15];
}
function OA() {
  return Array.prototype.slice.call(this);
}
function zA(t15) {
  let e, r;
  return t15 == null ? (e = this.parent().children(), r = this[0]) : typeof t15 == "string" ? (e = this._make(t15), r = this[0]) : (e = this, r = Mi(t15) ? t15[0] : t15), Array.prototype.indexOf.call(e, r);
}
function qA(t15, e) {
  return this._make(Array.prototype.slice.call(this, t15, e));
}
function RA() {
  var t15;
  return (t15 = this.prevObject) !== null && t15 !== void 0 ? t15 : this._make([]);
}
function PA(t15, e) {
  const r = this._make(t15, e), n = ca([...this.get(), ...r.get()]);
  return this._make(n);
}
function jA(t15) {
  return this.prevObject ? this.add(t15 ? this.prevObject.filter(t15) : this.prevObject) : this;
}
var WA = Object.freeze(Object.defineProperty({
  __proto__: null,
  _findBySelector: pA,
  add: PA,
  addBack: jA,
  children: SA,
  closest: yA,
  contents: TA,
  each: AA,
  end: RA,
  eq: NA,
  filter: EA,
  filterArray: Y1,
  find: dA,
  first: DA,
  get: IA,
  has: LA,
  index: zA,
  is: MA,
  last: FA,
  map: $A,
  next: bA,
  nextAll: xA,
  nextUntil: wA,
  not: BA,
  parent: fA,
  parents: mA,
  parentsUntil: gA,
  prev: kA,
  prevAll: vA,
  prevUntil: _A,
  siblings: CA,
  slice: qA,
  toArray: OA
}, Symbol.toStringTag, { value: "Module" }));
function HA(t15) {
  return function(e, r, n, i) {
    if (typeof Buffer < "u" && Buffer.isBuffer(e) && (e = e.toString()), typeof e == "string")
      return t15(e, r, n, i);
    const s = e;
    if (!Array.isArray(s) && oo(s))
      return s;
    const o = new Cl([]);
    return Ks(s, o), o;
  };
}
function Ks(t15, e) {
  const r = Array.isArray(t15) ? t15 : [t15];
  e ? e.children = r : e = null;
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    i.parent && i.parent.children !== r && ao(i), e ? (i.prev = r[n - 1] || null, i.next = r[n + 1] || null) : i.prev = i.next = null, i.parent = e;
  }
  return e;
}
function UA(t15, e) {
  if (t15 == null)
    return [];
  if (typeof t15 == "string")
    return this._parse(t15, this.options, false, null).children.slice(0);
  if ("length" in t15) {
    if (t15.length === 1)
      return this._makeDomArray(t15[0], e);
    const r = [];
    for (let n = 0; n < t15.length; n++) {
      const i = t15[n];
      if (typeof i == "object") {
        if (i == null)
          continue;
        if (!("length" in i)) {
          r.push(e ? Sl(i, true) : i);
          continue;
        }
      }
      r.push(...this._makeDomArray(i, e));
    }
    return r;
  }
  return [e ? Sl(t15, true) : t15];
}
function Sx(t15) {
  return function(...e) {
    const r = this.length - 1;
    return Oe(this, (n, i) => {
      if (!lr(n))
        return;
      const s = typeof e[0] == "function" ? e[0].call(n, i, this._render(n.children)) : e, o = this._makeDomArray(s, i < r);
      t15(o, n.children, n);
    });
  };
}
function ms(t15, e, r, n, i) {
  var s, o;
  const a = [
    e,
    r,
    ...n
  ], l = e === 0 ? null : t15[e - 1], c = e + r >= t15.length ? null : t15[e + r];
  for (let h10 = 0; h10 < n.length; ++h10) {
    const p = n[h10], m = p.parent;
    if (m) {
      const g = m.children.indexOf(p);
      g > -1 && (m.children.splice(g, 1), i === m && e > g && a[0]--);
    }
    p.parent = i, p.prev && (p.prev.next = (s = p.next) !== null && s !== void 0 ? s : null), p.next && (p.next.prev = (o = p.prev) !== null && o !== void 0 ? o : null), p.prev = h10 === 0 ? l : n[h10 - 1], p.next = h10 === n.length - 1 ? c : n[h10 + 1];
  }
  return l && (l.next = n[0]), c && (c.prev = n[n.length - 1]), t15.splice(...a);
}
function VA(t15) {
  return (Mi(t15) ? t15 : this._make(t15)).append(this), this;
}
function GA(t15) {
  return (Mi(t15) ? t15 : this._make(t15)).prepend(this), this;
}
var XA = Sx((t15, e, r) => {
  ms(e, e.length, 0, t15, r);
});
var YA = Sx((t15, e, r) => {
  ms(e, 0, 0, t15, r);
});
function Tx(t15) {
  return function(e) {
    const r = this.length - 1, n = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const s = this[i], o = typeof e == "function" ? e.call(s, i, s) : typeof e == "string" && !Jp(e) ? n.find(e).clone() : e, [a] = this._makeDomArray(o, i < r);
      if (!a || !lr(a))
        continue;
      let l = a, c = 0;
      for (; c < l.children.length; ) {
        const h10 = l.children[c];
        Xt(h10) ? (l = h10, c = 0) : c++;
      }
      t15(s, l, [a]);
    }
    return this;
  };
}
var KA = Tx((t15, e, r) => {
  const { parent: n } = t15;
  if (!n)
    return;
  const i = n.children, s = i.indexOf(t15);
  Ks([t15], e), ms(i, s, 0, r, n);
});
var ZA = Tx((t15, e, r) => {
  lr(t15) && (Ks(t15.children, e), Ks(r, t15));
});
function QA(t15) {
  return this.parent(t15).not("body").each((e, r) => {
    this._make(r).replaceWith(r.children);
  }), this;
}
function JA(t15) {
  const e = this[0];
  if (e) {
    const r = this._make(typeof t15 == "function" ? t15.call(e, 0, e) : t15).insertBefore(e);
    let n;
    for (let s = 0; s < r.length; s++)
      r[s].type === "tag" && (n = r[s]);
    let i = 0;
    for (; n && i < n.children.length; ) {
      const s = n.children[i];
      s.type === "tag" ? (n = s, i = 0) : i++;
    }
    n && this._make(n).append(this);
  }
  return this;
}
function t$(...t15) {
  const e = this.length - 1;
  return Oe(this, (r, n) => {
    if (!lr(r) || !r.parent)
      return;
    const i = r.parent.children, s = i.indexOf(r);
    if (s < 0)
      return;
    const o = typeof t15[0] == "function" ? t15[0].call(r, n, this._render(r.children)) : t15, a = this._makeDomArray(o, n < e);
    ms(i, s + 1, 0, a, r.parent);
  });
}
function e$(t15) {
  typeof t15 == "string" && (t15 = this._make(t15)), this.remove();
  const e = [];
  for (const r of this._makeDomArray(t15)) {
    const n = this.clone().toArray(), { parent: i } = r;
    if (!i)
      continue;
    const s = i.children, o = s.indexOf(r);
    o < 0 || (ms(s, o + 1, 0, n, i), e.push(...n));
  }
  return this._make(e);
}
function r$(...t15) {
  const e = this.length - 1;
  return Oe(this, (r, n) => {
    if (!lr(r) || !r.parent)
      return;
    const i = r.parent.children, s = i.indexOf(r);
    if (s < 0)
      return;
    const o = typeof t15[0] == "function" ? t15[0].call(r, n, this._render(r.children)) : t15, a = this._makeDomArray(o, n < e);
    ms(i, s, 0, a, r.parent);
  });
}
function n$(t15) {
  const e = this._make(t15);
  this.remove();
  const r = [];
  return Oe(e, (n) => {
    const i = this.clone().toArray(), { parent: s } = n;
    if (!s)
      return;
    const o = s.children, a = o.indexOf(n);
    a < 0 || (ms(o, a, 0, i, s), r.push(...i));
  }), this._make(r);
}
function i$(t15) {
  const e = t15 ? this.filter(t15) : this;
  return Oe(e, (r) => {
    ao(r), r.prev = r.next = r.parent = null;
  }), this;
}
function s$(t15) {
  return Oe(this, (e, r) => {
    const { parent: n } = e;
    if (!n)
      return;
    const i = n.children, s = typeof t15 == "function" ? t15.call(e, r, e) : t15, o = this._makeDomArray(s);
    Ks(o, null);
    const a = i.indexOf(e);
    ms(i, a, 1, o, n), o.includes(e) || (e.parent = e.prev = e.next = null);
  });
}
function o$() {
  return Oe(this, (t15) => {
    if (lr(t15)) {
      for (const e of t15.children)
        e.next = e.prev = e.parent = null;
      t15.children.length = 0;
    }
  });
}
function a$(t15) {
  if (t15 === void 0) {
    const e = this[0];
    return !e || !lr(e) ? null : this._render(e.children);
  }
  return Oe(this, (e) => {
    if (!lr(e))
      return;
    for (const n of e.children)
      n.next = n.prev = n.parent = null;
    const r = Mi(t15) ? t15.toArray() : this._parse(`${t15}`, this.options, false, e).children;
    Ks(r, e);
  });
}
function l$() {
  return this._render(this);
}
function c$(t15) {
  return t15 === void 0 ? Tl(this) : typeof t15 == "function" ? Oe(this, (e, r) => this._make(e).text(t15.call(e, r, Tl([e])))) : Oe(this, (e) => {
    if (!lr(e))
      return;
    for (const n of e.children)
      n.next = n.prev = n.parent = null;
    const r = new Xh(`${t15}`);
    Ks(r, e);
  });
}
function h$() {
  const t15 = Array.prototype.map.call(this.get(), (r) => Sl(r, true)), e = new Cl(t15);
  for (const r of t15)
    r.parent = e;
  return this._make(t15);
}
var u$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  _makeDomArray: UA,
  after: t$,
  append: XA,
  appendTo: VA,
  before: r$,
  clone: h$,
  empty: o$,
  html: a$,
  insertAfter: e$,
  insertBefore: n$,
  prepend: YA,
  prependTo: GA,
  remove: i$,
  replaceWith: s$,
  text: c$,
  toString: l$,
  unwrap: QA,
  wrap: KA,
  wrapAll: JA,
  wrapInner: ZA
}, Symbol.toStringTag, { value: "Module" }));
function d$(t15, e) {
  if (t15 != null && e != null || // When `prop` is a "plain" object
  typeof t15 == "object" && !Array.isArray(t15))
    return Oe(this, (r, n) => {
      Xt(r) && Ax(r, t15, e, n);
    });
  if (this.length !== 0)
    return $x(this[0], t15);
}
function Ax(t15, e, r, n) {
  if (typeof e == "string") {
    const i = $x(t15), s = typeof r == "function" ? r.call(t15, n, i[e]) : r;
    s === "" ? delete i[e] : s != null && (i[e] = s), t15.attribs.style = p$(i);
  } else if (typeof e == "object") {
    const i = Object.keys(e);
    for (let s = 0; s < i.length; s++) {
      const o = i[s];
      Ax(t15, o, e[o], s);
    }
  }
}
function $x(t15, e) {
  if (!t15 || !Xt(t15))
    return;
  const r = f$(t15.attribs.style);
  if (typeof e == "string")
    return r[e];
  if (Array.isArray(e)) {
    const n = {};
    for (const i of e)
      r[i] != null && (n[i] = r[i]);
    return n;
  }
  return r;
}
function p$(t15) {
  return Object.keys(t15).reduce((e, r) => `${e}${e ? " " : ""}${r}: ${t15[r]};`, "");
}
function f$(t15) {
  if (t15 = (t15 || "").trim(), !t15)
    return {};
  const e = {};
  let r;
  for (const n of t15.split(";")) {
    const i = n.indexOf(":");
    if (i < 1 || i === n.length - 1) {
      const s = n.trimEnd();
      s.length > 0 && r !== void 0 && (e[r] += `;${s}`);
    } else
      r = n.slice(0, i).trim(), e[r] = n.slice(i + 1).trim();
  }
  return e;
}
var m$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  css: d$
}, Symbol.toStringTag, { value: "Module" }));
var p2 = "input,select,textarea,keygen";
var g$ = /%20/g;
var f2 = /\r?\n/g;
function y$() {
  return this.serializeArray().map((t15) => `${encodeURIComponent(t15.name)}=${encodeURIComponent(t15.value)}`).join("&").replace(g$, "+");
}
function b$() {
  return this.map((t15, e) => {
    const r = this._make(e);
    return Xt(e) && e.name === "form" ? r.find(p2).toArray() : r.filter(p2).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
  ).map((t15, e) => {
    var r;
    const n = this._make(e), i = n.attr("name"), s = (r = n.val()) !== null && r !== void 0 ? r : "";
    return Array.isArray(s) ? s.map((o) => (
      /*
       * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
       * These can occur inside of `<textarea>'s`
       */
      { name: i, value: o.replace(f2, `\r
`) }
    )) : { name: i, value: s.replace(f2, `\r
`) };
  }).toArray();
}
var x$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  serialize: y$,
  serializeArray: b$
}, Symbol.toStringTag, { value: "Module" }));
function w$(t15) {
  var e;
  return typeof t15 == "string" ? { selector: t15, value: "textContent" } : {
    selector: t15.selector,
    value: (e = t15.value) !== null && e !== void 0 ? e : "textContent"
  };
}
function k$(t15) {
  const e = {};
  for (const r in t15) {
    const n = t15[r], i = Array.isArray(n), { selector: s, value: o } = w$(i ? n[0] : n), a = typeof o == "function" ? o : typeof o == "string" ? (l) => this._make(l).prop(o) : (l) => this._make(l).extract(o);
    if (i)
      e[r] = this._findBySelector(s, Number.POSITIVE_INFINITY).map((l, c) => a(c, r, e)).get();
    else {
      const l = this._findBySelector(s, 1);
      e[r] = l.length > 0 ? a(l[0], r, e) : void 0;
    }
  }
  return e;
}
var v$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  extract: k$
}, Symbol.toStringTag, { value: "Module" }));
var Jl = class {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(e, r, n) {
    if (this.length = 0, this.options = n, this._root = r, e) {
      for (let i = 0; i < e.length; i++)
        this[i] = e[i];
      this.length = e.length;
    }
  }
};
Jl.prototype.cheerio = "[cheerio object]";
Jl.prototype.splice = Array.prototype.splice;
Jl.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Jl.prototype, AT, WA, u$, m$, x$, v$);
function _$(t15, e) {
  return function r(n, i, s = true) {
    if (n == null)
      throw new Error("cheerio.load() expects a string");
    const o = Kp(i), a = t15(n, o, s, null);
    class l extends Jl {
      _make(p, m) {
        const g = c(p, m);
        return g.prevObject = this, g;
      }
      _parse(p, m, g, y) {
        return t15(p, m, g, y);
      }
      _render(p) {
        return e(p, this.options);
      }
    }
    function c(h10, p, m = a, g) {
      if (h10 && Mi(h10))
        return h10;
      const y = Kp(g, o), x = typeof m == "string" ? [t15(m, y, false, null)] : "length" in m ? m : [m], k = Mi(x) ? x : new l(x, null, y);
      if (k._root = k, !h10)
        return new l(void 0, k, y);
      const C = typeof h10 == "string" && Jp(h10) ? (
        // $(<html>)
        t15(h10, y, false, null).children
      ) : C$(h10) ? (
        // $(dom)
        [h10]
      ) : Array.isArray(h10) ? (
        // $([dom])
        h10
      ) : void 0, _ = new l(C, k, y);
      if (C)
        return _;
      if (typeof h10 != "string")
        throw new TypeError("Unexpected type of selector");
      let $ = h10;
      const L = p ? (
        // If we don't have a context, maybe we have a root, from loading
        typeof p == "string" ? Jp(p) ? (
          // $('li', '<ul>...</ul>')
          new l([t15(p, y, false, null)], k, y)
        ) : (
          // $('li', 'ul')
          ($ = `${p} ${$}`, k)
        ) : Mi(p) ? (
          // $('li', $)
          p
        ) : (
          // $('li', node), $('li', [nodes])
          new l(Array.isArray(p) ? p : [p], k, y)
        )
      ) : k;
      return L ? L.find($) : _;
    }
    return Object.assign(c, mT, {
      load: r,
      // `_root` and `_options` are used in static methods.
      _root: a,
      _options: o,
      // Add `fn` for plugins
      fn: l.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: l.prototype
    }), c;
  };
}
function C$(t15) {
  return !!t15.name || t15.type === "root" || t15.type === "text" || t15.type === "comment";
}
var Pt;
(function(t15) {
  t15[t15.Tab = 9] = "Tab", t15[t15.NewLine = 10] = "NewLine", t15[t15.FormFeed = 12] = "FormFeed", t15[t15.CarriageReturn = 13] = "CarriageReturn", t15[t15.Space = 32] = "Space", t15[t15.ExclamationMark = 33] = "ExclamationMark", t15[t15.Number = 35] = "Number", t15[t15.Amp = 38] = "Amp", t15[t15.SingleQuote = 39] = "SingleQuote", t15[t15.DoubleQuote = 34] = "DoubleQuote", t15[t15.Dash = 45] = "Dash", t15[t15.Slash = 47] = "Slash", t15[t15.Zero = 48] = "Zero", t15[t15.Nine = 57] = "Nine", t15[t15.Semi = 59] = "Semi", t15[t15.Lt = 60] = "Lt", t15[t15.Eq = 61] = "Eq", t15[t15.Gt = 62] = "Gt", t15[t15.Questionmark = 63] = "Questionmark", t15[t15.UpperA = 65] = "UpperA", t15[t15.LowerA = 97] = "LowerA", t15[t15.UpperF = 70] = "UpperF", t15[t15.LowerF = 102] = "LowerF", t15[t15.UpperZ = 90] = "UpperZ", t15[t15.LowerZ = 122] = "LowerZ", t15[t15.LowerX = 120] = "LowerX", t15[t15.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(Pt || (Pt = {}));
var pt;
(function(t15) {
  t15[t15.Text = 1] = "Text", t15[t15.BeforeTagName = 2] = "BeforeTagName", t15[t15.InTagName = 3] = "InTagName", t15[t15.InSelfClosingTag = 4] = "InSelfClosingTag", t15[t15.BeforeClosingTagName = 5] = "BeforeClosingTagName", t15[t15.InClosingTagName = 6] = "InClosingTagName", t15[t15.AfterClosingTagName = 7] = "AfterClosingTagName", t15[t15.BeforeAttributeName = 8] = "BeforeAttributeName", t15[t15.InAttributeName = 9] = "InAttributeName", t15[t15.AfterAttributeName = 10] = "AfterAttributeName", t15[t15.BeforeAttributeValue = 11] = "BeforeAttributeValue", t15[t15.InAttributeValueDq = 12] = "InAttributeValueDq", t15[t15.InAttributeValueSq = 13] = "InAttributeValueSq", t15[t15.InAttributeValueNq = 14] = "InAttributeValueNq", t15[t15.BeforeDeclaration = 15] = "BeforeDeclaration", t15[t15.InDeclaration = 16] = "InDeclaration", t15[t15.InProcessingInstruction = 17] = "InProcessingInstruction", t15[t15.BeforeComment = 18] = "BeforeComment", t15[t15.CDATASequence = 19] = "CDATASequence", t15[t15.InSpecialComment = 20] = "InSpecialComment", t15[t15.InCommentLike = 21] = "InCommentLike", t15[t15.BeforeSpecialS = 22] = "BeforeSpecialS", t15[t15.BeforeSpecialT = 23] = "BeforeSpecialT", t15[t15.SpecialStartSequence = 24] = "SpecialStartSequence", t15[t15.InSpecialTag = 25] = "InSpecialTag", t15[t15.InEntity = 26] = "InEntity";
})(pt || (pt = {}));
function vi(t15) {
  return t15 === Pt.Space || t15 === Pt.NewLine || t15 === Pt.Tab || t15 === Pt.FormFeed || t15 === Pt.CarriageReturn;
}
function Vc(t15) {
  return t15 === Pt.Slash || t15 === Pt.Gt || vi(t15);
}
function S$(t15) {
  return t15 >= Pt.LowerA && t15 <= Pt.LowerZ || t15 >= Pt.UpperA && t15 <= Pt.UpperZ;
}
var Gn;
(function(t15) {
  t15[t15.NoValue = 0] = "NoValue", t15[t15.Unquoted = 1] = "Unquoted", t15[t15.Single = 2] = "Single", t15[t15.Double = 3] = "Double";
})(Gn || (Gn = {}));
var hr = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea`
};
var T$ = class {
  constructor({ xmlMode: e = false, decodeEntities: r = true }, n) {
    this.cbs = n, this.state = pt.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = pt.Text, this.isSpecial = false, this.running = true, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = e, this.decodeEntities = r, this.entityDecoder = new U5(e ? H5 : W5, (i, s) => this.emitCodePoint(i, s));
  }
  reset() {
    this.state = pt.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = pt.Text, this.currentSequence = void 0, this.running = true, this.offset = 0;
  }
  write(e) {
    this.offset += this.buffer.length, this.buffer = e, this.parse();
  }
  end() {
    this.running && this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true, this.index < this.buffer.length + this.offset && this.parse();
  }
  stateText(e) {
    e === Pt.Lt || !this.decodeEntities && this.fastForwardTo(Pt.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = pt.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && e === Pt.Amp && this.startEntity();
  }
  stateSpecialStartSequence(e) {
    const r = this.sequenceIndex === this.currentSequence.length;
    if (!(r ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      Vc(e)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (e | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.isSpecial = false;
    else if (!r) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = pt.InTagName, this.stateInTagName(e);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === Pt.Gt || vi(e)) {
        const r = this.index - this.currentSequence.length;
        if (this.sectionStart < r) {
          const n = this.index;
          this.index = r, this.cbs.ontext(this.sectionStart, r), this.index = n;
        }
        this.isSpecial = false, this.sectionStart = r + 2, this.stateInClosingTagName(e);
        return;
      }
      this.sequenceIndex = 0;
    }
    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === hr.TitleEnd ? this.decodeEntities && e === Pt.Amp && this.startEntity() : this.fastForwardTo(Pt.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === Pt.Lt);
  }
  stateCDATASequence(e) {
    e === hr.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === hr.Cdata.length && (this.state = pt.InCommentLike, this.currentSequence = hr.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = pt.InDeclaration, this.stateInDeclaration(e));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length + this.offset; )
      if (this.buffer.charCodeAt(this.index - this.offset) === e)
        return true;
    return this.index = this.buffer.length + this.offset - 1, false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === hr.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = pt.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(e) {
    return this.xmlMode ? !Vc(e) : S$(e);
  }
  startSpecial(e, r) {
    this.isSpecial = true, this.currentSequence = e, this.sequenceIndex = r, this.state = pt.SpecialStartSequence;
  }
  stateBeforeTagName(e) {
    if (e === Pt.ExclamationMark)
      this.state = pt.BeforeDeclaration, this.sectionStart = this.index + 1;
    else if (e === Pt.Questionmark)
      this.state = pt.InProcessingInstruction, this.sectionStart = this.index + 1;
    else if (this.isTagStartChar(e)) {
      const r = e | 32;
      this.sectionStart = this.index, this.xmlMode ? this.state = pt.InTagName : r === hr.ScriptEnd[2] ? this.state = pt.BeforeSpecialS : r === hr.TitleEnd[2] ? this.state = pt.BeforeSpecialT : this.state = pt.InTagName;
    } else e === Pt.Slash ? this.state = pt.BeforeClosingTagName : (this.state = pt.Text, this.stateText(e));
  }
  stateInTagName(e) {
    Vc(e) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = pt.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateBeforeClosingTagName(e) {
    vi(e) || (e === Pt.Gt ? this.state = pt.Text : (this.state = this.isTagStartChar(e) ? pt.InClosingTagName : pt.InSpecialComment, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === Pt.Gt || vi(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = pt.AfterClosingTagName, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    (e === Pt.Gt || this.fastForwardTo(Pt.Gt)) && (this.state = pt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeAttributeName(e) {
    e === Pt.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = pt.InSpecialTag, this.sequenceIndex = 0) : this.state = pt.Text, this.sectionStart = this.index + 1) : e === Pt.Slash ? this.state = pt.InSelfClosingTag : vi(e) || (this.state = pt.InAttributeName, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === Pt.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = pt.Text, this.sectionStart = this.index + 1, this.isSpecial = false) : vi(e) || (this.state = pt.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateInAttributeName(e) {
    (e === Pt.Eq || Vc(e)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = this.index, this.state = pt.AfterAttributeName, this.stateAfterAttributeName(e));
  }
  stateAfterAttributeName(e) {
    e === Pt.Eq ? this.state = pt.BeforeAttributeValue : e === Pt.Slash || e === Pt.Gt ? (this.cbs.onattribend(Gn.NoValue, this.sectionStart), this.sectionStart = -1, this.state = pt.BeforeAttributeName, this.stateBeforeAttributeName(e)) : vi(e) || (this.cbs.onattribend(Gn.NoValue, this.sectionStart), this.state = pt.InAttributeName, this.sectionStart = this.index);
  }
  stateBeforeAttributeValue(e) {
    e === Pt.DoubleQuote ? (this.state = pt.InAttributeValueDq, this.sectionStart = this.index + 1) : e === Pt.SingleQuote ? (this.state = pt.InAttributeValueSq, this.sectionStart = this.index + 1) : vi(e) || (this.sectionStart = this.index, this.state = pt.InAttributeValueNq, this.stateInAttributeValueNoQuotes(e));
  }
  handleInAttributeValue(e, r) {
    e === r || !this.decodeEntities && this.fastForwardTo(r) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(r === Pt.DoubleQuote ? Gn.Double : Gn.Single, this.index + 1), this.state = pt.BeforeAttributeName) : this.decodeEntities && e === Pt.Amp && this.startEntity();
  }
  stateInAttributeValueDoubleQuotes(e) {
    this.handleInAttributeValue(e, Pt.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(e) {
    this.handleInAttributeValue(e, Pt.SingleQuote);
  }
  stateInAttributeValueNoQuotes(e) {
    vi(e) || e === Pt.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(Gn.Unquoted, this.index), this.state = pt.BeforeAttributeName, this.stateBeforeAttributeName(e)) : this.decodeEntities && e === Pt.Amp && this.startEntity();
  }
  stateBeforeDeclaration(e) {
    e === Pt.OpeningSquareBracket ? (this.state = pt.CDATASequence, this.sequenceIndex = 0) : this.state = e === Pt.Dash ? pt.BeforeComment : pt.InDeclaration;
  }
  stateInDeclaration(e) {
    (e === Pt.Gt || this.fastForwardTo(Pt.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = pt.Text, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === Pt.Gt || this.fastForwardTo(Pt.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = pt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === Pt.Dash ? (this.state = pt.InCommentLike, this.currentSequence = hr.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = pt.InDeclaration;
  }
  stateInSpecialComment(e) {
    (e === Pt.Gt || this.fastForwardTo(Pt.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = pt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    const r = e | 32;
    r === hr.ScriptEnd[3] ? this.startSpecial(hr.ScriptEnd, 4) : r === hr.StyleEnd[3] ? this.startSpecial(hr.StyleEnd, 4) : (this.state = pt.InTagName, this.stateInTagName(e));
  }
  stateBeforeSpecialT(e) {
    const r = e | 32;
    r === hr.TitleEnd[3] ? this.startSpecial(hr.TitleEnd, 4) : r === hr.TextareaEnd[3] ? this.startSpecial(hr.TextareaEnd, 4) : (this.state = pt.InTagName, this.stateInTagName(e));
  }
  startEntity() {
    this.baseState = this.state, this.state = pt.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? Vn.Strict : this.baseState === pt.Text || this.baseState === pt.InSpecialTag ? Vn.Legacy : Vn.Attribute);
  }
  stateInEntity() {
    const e = this.entityDecoder.write(this.buffer, this.index - this.offset);
    e >= 0 ? (this.state = this.baseState, e === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.running && this.sectionStart !== this.index && (this.state === pt.Text || this.state === pt.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === pt.InAttributeValueDq || this.state === pt.InAttributeValueSq || this.state === pt.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    for (; this.shouldContinue(); ) {
      const e = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case pt.Text: {
          this.stateText(e);
          break;
        }
        case pt.SpecialStartSequence: {
          this.stateSpecialStartSequence(e);
          break;
        }
        case pt.InSpecialTag: {
          this.stateInSpecialTag(e);
          break;
        }
        case pt.CDATASequence: {
          this.stateCDATASequence(e);
          break;
        }
        case pt.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(e);
          break;
        }
        case pt.InAttributeName: {
          this.stateInAttributeName(e);
          break;
        }
        case pt.InCommentLike: {
          this.stateInCommentLike(e);
          break;
        }
        case pt.InSpecialComment: {
          this.stateInSpecialComment(e);
          break;
        }
        case pt.BeforeAttributeName: {
          this.stateBeforeAttributeName(e);
          break;
        }
        case pt.InTagName: {
          this.stateInTagName(e);
          break;
        }
        case pt.InClosingTagName: {
          this.stateInClosingTagName(e);
          break;
        }
        case pt.BeforeTagName: {
          this.stateBeforeTagName(e);
          break;
        }
        case pt.AfterAttributeName: {
          this.stateAfterAttributeName(e);
          break;
        }
        case pt.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(e);
          break;
        }
        case pt.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(e);
          break;
        }
        case pt.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(e);
          break;
        }
        case pt.AfterClosingTagName: {
          this.stateAfterClosingTagName(e);
          break;
        }
        case pt.BeforeSpecialS: {
          this.stateBeforeSpecialS(e);
          break;
        }
        case pt.BeforeSpecialT: {
          this.stateBeforeSpecialT(e);
          break;
        }
        case pt.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(e);
          break;
        }
        case pt.InSelfClosingTag: {
          this.stateInSelfClosingTag(e);
          break;
        }
        case pt.InDeclaration: {
          this.stateInDeclaration(e);
          break;
        }
        case pt.BeforeDeclaration: {
          this.stateBeforeDeclaration(e);
          break;
        }
        case pt.BeforeComment: {
          this.stateBeforeComment(e);
          break;
        }
        case pt.InProcessingInstruction: {
          this.stateInProcessingInstruction(e);
          break;
        }
        case pt.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    this.state === pt.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const e = this.buffer.length + this.offset;
    this.sectionStart >= e || (this.state === pt.InCommentLike ? this.currentSequence === hr.CdataEnd ? this.cbs.oncdata(this.sectionStart, e, 0) : this.cbs.oncomment(this.sectionStart, e, 0) : this.state === pt.InTagName || this.state === pt.BeforeAttributeName || this.state === pt.BeforeAttributeValue || this.state === pt.AfterAttributeName || this.state === pt.InAttributeName || this.state === pt.InAttributeValueSq || this.state === pt.InAttributeValueDq || this.state === pt.InAttributeValueNq || this.state === pt.InClosingTagName || this.cbs.ontext(this.sectionStart, e));
  }
  emitCodePoint(e, r) {
    this.baseState !== pt.Text && this.baseState !== pt.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.onattribentity(e)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.ontextentity(e, this.sectionStart));
  }
};
var ko = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var ve = /* @__PURE__ */ new Set(["p"]);
var m2 = /* @__PURE__ */ new Set(["thead", "tbody"]);
var g2 = /* @__PURE__ */ new Set(["dd", "dt"]);
var y2 = /* @__PURE__ */ new Set(["rt", "rp"]);
var A$ = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", ve],
  ["h1", ve],
  ["h2", ve],
  ["h3", ve],
  ["h4", ve],
  ["h5", ve],
  ["h6", ve],
  ["select", ko],
  ["input", ko],
  ["output", ko],
  ["button", ko],
  ["datalist", ko],
  ["textarea", ko],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", g2],
  ["dt", g2],
  ["address", ve],
  ["article", ve],
  ["aside", ve],
  ["blockquote", ve],
  ["details", ve],
  ["div", ve],
  ["dl", ve],
  ["fieldset", ve],
  ["figcaption", ve],
  ["figure", ve],
  ["footer", ve],
  ["form", ve],
  ["header", ve],
  ["hr", ve],
  ["main", ve],
  ["nav", ve],
  ["ol", ve],
  ["pre", ve],
  ["section", ve],
  ["table", ve],
  ["ul", ve],
  ["rt", y2],
  ["rp", y2],
  ["tbody", m2],
  ["tfoot", m2]
]);
var $$ = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var b2 = /* @__PURE__ */ new Set(["math", "svg"]);
var x2 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var E$ = /\s|\//;
var M$ = class {
  constructor(t15, e = {}) {
    var r, n, i, s, o, a;
    this.options = e, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = false, this.cbs = t15 ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (r = e.lowerCaseTags) !== null && r !== void 0 ? r : this.htmlMode, this.lowerCaseAttributeNames = (n = e.lowerCaseAttributeNames) !== null && n !== void 0 ? n : this.htmlMode, this.recognizeSelfClosing = (i = e.recognizeSelfClosing) !== null && i !== void 0 ? i : !this.htmlMode, this.tokenizer = new ((s = e.Tokenizer) !== null && s !== void 0 ? s : T$)(this.options, this), this.foreignContext = [!this.htmlMode], (a = (o = this.cbs).onparserinit) === null || a === void 0 || a.call(o, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(t15, e) {
    var r, n;
    const i = this.getSlice(t15, e);
    this.endIndex = e - 1, (n = (r = this.cbs).ontext) === null || n === void 0 || n.call(r, i), this.startIndex = e;
  }
  /** @internal */
  ontextentity(t15, e) {
    var r, n;
    this.endIndex = e - 1, (n = (r = this.cbs).ontext) === null || n === void 0 || n.call(r, Zp(t15)), this.startIndex = e;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(t15) {
    return this.htmlMode && $$.has(t15);
  }
  /** @internal */
  onopentagname(t15, e) {
    this.endIndex = e;
    let r = this.getSlice(t15, e);
    this.lowerCaseTagNames && (r = r.toLowerCase()), this.emitOpenTag(r);
  }
  emitOpenTag(t15) {
    var e, r, n, i;
    this.openTagStart = this.startIndex, this.tagname = t15;
    const s = this.htmlMode && A$.get(t15);
    if (s)
      for (; this.stack.length > 0 && s.has(this.stack[0]); ) {
        const o = this.stack.shift();
        (r = (e = this.cbs).onclosetag) === null || r === void 0 || r.call(e, o, true);
      }
    this.isVoidElement(t15) || (this.stack.unshift(t15), this.htmlMode && (b2.has(t15) ? this.foreignContext.unshift(true) : x2.has(t15) && this.foreignContext.unshift(false))), (i = (n = this.cbs).onopentagname) === null || i === void 0 || i.call(n, t15), this.cbs.onopentag && (this.attribs = {});
  }
  endOpenTag(t15) {
    var e, r;
    this.startIndex = this.openTagStart, this.attribs && ((r = (e = this.cbs).onopentag) === null || r === void 0 || r.call(e, this.tagname, this.attribs, t15), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, true), this.tagname = "";
  }
  /** @internal */
  onopentagend(t15) {
    this.endIndex = t15, this.endOpenTag(false), this.startIndex = t15 + 1;
  }
  /** @internal */
  onclosetag(t15, e) {
    var r, n, i, s, o, a, l, c;
    this.endIndex = e;
    let h10 = this.getSlice(t15, e);
    if (this.lowerCaseTagNames && (h10 = h10.toLowerCase()), this.htmlMode && (b2.has(h10) || x2.has(h10)) && this.foreignContext.shift(), this.isVoidElement(h10))
      this.htmlMode && h10 === "br" && ((s = (i = this.cbs).onopentagname) === null || s === void 0 || s.call(i, "br"), (a = (o = this.cbs).onopentag) === null || a === void 0 || a.call(o, "br", {}, true), (c = (l = this.cbs).onclosetag) === null || c === void 0 || c.call(l, "br", false));
    else {
      const p = this.stack.indexOf(h10);
      if (p !== -1)
        for (let m = 0; m <= p; m++) {
          const g = this.stack.shift();
          (n = (r = this.cbs).onclosetag) === null || n === void 0 || n.call(r, g, m !== p);
        }
      else this.htmlMode && h10 === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(true));
    }
    this.startIndex = e + 1;
  }
  /** @internal */
  onselfclosingtag(t15) {
    this.endIndex = t15, this.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(false), this.startIndex = t15 + 1) : this.onopentagend(t15);
  }
  closeCurrentTag(t15) {
    var e, r;
    const n = this.tagname;
    this.endOpenTag(t15), this.stack[0] === n && ((r = (e = this.cbs).onclosetag) === null || r === void 0 || r.call(e, n, !t15), this.stack.shift());
  }
  /** @internal */
  onattribname(t15, e) {
    this.startIndex = t15;
    const r = this.getSlice(t15, e);
    this.attribname = this.lowerCaseAttributeNames ? r.toLowerCase() : r;
  }
  /** @internal */
  onattribdata(t15, e) {
    this.attribvalue += this.getSlice(t15, e);
  }
  /** @internal */
  onattribentity(t15) {
    this.attribvalue += Zp(t15);
  }
  /** @internal */
  onattribend(t15, e) {
    var r, n;
    this.endIndex = e, (n = (r = this.cbs).onattribute) === null || n === void 0 || n.call(r, this.attribname, this.attribvalue, t15 === Gn.Double ? '"' : t15 === Gn.Single ? "'" : t15 === Gn.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
  }
  getInstructionName(t15) {
    const e = t15.search(E$);
    let r = e < 0 ? t15 : t15.substr(0, e);
    return this.lowerCaseTagNames && (r = r.toLowerCase()), r;
  }
  /** @internal */
  ondeclaration(t15, e) {
    this.endIndex = e;
    const r = this.getSlice(t15, e);
    if (this.cbs.onprocessinginstruction) {
      const n = this.getInstructionName(r);
      this.cbs.onprocessinginstruction(`!${n}`, `!${r}`);
    }
    this.startIndex = e + 1;
  }
  /** @internal */
  onprocessinginstruction(t15, e) {
    this.endIndex = e;
    const r = this.getSlice(t15, e);
    if (this.cbs.onprocessinginstruction) {
      const n = this.getInstructionName(r);
      this.cbs.onprocessinginstruction(`?${n}`, `?${r}`);
    }
    this.startIndex = e + 1;
  }
  /** @internal */
  oncomment(t15, e, r) {
    var n, i, s, o;
    this.endIndex = e, (i = (n = this.cbs).oncomment) === null || i === void 0 || i.call(n, this.getSlice(t15, e - r)), (o = (s = this.cbs).oncommentend) === null || o === void 0 || o.call(s), this.startIndex = e + 1;
  }
  /** @internal */
  oncdata(t15, e, r) {
    var n, i, s, o, a, l, c, h10, p, m;
    this.endIndex = e;
    const g = this.getSlice(t15, e - r);
    !this.htmlMode || this.options.recognizeCDATA ? ((i = (n = this.cbs).oncdatastart) === null || i === void 0 || i.call(n), (o = (s = this.cbs).ontext) === null || o === void 0 || o.call(s, g), (l = (a = this.cbs).oncdataend) === null || l === void 0 || l.call(a)) : ((h10 = (c = this.cbs).oncomment) === null || h10 === void 0 || h10.call(c, `[CDATA[${g}]]`), (m = (p = this.cbs).oncommentend) === null || m === void 0 || m.call(p)), this.startIndex = e + 1;
  }
  /** @internal */
  onend() {
    var t15, e;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let r = 0; r < this.stack.length; r++)
        this.cbs.onclosetag(this.stack[r], true);
    }
    (e = (t15 = this.cbs).onend) === null || e === void 0 || e.call(t15);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var t15, e, r, n;
    (e = (t15 = this.cbs).onreset) === null || e === void 0 || e.call(t15), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (n = (r = this.cbs).onparserinit) === null || n === void 0 || n.call(r, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(t15) {
    this.reset(), this.end(t15);
  }
  getSlice(t15, e) {
    for (; t15 - this.bufferOffset >= this.buffers[0].length; )
      this.shiftBuffer();
    let r = this.buffers[0].slice(t15 - this.bufferOffset, e - this.bufferOffset);
    for (; e - this.bufferOffset > this.buffers[0].length; )
      this.shiftBuffer(), r += this.buffers[0].slice(0, e - this.bufferOffset);
    return r;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(t15) {
    var e, r;
    if (this.ended) {
      (r = (e = this.cbs).onerror) === null || r === void 0 || r.call(e, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(t15), this.tokenizer.running && (this.tokenizer.write(t15), this.writeIndex++);
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(t15) {
    var e, r;
    if (this.ended) {
      (r = (e = this.cbs).onerror) === null || r === void 0 || r.call(e, new Error(".end() after done!"));
      return;
    }
    t15 && this.write(t15), this.ended = true, this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    this.ended && this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(t15) {
    this.write(t15);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(t15) {
    this.end(t15);
  }
};
function B$(t15, e) {
  const r = new fS(void 0, e);
  return new M$(r, e).end(t15), r.root;
}
var L$ = _$(HA(B$), Ju);
var D$ = {
  "div,p": ({ $node: t15 }) => ({
    queue: t15.children()
  }),
  "h1,h2,h3,h4,h5,h6": ({ $node: t15, getContent: e }) => ({
    ...e(t15.contents())
  }),
  "ul,ol": ({ $node: t15 }) => ({
    queue: t15.children(),
    nesting: true
  }),
  li: ({ $node: t15, getContent: e }) => {
    const r = t15.children().filter("ul,ol");
    let n;
    if (t15.contents().first().is("div,p"))
      n = e(t15.children().first());
    else {
      let i = t15.contents();
      const s = i.index(r);
      s >= 0 && (i = i.slice(0, s)), n = e(i);
    }
    return {
      queue: r,
      nesting: true,
      ...n
    };
  },
  "table,pre,p>img:only-child": ({ $node: t15, getContent: e }) => ({
    ...e(t15)
  })
};
var F$ = {
  selector: "h1,h2,h3,h4,h5,h6,ul,ol,li,table,pre,p>img:only-child",
  selectorRules: D$
};
var w2 = "markmap: ";
var N$ = /^h[1-6]$/;
var I$ = /^[uo]l$/;
var O$ = /^li$/;
function z$(t15) {
  return N$.test(t15) ? +t15[1] : I$.test(t15) ? 8 : O$.test(t15) ? 9 : 7;
}
function q$(t15, e) {
  const r = {
    ...F$,
    ...e
  }, n = L$(t15);
  let i = n("body");
  i.length || (i = n.root());
  let s = 0;
  const o = {
    id: s,
    tag: "",
    html: "",
    level: 0,
    parent: 0,
    childrenLevel: 0,
    children: []
  }, a = [];
  let l = 0;
  return g(i.children()), o;
  function c(y) {
    var x;
    const { parent: k } = y, C = {
      id: ++s,
      tag: y.tagName,
      level: y.level,
      html: y.html,
      childrenLevel: 0,
      children: y.nesting ? [] : void 0,
      parent: k.id
    };
    return (x = y.comments) != null && x.length && (C.comments = y.comments), Object.keys(y.data || {}).length && (C.data = y.data), k.children && ((k.childrenLevel === 0 || k.childrenLevel > C.level) && (k.children = [], k.childrenLevel = C.level), k.childrenLevel === C.level && k.children.push(C)), C;
  }
  function h10(y) {
    let x;
    for (; (x = a[a.length - 1]) && x.level >= y; )
      a.pop();
    return x || o;
  }
  function p(y) {
    var x;
    const k = m(y), C = (x = n.html(k.$node)) == null ? void 0 : x.trimEnd();
    return { comments: k.comments, html: C };
  }
  function m(y) {
    const x = [];
    return y = y.filter((k, C) => {
      if (C.type === "comment") {
        const _ = C.data.trim();
        if (_.startsWith(w2))
          return x.push(_.slice(w2.length).trim()), false;
      }
      return true;
    }), { $node: y, comments: x };
  }
  function g(y, x) {
    y.each((k, C) => {
      var _;
      const $ = n(C), L = (_ = Object.entries(r.selectorRules).find(
        ([R]) => $.is(R)
      )) == null ? void 0 : _[1], B = L == null ? void 0 : L({ $node: $, $: n, getContent: p });
      if ((B == null ? void 0 : B.queue) && !B.nesting) {
        g(B.queue, x);
        return;
      }
      const q = z$(C.tagName);
      if (!B) {
        q <= 6 && (l = q);
        return;
      }
      if (l > 0 && q > l || !$.is(r.selector)) return;
      l = 0;
      const H = q <= 6;
      let G = {
        // If the child is an inline element and expected to be a separate node,
        // data from the closest `<p>` should be included, e.g. `<p data-lines><img /></p>`
        ...$.closest("p").data(),
        ...$.data()
      }, F = B.html || "";
      if ($.is("ol>li") && (x == null ? void 0 : x.children)) {
        const R = +($.parent().attr("start") || 1) + x.children.length;
        F = `${R}. ${F}`, G = {
          ...G,
          listIndex: R
        };
      }
      const W = c({
        parent: x || h10(q),
        nesting: !!B.queue || H,
        tagName: C.tagName,
        level: q,
        html: F,
        comments: B.comments,
        data: G
      });
      H && a.push(W), B.queue && g(B.queue, W);
    });
  }
}
function R$(t15) {
  return tl(t15, (e, r) => {
    const n = {
      content: e.html,
      children: r() || []
    };
    return e.data && (n.payload = {
      tag: e.tag,
      ...e.data
    }), e.comments && (e.comments.includes("foldAll") ? n.payload = { ...n.payload, fold: 2 } : e.comments.includes("fold") && (n.payload = { ...n.payload, fold: 1 })), n;
  });
}
function P$(t15, e) {
  const r = q$(t15, e);
  return R$(r);
}
var k2 = {};
function j$(t15) {
  let e = k2[t15];
  if (e)
    return e;
  e = k2[t15] = [];
  for (let r = 0; r < 128; r++) {
    const n = String.fromCharCode(r);
    e.push(n);
  }
  for (let r = 0; r < t15.length; r++) {
    const n = t15.charCodeAt(r);
    e[n] = "%" + ("0" + n.toString(16).toUpperCase()).slice(-2);
  }
  return e;
}
function Uo(t15, e) {
  typeof e != "string" && (e = Uo.defaultChars);
  const r = j$(e);
  return t15.replace(/(%[a-f0-9]{2})+/gi, function(n) {
    let i = "";
    for (let s = 0, o = n.length; s < o; s += 3) {
      const a = parseInt(n.slice(s + 1, s + 3), 16);
      if (a < 128) {
        i += r[a];
        continue;
      }
      if ((a & 224) === 192 && s + 3 < o) {
        const l = parseInt(n.slice(s + 4, s + 6), 16);
        if ((l & 192) === 128) {
          const c = a << 6 & 1984 | l & 63;
          c < 128 ? i += "��" : i += String.fromCharCode(c), s += 3;
          continue;
        }
      }
      if ((a & 240) === 224 && s + 6 < o) {
        const l = parseInt(n.slice(s + 4, s + 6), 16), c = parseInt(n.slice(s + 7, s + 9), 16);
        if ((l & 192) === 128 && (c & 192) === 128) {
          const h10 = a << 12 & 61440 | l << 6 & 4032 | c & 63;
          h10 < 2048 || h10 >= 55296 && h10 <= 57343 ? i += "���" : i += String.fromCharCode(h10), s += 6;
          continue;
        }
      }
      if ((a & 248) === 240 && s + 9 < o) {
        const l = parseInt(n.slice(s + 4, s + 6), 16), c = parseInt(n.slice(s + 7, s + 9), 16), h10 = parseInt(n.slice(s + 10, s + 12), 16);
        if ((l & 192) === 128 && (c & 192) === 128 && (h10 & 192) === 128) {
          let p = a << 18 & 1835008 | l << 12 & 258048 | c << 6 & 4032 | h10 & 63;
          p < 65536 || p > 1114111 ? i += "����" : (p -= 65536, i += String.fromCharCode(55296 + (p >> 10), 56320 + (p & 1023))), s += 9;
          continue;
        }
      }
      i += "�";
    }
    return i;
  });
}
Uo.defaultChars = ";/?:@&=+$,#";
Uo.componentChars = "";
var v2 = {};
function W$(t15) {
  let e = v2[t15];
  if (e)
    return e;
  e = v2[t15] = [];
  for (let r = 0; r < 128; r++) {
    const n = String.fromCharCode(r);
    /^[0-9a-z]$/i.test(n) ? e.push(n) : e.push("%" + ("0" + r.toString(16).toUpperCase()).slice(-2));
  }
  for (let r = 0; r < t15.length; r++)
    e[t15.charCodeAt(r)] = t15[r];
  return e;
}
function tc(t15, e, r) {
  typeof e != "string" && (r = e, e = tc.defaultChars), typeof r > "u" && (r = true);
  const n = W$(e);
  let i = "";
  for (let s = 0, o = t15.length; s < o; s++) {
    const a = t15.charCodeAt(s);
    if (r && a === 37 && s + 2 < o && /^[0-9a-f]{2}$/i.test(t15.slice(s + 1, s + 3))) {
      i += t15.slice(s, s + 3), s += 2;
      continue;
    }
    if (a < 128) {
      i += n[a];
      continue;
    }
    if (a >= 55296 && a <= 57343) {
      if (a >= 55296 && a <= 56319 && s + 1 < o) {
        const l = t15.charCodeAt(s + 1);
        if (l >= 56320 && l <= 57343) {
          i += encodeURIComponent(t15[s] + t15[s + 1]), s++;
          continue;
        }
      }
      i += "%EF%BF%BD";
      continue;
    }
    i += encodeURIComponent(t15[s]);
  }
  return i;
}
tc.defaultChars = ";/?:@&=+$,-_.!~*'()#";
tc.componentChars = "-_.!~*'()";
function K1(t15) {
  let e = "";
  return e += t15.protocol || "", e += t15.slashes ? "//" : "", e += t15.auth ? t15.auth + "@" : "", t15.hostname && t15.hostname.indexOf(":") !== -1 ? e += "[" + t15.hostname + "]" : e += t15.hostname || "", e += t15.port ? ":" + t15.port : "", e += t15.pathname || "", e += t15.search || "", e += t15.hash || "", e;
}
function nu() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var H$ = /^([a-z0-9.+-]+:)/i;
var U$ = /:[0-9]*$/;
var V$ = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var G$ = ["<", ">", '"', "`", " ", "\r", `
`, "	"];
var X$ = ["{", "}", "|", "\\", "^", "`"].concat(G$);
var Y$ = ["'"].concat(X$);
var _2 = ["%", "/", "?", ";", "#"].concat(Y$);
var C2 = ["/", "?", "#"];
var K$ = 255;
var S2 = /^[+a-z0-9A-Z_-]{0,63}$/;
var Z$ = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var T2 = {
  javascript: true,
  "javascript:": true
};
var A2 = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function Z1(t15, e) {
  if (t15 && t15 instanceof nu) return t15;
  const r = new nu();
  return r.parse(t15, e), r;
}
nu.prototype.parse = function(t15, e) {
  let r, n, i, s = t15;
  if (s = s.trim(), !e && t15.split("#").length === 1) {
    const c = V$.exec(s);
    if (c)
      return this.pathname = c[1], c[2] && (this.search = c[2]), this;
  }
  let o = H$.exec(s);
  if (o && (o = o[0], r = o.toLowerCase(), this.protocol = o, s = s.substr(o.length)), (e || o || s.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = s.substr(0, 2) === "//", i && !(o && T2[o]) && (s = s.substr(2), this.slashes = true)), !T2[o] && (i || o && !A2[o])) {
    let c = -1;
    for (let y = 0; y < C2.length; y++)
      n = s.indexOf(C2[y]), n !== -1 && (c === -1 || n < c) && (c = n);
    let h10, p;
    c === -1 ? p = s.lastIndexOf("@") : p = s.lastIndexOf("@", c), p !== -1 && (h10 = s.slice(0, p), s = s.slice(p + 1), this.auth = h10), c = -1;
    for (let y = 0; y < _2.length; y++)
      n = s.indexOf(_2[y]), n !== -1 && (c === -1 || n < c) && (c = n);
    c === -1 && (c = s.length), s[c - 1] === ":" && c--;
    const m = s.slice(0, c);
    s = s.slice(c), this.parseHost(m), this.hostname = this.hostname || "";
    const g = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!g) {
      const y = this.hostname.split(/\./);
      for (let x = 0, k = y.length; x < k; x++) {
        const C = y[x];
        if (C && !C.match(S2)) {
          let _ = "";
          for (let $ = 0, L = C.length; $ < L; $++)
            C.charCodeAt($) > 127 ? _ += "x" : _ += C[$];
          if (!_.match(S2)) {
            const $ = y.slice(0, x), L = y.slice(x + 1), B = C.match(Z$);
            B && ($.push(B[1]), L.unshift(B[2])), L.length && (s = L.join(".") + s), this.hostname = $.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > K$ && (this.hostname = ""), g && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const a = s.indexOf("#");
  a !== -1 && (this.hash = s.substr(a), s = s.slice(0, a));
  const l = s.indexOf("?");
  return l !== -1 && (this.search = s.substr(l), s = s.slice(0, l)), s && (this.pathname = s), A2[r] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
nu.prototype.parseHost = function(t15) {
  let e = U$.exec(t15);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t15 = t15.substr(0, t15.length - e.length)), t15 && (this.hostname = t15);
};
var Q$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: Uo,
  encode: tc,
  format: K1,
  parse: Z1
}, Symbol.toStringTag, { value: "Module" }));
var Ex = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var Mx = /[\0-\x1F\x7F-\x9F]/;
var J$ = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
var Q1 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var Bx = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
var Lx = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
var tE = Object.freeze(Object.defineProperty({
  __proto__: null,
  Any: Ex,
  Cc: Mx,
  Cf: J$,
  P: Q1,
  S: Bx,
  Z: Lx
}, Symbol.toStringTag, { value: "Module" }));
var eE = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((t15) => t15.charCodeAt(0))
);
var rE = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((t15) => t15.charCodeAt(0))
);
var Pd;
var nE = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var iE = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Pd = String.fromCodePoint) !== null && Pd !== void 0 ? Pd : function(t15) {
    let e = "";
    return t15 > 65535 && (t15 -= 65536, e += String.fromCharCode(t15 >>> 10 & 1023 | 55296), t15 = 56320 | t15 & 1023), e += String.fromCharCode(t15), e;
  }
);
function sE(t15) {
  var e;
  return t15 >= 55296 && t15 <= 57343 || t15 > 1114111 ? 65533 : (e = nE.get(t15)) !== null && e !== void 0 ? e : t15;
}
var or;
(function(t15) {
  t15[t15.NUM = 35] = "NUM", t15[t15.SEMI = 59] = "SEMI", t15[t15.EQUALS = 61] = "EQUALS", t15[t15.ZERO = 48] = "ZERO", t15[t15.NINE = 57] = "NINE", t15[t15.LOWER_A = 97] = "LOWER_A", t15[t15.LOWER_F = 102] = "LOWER_F", t15[t15.LOWER_X = 120] = "LOWER_X", t15[t15.LOWER_Z = 122] = "LOWER_Z", t15[t15.UPPER_A = 65] = "UPPER_A", t15[t15.UPPER_F = 70] = "UPPER_F", t15[t15.UPPER_Z = 90] = "UPPER_Z";
})(or || (or = {}));
var oE = 32;
var is;
(function(t15) {
  t15[t15.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t15[t15.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t15[t15.JUMP_TABLE = 127] = "JUMP_TABLE";
})(is || (is = {}));
function of(t15) {
  return t15 >= or.ZERO && t15 <= or.NINE;
}
function aE(t15) {
  return t15 >= or.UPPER_A && t15 <= or.UPPER_F || t15 >= or.LOWER_A && t15 <= or.LOWER_F;
}
function lE(t15) {
  return t15 >= or.UPPER_A && t15 <= or.UPPER_Z || t15 >= or.LOWER_A && t15 <= or.LOWER_Z || of(t15);
}
function cE(t15) {
  return t15 === or.EQUALS || lE(t15);
}
var nr;
(function(t15) {
  t15[t15.EntityStart = 0] = "EntityStart", t15[t15.NumericStart = 1] = "NumericStart", t15[t15.NumericDecimal = 2] = "NumericDecimal", t15[t15.NumericHex = 3] = "NumericHex", t15[t15.NamedEntity = 4] = "NamedEntity";
})(nr || (nr = {}));
var ts;
(function(t15) {
  t15[t15.Legacy = 0] = "Legacy", t15[t15.Strict = 1] = "Strict", t15[t15.Attribute = 2] = "Attribute";
})(ts || (ts = {}));
var hE = class {
  constructor(e, r, n) {
    this.decodeTree = e, this.emitCodePoint = r, this.errors = n, this.state = nr.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = ts.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = nr.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, r) {
    switch (this.state) {
      case nr.EntityStart:
        return e.charCodeAt(r) === or.NUM ? (this.state = nr.NumericStart, this.consumed += 1, this.stateNumericStart(e, r + 1)) : (this.state = nr.NamedEntity, this.stateNamedEntity(e, r));
      case nr.NumericStart:
        return this.stateNumericStart(e, r);
      case nr.NumericDecimal:
        return this.stateNumericDecimal(e, r);
      case nr.NumericHex:
        return this.stateNumericHex(e, r);
      case nr.NamedEntity:
        return this.stateNamedEntity(e, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, r) {
    return r >= e.length ? -1 : (e.charCodeAt(r) | oE) === or.LOWER_X ? (this.state = nr.NumericHex, this.consumed += 1, this.stateNumericHex(e, r + 1)) : (this.state = nr.NumericDecimal, this.stateNumericDecimal(e, r));
  }
  addToNumericResult(e, r, n, i) {
    if (r !== n) {
      const s = n - r;
      this.result = this.result * Math.pow(i, s) + parseInt(e.substr(r, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (of(i) || aE(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, n, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (of(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, n, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, r) {
    var n;
    if (this.consumed <= r)
      return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === or.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === ts.Strict)
      return 0;
    return this.emitCodePoint(sE(this.result), this.consumed), this.errors && (e !== or.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, r) {
    const { decodeTree: n } = this;
    let i = n[this.treeIndex], s = (i & is.VALUE_LENGTH) >> 14;
    for (; r < e.length; r++, this.excess++) {
      const o = e.charCodeAt(r);
      if (this.treeIndex = uE(n, i, this.treeIndex + Math.max(1, s), o), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === ts.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        cE(o)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = n[this.treeIndex], s = (i & is.VALUE_LENGTH) >> 14, s !== 0) {
        if (o === or.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== ts.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: r, decodeTree: n } = this, i = (n[r] & is.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, r, n) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(r === 1 ? i[e] & ~is.VALUE_LENGTH : i[e + 1], n), r === 3 && this.emitCodePoint(i[e + 2], n), n;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case nr.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== ts.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case nr.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case nr.NumericHex:
        return this.emitNumericEntity(0, 3);
      case nr.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case nr.EntityStart:
        return 0;
    }
  }
};
function Dx(t15) {
  let e = "";
  const r = new hE(t15, (n) => e += iE(n));
  return function(n, i) {
    let s = 0, o = 0;
    for (; (o = n.indexOf("&", o)) >= 0; ) {
      e += n.slice(s, o), r.startEntity(i);
      const l = r.write(
        n,
        // Skip the "&"
        o + 1
      );
      if (l < 0) {
        s = o + r.end();
        break;
      }
      s = o + l, o = l === 0 ? s + 1 : s;
    }
    const a = e + n.slice(s);
    return e = "", a;
  };
}
function uE(t15, e, r, n) {
  const i = (e & is.BRANCH_LENGTH) >> 7, s = e & is.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && n === s ? r : -1;
  if (s) {
    const l = n - s;
    return l < 0 || l >= i ? -1 : t15[r + l] - 1;
  }
  let o = r, a = o + i - 1;
  for (; o <= a; ) {
    const l = o + a >>> 1, c = t15[l];
    if (c < n)
      o = l + 1;
    else if (c > n)
      a = l - 1;
    else
      return t15[l + i];
  }
  return -1;
}
var dE = Dx(eE);
Dx(rE);
function Fx(t15, e = ts.Legacy) {
  return dE(t15, e);
}
function pE(t15) {
  return Object.prototype.toString.call(t15);
}
function J1(t15) {
  return pE(t15) === "[object String]";
}
var fE = Object.prototype.hasOwnProperty;
function mE(t15, e) {
  return fE.call(t15, e);
}
function i0(t15) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
    if (e) {
      if (typeof e != "object")
        throw new TypeError(e + "must be object");
      Object.keys(e).forEach(function(r) {
        t15[r] = e[r];
      });
    }
  }), t15;
}
function Nx(t15, e, r) {
  return [].concat(t15.slice(0, e), r, t15.slice(e + 1));
}
function tm(t15) {
  return !(t15 >= 55296 && t15 <= 57343 || t15 >= 64976 && t15 <= 65007 || (t15 & 65535) === 65535 || (t15 & 65535) === 65534 || t15 >= 0 && t15 <= 8 || t15 === 11 || t15 >= 14 && t15 <= 31 || t15 >= 127 && t15 <= 159 || t15 > 1114111);
}
function iu(t15) {
  if (t15 > 65535) {
    t15 -= 65536;
    const e = 55296 + (t15 >> 10), r = 56320 + (t15 & 1023);
    return String.fromCharCode(e, r);
  }
  return String.fromCharCode(t15);
}
var Ix = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var gE = /&([a-z#][a-z0-9]{1,31});/gi;
var yE = new RegExp(Ix.source + "|" + gE.source, "gi");
var bE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function xE(t15, e) {
  if (e.charCodeAt(0) === 35 && bE.test(e)) {
    const n = e[1].toLowerCase() === "x" ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10);
    return tm(n) ? iu(n) : t15;
  }
  const r = Fx(t15);
  return r !== t15 ? r : t15;
}
function wE(t15) {
  return t15.indexOf("\\") < 0 ? t15 : t15.replace(Ix, "$1");
}
function Vo(t15) {
  return t15.indexOf("\\") < 0 && t15.indexOf("&") < 0 ? t15 : t15.replace(yE, function(e, r, n) {
    return r || xE(e, n);
  });
}
var kE = /[&<>"]/;
var vE = /[&<>"]/g;
var _E = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function CE(t15) {
  return _E[t15];
}
function hs(t15) {
  return kE.test(t15) ? t15.replace(vE, CE) : t15;
}
var SE = /[.?*+^$[\]\\(){}|-]/g;
function TE(t15) {
  return t15.replace(SE, "\\$&");
}
function Se(t15) {
  switch (t15) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function El(t15) {
  if (t15 >= 8192 && t15 <= 8202)
    return true;
  switch (t15) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function Ml(t15) {
  return Q1.test(t15) || Bx.test(t15);
}
function Bl(t15) {
  switch (t15) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function s0(t15) {
  return t15 = t15.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (t15 = t15.replace(/ẞ/g, "ß")), t15.toLowerCase().toUpperCase();
}
var AE = { mdurl: Q$, ucmicro: tE };
var $E = Object.freeze(Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: Nx,
  assign: i0,
  escapeHtml: hs,
  escapeRE: TE,
  fromCodePoint: iu,
  has: mE,
  isMdAsciiPunct: Bl,
  isPunctChar: Ml,
  isSpace: Se,
  isString: J1,
  isValidEntityCode: tm,
  isWhiteSpace: El,
  lib: AE,
  normalizeReference: s0,
  unescapeAll: Vo,
  unescapeMd: wE
}, Symbol.toStringTag, { value: "Module" }));
function EE(t15, e, r) {
  let n, i, s, o;
  const a = t15.posMax, l = t15.pos;
  for (t15.pos = e + 1, n = 1; t15.pos < a; ) {
    if (s = t15.src.charCodeAt(t15.pos), s === 93 && (n--, n === 0)) {
      i = true;
      break;
    }
    if (o = t15.pos, t15.md.inline.skipToken(t15), s === 91) {
      if (o === t15.pos - 1)
        n++;
      else if (r)
        return t15.pos = l, -1;
    }
  }
  let c = -1;
  return i && (c = t15.pos), t15.pos = l, c;
}
function ME(t15, e, r) {
  let n, i = e;
  const s = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (t15.charCodeAt(i) === 60) {
    for (i++; i < r; ) {
      if (n = t15.charCodeAt(i), n === 10 || n === 60)
        return s;
      if (n === 62)
        return s.pos = i + 1, s.str = Vo(t15.slice(e + 1, i)), s.ok = true, s;
      if (n === 92 && i + 1 < r) {
        i += 2;
        continue;
      }
      i++;
    }
    return s;
  }
  let o = 0;
  for (; i < r && (n = t15.charCodeAt(i), !(n === 32 || n < 32 || n === 127)); ) {
    if (n === 92 && i + 1 < r) {
      if (t15.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (n === 40 && (o++, o > 32))
      return s;
    if (n === 41) {
      if (o === 0)
        break;
      o--;
    }
    i++;
  }
  return e === i || o !== 0 || (s.str = Vo(t15.slice(e, i)), s.pos = i, s.ok = true), s;
}
function BE(t15, e, r, n) {
  let i, s = e;
  const o = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (n)
    o.str = n.str, o.marker = n.marker;
  else {
    if (s >= r)
      return o;
    let a = t15.charCodeAt(s);
    if (a !== 34 && a !== 39 && a !== 40)
      return o;
    e++, s++, a === 40 && (a = 41), o.marker = a;
  }
  for (; s < r; ) {
    if (i = t15.charCodeAt(s), i === o.marker)
      return o.pos = s + 1, o.str += Vo(t15.slice(e, s)), o.ok = true, o;
    if (i === 40 && o.marker === 41)
      return o;
    i === 92 && s + 1 < r && s++, s++;
  }
  return o.can_continue = true, o.str += Vo(t15.slice(e, s)), o;
}
var LE = Object.freeze(Object.defineProperty({
  __proto__: null,
  parseLinkDestination: ME,
  parseLinkLabel: EE,
  parseLinkTitle: BE
}, Symbol.toStringTag, { value: "Module" }));
var ii = {};
ii.code_inline = function(t15, e, r, n, i) {
  const s = t15[e];
  return "<code" + i.renderAttrs(s) + ">" + hs(s.content) + "</code>";
};
ii.code_block = function(t15, e, r, n, i) {
  const s = t15[e];
  return "<pre" + i.renderAttrs(s) + "><code>" + hs(t15[e].content) + `</code></pre>
`;
};
ii.fence = function(t15, e, r, n, i) {
  const s = t15[e], o = s.info ? Vo(s.info).trim() : "";
  let a = "", l = "";
  if (o) {
    const h10 = o.split(/(\s+)/g);
    a = h10[0], l = h10.slice(2).join("");
  }
  let c;
  if (r.highlight ? c = r.highlight(s.content, a, l) || hs(s.content) : c = hs(s.content), c.indexOf("<pre") === 0)
    return c + `
`;
  if (o) {
    const h10 = s.attrIndex("class"), p = s.attrs ? s.attrs.slice() : [];
    h10 < 0 ? p.push(["class", r.langPrefix + a]) : (p[h10] = p[h10].slice(), p[h10][1] += " " + r.langPrefix + a);
    const m = {
      attrs: p
    };
    return `<pre><code${i.renderAttrs(m)}>${c}</code></pre>
`;
  }
  return `<pre><code${i.renderAttrs(s)}>${c}</code></pre>
`;
};
ii.image = function(t15, e, r, n, i) {
  const s = t15[e];
  return s.attrs[s.attrIndex("alt")][1] = i.renderInlineAsText(s.children, r, n), i.renderToken(t15, e, r);
};
ii.hardbreak = function(t15, e, r) {
  return r.xhtmlOut ? `<br />
` : `<br>
`;
};
ii.softbreak = function(t15, e, r) {
  return r.breaks ? r.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ii.text = function(t15, e) {
  return hs(t15[e].content);
};
ii.html_block = function(t15, e) {
  return t15[e].content;
};
ii.html_inline = function(t15, e) {
  return t15[e].content;
};
function ua() {
  this.rules = i0({}, ii);
}
ua.prototype.renderAttrs = function(t15) {
  let e, r, n;
  if (!t15.attrs)
    return "";
  for (n = "", e = 0, r = t15.attrs.length; e < r; e++)
    n += " " + hs(t15.attrs[e][0]) + '="' + hs(t15.attrs[e][1]) + '"';
  return n;
};
ua.prototype.renderToken = function(t15, e, r) {
  const n = t15[e];
  let i = "";
  if (n.hidden)
    return "";
  n.block && n.nesting !== -1 && e && t15[e - 1].hidden && (i += `
`), i += (n.nesting === -1 ? "</" : "<") + n.tag, i += this.renderAttrs(n), n.nesting === 0 && r.xhtmlOut && (i += " /");
  let s = false;
  if (n.block && (s = true, n.nesting === 1 && e + 1 < t15.length)) {
    const o = t15[e + 1];
    (o.type === "inline" || o.hidden || o.nesting === -1 && o.tag === n.tag) && (s = false);
  }
  return i += s ? `>
` : ">", i;
};
ua.prototype.renderInline = function(t15, e, r) {
  let n = "";
  const i = this.rules;
  for (let s = 0, o = t15.length; s < o; s++) {
    const a = t15[s].type;
    typeof i[a] < "u" ? n += i[a](t15, s, e, r, this) : n += this.renderToken(t15, s, e);
  }
  return n;
};
ua.prototype.renderInlineAsText = function(t15, e, r) {
  let n = "";
  for (let i = 0, s = t15.length; i < s; i++)
    switch (t15[i].type) {
      case "text":
        n += t15[i].content;
        break;
      case "image":
        n += this.renderInlineAsText(t15[i].children, e, r);
        break;
      case "html_inline":
      case "html_block":
        n += t15[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        n += `
`;
        break;
    }
  return n;
};
ua.prototype.render = function(t15, e, r) {
  let n = "";
  const i = this.rules;
  for (let s = 0, o = t15.length; s < o; s++) {
    const a = t15[s].type;
    a === "inline" ? n += this.renderInline(t15[s].children, e, r) : typeof i[a] < "u" ? n += i[a](t15, s, e, r, this) : n += this.renderToken(t15, s, e, r);
  }
  return n;
};
function Gr() {
  this.__rules__ = [], this.__cache__ = null;
}
Gr.prototype.__find__ = function(t15) {
  for (let e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t15)
      return e;
  return -1;
};
Gr.prototype.__compile__ = function() {
  const t15 = this, e = [""];
  t15.__rules__.forEach(function(r) {
    r.enabled && r.alt.forEach(function(n) {
      e.indexOf(n) < 0 && e.push(n);
    });
  }), t15.__cache__ = {}, e.forEach(function(r) {
    t15.__cache__[r] = [], t15.__rules__.forEach(function(n) {
      n.enabled && (r && n.alt.indexOf(r) < 0 || t15.__cache__[r].push(n.fn));
    });
  });
};
Gr.prototype.at = function(t15, e, r) {
  const n = this.__find__(t15), i = r || {};
  if (n === -1)
    throw new Error("Parser rule not found: " + t15);
  this.__rules__[n].fn = e, this.__rules__[n].alt = i.alt || [], this.__cache__ = null;
};
Gr.prototype.before = function(t15, e, r, n) {
  const i = this.__find__(t15), s = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t15);
  this.__rules__.splice(i, 0, {
    name: e,
    enabled: true,
    fn: r,
    alt: s.alt || []
  }), this.__cache__ = null;
};
Gr.prototype.after = function(t15, e, r, n) {
  const i = this.__find__(t15), s = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t15);
  this.__rules__.splice(i + 1, 0, {
    name: e,
    enabled: true,
    fn: r,
    alt: s.alt || []
  }), this.__cache__ = null;
};
Gr.prototype.push = function(t15, e, r) {
  const n = r || {};
  this.__rules__.push({
    name: t15,
    enabled: true,
    fn: e,
    alt: n.alt || []
  }), this.__cache__ = null;
};
Gr.prototype.enable = function(t15, e) {
  Array.isArray(t15) || (t15 = [t15]);
  const r = [];
  return t15.forEach(function(n) {
    const i = this.__find__(n);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + n);
    }
    this.__rules__[i].enabled = true, r.push(n);
  }, this), this.__cache__ = null, r;
};
Gr.prototype.enableOnly = function(t15, e) {
  Array.isArray(t15) || (t15 = [t15]), this.__rules__.forEach(function(r) {
    r.enabled = false;
  }), this.enable(t15, e);
};
Gr.prototype.disable = function(t15, e) {
  Array.isArray(t15) || (t15 = [t15]);
  const r = [];
  return t15.forEach(function(n) {
    const i = this.__find__(n);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + n);
    }
    this.__rules__[i].enabled = false, r.push(n);
  }, this), this.__cache__ = null, r;
};
Gr.prototype.getRules = function(t15) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t15] || [];
};
function Bn(t15, e, r) {
  this.type = t15, this.tag = e, this.attrs = null, this.map = null, this.nesting = r, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
Bn.prototype.attrIndex = function(t15) {
  if (!this.attrs)
    return -1;
  const e = this.attrs;
  for (let r = 0, n = e.length; r < n; r++)
    if (e[r][0] === t15)
      return r;
  return -1;
};
Bn.prototype.attrPush = function(t15) {
  this.attrs ? this.attrs.push(t15) : this.attrs = [t15];
};
Bn.prototype.attrSet = function(t15, e) {
  const r = this.attrIndex(t15), n = [t15, e];
  r < 0 ? this.attrPush(n) : this.attrs[r] = n;
};
Bn.prototype.attrGet = function(t15) {
  const e = this.attrIndex(t15);
  let r = null;
  return e >= 0 && (r = this.attrs[e][1]), r;
};
Bn.prototype.attrJoin = function(t15, e) {
  const r = this.attrIndex(t15);
  r < 0 ? this.attrPush([t15, e]) : this.attrs[r][1] = this.attrs[r][1] + " " + e;
};
function Ox(t15, e, r) {
  this.src = t15, this.env = r, this.tokens = [], this.inlineMode = false, this.md = e;
}
Ox.prototype.Token = Bn;
var DE = /\r\n?|\n/g;
var FE = /\0/g;
function NE(t15) {
  let e;
  e = t15.src.replace(DE, `
`), e = e.replace(FE, "�"), t15.src = e;
}
function IE(t15) {
  let e;
  t15.inlineMode ? (e = new t15.Token("inline", "", 0), e.content = t15.src, e.map = [0, 1], e.children = [], t15.tokens.push(e)) : t15.md.block.parse(t15.src, t15.md, t15.env, t15.tokens);
}
function OE(t15) {
  const e = t15.tokens;
  for (let r = 0, n = e.length; r < n; r++) {
    const i = e[r];
    i.type === "inline" && t15.md.inline.parse(i.content, t15.md, t15.env, i.children);
  }
}
function zE(t15) {
  return /^<a[>\s]/i.test(t15);
}
function qE(t15) {
  return /^<\/a\s*>/i.test(t15);
}
function RE(t15) {
  const e = t15.tokens;
  if (t15.md.options.linkify)
    for (let r = 0, n = e.length; r < n; r++) {
      if (e[r].type !== "inline" || !t15.md.linkify.pretest(e[r].content))
        continue;
      let i = e[r].children, s = 0;
      for (let o = i.length - 1; o >= 0; o--) {
        const a = i[o];
        if (a.type === "link_close") {
          for (o--; i[o].level !== a.level && i[o].type !== "link_open"; )
            o--;
          continue;
        }
        if (a.type === "html_inline" && (zE(a.content) && s > 0 && s--, qE(a.content) && s++), !(s > 0) && a.type === "text" && t15.md.linkify.test(a.content)) {
          const l = a.content;
          let c = t15.md.linkify.match(l);
          const h10 = [];
          let p = a.level, m = 0;
          c.length > 0 && c[0].index === 0 && o > 0 && i[o - 1].type === "text_special" && (c = c.slice(1));
          for (let g = 0; g < c.length; g++) {
            const y = c[g].url, x = t15.md.normalizeLink(y);
            if (!t15.md.validateLink(x))
              continue;
            let k = c[g].text;
            c[g].schema ? c[g].schema === "mailto:" && !/^mailto:/i.test(k) ? k = t15.md.normalizeLinkText("mailto:" + k).replace(/^mailto:/, "") : k = t15.md.normalizeLinkText(k) : k = t15.md.normalizeLinkText("http://" + k).replace(/^http:\/\//, "");
            const C = c[g].index;
            if (C > m) {
              const B = new t15.Token("text", "", 0);
              B.content = l.slice(m, C), B.level = p, h10.push(B);
            }
            const _ = new t15.Token("link_open", "a", 1);
            _.attrs = [["href", x]], _.level = p++, _.markup = "linkify", _.info = "auto", h10.push(_);
            const $ = new t15.Token("text", "", 0);
            $.content = k, $.level = p, h10.push($);
            const L = new t15.Token("link_close", "a", -1);
            L.level = --p, L.markup = "linkify", L.info = "auto", h10.push(L), m = c[g].lastIndex;
          }
          if (m < l.length) {
            const g = new t15.Token("text", "", 0);
            g.content = l.slice(m), g.level = p, h10.push(g);
          }
          e[r].children = i = Nx(i, o, h10);
        }
      }
    }
}
var zx = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var PE = /\((c|tm|r)\)/i;
var jE = /\((c|tm|r)\)/ig;
var WE = {
  c: "©",
  r: "®",
  tm: "™"
};
function HE(t15, e) {
  return WE[e.toLowerCase()];
}
function UE(t15) {
  let e = 0;
  for (let r = t15.length - 1; r >= 0; r--) {
    const n = t15[r];
    n.type === "text" && !e && (n.content = n.content.replace(jE, HE)), n.type === "link_open" && n.info === "auto" && e--, n.type === "link_close" && n.info === "auto" && e++;
  }
}
function VE(t15) {
  let e = 0;
  for (let r = t15.length - 1; r >= 0; r--) {
    const n = t15[r];
    n.type === "text" && !e && zx.test(n.content) && (n.content = n.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), n.type === "link_open" && n.info === "auto" && e--, n.type === "link_close" && n.info === "auto" && e++;
  }
}
function GE(t15) {
  let e;
  if (t15.md.options.typographer)
    for (e = t15.tokens.length - 1; e >= 0; e--)
      t15.tokens[e].type === "inline" && (PE.test(t15.tokens[e].content) && UE(t15.tokens[e].children), zx.test(t15.tokens[e].content) && VE(t15.tokens[e].children));
}
var XE = /['"]/;
var $2 = /['"]/g;
var E2 = "’";
function Gc(t15, e, r) {
  return t15.slice(0, e) + r + t15.slice(e + 1);
}
function YE(t15, e) {
  let r;
  const n = [];
  for (let i = 0; i < t15.length; i++) {
    const s = t15[i], o = t15[i].level;
    for (r = n.length - 1; r >= 0 && !(n[r].level <= o); r--)
      ;
    if (n.length = r + 1, s.type !== "text")
      continue;
    let a = s.content, l = 0, c = a.length;
    t:
      for (; l < c; ) {
        $2.lastIndex = l;
        const h10 = $2.exec(a);
        if (!h10)
          break;
        let p = true, m = true;
        l = h10.index + 1;
        const g = h10[0] === "'";
        let y = 32;
        if (h10.index - 1 >= 0)
          y = a.charCodeAt(h10.index - 1);
        else
          for (r = i - 1; r >= 0 && !(t15[r].type === "softbreak" || t15[r].type === "hardbreak"); r--)
            if (t15[r].content) {
              y = t15[r].content.charCodeAt(t15[r].content.length - 1);
              break;
            }
        let x = 32;
        if (l < c)
          x = a.charCodeAt(l);
        else
          for (r = i + 1; r < t15.length && !(t15[r].type === "softbreak" || t15[r].type === "hardbreak"); r++)
            if (t15[r].content) {
              x = t15[r].content.charCodeAt(0);
              break;
            }
        const k = Bl(y) || Ml(String.fromCharCode(y)), C = Bl(x) || Ml(String.fromCharCode(x)), _ = El(y), $ = El(x);
        if ($ ? p = false : C && (_ || k || (p = false)), _ ? m = false : k && ($ || C || (m = false)), x === 34 && h10[0] === '"' && y >= 48 && y <= 57 && (m = p = false), p && m && (p = k, m = C), !p && !m) {
          g && (s.content = Gc(s.content, h10.index, E2));
          continue;
        }
        if (m)
          for (r = n.length - 1; r >= 0; r--) {
            let L = n[r];
            if (n[r].level < o)
              break;
            if (L.single === g && n[r].level === o) {
              L = n[r];
              let B, q;
              g ? (B = e.md.options.quotes[2], q = e.md.options.quotes[3]) : (B = e.md.options.quotes[0], q = e.md.options.quotes[1]), s.content = Gc(s.content, h10.index, q), t15[L.token].content = Gc(
                t15[L.token].content,
                L.pos,
                B
              ), l += q.length - 1, L.token === i && (l += B.length - 1), a = s.content, c = a.length, n.length = r;
              continue t;
            }
          }
        p ? n.push({
          token: i,
          pos: h10.index,
          single: g,
          level: o
        }) : m && g && (s.content = Gc(s.content, h10.index, E2));
      }
  }
}
function KE(t15) {
  if (t15.md.options.typographer)
    for (let e = t15.tokens.length - 1; e >= 0; e--)
      t15.tokens[e].type !== "inline" || !XE.test(t15.tokens[e].content) || YE(t15.tokens[e].children, t15);
}
function ZE(t15) {
  let e, r;
  const n = t15.tokens, i = n.length;
  for (let s = 0; s < i; s++) {
    if (n[s].type !== "inline") continue;
    const o = n[s].children, a = o.length;
    for (e = 0; e < a; e++)
      o[e].type === "text_special" && (o[e].type = "text");
    for (e = r = 0; e < a; e++)
      o[e].type === "text" && e + 1 < a && o[e + 1].type === "text" ? o[e + 1].content = o[e].content + o[e + 1].content : (e !== r && (o[r] = o[e]), r++);
    e !== r && (o.length = r);
  }
}
var jd = [
  ["normalize", NE],
  ["block", IE],
  ["inline", OE],
  ["linkify", RE],
  ["replacements", GE],
  ["smartquotes", KE],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", ZE]
];
function em() {
  this.ruler = new Gr();
  for (let t15 = 0; t15 < jd.length; t15++)
    this.ruler.push(jd[t15][0], jd[t15][1]);
}
em.prototype.process = function(t15) {
  const e = this.ruler.getRules("");
  for (let r = 0, n = e.length; r < n; r++)
    e[r](t15);
};
em.prototype.State = Ox;
function si(t15, e, r, n) {
  this.src = t15, this.md = e, this.env = r, this.tokens = n, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const i = this.src;
  for (let s = 0, o = 0, a = 0, l = 0, c = i.length, h10 = false; o < c; o++) {
    const p = i.charCodeAt(o);
    if (!h10)
      if (Se(p)) {
        a++, p === 9 ? l += 4 - l % 4 : l++;
        continue;
      } else
        h10 = true;
    (p === 10 || o === c - 1) && (p !== 10 && o++, this.bMarks.push(s), this.eMarks.push(o), this.tShift.push(a), this.sCount.push(l), this.bsCount.push(0), h10 = false, a = 0, l = 0, s = o + 1);
  }
  this.bMarks.push(i.length), this.eMarks.push(i.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
si.prototype.push = function(t15, e, r) {
  const n = new Bn(t15, e, r);
  return n.block = true, r < 0 && this.level--, n.level = this.level, r > 0 && this.level++, this.tokens.push(n), n;
};
si.prototype.isEmpty = function(t15) {
  return this.bMarks[t15] + this.tShift[t15] >= this.eMarks[t15];
};
si.prototype.skipEmptyLines = function(t15) {
  for (let e = this.lineMax; t15 < e && !(this.bMarks[t15] + this.tShift[t15] < this.eMarks[t15]); t15++)
    ;
  return t15;
};
si.prototype.skipSpaces = function(t15) {
  for (let e = this.src.length; t15 < e; t15++) {
    const r = this.src.charCodeAt(t15);
    if (!Se(r))
      break;
  }
  return t15;
};
si.prototype.skipSpacesBack = function(t15, e) {
  if (t15 <= e)
    return t15;
  for (; t15 > e; )
    if (!Se(this.src.charCodeAt(--t15)))
      return t15 + 1;
  return t15;
};
si.prototype.skipChars = function(t15, e) {
  for (let r = this.src.length; t15 < r && this.src.charCodeAt(t15) === e; t15++)
    ;
  return t15;
};
si.prototype.skipCharsBack = function(t15, e, r) {
  if (t15 <= r)
    return t15;
  for (; t15 > r; )
    if (e !== this.src.charCodeAt(--t15))
      return t15 + 1;
  return t15;
};
si.prototype.getLines = function(t15, e, r, n) {
  if (t15 >= e)
    return "";
  const i = new Array(e - t15);
  for (let s = 0, o = t15; o < e; o++, s++) {
    let a = 0;
    const l = this.bMarks[o];
    let c = l, h10;
    for (o + 1 < e || n ? h10 = this.eMarks[o] + 1 : h10 = this.eMarks[o]; c < h10 && a < r; ) {
      const p = this.src.charCodeAt(c);
      if (Se(p))
        p === 9 ? a += 4 - (a + this.bsCount[o]) % 4 : a++;
      else if (c - l < this.tShift[o])
        a++;
      else
        break;
      c++;
    }
    a > r ? i[s] = new Array(a - r + 1).join(" ") + this.src.slice(c, h10) : i[s] = this.src.slice(c, h10);
  }
  return i.join("");
};
si.prototype.Token = Bn;
var QE = 65536;
function Wd(t15, e) {
  const r = t15.bMarks[e] + t15.tShift[e], n = t15.eMarks[e];
  return t15.src.slice(r, n);
}
function M2(t15) {
  const e = [], r = t15.length;
  let n = 0, i = t15.charCodeAt(n), s = false, o = 0, a = "";
  for (; n < r; )
    i === 124 && (s ? (a += t15.substring(o, n - 1), o = n) : (e.push(a + t15.substring(o, n)), a = "", o = n + 1)), s = i === 92, n++, i = t15.charCodeAt(n);
  return e.push(a + t15.substring(o)), e;
}
function JE(t15, e, r, n) {
  if (e + 2 > r)
    return false;
  let i = e + 1;
  if (t15.sCount[i] < t15.blkIndent || t15.sCount[i] - t15.blkIndent >= 4)
    return false;
  let s = t15.bMarks[i] + t15.tShift[i];
  if (s >= t15.eMarks[i])
    return false;
  const o = t15.src.charCodeAt(s++);
  if (o !== 124 && o !== 45 && o !== 58 || s >= t15.eMarks[i])
    return false;
  const a = t15.src.charCodeAt(s++);
  if (a !== 124 && a !== 45 && a !== 58 && !Se(a) || o === 45 && Se(a))
    return false;
  for (; s < t15.eMarks[i]; ) {
    const L = t15.src.charCodeAt(s);
    if (L !== 124 && L !== 45 && L !== 58 && !Se(L))
      return false;
    s++;
  }
  let l = Wd(t15, e + 1), c = l.split("|");
  const h10 = [];
  for (let L = 0; L < c.length; L++) {
    const B = c[L].trim();
    if (!B) {
      if (L === 0 || L === c.length - 1)
        continue;
      return false;
    }
    if (!/^:?-+:?$/.test(B))
      return false;
    B.charCodeAt(B.length - 1) === 58 ? h10.push(B.charCodeAt(0) === 58 ? "center" : "right") : B.charCodeAt(0) === 58 ? h10.push("left") : h10.push("");
  }
  if (l = Wd(t15, e).trim(), l.indexOf("|") === -1 || t15.sCount[e] - t15.blkIndent >= 4)
    return false;
  c = M2(l), c.length && c[0] === "" && c.shift(), c.length && c[c.length - 1] === "" && c.pop();
  const p = c.length;
  if (p === 0 || p !== h10.length)
    return false;
  if (n)
    return true;
  const m = t15.parentType;
  t15.parentType = "table";
  const g = t15.md.block.ruler.getRules("blockquote"), y = t15.push("table_open", "table", 1), x = [e, 0];
  y.map = x;
  const k = t15.push("thead_open", "thead", 1);
  k.map = [e, e + 1];
  const C = t15.push("tr_open", "tr", 1);
  C.map = [e, e + 1];
  for (let L = 0; L < c.length; L++) {
    const B = t15.push("th_open", "th", 1);
    h10[L] && (B.attrs = [["style", "text-align:" + h10[L]]]);
    const q = t15.push("inline", "", 0);
    q.content = c[L].trim(), q.children = [], t15.push("th_close", "th", -1);
  }
  t15.push("tr_close", "tr", -1), t15.push("thead_close", "thead", -1);
  let _, $ = 0;
  for (i = e + 2; i < r && !(t15.sCount[i] < t15.blkIndent); i++) {
    let L = false;
    for (let q = 0, H = g.length; q < H; q++)
      if (g[q](t15, i, r, true)) {
        L = true;
        break;
      }
    if (L || (l = Wd(t15, i).trim(), !l) || t15.sCount[i] - t15.blkIndent >= 4 || (c = M2(l), c.length && c[0] === "" && c.shift(), c.length && c[c.length - 1] === "" && c.pop(), $ += p - c.length, $ > QE))
      break;
    if (i === e + 2) {
      const q = t15.push("tbody_open", "tbody", 1);
      q.map = _ = [e + 2, 0];
    }
    const B = t15.push("tr_open", "tr", 1);
    B.map = [i, i + 1];
    for (let q = 0; q < p; q++) {
      const H = t15.push("td_open", "td", 1);
      h10[q] && (H.attrs = [["style", "text-align:" + h10[q]]]);
      const G = t15.push("inline", "", 0);
      G.content = c[q] ? c[q].trim() : "", G.children = [], t15.push("td_close", "td", -1);
    }
    t15.push("tr_close", "tr", -1);
  }
  return _ && (t15.push("tbody_close", "tbody", -1), _[1] = i), t15.push("table_close", "table", -1), x[1] = i, t15.parentType = m, t15.line = i, true;
}
function tM(t15, e, r) {
  if (t15.sCount[e] - t15.blkIndent < 4)
    return false;
  let n = e + 1, i = n;
  for (; n < r; ) {
    if (t15.isEmpty(n)) {
      n++;
      continue;
    }
    if (t15.sCount[n] - t15.blkIndent >= 4) {
      n++, i = n;
      continue;
    }
    break;
  }
  t15.line = i;
  const s = t15.push("code_block", "code", 0);
  return s.content = t15.getLines(e, i, 4 + t15.blkIndent, false) + `
`, s.map = [e, t15.line], true;
}
function eM(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e];
  if (t15.sCount[e] - t15.blkIndent >= 4 || i + 3 > s)
    return false;
  const o = t15.src.charCodeAt(i);
  if (o !== 126 && o !== 96)
    return false;
  let a = i;
  i = t15.skipChars(i, o);
  let l = i - a;
  if (l < 3)
    return false;
  const c = t15.src.slice(a, i), h10 = t15.src.slice(i, s);
  if (o === 96 && h10.indexOf(String.fromCharCode(o)) >= 0)
    return false;
  if (n)
    return true;
  let p = e, m = false;
  for (; p++, !(p >= r || (i = a = t15.bMarks[p] + t15.tShift[p], s = t15.eMarks[p], i < s && t15.sCount[p] < t15.blkIndent)); )
    if (t15.src.charCodeAt(i) === o && !(t15.sCount[p] - t15.blkIndent >= 4) && (i = t15.skipChars(i, o), !(i - a < l) && (i = t15.skipSpaces(i), !(i < s)))) {
      m = true;
      break;
    }
  l = t15.sCount[e], t15.line = p + (m ? 1 : 0);
  const g = t15.push("fence", "code", 0);
  return g.info = h10, g.content = t15.getLines(e + 1, p, l, true), g.markup = c, g.map = [e, t15.line], true;
}
function rM(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e];
  const o = t15.lineMax;
  if (t15.sCount[e] - t15.blkIndent >= 4 || t15.src.charCodeAt(i) !== 62)
    return false;
  if (n)
    return true;
  const a = [], l = [], c = [], h10 = [], p = t15.md.block.ruler.getRules("blockquote"), m = t15.parentType;
  t15.parentType = "blockquote";
  let g = false, y;
  for (y = e; y < r; y++) {
    const $ = t15.sCount[y] < t15.blkIndent;
    if (i = t15.bMarks[y] + t15.tShift[y], s = t15.eMarks[y], i >= s)
      break;
    if (t15.src.charCodeAt(i++) === 62 && !$) {
      let B = t15.sCount[y] + 1, q, H;
      t15.src.charCodeAt(i) === 32 ? (i++, B++, H = false, q = true) : t15.src.charCodeAt(i) === 9 ? (q = true, (t15.bsCount[y] + B) % 4 === 3 ? (i++, B++, H = false) : H = true) : q = false;
      let G = B;
      for (a.push(t15.bMarks[y]), t15.bMarks[y] = i; i < s; ) {
        const F = t15.src.charCodeAt(i);
        if (Se(F))
          F === 9 ? G += 4 - (G + t15.bsCount[y] + (H ? 1 : 0)) % 4 : G++;
        else
          break;
        i++;
      }
      g = i >= s, l.push(t15.bsCount[y]), t15.bsCount[y] = t15.sCount[y] + 1 + (q ? 1 : 0), c.push(t15.sCount[y]), t15.sCount[y] = G - B, h10.push(t15.tShift[y]), t15.tShift[y] = i - t15.bMarks[y];
      continue;
    }
    if (g)
      break;
    let L = false;
    for (let B = 0, q = p.length; B < q; B++)
      if (p[B](t15, y, r, true)) {
        L = true;
        break;
      }
    if (L) {
      t15.lineMax = y, t15.blkIndent !== 0 && (a.push(t15.bMarks[y]), l.push(t15.bsCount[y]), h10.push(t15.tShift[y]), c.push(t15.sCount[y]), t15.sCount[y] -= t15.blkIndent);
      break;
    }
    a.push(t15.bMarks[y]), l.push(t15.bsCount[y]), h10.push(t15.tShift[y]), c.push(t15.sCount[y]), t15.sCount[y] = -1;
  }
  const x = t15.blkIndent;
  t15.blkIndent = 0;
  const k = t15.push("blockquote_open", "blockquote", 1);
  k.markup = ">";
  const C = [e, 0];
  k.map = C, t15.md.block.tokenize(t15, e, y);
  const _ = t15.push("blockquote_close", "blockquote", -1);
  _.markup = ">", t15.lineMax = o, t15.parentType = m, C[1] = t15.line;
  for (let $ = 0; $ < h10.length; $++)
    t15.bMarks[$ + e] = a[$], t15.tShift[$ + e] = h10[$], t15.sCount[$ + e] = c[$], t15.bsCount[$ + e] = l[$];
  return t15.blkIndent = x, true;
}
function nM(t15, e, r, n) {
  const i = t15.eMarks[e];
  if (t15.sCount[e] - t15.blkIndent >= 4)
    return false;
  let s = t15.bMarks[e] + t15.tShift[e];
  const o = t15.src.charCodeAt(s++);
  if (o !== 42 && o !== 45 && o !== 95)
    return false;
  let a = 1;
  for (; s < i; ) {
    const c = t15.src.charCodeAt(s++);
    if (c !== o && !Se(c))
      return false;
    c === o && a++;
  }
  if (a < 3)
    return false;
  if (n)
    return true;
  t15.line = e + 1;
  const l = t15.push("hr", "hr", 0);
  return l.map = [e, t15.line], l.markup = Array(a + 1).join(String.fromCharCode(o)), true;
}
function B2(t15, e) {
  const r = t15.eMarks[e];
  let n = t15.bMarks[e] + t15.tShift[e];
  const i = t15.src.charCodeAt(n++);
  if (i !== 42 && i !== 45 && i !== 43)
    return -1;
  if (n < r) {
    const s = t15.src.charCodeAt(n);
    if (!Se(s))
      return -1;
  }
  return n;
}
function L2(t15, e) {
  const r = t15.bMarks[e] + t15.tShift[e], n = t15.eMarks[e];
  let i = r;
  if (i + 1 >= n)
    return -1;
  let s = t15.src.charCodeAt(i++);
  if (s < 48 || s > 57)
    return -1;
  for (; ; ) {
    if (i >= n)
      return -1;
    if (s = t15.src.charCodeAt(i++), s >= 48 && s <= 57) {
      if (i - r >= 10)
        return -1;
      continue;
    }
    if (s === 41 || s === 46)
      break;
    return -1;
  }
  return i < n && (s = t15.src.charCodeAt(i), !Se(s)) ? -1 : i;
}
function iM(t15, e) {
  const r = t15.level + 2;
  for (let n = e + 2, i = t15.tokens.length - 2; n < i; n++)
    t15.tokens[n].level === r && t15.tokens[n].type === "paragraph_open" && (t15.tokens[n + 2].hidden = true, t15.tokens[n].hidden = true, n += 2);
}
function sM(t15, e, r, n) {
  let i, s, o, a, l = e, c = true;
  if (t15.sCount[l] - t15.blkIndent >= 4 || t15.listIndent >= 0 && t15.sCount[l] - t15.listIndent >= 4 && t15.sCount[l] < t15.blkIndent)
    return false;
  let h10 = false;
  n && t15.parentType === "paragraph" && t15.sCount[l] >= t15.blkIndent && (h10 = true);
  let p, m, g;
  if ((g = L2(t15, l)) >= 0) {
    if (p = true, o = t15.bMarks[l] + t15.tShift[l], m = Number(t15.src.slice(o, g - 1)), h10 && m !== 1) return false;
  } else if ((g = B2(t15, l)) >= 0)
    p = false;
  else
    return false;
  if (h10 && t15.skipSpaces(g) >= t15.eMarks[l])
    return false;
  if (n)
    return true;
  const y = t15.src.charCodeAt(g - 1), x = t15.tokens.length;
  p ? (a = t15.push("ordered_list_open", "ol", 1), m !== 1 && (a.attrs = [["start", m]])) : a = t15.push("bullet_list_open", "ul", 1);
  const k = [l, 0];
  a.map = k, a.markup = String.fromCharCode(y);
  let C = false;
  const _ = t15.md.block.ruler.getRules("list"), $ = t15.parentType;
  for (t15.parentType = "list"; l < r; ) {
    s = g, i = t15.eMarks[l];
    const L = t15.sCount[l] + g - (t15.bMarks[l] + t15.tShift[l]);
    let B = L;
    for (; s < i; ) {
      const j = t15.src.charCodeAt(s);
      if (j === 9)
        B += 4 - (B + t15.bsCount[l]) % 4;
      else if (j === 32)
        B++;
      else
        break;
      s++;
    }
    const q = s;
    let H;
    q >= i ? H = 1 : H = B - L, H > 4 && (H = 1);
    const G = L + H;
    a = t15.push("list_item_open", "li", 1), a.markup = String.fromCharCode(y);
    const F = [l, 0];
    a.map = F, p && (a.info = t15.src.slice(o, g - 1));
    const W = t15.tight, R = t15.tShift[l], J = t15.sCount[l], rt = t15.listIndent;
    if (t15.listIndent = t15.blkIndent, t15.blkIndent = G, t15.tight = true, t15.tShift[l] = q - t15.bMarks[l], t15.sCount[l] = B, q >= i && t15.isEmpty(l + 1) ? t15.line = Math.min(t15.line + 2, r) : t15.md.block.tokenize(t15, l, r, true), (!t15.tight || C) && (c = false), C = t15.line - l > 1 && t15.isEmpty(t15.line - 1), t15.blkIndent = t15.listIndent, t15.listIndent = rt, t15.tShift[l] = R, t15.sCount[l] = J, t15.tight = W, a = t15.push("list_item_close", "li", -1), a.markup = String.fromCharCode(y), l = t15.line, F[1] = l, l >= r || t15.sCount[l] < t15.blkIndent || t15.sCount[l] - t15.blkIndent >= 4)
      break;
    let I = false;
    for (let j = 0, z = _.length; j < z; j++)
      if (_[j](t15, l, r, true)) {
        I = true;
        break;
      }
    if (I)
      break;
    if (p) {
      if (g = L2(t15, l), g < 0)
        break;
      o = t15.bMarks[l] + t15.tShift[l];
    } else if (g = B2(t15, l), g < 0)
      break;
    if (y !== t15.src.charCodeAt(g - 1))
      break;
  }
  return p ? a = t15.push("ordered_list_close", "ol", -1) : a = t15.push("bullet_list_close", "ul", -1), a.markup = String.fromCharCode(y), k[1] = l, t15.line = l, t15.parentType = $, c && iM(t15, x), true;
}
function oM(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e], o = e + 1;
  if (t15.sCount[e] - t15.blkIndent >= 4 || t15.src.charCodeAt(i) !== 91)
    return false;
  function a(_) {
    const $ = t15.lineMax;
    if (_ >= $ || t15.isEmpty(_))
      return null;
    let L = false;
    if (t15.sCount[_] - t15.blkIndent > 3 && (L = true), t15.sCount[_] < 0 && (L = true), !L) {
      const H = t15.md.block.ruler.getRules("reference"), G = t15.parentType;
      t15.parentType = "reference";
      let F = false;
      for (let W = 0, R = H.length; W < R; W++)
        if (H[W](t15, _, $, true)) {
          F = true;
          break;
        }
      if (t15.parentType = G, F)
        return null;
    }
    const B = t15.bMarks[_] + t15.tShift[_], q = t15.eMarks[_];
    return t15.src.slice(B, q + 1);
  }
  let l = t15.src.slice(i, s + 1);
  s = l.length;
  let c = -1;
  for (i = 1; i < s; i++) {
    const _ = l.charCodeAt(i);
    if (_ === 91)
      return false;
    if (_ === 93) {
      c = i;
      break;
    } else if (_ === 10) {
      const $ = a(o);
      $ !== null && (l += $, s = l.length, o++);
    } else if (_ === 92 && (i++, i < s && l.charCodeAt(i) === 10)) {
      const $ = a(o);
      $ !== null && (l += $, s = l.length, o++);
    }
  }
  if (c < 0 || l.charCodeAt(c + 1) !== 58)
    return false;
  for (i = c + 2; i < s; i++) {
    const _ = l.charCodeAt(i);
    if (_ === 10) {
      const $ = a(o);
      $ !== null && (l += $, s = l.length, o++);
    } else if (!Se(_)) break;
  }
  const h10 = t15.md.helpers.parseLinkDestination(l, i, s);
  if (!h10.ok)
    return false;
  const p = t15.md.normalizeLink(h10.str);
  if (!t15.md.validateLink(p))
    return false;
  i = h10.pos;
  const m = i, g = o, y = i;
  for (; i < s; i++) {
    const _ = l.charCodeAt(i);
    if (_ === 10) {
      const $ = a(o);
      $ !== null && (l += $, s = l.length, o++);
    } else if (!Se(_)) break;
  }
  let x = t15.md.helpers.parseLinkTitle(l, i, s);
  for (; x.can_continue; ) {
    const _ = a(o);
    if (_ === null) break;
    l += _, i = s, s = l.length, o++, x = t15.md.helpers.parseLinkTitle(l, i, s, x);
  }
  let k;
  for (i < s && y !== i && x.ok ? (k = x.str, i = x.pos) : (k = "", i = m, o = g); i < s; ) {
    const _ = l.charCodeAt(i);
    if (!Se(_))
      break;
    i++;
  }
  if (i < s && l.charCodeAt(i) !== 10 && k)
    for (k = "", i = m, o = g; i < s; ) {
      const _ = l.charCodeAt(i);
      if (!Se(_))
        break;
      i++;
    }
  if (i < s && l.charCodeAt(i) !== 10)
    return false;
  const C = s0(l.slice(1, c));
  return C ? (n || (typeof t15.env.references > "u" && (t15.env.references = {}), typeof t15.env.references[C] > "u" && (t15.env.references[C] = { title: k, href: p }), t15.line = o), true) : false;
}
var aM = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var lM = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var cM = "[^\"'=<>`\\x00-\\x20]+";
var hM = "'[^']*'";
var uM = '"[^"]*"';
var dM = "(?:" + cM + "|" + hM + "|" + uM + ")";
var pM = "(?:\\s+" + lM + "(?:\\s*=\\s*" + dM + ")?)";
var qx = "<[A-Za-z][A-Za-z0-9\\-]*" + pM + "*\\s*\\/?>";
var Rx = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var fM = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var mM = "<[?][\\s\\S]*?[?]>";
var gM = "<![A-Za-z][^>]*>";
var yM = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var bM = new RegExp("^(?:" + qx + "|" + Rx + "|" + fM + "|" + mM + "|" + gM + "|" + yM + ")");
var xM = new RegExp("^(?:" + qx + "|" + Rx + ")");
var vo = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + aM.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(xM.source + "\\s*$"), /^$/, false]
];
function wM(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e];
  if (t15.sCount[e] - t15.blkIndent >= 4 || !t15.md.options.html || t15.src.charCodeAt(i) !== 60)
    return false;
  let o = t15.src.slice(i, s), a = 0;
  for (; a < vo.length && !vo[a][0].test(o); a++)
    ;
  if (a === vo.length)
    return false;
  if (n)
    return vo[a][2];
  let l = e + 1;
  if (!vo[a][1].test(o)) {
    for (; l < r && !(t15.sCount[l] < t15.blkIndent); l++)
      if (i = t15.bMarks[l] + t15.tShift[l], s = t15.eMarks[l], o = t15.src.slice(i, s), vo[a][1].test(o)) {
        o.length !== 0 && l++;
        break;
      }
  }
  t15.line = l;
  const c = t15.push("html_block", "", 0);
  return c.map = [e, l], c.content = t15.getLines(e, l, t15.blkIndent, true), true;
}
function kM(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e];
  if (t15.sCount[e] - t15.blkIndent >= 4)
    return false;
  let o = t15.src.charCodeAt(i);
  if (o !== 35 || i >= s)
    return false;
  let a = 1;
  for (o = t15.src.charCodeAt(++i); o === 35 && i < s && a <= 6; )
    a++, o = t15.src.charCodeAt(++i);
  if (a > 6 || i < s && !Se(o))
    return false;
  if (n)
    return true;
  s = t15.skipSpacesBack(s, i);
  const l = t15.skipCharsBack(s, 35, i);
  l > i && Se(t15.src.charCodeAt(l - 1)) && (s = l), t15.line = e + 1;
  const c = t15.push("heading_open", "h" + String(a), 1);
  c.markup = "########".slice(0, a), c.map = [e, t15.line];
  const h10 = t15.push("inline", "", 0);
  h10.content = t15.src.slice(i, s).trim(), h10.map = [e, t15.line], h10.children = [];
  const p = t15.push("heading_close", "h" + String(a), -1);
  return p.markup = "########".slice(0, a), true;
}
function vM(t15, e, r) {
  const n = t15.md.block.ruler.getRules("paragraph");
  if (t15.sCount[e] - t15.blkIndent >= 4)
    return false;
  const i = t15.parentType;
  t15.parentType = "paragraph";
  let s = 0, o, a = e + 1;
  for (; a < r && !t15.isEmpty(a); a++) {
    if (t15.sCount[a] - t15.blkIndent > 3)
      continue;
    if (t15.sCount[a] >= t15.blkIndent) {
      let g = t15.bMarks[a] + t15.tShift[a];
      const y = t15.eMarks[a];
      if (g < y && (o = t15.src.charCodeAt(g), (o === 45 || o === 61) && (g = t15.skipChars(g, o), g = t15.skipSpaces(g), g >= y))) {
        s = o === 61 ? 1 : 2;
        break;
      }
    }
    if (t15.sCount[a] < 0)
      continue;
    let m = false;
    for (let g = 0, y = n.length; g < y; g++)
      if (n[g](t15, a, r, true)) {
        m = true;
        break;
      }
    if (m)
      break;
  }
  if (!s)
    return false;
  const l = t15.getLines(e, a, t15.blkIndent, false).trim();
  t15.line = a + 1;
  const c = t15.push("heading_open", "h" + String(s), 1);
  c.markup = String.fromCharCode(o), c.map = [e, t15.line];
  const h10 = t15.push("inline", "", 0);
  h10.content = l, h10.map = [e, t15.line - 1], h10.children = [];
  const p = t15.push("heading_close", "h" + String(s), -1);
  return p.markup = String.fromCharCode(o), t15.parentType = i, true;
}
function _M(t15, e, r) {
  const n = t15.md.block.ruler.getRules("paragraph"), i = t15.parentType;
  let s = e + 1;
  for (t15.parentType = "paragraph"; s < r && !t15.isEmpty(s); s++) {
    if (t15.sCount[s] - t15.blkIndent > 3 || t15.sCount[s] < 0)
      continue;
    let c = false;
    for (let h10 = 0, p = n.length; h10 < p; h10++)
      if (n[h10](t15, s, r, true)) {
        c = true;
        break;
      }
    if (c)
      break;
  }
  const o = t15.getLines(e, s, t15.blkIndent, false).trim();
  t15.line = s;
  const a = t15.push("paragraph_open", "p", 1);
  a.map = [e, t15.line];
  const l = t15.push("inline", "", 0);
  return l.content = o, l.map = [e, t15.line], l.children = [], t15.push("paragraph_close", "p", -1), t15.parentType = i, true;
}
var Xc = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", JE, ["paragraph", "reference"]],
  ["code", tM],
  ["fence", eM, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", rM, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", nM, ["paragraph", "reference", "blockquote", "list"]],
  ["list", sM, ["paragraph", "reference", "blockquote"]],
  ["reference", oM],
  ["html_block", wM, ["paragraph", "reference", "blockquote"]],
  ["heading", kM, ["paragraph", "reference", "blockquote"]],
  ["lheading", vM],
  ["paragraph", _M]
];
function o0() {
  this.ruler = new Gr();
  for (let t15 = 0; t15 < Xc.length; t15++)
    this.ruler.push(Xc[t15][0], Xc[t15][1], { alt: (Xc[t15][2] || []).slice() });
}
o0.prototype.tokenize = function(t15, e, r) {
  const n = this.ruler.getRules(""), i = n.length, s = t15.md.options.maxNesting;
  let o = e, a = false;
  for (; o < r && (t15.line = o = t15.skipEmptyLines(o), !(o >= r || t15.sCount[o] < t15.blkIndent)); ) {
    if (t15.level >= s) {
      t15.line = r;
      break;
    }
    const l = t15.line;
    let c = false;
    for (let h10 = 0; h10 < i; h10++)
      if (c = n[h10](t15, o, r, false), c) {
        if (l >= t15.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!c) throw new Error("none of the block rules matched");
    t15.tight = !a, t15.isEmpty(t15.line - 1) && (a = true), o = t15.line, o < r && t15.isEmpty(o) && (a = true, o++, t15.line = o);
  }
};
o0.prototype.parse = function(t15, e, r, n) {
  if (!t15)
    return;
  const i = new this.State(t15, e, r, n);
  this.tokenize(i, i.line, i.lineMax);
};
o0.prototype.State = si;
function ec(t15, e, r, n) {
  this.src = t15, this.env = r, this.md = e, this.tokens = n, this.tokens_meta = Array(n.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
ec.prototype.pushPending = function() {
  const t15 = new Bn("text", "", 0);
  return t15.content = this.pending, t15.level = this.pendingLevel, this.tokens.push(t15), this.pending = "", t15;
};
ec.prototype.push = function(t15, e, r) {
  this.pending && this.pushPending();
  const n = new Bn(t15, e, r);
  let i = null;
  return r < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), n.level = this.level, r > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(n), this.tokens_meta.push(i), n;
};
ec.prototype.scanDelims = function(t15, e) {
  const r = this.posMax, n = this.src.charCodeAt(t15), i = t15 > 0 ? this.src.charCodeAt(t15 - 1) : 32;
  let s = t15;
  for (; s < r && this.src.charCodeAt(s) === n; )
    s++;
  const o = s - t15, a = s < r ? this.src.charCodeAt(s) : 32, l = Bl(i) || Ml(String.fromCharCode(i)), c = Bl(a) || Ml(String.fromCharCode(a)), h10 = El(i), p = El(a), m = !p && (!c || h10 || l), g = !h10 && (!l || p || c);
  return { can_open: m && (e || !g || l), can_close: g && (e || !m || c), length: o };
};
ec.prototype.Token = Bn;
function CM(t15) {
  switch (t15) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function SM(t15, e) {
  let r = t15.pos;
  for (; r < t15.posMax && !CM(t15.src.charCodeAt(r)); )
    r++;
  return r === t15.pos ? false : (e || (t15.pending += t15.src.slice(t15.pos, r)), t15.pos = r, true);
}
var TM = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function AM(t15, e) {
  if (!t15.md.options.linkify || t15.linkLevel > 0) return false;
  const r = t15.pos, n = t15.posMax;
  if (r + 3 > n || t15.src.charCodeAt(r) !== 58 || t15.src.charCodeAt(r + 1) !== 47 || t15.src.charCodeAt(r + 2) !== 47) return false;
  const i = t15.pending.match(TM);
  if (!i) return false;
  const s = i[1], o = t15.md.linkify.matchAtStart(t15.src.slice(r - s.length));
  if (!o) return false;
  let a = o.url;
  if (a.length <= s.length) return false;
  a = a.replace(/\*+$/, "");
  const l = t15.md.normalizeLink(a);
  if (!t15.md.validateLink(l)) return false;
  if (!e) {
    t15.pending = t15.pending.slice(0, -s.length);
    const c = t15.push("link_open", "a", 1);
    c.attrs = [["href", l]], c.markup = "linkify", c.info = "auto";
    const h10 = t15.push("text", "", 0);
    h10.content = t15.md.normalizeLinkText(a);
    const p = t15.push("link_close", "a", -1);
    p.markup = "linkify", p.info = "auto";
  }
  return t15.pos += a.length - s.length, true;
}
function $M(t15, e) {
  let r = t15.pos;
  if (t15.src.charCodeAt(r) !== 10)
    return false;
  const n = t15.pending.length - 1, i = t15.posMax;
  if (!e)
    if (n >= 0 && t15.pending.charCodeAt(n) === 32)
      if (n >= 1 && t15.pending.charCodeAt(n - 1) === 32) {
        let s = n - 1;
        for (; s >= 1 && t15.pending.charCodeAt(s - 1) === 32; ) s--;
        t15.pending = t15.pending.slice(0, s), t15.push("hardbreak", "br", 0);
      } else
        t15.pending = t15.pending.slice(0, -1), t15.push("softbreak", "br", 0);
    else
      t15.push("softbreak", "br", 0);
  for (r++; r < i && Se(t15.src.charCodeAt(r)); )
    r++;
  return t15.pos = r, true;
}
var rm = [];
for (let t15 = 0; t15 < 256; t15++)
  rm.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(t15) {
  rm[t15.charCodeAt(0)] = 1;
});
function EM(t15, e) {
  let r = t15.pos;
  const n = t15.posMax;
  if (t15.src.charCodeAt(r) !== 92 || (r++, r >= n)) return false;
  let i = t15.src.charCodeAt(r);
  if (i === 10) {
    for (e || t15.push("hardbreak", "br", 0), r++; r < n && (i = t15.src.charCodeAt(r), !!Se(i)); )
      r++;
    return t15.pos = r, true;
  }
  let s = t15.src[r];
  if (i >= 55296 && i <= 56319 && r + 1 < n) {
    const a = t15.src.charCodeAt(r + 1);
    a >= 56320 && a <= 57343 && (s += t15.src[r + 1], r++);
  }
  const o = "\\" + s;
  if (!e) {
    const a = t15.push("text_special", "", 0);
    i < 256 && rm[i] !== 0 ? a.content = s : a.content = o, a.markup = o, a.info = "escape";
  }
  return t15.pos = r + 1, true;
}
function MM(t15, e) {
  let r = t15.pos;
  if (t15.src.charCodeAt(r) !== 96)
    return false;
  const n = r;
  r++;
  const i = t15.posMax;
  for (; r < i && t15.src.charCodeAt(r) === 96; )
    r++;
  const s = t15.src.slice(n, r), o = s.length;
  if (t15.backticksScanned && (t15.backticks[o] || 0) <= n)
    return e || (t15.pending += s), t15.pos += o, true;
  let a = r, l;
  for (; (l = t15.src.indexOf("`", a)) !== -1; ) {
    for (a = l + 1; a < i && t15.src.charCodeAt(a) === 96; )
      a++;
    const c = a - l;
    if (c === o) {
      if (!e) {
        const h10 = t15.push("code_inline", "code", 0);
        h10.markup = s, h10.content = t15.src.slice(r, l).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return t15.pos = a, true;
    }
    t15.backticks[c] = l;
  }
  return t15.backticksScanned = true, e || (t15.pending += s), t15.pos += o, true;
}
function BM(t15, e) {
  const r = t15.pos, n = t15.src.charCodeAt(r);
  if (e || n !== 126)
    return false;
  const i = t15.scanDelims(t15.pos, true);
  let s = i.length;
  const o = String.fromCharCode(n);
  if (s < 2)
    return false;
  let a;
  s % 2 && (a = t15.push("text", "", 0), a.content = o, s--);
  for (let l = 0; l < s; l += 2)
    a = t15.push("text", "", 0), a.content = o + o, t15.delimiters.push({
      marker: n,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: t15.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return t15.pos += i.length, true;
}
function D2(t15, e) {
  let r;
  const n = [], i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s];
    if (o.marker !== 126 || o.end === -1)
      continue;
    const a = e[o.end];
    r = t15.tokens[o.token], r.type = "s_open", r.tag = "s", r.nesting = 1, r.markup = "~~", r.content = "", r = t15.tokens[a.token], r.type = "s_close", r.tag = "s", r.nesting = -1, r.markup = "~~", r.content = "", t15.tokens[a.token - 1].type === "text" && t15.tokens[a.token - 1].content === "~" && n.push(a.token - 1);
  }
  for (; n.length; ) {
    const s = n.pop();
    let o = s + 1;
    for (; o < t15.tokens.length && t15.tokens[o].type === "s_close"; )
      o++;
    o--, s !== o && (r = t15.tokens[o], t15.tokens[o] = t15.tokens[s], t15.tokens[s] = r);
  }
}
function LM(t15) {
  const e = t15.tokens_meta, r = t15.tokens_meta.length;
  D2(t15, t15.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && D2(t15, e[n].delimiters);
}
var Px = {
  tokenize: BM,
  postProcess: LM
};
function DM(t15, e) {
  const r = t15.pos, n = t15.src.charCodeAt(r);
  if (e || n !== 95 && n !== 42)
    return false;
  const i = t15.scanDelims(t15.pos, n === 42);
  for (let s = 0; s < i.length; s++) {
    const o = t15.push("text", "", 0);
    o.content = String.fromCharCode(n), t15.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: n,
      // Total length of these series of delimiters.
      //
      length: i.length,
      // A position of the token this delimiter corresponds to.
      //
      token: t15.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: i.can_open,
      close: i.can_close
    });
  }
  return t15.pos += i.length, true;
}
function F2(t15, e) {
  const r = e.length;
  for (let n = r - 1; n >= 0; n--) {
    const i = e[n];
    if (i.marker !== 95 && i.marker !== 42 || i.end === -1)
      continue;
    const s = e[i.end], o = n > 0 && e[n - 1].end === i.end + 1 && // check that first two markers match and adjacent
    e[n - 1].marker === i.marker && e[n - 1].token === i.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[i.end + 1].token === s.token + 1, a = String.fromCharCode(i.marker), l = t15.tokens[i.token];
    l.type = o ? "strong_open" : "em_open", l.tag = o ? "strong" : "em", l.nesting = 1, l.markup = o ? a + a : a, l.content = "";
    const c = t15.tokens[s.token];
    c.type = o ? "strong_close" : "em_close", c.tag = o ? "strong" : "em", c.nesting = -1, c.markup = o ? a + a : a, c.content = "", o && (t15.tokens[e[n - 1].token].content = "", t15.tokens[e[i.end + 1].token].content = "", n--);
  }
}
function FM(t15) {
  const e = t15.tokens_meta, r = t15.tokens_meta.length;
  F2(t15, t15.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && F2(t15, e[n].delimiters);
}
var jx = {
  tokenize: DM,
  postProcess: FM
};
function NM(t15, e) {
  let r, n, i, s, o = "", a = "", l = t15.pos, c = true;
  if (t15.src.charCodeAt(t15.pos) !== 91)
    return false;
  const h10 = t15.pos, p = t15.posMax, m = t15.pos + 1, g = t15.md.helpers.parseLinkLabel(t15, t15.pos, true);
  if (g < 0)
    return false;
  let y = g + 1;
  if (y < p && t15.src.charCodeAt(y) === 40) {
    for (c = false, y++; y < p && (r = t15.src.charCodeAt(y), !(!Se(r) && r !== 10)); y++)
      ;
    if (y >= p)
      return false;
    if (l = y, i = t15.md.helpers.parseLinkDestination(t15.src, y, t15.posMax), i.ok) {
      for (o = t15.md.normalizeLink(i.str), t15.md.validateLink(o) ? y = i.pos : o = "", l = y; y < p && (r = t15.src.charCodeAt(y), !(!Se(r) && r !== 10)); y++)
        ;
      if (i = t15.md.helpers.parseLinkTitle(t15.src, y, t15.posMax), y < p && l !== y && i.ok)
        for (a = i.str, y = i.pos; y < p && (r = t15.src.charCodeAt(y), !(!Se(r) && r !== 10)); y++)
          ;
    }
    (y >= p || t15.src.charCodeAt(y) !== 41) && (c = true), y++;
  }
  if (c) {
    if (typeof t15.env.references > "u")
      return false;
    if (y < p && t15.src.charCodeAt(y) === 91 ? (l = y + 1, y = t15.md.helpers.parseLinkLabel(t15, y), y >= 0 ? n = t15.src.slice(l, y++) : y = g + 1) : y = g + 1, n || (n = t15.src.slice(m, g)), s = t15.env.references[s0(n)], !s)
      return t15.pos = h10, false;
    o = s.href, a = s.title;
  }
  if (!e) {
    t15.pos = m, t15.posMax = g;
    const x = t15.push("link_open", "a", 1), k = [["href", o]];
    x.attrs = k, a && k.push(["title", a]), t15.linkLevel++, t15.md.inline.tokenize(t15), t15.linkLevel--, t15.push("link_close", "a", -1);
  }
  return t15.pos = y, t15.posMax = p, true;
}
function IM(t15, e) {
  let r, n, i, s, o, a, l, c, h10 = "";
  const p = t15.pos, m = t15.posMax;
  if (t15.src.charCodeAt(t15.pos) !== 33 || t15.src.charCodeAt(t15.pos + 1) !== 91)
    return false;
  const g = t15.pos + 2, y = t15.md.helpers.parseLinkLabel(t15, t15.pos + 1, false);
  if (y < 0)
    return false;
  if (s = y + 1, s < m && t15.src.charCodeAt(s) === 40) {
    for (s++; s < m && (r = t15.src.charCodeAt(s), !(!Se(r) && r !== 10)); s++)
      ;
    if (s >= m)
      return false;
    for (c = s, a = t15.md.helpers.parseLinkDestination(t15.src, s, t15.posMax), a.ok && (h10 = t15.md.normalizeLink(a.str), t15.md.validateLink(h10) ? s = a.pos : h10 = ""), c = s; s < m && (r = t15.src.charCodeAt(s), !(!Se(r) && r !== 10)); s++)
      ;
    if (a = t15.md.helpers.parseLinkTitle(t15.src, s, t15.posMax), s < m && c !== s && a.ok)
      for (l = a.str, s = a.pos; s < m && (r = t15.src.charCodeAt(s), !(!Se(r) && r !== 10)); s++)
        ;
    else
      l = "";
    if (s >= m || t15.src.charCodeAt(s) !== 41)
      return t15.pos = p, false;
    s++;
  } else {
    if (typeof t15.env.references > "u")
      return false;
    if (s < m && t15.src.charCodeAt(s) === 91 ? (c = s + 1, s = t15.md.helpers.parseLinkLabel(t15, s), s >= 0 ? i = t15.src.slice(c, s++) : s = y + 1) : s = y + 1, i || (i = t15.src.slice(g, y)), o = t15.env.references[s0(i)], !o)
      return t15.pos = p, false;
    h10 = o.href, l = o.title;
  }
  if (!e) {
    n = t15.src.slice(g, y);
    const x = [];
    t15.md.inline.parse(
      n,
      t15.md,
      t15.env,
      x
    );
    const k = t15.push("image", "img", 0), C = [["src", h10], ["alt", ""]];
    k.attrs = C, k.children = x, k.content = n, l && C.push(["title", l]);
  }
  return t15.pos = s, t15.posMax = m, true;
}
var OM = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var zM = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function qM(t15, e) {
  let r = t15.pos;
  if (t15.src.charCodeAt(r) !== 60)
    return false;
  const n = t15.pos, i = t15.posMax;
  for (; ; ) {
    if (++r >= i) return false;
    const o = t15.src.charCodeAt(r);
    if (o === 60) return false;
    if (o === 62) break;
  }
  const s = t15.src.slice(n + 1, r);
  if (zM.test(s)) {
    const o = t15.md.normalizeLink(s);
    if (!t15.md.validateLink(o))
      return false;
    if (!e) {
      const a = t15.push("link_open", "a", 1);
      a.attrs = [["href", o]], a.markup = "autolink", a.info = "auto";
      const l = t15.push("text", "", 0);
      l.content = t15.md.normalizeLinkText(s);
      const c = t15.push("link_close", "a", -1);
      c.markup = "autolink", c.info = "auto";
    }
    return t15.pos += s.length + 2, true;
  }
  if (OM.test(s)) {
    const o = t15.md.normalizeLink("mailto:" + s);
    if (!t15.md.validateLink(o))
      return false;
    if (!e) {
      const a = t15.push("link_open", "a", 1);
      a.attrs = [["href", o]], a.markup = "autolink", a.info = "auto";
      const l = t15.push("text", "", 0);
      l.content = t15.md.normalizeLinkText(s);
      const c = t15.push("link_close", "a", -1);
      c.markup = "autolink", c.info = "auto";
    }
    return t15.pos += s.length + 2, true;
  }
  return false;
}
function RM(t15) {
  return /^<a[>\s]/i.test(t15);
}
function PM(t15) {
  return /^<\/a\s*>/i.test(t15);
}
function jM(t15) {
  const e = t15 | 32;
  return e >= 97 && e <= 122;
}
function WM(t15, e) {
  if (!t15.md.options.html)
    return false;
  const r = t15.posMax, n = t15.pos;
  if (t15.src.charCodeAt(n) !== 60 || n + 2 >= r)
    return false;
  const i = t15.src.charCodeAt(n + 1);
  if (i !== 33 && i !== 63 && i !== 47 && !jM(i))
    return false;
  const s = t15.src.slice(n).match(bM);
  if (!s)
    return false;
  if (!e) {
    const o = t15.push("html_inline", "", 0);
    o.content = s[0], RM(o.content) && t15.linkLevel++, PM(o.content) && t15.linkLevel--;
  }
  return t15.pos += s[0].length, true;
}
var HM = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var UM = /^&([a-z][a-z0-9]{1,31});/i;
function VM(t15, e) {
  const r = t15.pos, n = t15.posMax;
  if (t15.src.charCodeAt(r) !== 38 || r + 1 >= n) return false;
  if (t15.src.charCodeAt(r + 1) === 35) {
    const i = t15.src.slice(r).match(HM);
    if (i) {
      if (!e) {
        const s = i[1][0].toLowerCase() === "x" ? parseInt(i[1].slice(1), 16) : parseInt(i[1], 10), o = t15.push("text_special", "", 0);
        o.content = tm(s) ? iu(s) : iu(65533), o.markup = i[0], o.info = "entity";
      }
      return t15.pos += i[0].length, true;
    }
  } else {
    const i = t15.src.slice(r).match(UM);
    if (i) {
      const s = Fx(i[0]);
      if (s !== i[0]) {
        if (!e) {
          const o = t15.push("text_special", "", 0);
          o.content = s, o.markup = i[0], o.info = "entity";
        }
        return t15.pos += i[0].length, true;
      }
    }
  }
  return false;
}
function N2(t15) {
  const e = {}, r = t15.length;
  if (!r) return;
  let n = 0, i = -2;
  const s = [];
  for (let o = 0; o < r; o++) {
    const a = t15[o];
    if (s.push(0), (t15[n].marker !== a.marker || i !== a.token - 1) && (n = o), i = a.token, a.length = a.length || 0, !a.close) continue;
    e.hasOwnProperty(a.marker) || (e[a.marker] = [-1, -1, -1, -1, -1, -1]);
    const l = e[a.marker][(a.open ? 3 : 0) + a.length % 3];
    let c = n - s[n] - 1, h10 = c;
    for (; c > l; c -= s[c] + 1) {
      const p = t15[c];
      if (p.marker === a.marker && p.open && p.end < 0) {
        let m = false;
        if ((p.close || a.open) && (p.length + a.length) % 3 === 0 && (p.length % 3 !== 0 || a.length % 3 !== 0) && (m = true), !m) {
          const g = c > 0 && !t15[c - 1].open ? s[c - 1] + 1 : 0;
          s[o] = o - c + g, s[c] = g, a.open = false, p.end = o, p.close = false, h10 = -1, i = -2;
          break;
        }
      }
    }
    h10 !== -1 && (e[a.marker][(a.open ? 3 : 0) + (a.length || 0) % 3] = h10);
  }
}
function GM(t15) {
  const e = t15.tokens_meta, r = t15.tokens_meta.length;
  N2(t15.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && N2(e[n].delimiters);
}
function XM(t15) {
  let e, r, n = 0;
  const i = t15.tokens, s = t15.tokens.length;
  for (e = r = 0; e < s; e++)
    i[e].nesting < 0 && n--, i[e].level = n, i[e].nesting > 0 && n++, i[e].type === "text" && e + 1 < s && i[e + 1].type === "text" ? i[e + 1].content = i[e].content + i[e + 1].content : (e !== r && (i[r] = i[e]), r++);
  e !== r && (i.length = r);
}
var Hd = [
  ["text", SM],
  ["linkify", AM],
  ["newline", $M],
  ["escape", EM],
  ["backticks", MM],
  ["strikethrough", Px.tokenize],
  ["emphasis", jx.tokenize],
  ["link", NM],
  ["image", IM],
  ["autolink", qM],
  ["html_inline", WM],
  ["entity", VM]
];
var Ud = [
  ["balance_pairs", GM],
  ["strikethrough", Px.postProcess],
  ["emphasis", jx.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", XM]
];
function rc() {
  this.ruler = new Gr();
  for (let t15 = 0; t15 < Hd.length; t15++)
    this.ruler.push(Hd[t15][0], Hd[t15][1]);
  this.ruler2 = new Gr();
  for (let t15 = 0; t15 < Ud.length; t15++)
    this.ruler2.push(Ud[t15][0], Ud[t15][1]);
}
rc.prototype.skipToken = function(t15) {
  const e = t15.pos, r = this.ruler.getRules(""), n = r.length, i = t15.md.options.maxNesting, s = t15.cache;
  if (typeof s[e] < "u") {
    t15.pos = s[e];
    return;
  }
  let o = false;
  if (t15.level < i) {
    for (let a = 0; a < n; a++)
      if (t15.level++, o = r[a](t15, true), t15.level--, o) {
        if (e >= t15.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    t15.pos = t15.posMax;
  o || t15.pos++, s[e] = t15.pos;
};
rc.prototype.tokenize = function(t15) {
  const e = this.ruler.getRules(""), r = e.length, n = t15.posMax, i = t15.md.options.maxNesting;
  for (; t15.pos < n; ) {
    const s = t15.pos;
    let o = false;
    if (t15.level < i) {
      for (let a = 0; a < r; a++)
        if (o = e[a](t15, false), o) {
          if (s >= t15.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (o) {
      if (t15.pos >= n)
        break;
      continue;
    }
    t15.pending += t15.src[t15.pos++];
  }
  t15.pending && t15.pushPending();
};
rc.prototype.parse = function(t15, e, r, n) {
  const i = new this.State(t15, e, r, n);
  this.tokenize(i);
  const s = this.ruler2.getRules(""), o = s.length;
  for (let a = 0; a < o; a++)
    s[a](i);
};
rc.prototype.State = ec;
function YM(t15) {
  const e = {};
  t15 = t15 || {}, e.src_Any = Ex.source, e.src_Cc = Mx.source, e.src_Z = Lx.source, e.src_P = Q1.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
  const r = "[><｜]";
  return e.src_pseudo_letter = "(?:(?!" + r + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + r + "|" + e.src_ZPCc + ")(?!" + (t15["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + r + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (t15["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + r + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
}
function af(t15) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
    e && Object.keys(e).forEach(function(r) {
      t15[r] = e[r];
    });
  }), t15;
}
function a0(t15) {
  return Object.prototype.toString.call(t15);
}
function KM(t15) {
  return a0(t15) === "[object String]";
}
function ZM(t15) {
  return a0(t15) === "[object Object]";
}
function QM(t15) {
  return a0(t15) === "[object RegExp]";
}
function I2(t15) {
  return a0(t15) === "[object Function]";
}
function JM(t15) {
  return t15.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var Wx = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function tB(t15) {
  return Object.keys(t15 || {}).reduce(function(e, r) {
    return e || Wx.hasOwnProperty(r);
  }, false);
}
var eB = {
  "http:": {
    validate: function(t15, e, r) {
      const n = t15.slice(e);
      return r.re.http || (r.re.http = new RegExp(
        "^\\/\\/" + r.re.src_auth + r.re.src_host_port_strict + r.re.src_path,
        "i"
      )), r.re.http.test(n) ? n.match(r.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(t15, e, r) {
      const n = t15.slice(e);
      return r.re.no_http || (r.re.no_http = new RegExp(
        "^" + r.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + r.re.src_domain + ")\\.)+" + r.re.src_domain_root + ")" + r.re.src_port + r.re.src_host_terminator + r.re.src_path,
        "i"
      )), r.re.no_http.test(n) ? e >= 3 && t15[e - 3] === ":" || e >= 3 && t15[e - 3] === "/" ? 0 : n.match(r.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(t15, e, r) {
      const n = t15.slice(e);
      return r.re.mailto || (r.re.mailto = new RegExp(
        "^" + r.re.src_email_name + "@" + r.re.src_host_strict,
        "i"
      )), r.re.mailto.test(n) ? n.match(r.re.mailto)[0].length : 0;
    }
  }
};
var rB = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var nB = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function iB(t15) {
  t15.__index__ = -1, t15.__text_cache__ = "";
}
function sB(t15) {
  return function(e, r) {
    const n = e.slice(r);
    return t15.test(n) ? n.match(t15)[0].length : 0;
  };
}
function O2() {
  return function(t15, e) {
    e.normalize(t15);
  };
}
function su(t15) {
  const e = t15.re = YM(t15.__opts__), r = t15.__tlds__.slice();
  t15.onCompile(), t15.__tlds_replaced__ || r.push(rB), r.push(e.src_xn), e.src_tlds = r.join("|");
  function n(a) {
    return a.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(n(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(n(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(n(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(n(e.tpl_host_fuzzy_test), "i");
  const i = [];
  t15.__compiled__ = {};
  function s(a, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
  }
  Object.keys(t15.__schemas__).forEach(function(a) {
    const l = t15.__schemas__[a];
    if (l === null)
      return;
    const c = { validate: null, link: null };
    if (t15.__compiled__[a] = c, ZM(l)) {
      QM(l.validate) ? c.validate = sB(l.validate) : I2(l.validate) ? c.validate = l.validate : s(a, l), I2(l.normalize) ? c.normalize = l.normalize : l.normalize ? s(a, l) : c.normalize = O2();
      return;
    }
    if (KM(l)) {
      i.push(a);
      return;
    }
    s(a, l);
  }), i.forEach(function(a) {
    t15.__compiled__[t15.__schemas__[a]] && (t15.__compiled__[a].validate = t15.__compiled__[t15.__schemas__[a]].validate, t15.__compiled__[a].normalize = t15.__compiled__[t15.__schemas__[a]].normalize);
  }), t15.__compiled__[""] = { validate: null, normalize: O2() };
  const o = Object.keys(t15.__compiled__).filter(function(a) {
    return a.length > 0 && t15.__compiled__[a];
  }).map(JM).join("|");
  t15.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + o + ")", "i"), t15.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + o + ")", "ig"), t15.re.schema_at_start = RegExp("^" + t15.re.schema_search.source, "i"), t15.re.pretest = RegExp(
    "(" + t15.re.schema_test.source + ")|(" + t15.re.host_fuzzy_test.source + ")|@",
    "i"
  ), iB(t15);
}
function oB(t15, e) {
  const r = t15.__index__, n = t15.__last_index__, i = t15.__text_cache__.slice(r, n);
  this.schema = t15.__schema__.toLowerCase(), this.index = r + e, this.lastIndex = n + e, this.raw = i, this.text = i, this.url = i;
}
function lf(t15, e) {
  const r = new oB(t15, e);
  return t15.__compiled__[r.schema].normalize(r, t15), r;
}
function en(t15, e) {
  if (!(this instanceof en))
    return new en(t15, e);
  e || tB(t15) && (e = t15, t15 = {}), this.__opts__ = af({}, Wx, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = af({}, eB, t15), this.__compiled__ = {}, this.__tlds__ = nB, this.__tlds_replaced__ = false, this.re = {}, su(this);
}
en.prototype.add = function(t15, e) {
  return this.__schemas__[t15] = e, su(this), this;
};
en.prototype.set = function(t15) {
  return this.__opts__ = af(this.__opts__, t15), this;
};
en.prototype.test = function(t15) {
  if (this.__text_cache__ = t15, this.__index__ = -1, !t15.length)
    return false;
  let e, r, n, i, s, o, a, l, c;
  if (this.re.schema_test.test(t15)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (e = a.exec(t15)) !== null; )
      if (i = this.testSchemaAt(t15, e[2], a.lastIndex), i) {
        this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + i;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = t15.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = t15.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (s = r.index + r[1].length, (this.__index__ < 0 || s < this.__index__) && (this.__schema__ = "", this.__index__ = s, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (c = t15.indexOf("@"), c >= 0 && (n = t15.match(this.re.email_fuzzy)) !== null && (s = n.index + n[1].length, o = n.index + n[0].length, (this.__index__ < 0 || s < this.__index__ || s === this.__index__ && o > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = s, this.__last_index__ = o))), this.__index__ >= 0;
};
en.prototype.pretest = function(t15) {
  return this.re.pretest.test(t15);
};
en.prototype.testSchemaAt = function(t15, e, r) {
  return this.__compiled__[e.toLowerCase()] ? this.__compiled__[e.toLowerCase()].validate(t15, r, this) : 0;
};
en.prototype.match = function(t15) {
  const e = [];
  let r = 0;
  this.__index__ >= 0 && this.__text_cache__ === t15 && (e.push(lf(this, r)), r = this.__last_index__);
  let n = r ? t15.slice(r) : t15;
  for (; this.test(n); )
    e.push(lf(this, r)), n = n.slice(this.__last_index__), r += this.__last_index__;
  return e.length ? e : null;
};
en.prototype.matchAtStart = function(t15) {
  if (this.__text_cache__ = t15, this.__index__ = -1, !t15.length) return null;
  const e = this.re.schema_at_start.exec(t15);
  if (!e) return null;
  const r = this.testSchemaAt(t15, e[2], e[0].length);
  return r ? (this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + r, lf(this, 0)) : null;
};
en.prototype.tlds = function(t15, e) {
  return t15 = Array.isArray(t15) ? t15 : [t15], e ? (this.__tlds__ = this.__tlds__.concat(t15).sort().filter(function(r, n, i) {
    return r !== i[n - 1];
  }).reverse(), su(this), this) : (this.__tlds__ = t15.slice(), this.__tlds_replaced__ = true, su(this), this);
};
en.prototype.normalize = function(t15) {
  t15.schema || (t15.url = "http://" + t15.url), t15.schema === "mailto:" && !/^mailto:/i.test(t15.url) && (t15.url = "mailto:" + t15.url);
};
en.prototype.onCompile = function() {
};
var Oo = 2147483647;
var Kn = 36;
var nm = 1;
var Ll = 26;
var aB = 38;
var lB = 700;
var Hx = 72;
var Ux = 128;
var Vx = "-";
var cB = /^xn--/;
var hB = /[^\0-\x7F]/;
var uB = /[\x2E\u3002\uFF0E\uFF61]/g;
var dB = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var Vd = Kn - nm;
var Zn = Math.floor;
var Gd = String.fromCharCode;
function Ki(t15) {
  throw new RangeError(dB[t15]);
}
function pB(t15, e) {
  const r = [];
  let n = t15.length;
  for (; n--; )
    r[n] = e(t15[n]);
  return r;
}
function Gx(t15, e) {
  const r = t15.split("@");
  let n = "";
  r.length > 1 && (n = r[0] + "@", t15 = r[1]), t15 = t15.replace(uB, ".");
  const i = t15.split("."), s = pB(i, e).join(".");
  return n + s;
}
function Xx(t15) {
  const e = [];
  let r = 0;
  const n = t15.length;
  for (; r < n; ) {
    const i = t15.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      const s = t15.charCodeAt(r++);
      (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), r--);
    } else
      e.push(i);
  }
  return e;
}
var fB = (t15) => String.fromCodePoint(...t15);
var mB = function(t15) {
  return t15 >= 48 && t15 < 58 ? 26 + (t15 - 48) : t15 >= 65 && t15 < 91 ? t15 - 65 : t15 >= 97 && t15 < 123 ? t15 - 97 : Kn;
};
var z2 = function(t15, e) {
  return t15 + 22 + 75 * (t15 < 26) - ((e != 0) << 5);
};
var Yx = function(t15, e, r) {
  let n = 0;
  for (t15 = r ? Zn(t15 / lB) : t15 >> 1, t15 += Zn(t15 / e); t15 > Vd * Ll >> 1; n += Kn)
    t15 = Zn(t15 / Vd);
  return Zn(n + (Vd + 1) * t15 / (t15 + aB));
};
var Kx = function(t15) {
  const e = [], r = t15.length;
  let n = 0, i = Ux, s = Hx, o = t15.lastIndexOf(Vx);
  o < 0 && (o = 0);
  for (let a = 0; a < o; ++a)
    t15.charCodeAt(a) >= 128 && Ki("not-basic"), e.push(t15.charCodeAt(a));
  for (let a = o > 0 ? o + 1 : 0; a < r; ) {
    const l = n;
    for (let h10 = 1, p = Kn; ; p += Kn) {
      a >= r && Ki("invalid-input");
      const m = mB(t15.charCodeAt(a++));
      m >= Kn && Ki("invalid-input"), m > Zn((Oo - n) / h10) && Ki("overflow"), n += m * h10;
      const g = p <= s ? nm : p >= s + Ll ? Ll : p - s;
      if (m < g)
        break;
      const y = Kn - g;
      h10 > Zn(Oo / y) && Ki("overflow"), h10 *= y;
    }
    const c = e.length + 1;
    s = Yx(n - l, c, l == 0), Zn(n / c) > Oo - i && Ki("overflow"), i += Zn(n / c), n %= c, e.splice(n++, 0, i);
  }
  return String.fromCodePoint(...e);
};
var Zx = function(t15) {
  const e = [];
  t15 = Xx(t15);
  const r = t15.length;
  let n = Ux, i = 0, s = Hx;
  for (const l of t15)
    l < 128 && e.push(Gd(l));
  const o = e.length;
  let a = o;
  for (o && e.push(Vx); a < r; ) {
    let l = Oo;
    for (const h10 of t15)
      h10 >= n && h10 < l && (l = h10);
    const c = a + 1;
    l - n > Zn((Oo - i) / c) && Ki("overflow"), i += (l - n) * c, n = l;
    for (const h10 of t15)
      if (h10 < n && ++i > Oo && Ki("overflow"), h10 === n) {
        let p = i;
        for (let m = Kn; ; m += Kn) {
          const g = m <= s ? nm : m >= s + Ll ? Ll : m - s;
          if (p < g)
            break;
          const y = p - g, x = Kn - g;
          e.push(
            Gd(z2(g + y % x, 0))
          ), p = Zn(y / x);
        }
        e.push(Gd(z2(p, 0))), s = Yx(i, c, a === o), i = 0, ++a;
      }
    ++i, ++n;
  }
  return e.join("");
};
var gB = function(t15) {
  return Gx(t15, function(e) {
    return cB.test(e) ? Kx(e.slice(4).toLowerCase()) : e;
  });
};
var yB = function(t15) {
  return Gx(t15, function(e) {
    return hB.test(e) ? "xn--" + Zx(e) : e;
  });
};
var Qx = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: Xx,
    encode: fB
  },
  decode: Kx,
  encode: Zx,
  toASCII: yB,
  toUnicode: gB
};
var bB = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var xB = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
var wB = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
var kB = {
  default: bB,
  zero: xB,
  commonmark: wB
};
var vB = /^(vbscript|javascript|file|data):/;
var _B = /^data:image\/(gif|png|jpeg|webp);/;
function CB(t15) {
  const e = t15.trim().toLowerCase();
  return vB.test(e) ? _B.test(e) : true;
}
var Jx = ["http:", "https:", "mailto:"];
function SB(t15) {
  const e = Z1(t15, true);
  if (e.hostname && (!e.protocol || Jx.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Qx.toASCII(e.hostname);
    } catch {
    }
  return tc(K1(e));
}
function TB(t15) {
  const e = Z1(t15, true);
  if (e.hostname && (!e.protocol || Jx.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Qx.toUnicode(e.hostname);
    } catch {
    }
  return Uo(K1(e), Uo.defaultChars + "%");
}
function yn(t15, e) {
  if (!(this instanceof yn))
    return new yn(t15, e);
  e || J1(t15) || (e = t15 || {}, t15 = "default"), this.inline = new rc(), this.block = new o0(), this.core = new em(), this.renderer = new ua(), this.linkify = new en(), this.validateLink = CB, this.normalizeLink = SB, this.normalizeLinkText = TB, this.utils = $E, this.helpers = i0({}, LE), this.options = {}, this.configure(t15), e && this.set(e);
}
yn.prototype.set = function(t15) {
  return i0(this.options, t15), this;
};
yn.prototype.configure = function(t15) {
  const e = this;
  if (J1(t15)) {
    const r = t15;
    if (t15 = kB[r], !t15)
      throw new Error('Wrong `markdown-it` preset "' + r + '", check name');
  }
  if (!t15)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return t15.options && e.set(t15.options), t15.components && Object.keys(t15.components).forEach(function(r) {
    t15.components[r].rules && e[r].ruler.enableOnly(t15.components[r].rules), t15.components[r].rules2 && e[r].ruler2.enableOnly(t15.components[r].rules2);
  }), this;
};
yn.prototype.enable = function(t15, e) {
  let r = [];
  Array.isArray(t15) || (t15 = [t15]), ["core", "block", "inline"].forEach(function(i) {
    r = r.concat(this[i].ruler.enable(t15, true));
  }, this), r = r.concat(this.inline.ruler2.enable(t15, true));
  const n = t15.filter(function(i) {
    return r.indexOf(i) < 0;
  });
  if (n.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + n);
  return this;
};
yn.prototype.disable = function(t15, e) {
  let r = [];
  Array.isArray(t15) || (t15 = [t15]), ["core", "block", "inline"].forEach(function(i) {
    r = r.concat(this[i].ruler.disable(t15, true));
  }, this), r = r.concat(this.inline.ruler2.disable(t15, true));
  const n = t15.filter(function(i) {
    return r.indexOf(i) < 0;
  });
  if (n.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + n);
  return this;
};
yn.prototype.use = function(t15) {
  const e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t15.apply(t15, e), this;
};
yn.prototype.parse = function(t15, e) {
  if (typeof t15 != "string")
    throw new Error("Input data should be a String");
  const r = new this.core.State(t15, this, e);
  return this.core.process(r), r.tokens;
};
yn.prototype.render = function(t15, e) {
  return e = e || {}, this.renderer.render(this.parse(t15, e), this.options, e);
};
yn.prototype.parseInline = function(t15, e) {
  const r = new this.core.State(t15, this, e);
  return r.inlineMode = true, this.core.process(r), r.tokens;
};
yn.prototype.renderInline = function(t15, e) {
  return e = e || {}, this.renderer.render(this.parseInline(t15, e), this.options, e);
};
function AB(t15) {
  function e(n, i) {
    const s = n.pos, o = n.src.charCodeAt(s);
    if (i || o !== 43)
      return false;
    const a = n.scanDelims(n.pos, true);
    let l = a.length;
    const c = String.fromCharCode(o);
    if (l < 2)
      return false;
    if (l % 2) {
      const h10 = n.push("text", "", 0);
      h10.content = c, l--;
    }
    for (let h10 = 0; h10 < l; h10 += 2) {
      const p = n.push("text", "", 0);
      p.content = c + c, !(!a.can_open && !a.can_close) && n.delimiters.push({
        marker: o,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: h10 / 2,
        // 1 delimiter = 2 characters
        token: n.tokens.length - 1,
        end: -1,
        open: a.can_open,
        close: a.can_close
      });
    }
    return n.pos += a.length, true;
  }
  function r(n, i) {
    let s;
    const o = [], a = i.length;
    for (let l = 0; l < a; l++) {
      const c = i[l];
      if (c.marker !== 43 || c.end === -1)
        continue;
      const h10 = i[c.end];
      s = n.tokens[c.token], s.type = "ins_open", s.tag = "ins", s.nesting = 1, s.markup = "++", s.content = "", s = n.tokens[h10.token], s.type = "ins_close", s.tag = "ins", s.nesting = -1, s.markup = "++", s.content = "", n.tokens[h10.token - 1].type === "text" && n.tokens[h10.token - 1].content === "+" && o.push(h10.token - 1);
    }
    for (; o.length; ) {
      const l = o.pop();
      let c = l + 1;
      for (; c < n.tokens.length && n.tokens[c].type === "ins_close"; )
        c++;
      c--, l !== c && (s = n.tokens[c], n.tokens[c] = n.tokens[l], n.tokens[l] = s);
    }
  }
  t15.inline.ruler.before("emphasis", "ins", e), t15.inline.ruler2.before("emphasis", "ins", function(n) {
    const i = n.tokens_meta, s = (n.tokens_meta || []).length;
    r(n, n.delimiters);
    for (let o = 0; o < s; o++)
      i[o] && i[o].delimiters && r(n, i[o].delimiters);
  });
}
function $B(t15) {
  function e(n, i) {
    const s = n.pos, o = n.src.charCodeAt(s);
    if (i || o !== 61)
      return false;
    const a = n.scanDelims(n.pos, true);
    let l = a.length;
    const c = String.fromCharCode(o);
    if (l < 2)
      return false;
    if (l % 2) {
      const h10 = n.push("text", "", 0);
      h10.content = c, l--;
    }
    for (let h10 = 0; h10 < l; h10 += 2) {
      const p = n.push("text", "", 0);
      p.content = c + c, !(!a.can_open && !a.can_close) && n.delimiters.push({
        marker: o,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: h10 / 2,
        // 1 delimiter = 2 characters
        token: n.tokens.length - 1,
        end: -1,
        open: a.can_open,
        close: a.can_close
      });
    }
    return n.pos += a.length, true;
  }
  function r(n, i) {
    const s = [], o = i.length;
    for (let a = 0; a < o; a++) {
      const l = i[a];
      if (l.marker !== 61 || l.end === -1)
        continue;
      const c = i[l.end], h10 = n.tokens[l.token];
      h10.type = "mark_open", h10.tag = "mark", h10.nesting = 1, h10.markup = "==", h10.content = "";
      const p = n.tokens[c.token];
      p.type = "mark_close", p.tag = "mark", p.nesting = -1, p.markup = "==", p.content = "", n.tokens[c.token - 1].type === "text" && n.tokens[c.token - 1].content === "=" && s.push(c.token - 1);
    }
    for (; s.length; ) {
      const a = s.pop();
      let l = a + 1;
      for (; l < n.tokens.length && n.tokens[l].type === "mark_close"; )
        l++;
      if (l--, a !== l) {
        const c = n.tokens[l];
        n.tokens[l] = n.tokens[a], n.tokens[a] = c;
      }
    }
  }
  t15.inline.ruler.before("emphasis", "mark", e), t15.inline.ruler2.before("emphasis", "mark", function(n) {
    let i;
    const s = n.tokens_meta, o = (n.tokens_meta || []).length;
    for (r(n, n.delimiters), i = 0; i < o; i++)
      s[i] && s[i].delimiters && r(n, s[i].delimiters);
  });
}
var EB = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function MB(t15, e) {
  const r = t15.posMax, n = t15.pos;
  if (t15.src.charCodeAt(n) !== 126 || e || n + 2 >= r)
    return false;
  t15.pos = n + 1;
  let i = false;
  for (; t15.pos < r; ) {
    if (t15.src.charCodeAt(t15.pos) === 126) {
      i = true;
      break;
    }
    t15.md.inline.skipToken(t15);
  }
  if (!i || n + 1 === t15.pos)
    return t15.pos = n, false;
  const s = t15.src.slice(n + 1, t15.pos);
  if (s.match(/(^|[^\\])(\\\\)*\s/))
    return t15.pos = n, false;
  t15.posMax = t15.pos, t15.pos = n + 1;
  const o = t15.push("sub_open", "sub", 1);
  o.markup = "~";
  const a = t15.push("text", "", 0);
  a.content = s.replace(EB, "$1");
  const l = t15.push("sub_close", "sub", -1);
  return l.markup = "~", t15.pos = t15.posMax + 1, t15.posMax = r, true;
}
function BB(t15) {
  t15.inline.ruler.after("emphasis", "sub", MB);
}
var LB = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function DB(t15, e) {
  const r = t15.posMax, n = t15.pos;
  if (t15.src.charCodeAt(n) !== 94 || e || n + 2 >= r)
    return false;
  t15.pos = n + 1;
  let i = false;
  for (; t15.pos < r; ) {
    if (t15.src.charCodeAt(t15.pos) === 94) {
      i = true;
      break;
    }
    t15.md.inline.skipToken(t15);
  }
  if (!i || n + 1 === t15.pos)
    return t15.pos = n, false;
  const s = t15.src.slice(n + 1, t15.pos);
  if (s.match(/(^|[^\\])(\\\\)*\s/))
    return t15.pos = n, false;
  t15.posMax = t15.pos, t15.pos = n + 1;
  const o = t15.push("sup_open", "sup", 1);
  o.markup = "^";
  const a = t15.push("text", "", 0);
  a.content = s.replace(LB, "$1");
  const l = t15.push("sup_close", "sup", -1);
  return l.markup = "^", t15.pos = t15.posMax + 1, t15.posMax = r, true;
}
function FB(t15) {
  t15.inline.ruler.after("emphasis", "sup", DB);
}
var im = Symbol.for("yaml.alias");
var cf = Symbol.for("yaml.document");
var ls = Symbol.for("yaml.map");
var t3 = Symbol.for("yaml.pair");
var ei = Symbol.for("yaml.scalar");
var da = Symbol.for("yaml.seq");
var bn = Symbol.for("yaml.node.type");
var lo = (t15) => !!t15 && typeof t15 == "object" && t15[bn] === im;
var l0 = (t15) => !!t15 && typeof t15 == "object" && t15[bn] === cf;
var nc = (t15) => !!t15 && typeof t15 == "object" && t15[bn] === ls;
var He = (t15) => !!t15 && typeof t15 == "object" && t15[bn] === t3;
var Te = (t15) => !!t15 && typeof t15 == "object" && t15[bn] === ei;
var ic = (t15) => !!t15 && typeof t15 == "object" && t15[bn] === da;
function Pe(t15) {
  if (t15 && typeof t15 == "object")
    switch (t15[bn]) {
      case ls:
      case da:
        return true;
    }
  return false;
}
function We(t15) {
  if (t15 && typeof t15 == "object")
    switch (t15[bn]) {
      case im:
      case ls:
      case ei:
      case da:
        return true;
    }
  return false;
}
var e3 = (t15) => (Te(t15) || Pe(t15)) && !!t15.anchor;
var Ls = Symbol("break visit");
var NB = Symbol("skip children");
var gl = Symbol("remove node");
function pa(t15, e) {
  const r = IB(e);
  l0(t15) ? Lo(null, t15.contents, r, Object.freeze([t15])) === gl && (t15.contents = null) : Lo(null, t15, r, Object.freeze([]));
}
pa.BREAK = Ls;
pa.SKIP = NB;
pa.REMOVE = gl;
function Lo(t15, e, r, n) {
  const i = OB(t15, e, r, n);
  if (We(i) || He(i))
    return zB(t15, n, i), Lo(t15, i, r, n);
  if (typeof i != "symbol") {
    if (Pe(e)) {
      n = Object.freeze(n.concat(e));
      for (let s = 0; s < e.items.length; ++s) {
        const o = Lo(s, e.items[s], r, n);
        if (typeof o == "number")
          s = o - 1;
        else {
          if (o === Ls)
            return Ls;
          o === gl && (e.items.splice(s, 1), s -= 1);
        }
      }
    } else if (He(e)) {
      n = Object.freeze(n.concat(e));
      const s = Lo("key", e.key, r, n);
      if (s === Ls)
        return Ls;
      s === gl && (e.key = null);
      const o = Lo("value", e.value, r, n);
      if (o === Ls)
        return Ls;
      o === gl && (e.value = null);
    }
  }
  return i;
}
function IB(t15) {
  return typeof t15 == "object" && (t15.Collection || t15.Node || t15.Value) ? Object.assign({
    Alias: t15.Node,
    Map: t15.Node,
    Scalar: t15.Node,
    Seq: t15.Node
  }, t15.Value && {
    Map: t15.Value,
    Scalar: t15.Value,
    Seq: t15.Value
  }, t15.Collection && {
    Map: t15.Collection,
    Seq: t15.Collection
  }, t15) : t15;
}
function OB(t15, e, r, n) {
  var _a2, _b2, _c, _d, _e;
  if (typeof r == "function")
    return r(t15, e, n);
  if (nc(e))
    return (_a2 = r.Map) == null ? void 0 : _a2.call(r, t15, e, n);
  if (ic(e))
    return (_b2 = r.Seq) == null ? void 0 : _b2.call(r, t15, e, n);
  if (He(e))
    return (_c = r.Pair) == null ? void 0 : _c.call(r, t15, e, n);
  if (Te(e))
    return (_d = r.Scalar) == null ? void 0 : _d.call(r, t15, e, n);
  if (lo(e))
    return (_e = r.Alias) == null ? void 0 : _e.call(r, t15, e, n);
}
function zB(t15, e, r) {
  const n = e[e.length - 1];
  if (Pe(n))
    n.items[t15] = r;
  else if (He(n))
    t15 === "key" ? n.key = r : n.value = r;
  else if (l0(n))
    n.contents = r;
  else {
    const i = lo(n) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${i} parent`);
  }
}
var qB = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var RB = (t15) => t15.replace(/[!,[\]{}]/g, (e) => qB[e]);
var Tr = class _Tr {
  constructor(e, r) {
    this.docStart = null, this.docEnd = false, this.yaml = Object.assign({}, _Tr.defaultYaml, e), this.tags = Object.assign({}, _Tr.defaultTags, r);
  }
  clone() {
    const e = new _Tr(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new _Tr(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false, this.yaml = {
          explicit: _Tr.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, _Tr.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, r) {
    this.atNextDocument && (this.yaml = { explicit: _Tr.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, _Tr.defaultTags), this.atNextDocument = false);
    const n = e.trim().split(/[ \t]+/), i = n.shift();
    switch (i) {
      case "%TAG": {
        if (n.length !== 2 && (r(0, "%TAG directive should contain exactly two parts"), n.length < 2))
          return false;
        const [s, o] = n;
        return this.tags[s] = o, true;
      }
      case "%YAML": {
        if (this.yaml.explicit = true, n.length !== 1)
          return r(0, "%YAML directive should contain exactly one part"), false;
        const [s] = n;
        if (s === "1.1" || s === "1.2")
          return this.yaml.version = s, true;
        {
          const o = /^\d+\.\d+$/.test(s);
          return r(6, `Unsupported YAML version ${s}`, o), false;
        }
      }
      default:
        return r(0, `Unknown directive ${i}`, true), false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, r) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return r(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const o = e.slice(2, -1);
      return o === "!" || o === "!!" ? (r(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && r("Verbatim tags must end with a >"), o);
    }
    const [, n, i] = e.match(/^(.*!)([^!]*)$/s);
    i || r(`The ${e} tag has no suffix`);
    const s = this.tags[n];
    if (s)
      try {
        return s + decodeURIComponent(i);
      } catch (o) {
        return r(String(o)), null;
      }
    return n === "!" ? e : (r(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [r, n] of Object.entries(this.tags))
      if (e.startsWith(n))
        return r + RB(e.substring(n.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const r = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n = Object.entries(this.tags);
    let i;
    if (e && n.length > 0 && We(e.contents)) {
      const s = {};
      pa(e.contents, (o, a) => {
        We(a) && a.tag && (s[a.tag] = true);
      }), i = Object.keys(s);
    } else
      i = [];
    for (const [s, o] of n)
      s === "!!" && o === "tag:yaml.org,2002:" || (!e || i.some((a) => a.startsWith(o))) && r.push(`%TAG ${s} ${o}`);
    return r.join(`
`);
  }
};
Tr.defaultYaml = { explicit: false, version: "1.2" };
Tr.defaultTags = { "!!": "tag:yaml.org,2002:" };
function r3(t15) {
  if (/[\x00-\x19\s,[\]{}]/.test(t15)) {
    const e = `Anchor must not contain whitespace or control characters: ${JSON.stringify(t15)}`;
    throw new Error(e);
  }
  return true;
}
function n3(t15) {
  const e = /* @__PURE__ */ new Set();
  return pa(t15, {
    Value(r, n) {
      n.anchor && e.add(n.anchor);
    }
  }), e;
}
function i3(t15, e) {
  for (let r = 1; ; ++r) {
    const n = `${t15}${r}`;
    if (!e.has(n))
      return n;
  }
}
function PB(t15, e) {
  const r = [], n = /* @__PURE__ */ new Map();
  let i = null;
  return {
    onAnchor: (s) => {
      r.push(s), i ?? (i = n3(t15));
      const o = i3(e, i);
      return i.add(o), o;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const s of r) {
        const o = n.get(s);
        if (typeof o == "object" && o.anchor && (Te(o.node) || Pe(o.node)))
          o.node.anchor = o.anchor;
        else {
          const a = new Error("Failed to resolve repeated object (this should not happen)");
          throw a.source = s, a;
        }
      }
    },
    sourceObjects: n
  };
}
function Do(t15, e, r, n) {
  if (n && typeof n == "object")
    if (Array.isArray(n))
      for (let i = 0, s = n.length; i < s; ++i) {
        const o = n[i], a = Do(t15, n, String(i), o);
        a === void 0 ? delete n[i] : a !== o && (n[i] = a);
      }
    else if (n instanceof Map)
      for (const i of Array.from(n.keys())) {
        const s = n.get(i), o = Do(t15, n, i, s);
        o === void 0 ? n.delete(i) : o !== s && n.set(i, o);
      }
    else if (n instanceof Set)
      for (const i of Array.from(n)) {
        const s = Do(t15, n, i, i);
        s === void 0 ? n.delete(i) : s !== i && (n.delete(i), n.add(s));
      }
    else
      for (const [i, s] of Object.entries(n)) {
        const o = Do(t15, n, i, s);
        o === void 0 ? delete n[i] : o !== s && (n[i] = o);
      }
  return t15.call(e, r, n);
}
function gn(t15, e, r) {
  if (Array.isArray(t15))
    return t15.map((n, i) => gn(n, String(i), r));
  if (t15 && typeof t15.toJSON == "function") {
    if (!r || !e3(t15))
      return t15.toJSON(e, r);
    const n = { aliasCount: 0, count: 1, res: void 0 };
    r.anchors.set(t15, n), r.onCreate = (s) => {
      n.res = s, delete r.onCreate;
    };
    const i = t15.toJSON(e, r);
    return r.onCreate && r.onCreate(i), i;
  }
  return typeof t15 == "bigint" && !(r == null ? void 0 : r.keep) ? Number(t15) : t15;
}
var sm = class {
  constructor(e) {
    Object.defineProperty(this, bn, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: r, maxAliasCount: n, onAnchor: i, reviver: s } = {}) {
    if (!l0(e))
      throw new TypeError("A document argument is required");
    const o = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: true,
      mapAsMap: r === true,
      mapKeyWarned: false,
      maxAliasCount: typeof n == "number" ? n : 100
    }, a = gn(this, "", o);
    if (typeof i == "function")
      for (const { count: l, res: c } of o.anchors.values())
        i(c, l);
    return typeof s == "function" ? Do(s, { "": a }, "", a) : a;
  }
};
var om = class extends sm {
  constructor(e) {
    super(im), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e, r) {
    let n;
    (r == null ? void 0 : r.aliasResolveCache) ? n = r.aliasResolveCache : (n = [], pa(e, {
      Node: (s, o) => {
        (lo(o) || e3(o)) && n.push(o);
      }
    }), r && (r.aliasResolveCache = n));
    let i;
    for (const s of n) {
      if (s === this)
        break;
      s.anchor === this.source && (i = s);
    }
    return i;
  }
  toJSON(e, r) {
    if (!r)
      return { source: this.source };
    const { anchors: n, doc: i, maxAliasCount: s } = r, o = this.resolve(i, r);
    if (!o) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let a = n.get(o);
    if (a || (gn(o, null, r), a = n.get(o)), !a || a.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (s >= 0 && (a.count += 1, a.aliasCount === 0 && (a.aliasCount = wh(i, o, n)), a.count * a.aliasCount > s)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return a.res;
  }
  toString(e, r, n) {
    const i = `*${this.source}`;
    if (e) {
      if (r3(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const s = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(s);
      }
      if (e.implicitKey)
        return `${i} `;
    }
    return i;
  }
};
function wh(t15, e, r) {
  if (lo(e)) {
    const n = e.resolve(t15), i = r && n && r.get(n);
    return i ? i.count * i.aliasCount : 0;
  } else if (Pe(e)) {
    let n = 0;
    for (const i of e.items) {
      const s = wh(t15, i, r);
      s > n && (n = s);
    }
    return n;
  } else if (He(e)) {
    const n = wh(t15, e.key, r), i = wh(t15, e.value, r);
    return Math.max(n, i);
  }
  return 1;
}
var s3 = (t15) => !t15 || typeof t15 != "function" && typeof t15 != "object";
var Zt = class extends sm {
  constructor(e) {
    super(ei), this.value = e;
  }
  toJSON(e, r) {
    return (r == null ? void 0 : r.keep) ? this.value : gn(this.value, e, r);
  }
  toString() {
    return String(this.value);
  }
};
Zt.BLOCK_FOLDED = "BLOCK_FOLDED";
Zt.BLOCK_LITERAL = "BLOCK_LITERAL";
Zt.PLAIN = "PLAIN";
Zt.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Zt.QUOTE_SINGLE = "QUOTE_SINGLE";
var jB = "tag:yaml.org,2002:";
function WB(t15, e, r) {
  if (e) {
    const n = r.filter((s) => s.tag === e), i = n.find((s) => !s.format) ?? n[0];
    if (!i)
      throw new Error(`Tag ${e} not found`);
    return i;
  }
  return r.find((n) => {
    var _a2;
    return ((_a2 = n.identify) == null ? void 0 : _a2.call(n, t15)) && !n.format;
  });
}
function Dl(t15, e, r) {
  var _a2, _b2, _c;
  if (l0(t15) && (t15 = t15.contents), We(t15))
    return t15;
  if (He(t15)) {
    const p = (_b2 = (_a2 = r.schema[ls]).createNode) == null ? void 0 : _b2.call(_a2, r.schema, null, r);
    return p.items.push(t15), p;
  }
  (t15 instanceof String || t15 instanceof Number || t15 instanceof Boolean || typeof BigInt < "u" && t15 instanceof BigInt) && (t15 = t15.valueOf());
  const { aliasDuplicateObjects: n, onAnchor: i, onTagObj: s, schema: o, sourceObjects: a } = r;
  let l;
  if (n && t15 && typeof t15 == "object") {
    if (l = a.get(t15), l)
      return l.anchor ?? (l.anchor = i(t15)), new om(l.anchor);
    l = { anchor: null, node: null }, a.set(t15, l);
  }
  (e == null ? void 0 : e.startsWith("!!")) && (e = jB + e.slice(2));
  let c = WB(t15, e, o.tags);
  if (!c) {
    if (t15 && typeof t15.toJSON == "function" && (t15 = t15.toJSON()), !t15 || typeof t15 != "object") {
      const p = new Zt(t15);
      return l && (l.node = p), p;
    }
    c = t15 instanceof Map ? o[ls] : Symbol.iterator in Object(t15) ? o[da] : o[ls];
  }
  s && (s(c), delete r.onTagObj);
  const h10 = (c == null ? void 0 : c.createNode) ? c.createNode(r.schema, t15, r) : typeof ((_c = c == null ? void 0 : c.nodeClass) == null ? void 0 : _c.from) == "function" ? c.nodeClass.from(r.schema, t15, r) : new Zt(t15);
  return e ? h10.tag = e : c.default || (h10.tag = c.tag), l && (l.node = h10), h10;
}
function ou(t15, e, r) {
  let n = r;
  for (let i = e.length - 1; i >= 0; --i) {
    const s = e[i];
    if (typeof s == "number" && Number.isInteger(s) && s >= 0) {
      const o = [];
      o[s] = n, n = o;
    } else
      n = /* @__PURE__ */ new Map([[s, n]]);
  }
  return Dl(n, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: t15,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var el = (t15) => t15 == null || typeof t15 == "object" && !!t15[Symbol.iterator]().next().done;
var o3 = class extends sm {
  constructor(e, r) {
    super(e), Object.defineProperty(this, "schema", {
      value: r,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const r = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (r.schema = e), r.items = r.items.map((n) => We(n) || He(n) ? n.clone(e) : n), this.range && (r.range = this.range.slice()), r;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, r) {
    if (el(e))
      this.add(r);
    else {
      const [n, ...i] = e, s = this.get(n, true);
      if (Pe(s))
        s.addIn(i, r);
      else if (s === void 0 && this.schema)
        this.set(n, ou(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.delete(r);
    const i = this.get(r, true);
    if (Pe(i))
      return i.deleteIn(n);
    throw new Error(`Expected YAML collection at ${r}. Remaining path: ${n}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    const [n, ...i] = e, s = this.get(n, true);
    return i.length === 0 ? !r && Te(s) ? s.value : s : Pe(s) ? s.getIn(i, r) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((r) => {
      if (!He(r))
        return false;
      const n = r.value;
      return n == null || e && Te(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.has(r);
    const i = this.get(r, true);
    return Pe(i) ? i.hasIn(n) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    const [n, ...i] = e;
    if (i.length === 0)
      this.set(n, r);
    else {
      const s = this.get(n, true);
      if (Pe(s))
        s.setIn(i, r);
      else if (s === void 0 && this.schema)
        this.set(n, ou(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
};
var HB = (t15) => t15.replace(/^(?!$)(?: $)?/gm, "#");
function Ti(t15, e) {
  return /^\n+$/.test(t15) ? t15.substring(1) : e ? t15.replace(/^(?! *$)/gm, e) : t15;
}
var zs = (t15, e, r) => t15.endsWith(`
`) ? Ti(r, e) : r.includes(`
`) ? `
` + Ti(r, e) : (t15.endsWith(" ") ? "" : " ") + r;
var a3 = "flow";
var hf = "block";
var kh = "quoted";
function c0(t15, e, r = "flow", { indentAtStart: n, lineWidth: i = 80, minContentWidth: s = 20, onFold: o, onOverflow: a } = {}) {
  if (!i || i < 0)
    return t15;
  i < s && (s = 0);
  const l = Math.max(1 + s, 1 + i - e.length);
  if (t15.length <= l)
    return t15;
  const c = [], h10 = {};
  let p = i - e.length;
  typeof n == "number" && (n > i - Math.max(2, s) ? c.push(0) : p = i - n);
  let m, g, y = false, x = -1, k = -1, C = -1;
  r === hf && (x = q2(t15, x, e.length), x !== -1 && (p = x + l));
  for (let $; $ = t15[x += 1]; ) {
    if (r === kh && $ === "\\") {
      switch (k = x, t15[x + 1]) {
        case "x":
          x += 3;
          break;
        case "u":
          x += 5;
          break;
        case "U":
          x += 9;
          break;
        default:
          x += 1;
      }
      C = x;
    }
    if ($ === `
`)
      r === hf && (x = q2(t15, x, e.length)), p = x + e.length + l, m = void 0;
    else {
      if ($ === " " && g && g !== " " && g !== `
` && g !== "	") {
        const L = t15[x + 1];
        L && L !== " " && L !== `
` && L !== "	" && (m = x);
      }
      if (x >= p)
        if (m)
          c.push(m), p = m + l, m = void 0;
        else if (r === kh) {
          for (; g === " " || g === "	"; )
            g = $, $ = t15[x += 1], y = true;
          const L = x > C + 1 ? x - 2 : k - 1;
          if (h10[L])
            return t15;
          c.push(L), h10[L] = true, p = L + l, m = void 0;
        } else
          y = true;
    }
    g = $;
  }
  if (y && a && a(), c.length === 0)
    return t15;
  o && o();
  let _ = t15.slice(0, c[0]);
  for (let $ = 0; $ < c.length; ++$) {
    const L = c[$], B = c[$ + 1] || t15.length;
    L === 0 ? _ = `
${e}${t15.slice(0, B)}` : (r === kh && h10[L] && (_ += `${t15[L]}\\`), _ += `
${e}${t15.slice(L + 1, B)}`);
  }
  return _;
}
function q2(t15, e, r) {
  let n = e, i = e + 1, s = t15[i];
  for (; s === " " || s === "	"; )
    if (e < i + r)
      s = t15[++e];
    else {
      do
        s = t15[++e];
      while (s && s !== `
`);
      n = e, i = e + 1, s = t15[i];
    }
  return n;
}
var h0 = (t15, e) => ({
  indentAtStart: e ? t15.indent.length : t15.indentAtStart,
  lineWidth: t15.options.lineWidth,
  minContentWidth: t15.options.minContentWidth
});
var u0 = (t15) => /^(%|---|\.\.\.)/m.test(t15);
function UB(t15, e, r) {
  if (!e || e < 0)
    return false;
  const n = e - r, i = t15.length;
  if (i <= n)
    return false;
  for (let s = 0, o = 0; s < i; ++s)
    if (t15[s] === `
`) {
      if (s - o > n)
        return true;
      if (o = s + 1, i - o <= n)
        return false;
    }
  return true;
}
function yl(t15, e) {
  const r = JSON.stringify(t15);
  if (e.options.doubleQuotedAsJSON)
    return r;
  const { implicitKey: n } = e, i = e.options.doubleQuotedMinMultiLineLength, s = e.indent || (u0(t15) ? "  " : "");
  let o = "", a = 0;
  for (let l = 0, c = r[l]; c; c = r[++l])
    if (c === " " && r[l + 1] === "\\" && r[l + 2] === "n" && (o += r.slice(a, l) + "\\ ", l += 1, a = l, c = "\\"), c === "\\")
      switch (r[l + 1]) {
        case "u":
          {
            o += r.slice(a, l);
            const h10 = r.substr(l + 2, 4);
            switch (h10) {
              case "0000":
                o += "\\0";
                break;
              case "0007":
                o += "\\a";
                break;
              case "000b":
                o += "\\v";
                break;
              case "001b":
                o += "\\e";
                break;
              case "0085":
                o += "\\N";
                break;
              case "00a0":
                o += "\\_";
                break;
              case "2028":
                o += "\\L";
                break;
              case "2029":
                o += "\\P";
                break;
              default:
                h10.substr(0, 2) === "00" ? o += "\\x" + h10.substr(2) : o += r.substr(l, 6);
            }
            l += 5, a = l + 1;
          }
          break;
        case "n":
          if (n || r[l + 2] === '"' || r.length < i)
            l += 1;
          else {
            for (o += r.slice(a, l) + `

`; r[l + 2] === "\\" && r[l + 3] === "n" && r[l + 4] !== '"'; )
              o += `
`, l += 2;
            o += s, r[l + 2] === " " && (o += "\\"), l += 1, a = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return o = a ? o + r.slice(a) : r, n ? o : c0(o, s, kh, h0(e, false));
}
function uf(t15, e) {
  if (e.options.singleQuote === false || e.implicitKey && t15.includes(`
`) || /[ \t]\n|\n[ \t]/.test(t15))
    return yl(t15, e);
  const r = e.indent || (u0(t15) ? "  " : ""), n = "'" + t15.replace(/'/g, "''").replace(/\n+/g, `$&
${r}`) + "'";
  return e.implicitKey ? n : c0(n, r, a3, h0(e, false));
}
function Fo(t15, e) {
  const { singleQuote: r } = e.options;
  let n;
  if (r === false)
    n = yl;
  else {
    const i = t15.includes('"'), s = t15.includes("'");
    i && !s ? n = uf : s && !i ? n = yl : n = r ? uf : yl;
  }
  return n(t15, e);
}
var df;
try {
  df = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  df = /\n+(?!\n|$)/g;
}
function vh({ comment: t15, type: e, value: r }, n, i, s) {
  const { blockQuote: o, commentString: a, lineWidth: l } = n.options;
  if (!o || /\n[\t ]+$/.test(r) || /^\s*$/.test(r))
    return Fo(r, n);
  const c = n.indent || (n.forceBlockIndent || u0(r) ? "  " : ""), h10 = o === "literal" ? true : o === "folded" || e === Zt.BLOCK_FOLDED ? false : e === Zt.BLOCK_LITERAL ? true : !UB(r, l, c.length);
  if (!r)
    return h10 ? `|
` : `>
`;
  let p, m;
  for (m = r.length; m > 0; --m) {
    const L = r[m - 1];
    if (L !== `
` && L !== "	" && L !== " ")
      break;
  }
  let g = r.substring(m);
  const y = g.indexOf(`
`);
  y === -1 ? p = "-" : r === g || y !== g.length - 1 ? (p = "+", s && s()) : p = "", g && (r = r.slice(0, -g.length), g[g.length - 1] === `
` && (g = g.slice(0, -1)), g = g.replace(df, `$&${c}`));
  let x = false, k, C = -1;
  for (k = 0; k < r.length; ++k) {
    const L = r[k];
    if (L === " ")
      x = true;
    else if (L === `
`)
      C = k;
    else
      break;
  }
  let _ = r.substring(0, C < k ? C + 1 : k);
  _ && (r = r.substring(_.length), _ = _.replace(/\n+/g, `$&${c}`));
  let $ = (x ? c ? "2" : "1" : "") + p;
  if (t15 && ($ += " " + a(t15.replace(/ ?[\r\n]+/g, " ")), i && i()), !h10) {
    const L = r.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`);
    let B = false;
    const q = h0(n, true);
    o !== "folded" && e !== Zt.BLOCK_FOLDED && (q.onOverflow = () => {
      B = true;
    });
    const H = c0(`${_}${L}${g}`, c, hf, q);
    if (!B)
      return `>${$}
${c}${H}`;
  }
  return r = r.replace(/\n+/g, `$&${c}`), `|${$}
${c}${_}${r}${g}`;
}
function VB(t15, e, r, n) {
  const { type: i, value: s } = t15, { actualString: o, implicitKey: a, indent: l, indentStep: c, inFlow: h10 } = e;
  if (a && s.includes(`
`) || h10 && /[[\]{},]/.test(s))
    return Fo(s, e);
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(s))
    return a || h10 || !s.includes(`
`) ? Fo(s, e) : vh(t15, e, r, n);
  if (!a && !h10 && i !== Zt.PLAIN && s.includes(`
`))
    return vh(t15, e, r, n);
  if (u0(s)) {
    if (l === "")
      return e.forceBlockIndent = true, vh(t15, e, r, n);
    if (a && l === c)
      return Fo(s, e);
  }
  const p = s.replace(/\n+/g, `$&
${l}`);
  if (o) {
    const m = (x) => {
      var _a2;
      return x.default && x.tag !== "tag:yaml.org,2002:str" && ((_a2 = x.test) == null ? void 0 : _a2.test(p));
    }, { compat: g, tags: y } = e.doc.schema;
    if (y.some(m) || (g == null ? void 0 : g.some(m)))
      return Fo(s, e);
  }
  return a ? p : c0(p, l, a3, h0(e, false));
}
function am(t15, e, r, n) {
  const { implicitKey: i, inFlow: s } = e, o = typeof t15.value == "string" ? t15 : Object.assign({}, t15, { value: String(t15.value) });
  let { type: a } = t15;
  a !== Zt.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(o.value) && (a = Zt.QUOTE_DOUBLE);
  const l = (h10) => {
    switch (h10) {
      case Zt.BLOCK_FOLDED:
      case Zt.BLOCK_LITERAL:
        return i || s ? Fo(o.value, e) : vh(o, e, r, n);
      case Zt.QUOTE_DOUBLE:
        return yl(o.value, e);
      case Zt.QUOTE_SINGLE:
        return uf(o.value, e);
      case Zt.PLAIN:
        return VB(o, e, r, n);
      default:
        return null;
    }
  };
  let c = l(a);
  if (c === null) {
    const { defaultKeyType: h10, defaultStringType: p } = e.options, m = i && h10 || p;
    if (c = l(m), c === null)
      throw new Error(`Unsupported default string type ${m}`);
  }
  return c;
}
function l3(t15, e) {
  const r = Object.assign({
    blockQuote: true,
    commentString: HB,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, t15.schema.toStringOptions, e);
  let n;
  switch (r.collectionStyle) {
    case "block":
      n = false;
      break;
    case "flow":
      n = true;
      break;
    default:
      n = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: t15,
    flowCollectionPadding: r.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof r.indent == "number" ? " ".repeat(r.indent) : "  ",
    inFlow: n,
    options: r
  };
}
function GB(t15, e) {
  var _a2;
  if (e.tag) {
    const i = t15.filter((s) => s.tag === e.tag);
    if (i.length > 0)
      return i.find((s) => s.format === e.format) ?? i[0];
  }
  let r, n;
  if (Te(e)) {
    n = e.value;
    let i = t15.filter((s) => {
      var _a3;
      return (_a3 = s.identify) == null ? void 0 : _a3.call(s, n);
    });
    if (i.length > 1) {
      const s = i.filter((o) => o.test);
      s.length > 0 && (i = s);
    }
    r = i.find((s) => s.format === e.format) ?? i.find((s) => !s.format);
  } else
    n = e, r = t15.find((i) => i.nodeClass && n instanceof i.nodeClass);
  if (!r) {
    const i = ((_a2 = n == null ? void 0 : n.constructor) == null ? void 0 : _a2.name) ?? (n === null ? "null" : typeof n);
    throw new Error(`Tag not resolved for ${i} value`);
  }
  return r;
}
function XB(t15, e, { anchors: r, doc: n }) {
  if (!n.directives)
    return "";
  const i = [], s = (Te(t15) || Pe(t15)) && t15.anchor;
  s && r3(s) && (r.add(s), i.push(`&${s}`));
  const o = t15.tag ?? (e.default ? null : e.tag);
  return o && i.push(n.directives.tagString(o)), i.join(" ");
}
function Go(t15, e, r, n) {
  var _a2;
  if (He(t15))
    return t15.toString(e, r, n);
  if (lo(t15)) {
    if (e.doc.directives)
      return t15.toString(e);
    if ((_a2 = e.resolvedAliases) == null ? void 0 : _a2.has(t15))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(t15) : e.resolvedAliases = /* @__PURE__ */ new Set([t15]), t15 = t15.resolve(e.doc);
  }
  let i;
  const s = We(t15) ? t15 : e.doc.createNode(t15, { onTagObj: (l) => i = l });
  i ?? (i = GB(e.doc.schema.tags, s));
  const o = XB(s, i, e);
  o.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + o.length + 1);
  const a = typeof i.stringify == "function" ? i.stringify(s, e, r, n) : Te(s) ? am(s, e, r, n) : s.toString(e, r, n);
  return o ? Te(s) || a[0] === "{" || a[0] === "[" ? `${o} ${a}` : `${o}
${e.indent}${a}` : a;
}
function YB({ key: t15, value: e }, r, n, i) {
  const { allNullValues: s, doc: o, indent: a, indentStep: l, options: { commentString: c, indentSeq: h10, simpleKeys: p } } = r;
  let m = We(t15) && t15.comment || null;
  if (p) {
    if (m)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (Pe(t15) || !We(t15) && typeof t15 == "object") {
      const H = "With simple keys, collection cannot be used as a key value";
      throw new Error(H);
    }
  }
  let g = !p && (!t15 || m && e == null && !r.inFlow || Pe(t15) || (Te(t15) ? t15.type === Zt.BLOCK_FOLDED || t15.type === Zt.BLOCK_LITERAL : typeof t15 == "object"));
  r = Object.assign({}, r, {
    allNullValues: false,
    implicitKey: !g && (p || !s),
    indent: a + l
  });
  let y = false, x = false, k = Go(t15, r, () => y = true, () => x = true);
  if (!g && !r.inFlow && k.length > 1024) {
    if (p)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    g = true;
  }
  if (r.inFlow) {
    if (s || e == null)
      return y && n && n(), k === "" ? "?" : g ? `? ${k}` : k;
  } else if (s && !p || e == null && g)
    return k = `? ${k}`, m && !y ? k += zs(k, r.indent, c(m)) : x && i && i(), k;
  y && (m = null), g ? (m && (k += zs(k, r.indent, c(m))), k = `? ${k}
${a}:`) : (k = `${k}:`, m && (k += zs(k, r.indent, c(m))));
  let C, _, $;
  We(e) ? (C = !!e.spaceBefore, _ = e.commentBefore, $ = e.comment) : (C = false, _ = null, $ = null, e && typeof e == "object" && (e = o.createNode(e))), r.implicitKey = false, !g && !m && Te(e) && (r.indentAtStart = k.length + 1), x = false, !h10 && l.length >= 2 && !r.inFlow && !g && ic(e) && !e.flow && !e.tag && !e.anchor && (r.indent = r.indent.substring(2));
  let L = false;
  const B = Go(e, r, () => L = true, () => x = true);
  let q = " ";
  if (m || C || _) {
    if (q = C ? `
` : "", _) {
      const H = c(_);
      q += `
${Ti(H, r.indent)}`;
    }
    B === "" && !r.inFlow ? q === `
` && (q = `

`) : q += `
${r.indent}`;
  } else if (!g && Pe(e)) {
    const H = B[0], G = B.indexOf(`
`), F = G !== -1, W = r.inFlow ?? e.flow ?? e.items.length === 0;
    if (F || !W) {
      let R = false;
      if (F && (H === "&" || H === "!")) {
        let J = B.indexOf(" ");
        H === "&" && J !== -1 && J < G && B[J + 1] === "!" && (J = B.indexOf(" ", J + 1)), (J === -1 || G < J) && (R = true);
      }
      R || (q = `
${r.indent}`);
    }
  } else (B === "" || B[0] === `
`) && (q = "");
  return k += q + B, r.inFlow ? L && n && n() : $ && !L ? k += zs(k, r.indent, c($)) : x && i && i(), k;
}
function c3(t15, e) {
  (t15 === "debug" || t15 === "warn") && console.warn(e);
}
var Yc = "<<";
var Bi = {
  identify: (t15) => t15 === Yc || typeof t15 == "symbol" && t15.description === Yc,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Zt(Symbol(Yc)), {
    addToJSMap: h3
  }),
  stringify: () => Yc
};
var KB = (t15, e) => (Bi.identify(e) || Te(e) && (!e.type || e.type === Zt.PLAIN) && Bi.identify(e.value)) && (t15 == null ? void 0 : t15.doc.schema.tags.some((r) => r.tag === Bi.tag && r.default));
function h3(t15, e, r) {
  if (r = t15 && lo(r) ? r.resolve(t15.doc) : r, ic(r))
    for (const n of r.items)
      Xd(t15, e, n);
  else if (Array.isArray(r))
    for (const n of r)
      Xd(t15, e, n);
  else
    Xd(t15, e, r);
}
function Xd(t15, e, r) {
  const n = t15 && lo(r) ? r.resolve(t15.doc) : r;
  if (!nc(n))
    throw new Error("Merge sources must be maps or map aliases");
  const i = n.toJSON(null, t15, Map);
  for (const [s, o] of i)
    e instanceof Map ? e.has(s) || e.set(s, o) : e instanceof Set ? e.add(s) : Object.prototype.hasOwnProperty.call(e, s) || Object.defineProperty(e, s, {
      value: o,
      writable: true,
      enumerable: true,
      configurable: true
    });
  return e;
}
function u3(t15, e, { key: r, value: n }) {
  if (We(r) && r.addToJSMap)
    r.addToJSMap(t15, e, n);
  else if (KB(t15, r))
    h3(t15, e, n);
  else {
    const i = gn(r, "", t15);
    if (e instanceof Map)
      e.set(i, gn(n, i, t15));
    else if (e instanceof Set)
      e.add(i);
    else {
      const s = ZB(r, i, t15), o = gn(n, s, t15);
      s in e ? Object.defineProperty(e, s, {
        value: o,
        writable: true,
        enumerable: true,
        configurable: true
      }) : e[s] = o;
    }
  }
  return e;
}
function ZB(t15, e, r) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (We(t15) && (r == null ? void 0 : r.doc)) {
    const n = l3(r.doc, {});
    n.anchors = /* @__PURE__ */ new Set();
    for (const s of r.anchors.keys())
      n.anchors.add(s.anchor);
    n.inFlow = true, n.inStringifyKey = true;
    const i = t15.toString(n);
    if (!r.mapKeyWarned) {
      let s = JSON.stringify(i);
      s.length > 40 && (s = s.substring(0, 36) + '..."'), c3(r.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${s}. Set mapAsMap: true to use object keys.`), r.mapKeyWarned = true;
    }
    return i;
  }
  return JSON.stringify(e);
}
function lm(t15, e, r) {
  const n = Dl(t15, void 0, r), i = Dl(e, void 0, r);
  return new tn(n, i);
}
var tn = class d3 {
  constructor(e, r = null) {
    Object.defineProperty(this, bn, { value: t3 }), this.key = e, this.value = r;
  }
  clone(e) {
    let { key: r, value: n } = this;
    return We(r) && (r = r.clone(e)), We(n) && (n = n.clone(e)), new d3(r, n);
  }
  toJSON(e, r) {
    const n = (r == null ? void 0 : r.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return u3(r, n, this);
  }
  toString(e, r, n) {
    return (e == null ? void 0 : e.doc) ? YB(this, e, r, n) : JSON.stringify(this);
  }
};
function p3(t15, e, r) {
  return (e.inFlow ?? t15.flow ? JB : QB)(t15, e, r);
}
function QB({ comment: t15, items: e }, r, { blockItemPrefix: n, flowChars: i, itemIndent: s, onChompKeep: o, onComment: a }) {
  const { indent: l, options: { commentString: c } } = r, h10 = Object.assign({}, r, { indent: s, type: null });
  let p = false;
  const m = [];
  for (let y = 0; y < e.length; ++y) {
    const x = e[y];
    let k = null;
    if (We(x))
      !p && x.spaceBefore && m.push(""), au(r, m, x.commentBefore, p), x.comment && (k = x.comment);
    else if (He(x)) {
      const _ = We(x.key) ? x.key : null;
      _ && (!p && _.spaceBefore && m.push(""), au(r, m, _.commentBefore, p));
    }
    p = false;
    let C = Go(x, h10, () => k = null, () => p = true);
    k && (C += zs(C, s, c(k))), p && k && (p = false), m.push(n + C);
  }
  let g;
  if (m.length === 0)
    g = i.start + i.end;
  else {
    g = m[0];
    for (let y = 1; y < m.length; ++y) {
      const x = m[y];
      g += x ? `
${l}${x}` : `
`;
    }
  }
  return t15 ? (g += `
` + Ti(c(t15), l), a && a()) : p && o && o(), g;
}
function JB({ items: t15 }, e, { flowChars: r, itemIndent: n }) {
  const { indent: i, indentStep: s, flowCollectionPadding: o, options: { commentString: a } } = e;
  n += s;
  const l = Object.assign({}, e, {
    indent: n,
    inFlow: true,
    type: null
  });
  let c = false, h10 = 0;
  const p = [];
  for (let y = 0; y < t15.length; ++y) {
    const x = t15[y];
    let k = null;
    if (We(x))
      x.spaceBefore && p.push(""), au(e, p, x.commentBefore, false), x.comment && (k = x.comment);
    else if (He(x)) {
      const _ = We(x.key) ? x.key : null;
      _ && (_.spaceBefore && p.push(""), au(e, p, _.commentBefore, false), _.comment && (c = true));
      const $ = We(x.value) ? x.value : null;
      $ ? ($.comment && (k = $.comment), $.commentBefore && (c = true)) : x.value == null && (_ == null ? void 0 : _.comment) && (k = _.comment);
    }
    k && (c = true);
    let C = Go(x, l, () => k = null);
    y < t15.length - 1 && (C += ","), k && (C += zs(C, n, a(k))), !c && (p.length > h10 || C.includes(`
`)) && (c = true), p.push(C), h10 = p.length;
  }
  const { start: m, end: g } = r;
  if (p.length === 0)
    return m + g;
  if (!c) {
    const y = p.reduce((x, k) => x + k.length + 2, 2);
    c = e.options.lineWidth > 0 && y > e.options.lineWidth;
  }
  if (c) {
    let y = m;
    for (const x of p)
      y += x ? `
${s}${i}${x}` : `
`;
    return `${y}
${i}${g}`;
  } else
    return `${m}${o}${p.join(" ")}${o}${g}`;
}
function au({ indent: t15, options: { commentString: e } }, r, n, i) {
  if (n && i && (n = n.replace(/^\n+/, "")), n) {
    const s = Ti(e(n), t15);
    r.push(s.trimStart());
  }
}
function qs(t15, e) {
  const r = Te(e) ? e.value : e;
  for (const n of t15)
    if (He(n) && (n.key === e || n.key === r || Te(n.key) && n.key.value === r))
      return n;
}
var mn = class extends o3 {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(ls, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, r, n) {
    const { keepUndefined: i, replacer: s } = n, o = new this(e), a = (l, c) => {
      if (typeof s == "function")
        c = s.call(r, l, c);
      else if (Array.isArray(s) && !s.includes(l))
        return;
      (c !== void 0 || i) && o.items.push(lm(l, c, n));
    };
    if (r instanceof Map)
      for (const [l, c] of r)
        a(l, c);
    else if (r && typeof r == "object")
      for (const l of Object.keys(r))
        a(l, r[l]);
    return typeof e.sortMapEntries == "function" && o.items.sort(e.sortMapEntries), o;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, r) {
    var _a2;
    let n;
    He(e) ? n = e : !e || typeof e != "object" || !("key" in e) ? n = new tn(e, e == null ? void 0 : e.value) : n = new tn(e.key, e.value);
    const i = qs(this.items, n.key), s = (_a2 = this.schema) == null ? void 0 : _a2.sortMapEntries;
    if (i) {
      if (!r)
        throw new Error(`Key ${n.key} already set`);
      Te(i.value) && s3(n.value) ? i.value.value = n.value : i.value = n.value;
    } else if (s) {
      const o = this.items.findIndex((a) => s(n, a) < 0);
      o === -1 ? this.items.push(n) : this.items.splice(o, 0, n);
    } else
      this.items.push(n);
  }
  delete(e) {
    const r = qs(this.items, e);
    return r ? this.items.splice(this.items.indexOf(r), 1).length > 0 : false;
  }
  get(e, r) {
    var _a2;
    const n = (_a2 = qs(this.items, e)) == null ? void 0 : _a2.value;
    return (!r && Te(n) ? n.value : n) ?? void 0;
  }
  has(e) {
    return !!qs(this.items, e);
  }
  set(e, r) {
    this.add(new tn(e, r), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, r, n) {
    const i = n ? new n() : (r == null ? void 0 : r.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    (r == null ? void 0 : r.onCreate) && r.onCreate(i);
    for (const s of this.items)
      u3(r, i, s);
    return i;
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    for (const i of this.items)
      if (!He(i))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);
    return !e.allNullValues && this.hasAllNullValues(false) && (e = Object.assign({}, e, { allNullValues: true })), p3(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: n,
      onComment: r
    });
  }
};
var fa = {
  collection: "map",
  default: true,
  nodeClass: mn,
  tag: "tag:yaml.org,2002:map",
  resolve(t15, e) {
    return nc(t15) || e("Expected a mapping for this tag"), t15;
  },
  createNode: (t15, e, r) => mn.from(t15, e, r)
};
var Zs = class extends o3 {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(da, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const r = Kc(e);
    return typeof r != "number" ? false : this.items.splice(r, 1).length > 0;
  }
  get(e, r) {
    const n = Kc(e);
    if (typeof n != "number")
      return;
    const i = this.items[n];
    return !r && Te(i) ? i.value : i;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const r = Kc(e);
    return typeof r == "number" && r < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, r) {
    const n = Kc(e);
    if (typeof n != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const i = this.items[n];
    Te(i) && s3(r) ? i.value = r : this.items[n] = r;
  }
  toJSON(e, r) {
    const n = [];
    (r == null ? void 0 : r.onCreate) && r.onCreate(n);
    let i = 0;
    for (const s of this.items)
      n.push(gn(s, String(i++), r));
    return n;
  }
  toString(e, r, n) {
    return e ? p3(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: n,
      onComment: r
    }) : JSON.stringify(this);
  }
  static from(e, r, n) {
    const { replacer: i } = n, s = new this(e);
    if (r && Symbol.iterator in Object(r)) {
      let o = 0;
      for (let a of r) {
        if (typeof i == "function") {
          const l = r instanceof Set ? a : String(o++);
          a = i.call(r, l, a);
        }
        s.items.push(Dl(a, void 0, n));
      }
    }
    return s;
  }
};
function Kc(t15) {
  let e = Te(t15) ? t15.value : t15;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
var ma = {
  collection: "seq",
  default: true,
  nodeClass: Zs,
  tag: "tag:yaml.org,2002:seq",
  resolve(t15, e) {
    return ic(t15) || e("Expected a sequence for this tag"), t15;
  },
  createNode: (t15, e, r) => Zs.from(t15, e, r)
};
var d0 = {
  identify: (t15) => typeof t15 == "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (t15) => t15,
  stringify(t15, e, r, n) {
    return e = Object.assign({ actualString: true }, e), am(t15, e, r, n);
  }
};
var p0 = {
  identify: (t15) => t15 == null,
  createNode: () => new Zt(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Zt(null),
  stringify: ({ source: t15 }, e) => typeof t15 == "string" && p0.test.test(t15) ? t15 : e.options.nullStr
};
var cm = {
  identify: (t15) => typeof t15 == "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (t15) => new Zt(t15[0] === "t" || t15[0] === "T"),
  stringify({ source: t15, value: e }, r) {
    if (t15 && cm.test.test(t15)) {
      const n = t15[0] === "t" || t15[0] === "T";
      if (e === n)
        return t15;
    }
    return e ? r.options.trueStr : r.options.falseStr;
  }
};
function Ln({ format: t15, minFractionDigits: e, tag: r, value: n }) {
  if (typeof n == "bigint")
    return String(n);
  const i = typeof n == "number" ? n : Number(n);
  if (!isFinite(i))
    return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  let s = JSON.stringify(n);
  if (!t15 && e && (!r || r === "tag:yaml.org,2002:float") && /^\d/.test(s)) {
    let o = s.indexOf(".");
    o < 0 && (o = s.length, s += ".");
    let a = e - (s.length - o - 1);
    for (; a-- > 0; )
      s += "0";
  }
  return s;
}
var f3 = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t15) => t15.slice(-3).toLowerCase() === "nan" ? NaN : t15[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Ln
};
var m3 = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (t15) => parseFloat(t15),
  stringify(t15) {
    const e = Number(t15.value);
    return isFinite(e) ? e.toExponential() : Ln(t15);
  }
};
var g3 = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(t15) {
    const e = new Zt(parseFloat(t15)), r = t15.indexOf(".");
    return r !== -1 && t15[t15.length - 1] === "0" && (e.minFractionDigits = t15.length - r - 1), e;
  },
  stringify: Ln
};
var f0 = (t15) => typeof t15 == "bigint" || Number.isInteger(t15);
var hm = (t15, e, r, { intAsBigInt: n }) => n ? BigInt(t15) : parseInt(t15.substring(e), r);
function y3(t15, e, r) {
  const { value: n } = t15;
  return f0(n) && n >= 0 ? r + n.toString(e) : Ln(t15);
}
var b3 = {
  identify: (t15) => f0(t15) && t15 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (t15, e, r) => hm(t15, 2, 8, r),
  stringify: (t15) => y3(t15, 8, "0o")
};
var x3 = {
  identify: f0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (t15, e, r) => hm(t15, 0, 10, r),
  stringify: Ln
};
var w3 = {
  identify: (t15) => f0(t15) && t15 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (t15, e, r) => hm(t15, 2, 16, r),
  stringify: (t15) => y3(t15, 16, "0x")
};
var tL = [
  fa,
  ma,
  d0,
  p0,
  cm,
  b3,
  x3,
  w3,
  f3,
  m3,
  g3
];
function R2(t15) {
  return typeof t15 == "bigint" || Number.isInteger(t15);
}
var Zc = ({ value: t15 }) => JSON.stringify(t15);
var eL = [
  {
    identify: (t15) => typeof t15 == "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (t15) => t15,
    stringify: Zc
  },
  {
    identify: (t15) => t15 == null,
    createNode: () => new Zt(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: Zc
  },
  {
    identify: (t15) => typeof t15 == "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (t15) => t15 === "true",
    stringify: Zc
  },
  {
    identify: R2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (t15, e, { intAsBigInt: r }) => r ? BigInt(t15) : parseInt(t15, 10),
    stringify: ({ value: t15 }) => R2(t15) ? t15.toString() : JSON.stringify(t15)
  },
  {
    identify: (t15) => typeof t15 == "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (t15) => parseFloat(t15),
    stringify: Zc
  }
];
var rL = {
  default: true,
  tag: "",
  test: /^/,
  resolve(t15, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(t15)}`), t15;
  }
};
var nL = [fa, ma].concat(eL, rL);
var um = {
  identify: (t15) => t15 instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(t15, e) {
    if (typeof atob == "function") {
      const r = atob(t15.replace(/[\n\r]/g, "")), n = new Uint8Array(r.length);
      for (let i = 0; i < r.length; ++i)
        n[i] = r.charCodeAt(i);
      return n;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), t15;
  },
  stringify({ comment: t15, type: e, value: r }, n, i, s) {
    if (!r)
      return "";
    const o = r;
    let a;
    if (typeof btoa == "function") {
      let l = "";
      for (let c = 0; c < o.length; ++c)
        l += String.fromCharCode(o[c]);
      a = btoa(l);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e ?? (e = Zt.BLOCK_LITERAL), e !== Zt.QUOTE_DOUBLE) {
      const l = Math.max(n.options.lineWidth - n.indent.length, n.options.minContentWidth), c = Math.ceil(a.length / l), h10 = new Array(c);
      for (let p = 0, m = 0; p < c; ++p, m += l)
        h10[p] = a.substr(m, l);
      a = h10.join(e === Zt.BLOCK_LITERAL ? `
` : " ");
    }
    return am({ comment: t15, type: e, value: a }, n, i, s);
  }
};
function k3(t15, e) {
  if (ic(t15))
    for (let r = 0; r < t15.items.length; ++r) {
      let n = t15.items[r];
      if (!He(n)) {
        if (nc(n)) {
          n.items.length > 1 && e("Each pair must have its own sequence indicator");
          const i = n.items[0] || new tn(new Zt(null));
          if (n.commentBefore && (i.key.commentBefore = i.key.commentBefore ? `${n.commentBefore}
${i.key.commentBefore}` : n.commentBefore), n.comment) {
            const s = i.value ?? i.key;
            s.comment = s.comment ? `${n.comment}
${s.comment}` : n.comment;
          }
          n = i;
        }
        t15.items[r] = He(n) ? n : new tn(n);
      }
    }
  else
    e("Expected a sequence for this tag");
  return t15;
}
function v3(t15, e, r) {
  const { replacer: n } = r, i = new Zs(t15);
  i.tag = "tag:yaml.org,2002:pairs";
  let s = 0;
  if (e && Symbol.iterator in Object(e))
    for (let o of e) {
      typeof n == "function" && (o = n.call(e, String(s++), o));
      let a, l;
      if (Array.isArray(o))
        if (o.length === 2)
          a = o[0], l = o[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${o}`);
      else if (o && o instanceof Object) {
        const c = Object.keys(o);
        if (c.length === 1)
          a = c[0], l = o[a];
        else
          throw new TypeError(`Expected tuple with one key, not ${c.length} keys`);
      } else
        a = o;
      i.items.push(lm(a, l, r));
    }
  return i;
}
var dm = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: k3,
  createNode: v3
};
var _h = class _3 extends Zs {
  constructor() {
    super(), this.add = mn.prototype.add.bind(this), this.delete = mn.prototype.delete.bind(this), this.get = mn.prototype.get.bind(this), this.has = mn.prototype.has.bind(this), this.set = mn.prototype.set.bind(this), this.tag = _3.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, r) {
    if (!r)
      return super.toJSON(e);
    const n = /* @__PURE__ */ new Map();
    (r == null ? void 0 : r.onCreate) && r.onCreate(n);
    for (const i of this.items) {
      let s, o;
      if (He(i) ? (s = gn(i.key, "", r), o = gn(i.value, s, r)) : s = gn(i, "", r), n.has(s))
        throw new Error("Ordered maps must not include duplicate keys");
      n.set(s, o);
    }
    return n;
  }
  static from(e, r, n) {
    const i = v3(e, r, n), s = new this();
    return s.items = i.items, s;
  }
};
_h.tag = "tag:yaml.org,2002:omap";
var pm = {
  collection: "seq",
  identify: (t15) => t15 instanceof Map,
  nodeClass: _h,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(t15, e) {
    const r = k3(t15, e), n = [];
    for (const { key: i } of r.items)
      Te(i) && (n.includes(i.value) ? e(`Ordered maps must not include duplicate keys: ${i.value}`) : n.push(i.value));
    return Object.assign(new _h(), r);
  },
  createNode: (t15, e, r) => _h.from(t15, e, r)
};
function C3({ value: t15, source: e }, r) {
  return e && (t15 ? S3 : T3).test.test(e) ? e : t15 ? r.options.trueStr : r.options.falseStr;
}
var S3 = {
  identify: (t15) => t15 === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Zt(true),
  stringify: C3
};
var T3 = {
  identify: (t15) => t15 === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Zt(false),
  stringify: C3
};
var iL = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t15) => t15.slice(-3).toLowerCase() === "nan" ? NaN : t15[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Ln
};
var sL = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (t15) => parseFloat(t15.replace(/_/g, "")),
  stringify(t15) {
    const e = Number(t15.value);
    return isFinite(e) ? e.toExponential() : Ln(t15);
  }
};
var oL = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(t15) {
    const e = new Zt(parseFloat(t15.replace(/_/g, ""))), r = t15.indexOf(".");
    if (r !== -1) {
      const n = t15.substring(r + 1).replace(/_/g, "");
      n[n.length - 1] === "0" && (e.minFractionDigits = n.length);
    }
    return e;
  },
  stringify: Ln
};
var sc = (t15) => typeof t15 == "bigint" || Number.isInteger(t15);
function m0(t15, e, r, { intAsBigInt: n }) {
  const i = t15[0];
  if ((i === "-" || i === "+") && (e += 1), t15 = t15.substring(e).replace(/_/g, ""), n) {
    switch (r) {
      case 2:
        t15 = `0b${t15}`;
        break;
      case 8:
        t15 = `0o${t15}`;
        break;
      case 16:
        t15 = `0x${t15}`;
        break;
    }
    const o = BigInt(t15);
    return i === "-" ? BigInt(-1) * o : o;
  }
  const s = parseInt(t15, r);
  return i === "-" ? -1 * s : s;
}
function fm(t15, e, r) {
  const { value: n } = t15;
  if (sc(n)) {
    const i = n.toString(e);
    return n < 0 ? "-" + r + i.substr(1) : r + i;
  }
  return Ln(t15);
}
var aL = {
  identify: sc,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (t15, e, r) => m0(t15, 2, 2, r),
  stringify: (t15) => fm(t15, 2, "0b")
};
var lL = {
  identify: sc,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (t15, e, r) => m0(t15, 1, 8, r),
  stringify: (t15) => fm(t15, 8, "0")
};
var cL = {
  identify: sc,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (t15, e, r) => m0(t15, 0, 10, r),
  stringify: Ln
};
var hL = {
  identify: sc,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (t15, e, r) => m0(t15, 2, 16, r),
  stringify: (t15) => fm(t15, 16, "0x")
};
var Ch = class A3 extends mn {
  constructor(e) {
    super(e), this.tag = A3.tag;
  }
  add(e) {
    let r;
    He(e) ? r = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? r = new tn(e.key, null) : r = new tn(e, null), qs(this.items, r.key) || this.items.push(r);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, r) {
    const n = qs(this.items, e);
    return !r && He(n) ? Te(n.key) ? n.key.value : n.key : n;
  }
  set(e, r) {
    if (typeof r != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof r}`);
    const n = qs(this.items, e);
    n && !r ? this.items.splice(this.items.indexOf(n), 1) : !n && r && this.items.push(new tn(e));
  }
  toJSON(e, r) {
    return super.toJSON(e, r, Set);
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, e, { allNullValues: true }), r, n);
    throw new Error("Set items must all have null values");
  }
  static from(e, r, n) {
    const { replacer: i } = n, s = new this(e);
    if (r && Symbol.iterator in Object(r))
      for (let o of r)
        typeof i == "function" && (o = i.call(r, o, o)), s.items.push(lm(o, null, n));
    return s;
  }
};
Ch.tag = "tag:yaml.org,2002:set";
var mm = {
  collection: "map",
  identify: (t15) => t15 instanceof Set,
  nodeClass: Ch,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (t15, e, r) => Ch.from(t15, e, r),
  resolve(t15, e) {
    if (nc(t15)) {
      if (t15.hasAllNullValues(true))
        return Object.assign(new Ch(), t15);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return t15;
  }
};
function gm(t15, e) {
  const r = t15[0], n = r === "-" || r === "+" ? t15.substring(1) : t15, i = (o) => e ? BigInt(o) : Number(o), s = n.replace(/_/g, "").split(":").reduce((o, a) => o * i(60) + i(a), i(0));
  return r === "-" ? i(-1) * s : s;
}
function $3(t15) {
  let { value: e } = t15, r = (o) => o;
  if (typeof e == "bigint")
    r = (o) => BigInt(o);
  else if (isNaN(e) || !isFinite(e))
    return Ln(t15);
  let n = "";
  e < 0 && (n = "-", e *= r(-1));
  const i = r(60), s = [e % i];
  return e < 60 ? s.unshift(0) : (e = (e - s[0]) / i, s.unshift(e % i), e >= 60 && (e = (e - s[0]) / i, s.unshift(e))), n + s.map((o) => String(o).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var E3 = {
  identify: (t15) => typeof t15 == "bigint" || Number.isInteger(t15),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (t15, e, { intAsBigInt: r }) => gm(t15, r),
  stringify: $3
};
var M3 = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (t15) => gm(t15, false),
  stringify: $3
};
var g0 = {
  identify: (t15) => t15 instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(t15) {
    const e = t15.match(g0.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, r, n, i, s, o, a] = e.map(Number), l = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let c = Date.UTC(r, n - 1, i, s || 0, o || 0, a || 0, l);
    const h10 = e[8];
    if (h10 && h10 !== "Z") {
      let p = gm(h10, false);
      Math.abs(p) < 30 && (p *= 60), c -= 6e4 * p;
    }
    return new Date(c);
  },
  stringify: ({ value: t15 }) => (t15 == null ? void 0 : t15.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) ?? ""
};
var P2 = [
  fa,
  ma,
  d0,
  p0,
  S3,
  T3,
  aL,
  lL,
  cL,
  hL,
  iL,
  sL,
  oL,
  um,
  Bi,
  pm,
  dm,
  mm,
  E3,
  M3,
  g0
];
var j2 = /* @__PURE__ */ new Map([
  ["core", tL],
  ["failsafe", [fa, ma, d0]],
  ["json", nL],
  ["yaml11", P2],
  ["yaml-1.1", P2]
]);
var W2 = {
  binary: um,
  bool: cm,
  float: g3,
  floatExp: m3,
  floatNaN: f3,
  floatTime: M3,
  int: x3,
  intHex: w3,
  intOct: b3,
  intTime: E3,
  map: fa,
  merge: Bi,
  null: p0,
  omap: pm,
  pairs: dm,
  seq: ma,
  set: mm,
  timestamp: g0
};
var uL = {
  "tag:yaml.org,2002:binary": um,
  "tag:yaml.org,2002:merge": Bi,
  "tag:yaml.org,2002:omap": pm,
  "tag:yaml.org,2002:pairs": dm,
  "tag:yaml.org,2002:set": mm,
  "tag:yaml.org,2002:timestamp": g0
};
function Yd(t15, e, r) {
  const n = j2.get(e);
  if (n && !t15)
    return r && !n.includes(Bi) ? n.concat(Bi) : n.slice();
  let i = n;
  if (!i)
    if (Array.isArray(t15))
      i = [];
    else {
      const s = Array.from(j2.keys()).filter((o) => o !== "yaml11").map((o) => JSON.stringify(o)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${s} or define customTags array`);
    }
  if (Array.isArray(t15))
    for (const s of t15)
      i = i.concat(s);
  else typeof t15 == "function" && (i = t15(i.slice()));
  return r && (i = i.concat(Bi)), i.reduce((s, o) => {
    const a = typeof o == "string" ? W2[o] : o;
    if (!a) {
      const l = JSON.stringify(o), c = Object.keys(W2).map((h10) => JSON.stringify(h10)).join(", ");
      throw new Error(`Unknown custom tag ${l}; use one of ${c}`);
    }
    return s.includes(a) || s.push(a), s;
  }, []);
}
var dL = (t15, e) => t15.key < e.key ? -1 : t15.key > e.key ? 1 : 0;
var pL = class B3 {
  constructor({ compat: e, customTags: r, merge: n, resolveKnownTags: i, schema: s, sortMapEntries: o, toStringDefaults: a }) {
    this.compat = Array.isArray(e) ? Yd(e, "compat") : e ? Yd(null, e) : null, this.name = typeof s == "string" && s || "core", this.knownTags = i ? uL : {}, this.tags = Yd(r, this.name, n), this.toStringOptions = a ?? null, Object.defineProperty(this, ls, { value: fa }), Object.defineProperty(this, ei, { value: d0 }), Object.defineProperty(this, da, { value: ma }), this.sortMapEntries = typeof o == "function" ? o : o === true ? dL : null;
  }
  clone() {
    const e = Object.create(B3.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
};
function fL(t15, e) {
  var _a2;
  const r = [];
  let n = e.directives === true;
  if (e.directives !== false && t15.directives) {
    const l = t15.directives.toString(t15);
    l ? (r.push(l), n = true) : t15.directives.docStart && (n = true);
  }
  n && r.push("---");
  const i = l3(t15, e), { commentString: s } = i.options;
  if (t15.commentBefore) {
    r.length !== 1 && r.unshift("");
    const l = s(t15.commentBefore);
    r.unshift(Ti(l, ""));
  }
  let o = false, a = null;
  if (t15.contents) {
    if (We(t15.contents)) {
      if (t15.contents.spaceBefore && n && r.push(""), t15.contents.commentBefore) {
        const h10 = s(t15.contents.commentBefore);
        r.push(Ti(h10, ""));
      }
      i.forceBlockIndent = !!t15.comment, a = t15.contents.comment;
    }
    const l = a ? void 0 : () => o = true;
    let c = Go(t15.contents, i, () => a = null, l);
    a && (c += zs(c, "", s(a))), (c[0] === "|" || c[0] === ">") && r[r.length - 1] === "---" ? r[r.length - 1] = `--- ${c}` : r.push(c);
  } else
    r.push(Go(t15.contents, i));
  if ((_a2 = t15.directives) == null ? void 0 : _a2.docEnd)
    if (t15.comment) {
      const l = s(t15.comment);
      l.includes(`
`) ? (r.push("..."), r.push(Ti(l, ""))) : r.push(`... ${l}`);
    } else
      r.push("...");
  else {
    let l = t15.comment;
    l && o && (l = l.replace(/^\n+/, "")), l && ((!o || a) && r[r.length - 1] !== "" && r.push(""), r.push(Ti(s(l), "")));
  }
  return r.join(`
`) + `
`;
}
var L3 = class D3 {
  constructor(e, r, n) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, bn, { value: cf });
    let i = null;
    typeof r == "function" || Array.isArray(r) ? i = r : n === void 0 && r && (n = r, r = void 0);
    const s = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, n);
    this.options = s;
    let { version: o } = s;
    (n == null ? void 0 : n._directives) ? (this.directives = n._directives.atDocument(), this.directives.yaml.explicit && (o = this.directives.yaml.version)) : this.directives = new Tr({ version: o }), this.setSchema(o, n), this.contents = e === void 0 ? null : this.createNode(e, i, n);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(D3.prototype, {
      [bn]: { value: cf }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = We(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    _o(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, r) {
    _o(this.contents) && this.contents.addIn(e, r);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, r) {
    if (!e.anchor) {
      const n = n3(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !r || n.has(r) ? i3(r || "a", n) : r;
    }
    return new om(e.anchor);
  }
  createNode(e, r, n) {
    let i;
    if (typeof r == "function")
      e = r.call({ "": e }, "", e), i = r;
    else if (Array.isArray(r)) {
      const k = (_) => typeof _ == "number" || _ instanceof String || _ instanceof Number, C = r.filter(k).map(String);
      C.length > 0 && (r = r.concat(C)), i = r;
    } else n === void 0 && r && (n = r, r = void 0);
    const { aliasDuplicateObjects: s, anchorPrefix: o, flow: a, keepUndefined: l, onTagObj: c, tag: h10 } = n ?? {}, { onAnchor: p, setAnchors: m, sourceObjects: g } = PB(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      o || "a"
    ), y = {
      aliasDuplicateObjects: s ?? true,
      keepUndefined: l ?? false,
      onAnchor: p,
      onTagObj: c,
      replacer: i,
      schema: this.schema,
      sourceObjects: g
    }, x = Dl(e, h10, y);
    return a && Pe(x) && (x.flow = true), m(), x;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, r, n = {}) {
    const i = this.createNode(e, null, n), s = this.createNode(r, null, n);
    return new tn(i, s);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return _o(this.contents) ? this.contents.delete(e) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return el(e) ? this.contents == null ? false : (this.contents = null, true) : _o(this.contents) ? this.contents.deleteIn(e) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, r) {
    return Pe(this.contents) ? this.contents.get(e, r) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    return el(e) ? !r && Te(this.contents) ? this.contents.value : this.contents : Pe(this.contents) ? this.contents.getIn(e, r) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return Pe(this.contents) ? this.contents.has(e) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return el(e) ? this.contents !== void 0 : Pe(this.contents) ? this.contents.hasIn(e) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, r) {
    this.contents == null ? this.contents = ou(this.schema, [e], r) : _o(this.contents) && this.contents.set(e, r);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    el(e) ? this.contents = r : this.contents == null ? this.contents = ou(this.schema, Array.from(e), r) : _o(this.contents) && this.contents.setIn(e, r);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, r = {}) {
    typeof e == "number" && (e = String(e));
    let n;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Tr({ version: "1.1" }), n = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Tr({ version: e }), n = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, n = null;
        break;
      default: {
        const i = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i}`);
      }
    }
    if (r.schema instanceof Object)
      this.schema = r.schema;
    else if (n)
      this.schema = new pL(Object.assign(n, r));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: r, mapAsMap: n, maxAliasCount: i, onAnchor: s, reviver: o } = {}) {
    const a = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: n === true,
      mapKeyWarned: false,
      maxAliasCount: typeof i == "number" ? i : 100
    }, l = gn(this.contents, r ?? "", a);
    if (typeof s == "function")
      for (const { count: c, res: h10 } of a.anchors.values())
        s(h10, c);
    return typeof o == "function" ? Do(o, { "": l }, "", l) : l;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, r) {
    return this.toJS({ json: true, jsonArg: e, mapAsMap: false, onAnchor: r });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const r = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${r}`);
    }
    return fL(this, e);
  }
};
function _o(t15) {
  if (Pe(t15))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var F3 = class extends Error {
  constructor(e, r, n, i) {
    super(), this.name = e, this.code = n, this.message = i, this.pos = r;
  }
};
var rl = class extends F3 {
  constructor(e, r, n) {
    super("YAMLParseError", e, r, n);
  }
};
var mL = class extends F3 {
  constructor(e, r, n) {
    super("YAMLWarning", e, r, n);
  }
};
var H2 = (t15, e) => (r) => {
  if (r.pos[0] === -1)
    return;
  r.linePos = r.pos.map((a) => e.linePos(a));
  const { line: n, col: i } = r.linePos[0];
  r.message += ` at line ${n}, column ${i}`;
  let s = i - 1, o = t15.substring(e.lineStarts[n - 1], e.lineStarts[n]).replace(/[\n\r]+$/, "");
  if (s >= 60 && o.length > 80) {
    const a = Math.min(s - 39, o.length - 79);
    o = "…" + o.substring(a), s -= a - 1;
  }
  if (o.length > 80 && (o = o.substring(0, 79) + "…"), n > 1 && /^ *$/.test(o.substring(0, s))) {
    let a = t15.substring(e.lineStarts[n - 2], e.lineStarts[n - 1]);
    a.length > 80 && (a = a.substring(0, 79) + `…
`), o = a + o;
  }
  if (/[^ ]/.test(o)) {
    let a = 1;
    const l = r.linePos[1];
    l && l.line === n && l.col > i && (a = Math.max(1, Math.min(l.col - i, 80 - s)));
    const c = " ".repeat(s) + "^".repeat(a);
    r.message += `:

${o}
${c}
`;
  }
};
function Xo(t15, { flow: e, indicator: r, next: n, offset: i, onError: s, parentIndent: o, startOnNewline: a }) {
  let l = false, c = a, h10 = a, p = "", m = "", g = false, y = false, x = null, k = null, C = null, _ = null, $ = null, L = null, B = null;
  for (const G of t15)
    switch (y && (G.type !== "space" && G.type !== "newline" && G.type !== "comma" && s(G.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), y = false), x && (c && G.type !== "comment" && G.type !== "newline" && s(x, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), x = null), G.type) {
      case "space":
        !e && (r !== "doc-start" || (n == null ? void 0 : n.type) !== "flow-collection") && G.source.includes("	") && (x = G), h10 = true;
        break;
      case "comment": {
        h10 || s(G, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const F = G.source.substring(1) || " ";
        p ? p += m + F : p = F, m = "", c = false;
        break;
      }
      case "newline":
        c ? p ? p += G.source : (!L || r !== "seq-item-ind") && (l = true) : m += G.source, c = true, g = true, (k || C) && (_ = G), h10 = true;
        break;
      case "anchor":
        k && s(G, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), G.source.endsWith(":") && s(G.offset + G.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true), k = G, B ?? (B = G.offset), c = false, h10 = false, y = true;
        break;
      case "tag": {
        C && s(G, "MULTIPLE_TAGS", "A node can have at most one tag"), C = G, B ?? (B = G.offset), c = false, h10 = false, y = true;
        break;
      }
      case r:
        (k || C) && s(G, "BAD_PROP_ORDER", `Anchors and tags must be after the ${G.source} indicator`), L && s(G, "UNEXPECTED_TOKEN", `Unexpected ${G.source} in ${e ?? "collection"}`), L = G, c = r === "seq-item-ind" || r === "explicit-key-ind", h10 = false;
        break;
      case "comma":
        if (e) {
          $ && s(G, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), $ = G, c = false, h10 = false;
          break;
        }
      default:
        s(G, "UNEXPECTED_TOKEN", `Unexpected ${G.type} token`), c = false, h10 = false;
    }
  const q = t15[t15.length - 1], H = q ? q.offset + q.source.length : i;
  return y && n && n.type !== "space" && n.type !== "newline" && n.type !== "comma" && (n.type !== "scalar" || n.source !== "") && s(n.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), x && (c && x.indent <= o || (n == null ? void 0 : n.type) === "block-map" || (n == null ? void 0 : n.type) === "block-seq") && s(x, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: $,
    found: L,
    spaceBefore: l,
    comment: p,
    hasNewline: g,
    anchor: k,
    tag: C,
    newlineAfterProp: _,
    end: H,
    start: B ?? H
  };
}
function Fl(t15) {
  if (!t15)
    return null;
  switch (t15.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (t15.source.includes(`
`))
        return true;
      if (t15.end) {
        for (const e of t15.end)
          if (e.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const e of t15.items) {
        for (const r of e.start)
          if (r.type === "newline")
            return true;
        if (e.sep) {
          for (const r of e.sep)
            if (r.type === "newline")
              return true;
        }
        if (Fl(e.key) || Fl(e.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function pf(t15, e, r) {
  if ((e == null ? void 0 : e.type) === "flow-collection") {
    const n = e.end[0];
    n.indent === t15 && (n.source === "]" || n.source === "}") && Fl(e) && r(n, "BAD_INDENT", "Flow end indicator should be more indented than parent", true);
  }
}
function N3(t15, e, r) {
  const { uniqueKeys: n } = t15.options;
  if (n === false)
    return false;
  const i = typeof n == "function" ? n : (s, o) => s === o || Te(s) && Te(o) && s.value === o.value;
  return e.some((s) => i(s.key, r));
}
var U2 = "All mapping items must start at the same column";
function gL({ composeNode: t15, composeEmptyNode: e }, r, n, i, s) {
  var _a2;
  const o = (s == null ? void 0 : s.nodeClass) ?? mn, a = new o(r.schema);
  r.atRoot && (r.atRoot = false);
  let l = n.offset, c = null;
  for (const h10 of n.items) {
    const { start: p, key: m, sep: g, value: y } = h10, x = Xo(p, {
      indicator: "explicit-key-ind",
      next: m ?? (g == null ? void 0 : g[0]),
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: true
    }), k = !x.found;
    if (k) {
      if (m && (m.type === "block-seq" ? i(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in m && m.indent !== n.indent && i(l, "BAD_INDENT", U2)), !x.anchor && !x.tag && !g) {
        c = x.end, x.comment && (a.comment ? a.comment += `
` + x.comment : a.comment = x.comment);
        continue;
      }
      (x.newlineAfterProp || Fl(m)) && i(m ?? p[p.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else ((_a2 = x.found) == null ? void 0 : _a2.indent) !== n.indent && i(l, "BAD_INDENT", U2);
    r.atKey = true;
    const C = x.end, _ = m ? t15(r, m, x, i) : e(r, C, p, null, x, i);
    r.schema.compat && pf(n.indent, m, i), r.atKey = false, N3(r, a.items, _) && i(C, "DUPLICATE_KEY", "Map keys must be unique");
    const $ = Xo(g ?? [], {
      indicator: "map-value-ind",
      next: y,
      offset: _.range[2],
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !m || m.type === "block-scalar"
    });
    if (l = $.end, $.found) {
      k && ((y == null ? void 0 : y.type) === "block-map" && !$.hasNewline && i(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), r.options.strict && x.start < $.found.offset - 1024 && i(_.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const L = y ? t15(r, y, $, i) : e(r, l, g, null, $, i);
      r.schema.compat && pf(n.indent, y, i), l = L.range[2];
      const B = new tn(_, L);
      r.options.keepSourceTokens && (B.srcToken = h10), a.items.push(B);
    } else {
      k && i(_.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), $.comment && (_.comment ? _.comment += `
` + $.comment : _.comment = $.comment);
      const L = new tn(_);
      r.options.keepSourceTokens && (L.srcToken = h10), a.items.push(L);
    }
  }
  return c && c < l && i(c, "IMPOSSIBLE", "Map comment with trailing content"), a.range = [n.offset, l, c ?? l], a;
}
function yL({ composeNode: t15, composeEmptyNode: e }, r, n, i, s) {
  const o = (s == null ? void 0 : s.nodeClass) ?? Zs, a = new o(r.schema);
  r.atRoot && (r.atRoot = false), r.atKey && (r.atKey = false);
  let l = n.offset, c = null;
  for (const { start: h10, value: p } of n.items) {
    const m = Xo(h10, {
      indicator: "seq-item-ind",
      next: p,
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: true
    });
    if (!m.found)
      if (m.anchor || m.tag || p)
        p && p.type === "block-seq" ? i(m.end, "BAD_INDENT", "All sequence items must start at the same column") : i(l, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        c = m.end, m.comment && (a.comment = m.comment);
        continue;
      }
    const g = p ? t15(r, p, m, i) : e(r, m.end, h10, null, m, i);
    r.schema.compat && pf(n.indent, p, i), l = g.range[2], a.items.push(g);
  }
  return a.range = [n.offset, l, c ?? l], a;
}
function oc(t15, e, r, n) {
  let i = "";
  if (t15) {
    let s = false, o = "";
    for (const a of t15) {
      const { source: l, type: c } = a;
      switch (c) {
        case "space":
          s = true;
          break;
        case "comment": {
          r && !s && n(a, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const h10 = l.substring(1) || " ";
          i ? i += o + h10 : i = h10, o = "";
          break;
        }
        case "newline":
          i && (o += l), s = true;
          break;
        default:
          n(a, "UNEXPECTED_TOKEN", `Unexpected ${c} at node end`);
      }
      e += l.length;
    }
  }
  return { comment: i, offset: e };
}
var Kd = "Block collections are not allowed within flow collections";
var Zd = (t15) => t15 && (t15.type === "block-map" || t15.type === "block-seq");
function bL({ composeNode: t15, composeEmptyNode: e }, r, n, i, s) {
  const o = n.start.source === "{", a = o ? "flow map" : "flow sequence", l = (s == null ? void 0 : s.nodeClass) ?? (o ? mn : Zs), c = new l(r.schema);
  c.flow = true;
  const h10 = r.atRoot;
  h10 && (r.atRoot = false), r.atKey && (r.atKey = false);
  let p = n.offset + n.start.source.length;
  for (let k = 0; k < n.items.length; ++k) {
    const C = n.items[k], { start: _, key: $, sep: L, value: B } = C, q = Xo(_, {
      flow: a,
      indicator: "explicit-key-ind",
      next: $ ?? (L == null ? void 0 : L[0]),
      offset: p,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: false
    });
    if (!q.found) {
      if (!q.anchor && !q.tag && !L && !B) {
        k === 0 && q.comma ? i(q.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`) : k < n.items.length - 1 && i(q.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${a}`), q.comment && (c.comment ? c.comment += `
` + q.comment : c.comment = q.comment), p = q.end;
        continue;
      }
      !o && r.options.strict && Fl($) && i(
        $,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (k === 0)
      q.comma && i(q.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`);
    else if (q.comma || i(q.start, "MISSING_CHAR", `Missing , between ${a} items`), q.comment) {
      let H = "";
      t: for (const G of _)
        switch (G.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            H = G.source.substring(1);
            break t;
          default:
            break t;
        }
      if (H) {
        let G = c.items[c.items.length - 1];
        He(G) && (G = G.value ?? G.key), G.comment ? G.comment += `
` + H : G.comment = H, q.comment = q.comment.substring(H.length + 1);
      }
    }
    if (!o && !L && !q.found) {
      const H = B ? t15(r, B, q, i) : e(r, q.end, L, null, q, i);
      c.items.push(H), p = H.range[2], Zd(B) && i(H.range, "BLOCK_IN_FLOW", Kd);
    } else {
      r.atKey = true;
      const H = q.end, G = $ ? t15(r, $, q, i) : e(r, H, _, null, q, i);
      Zd($) && i(G.range, "BLOCK_IN_FLOW", Kd), r.atKey = false;
      const F = Xo(L ?? [], {
        flow: a,
        indicator: "map-value-ind",
        next: B,
        offset: G.range[2],
        onError: i,
        parentIndent: n.indent,
        startOnNewline: false
      });
      if (F.found) {
        if (!o && !q.found && r.options.strict) {
          if (L)
            for (const J of L) {
              if (J === F.found)
                break;
              if (J.type === "newline") {
                i(J, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          q.start < F.found.offset - 1024 && i(F.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else B && ("source" in B && B.source && B.source[0] === ":" ? i(B, "MISSING_CHAR", `Missing space after : in ${a}`) : i(F.start, "MISSING_CHAR", `Missing , or : between ${a} items`));
      const W = B ? t15(r, B, F, i) : F.found ? e(r, F.end, L, null, F, i) : null;
      W ? Zd(B) && i(W.range, "BLOCK_IN_FLOW", Kd) : F.comment && (G.comment ? G.comment += `
` + F.comment : G.comment = F.comment);
      const R = new tn(G, W);
      if (r.options.keepSourceTokens && (R.srcToken = C), o) {
        const J = c;
        N3(r, J.items, G) && i(H, "DUPLICATE_KEY", "Map keys must be unique"), J.items.push(R);
      } else {
        const J = new mn(r.schema);
        J.flow = true, J.items.push(R);
        const rt = (W ?? G).range;
        J.range = [G.range[0], rt[1], rt[2]], c.items.push(J);
      }
      p = W ? W.range[2] : F.end;
    }
  }
  const m = o ? "}" : "]", [g, ...y] = n.end;
  let x = p;
  if (g && g.source === m)
    x = g.offset + g.source.length;
  else {
    const k = a[0].toUpperCase() + a.substring(1), C = h10 ? `${k} must end with a ${m}` : `${k} in block collection must be sufficiently indented and end with a ${m}`;
    i(p, h10 ? "MISSING_CHAR" : "BAD_INDENT", C), g && g.source.length !== 1 && y.unshift(g);
  }
  if (y.length > 0) {
    const k = oc(y, x, r.options.strict, i);
    k.comment && (c.comment ? c.comment += `
` + k.comment : c.comment = k.comment), c.range = [n.offset, x, k.offset];
  } else
    c.range = [n.offset, x, x];
  return c;
}
function Qd(t15, e, r, n, i, s) {
  const o = r.type === "block-map" ? gL(t15, e, r, n, s) : r.type === "block-seq" ? yL(t15, e, r, n, s) : bL(t15, e, r, n, s), a = o.constructor;
  return i === "!" || i === a.tagName ? (o.tag = a.tagName, o) : (i && (o.tag = i), o);
}
function xL(t15, e, r, n, i) {
  var _a2;
  const s = n.tag, o = s ? e.directives.tagName(s.source, (m) => i(s, "TAG_RESOLVE_FAILED", m)) : null;
  if (r.type === "block-seq") {
    const { anchor: m, newlineAfterProp: g } = n, y = m && s ? m.offset > s.offset ? m : s : m ?? s;
    y && (!g || g.offset < y.offset) && i(y, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const a = r.type === "block-map" ? "map" : r.type === "block-seq" ? "seq" : r.start.source === "{" ? "map" : "seq";
  if (!s || !o || o === "!" || o === mn.tagName && a === "map" || o === Zs.tagName && a === "seq")
    return Qd(t15, e, r, i, o);
  let l = e.schema.tags.find((m) => m.tag === o && m.collection === a);
  if (!l) {
    const m = e.schema.knownTags[o];
    if (m && m.collection === a)
      e.schema.tags.push(Object.assign({}, m, { default: false })), l = m;
    else
      return m ? i(s, "BAD_COLLECTION_TYPE", `${m.tag} used for ${a} collection, but expects ${m.collection ?? "scalar"}`, true) : i(s, "TAG_RESOLVE_FAILED", `Unresolved tag: ${o}`, true), Qd(t15, e, r, i, o);
  }
  const c = Qd(t15, e, r, i, o, l), h10 = ((_a2 = l.resolve) == null ? void 0 : _a2.call(l, c, (m) => i(s, "TAG_RESOLVE_FAILED", m), e.options)) ?? c, p = We(h10) ? h10 : new Zt(h10);
  return p.range = c.range, p.tag = o, (l == null ? void 0 : l.format) && (p.format = l.format), p;
}
function wL(t15, e, r) {
  const n = e.offset, i = kL(e, t15.options.strict, r);
  if (!i)
    return { value: "", type: null, comment: "", range: [n, n, n] };
  const s = i.mode === ">" ? Zt.BLOCK_FOLDED : Zt.BLOCK_LITERAL, o = e.source ? vL(e.source) : [];
  let a = o.length;
  for (let x = o.length - 1; x >= 0; --x) {
    const k = o[x][1];
    if (k === "" || k === "\r")
      a = x;
    else
      break;
  }
  if (a === 0) {
    const x = i.chomp === "+" && o.length > 0 ? `
`.repeat(Math.max(1, o.length - 1)) : "";
    let k = n + i.length;
    return e.source && (k += e.source.length), { value: x, type: s, comment: i.comment, range: [n, k, k] };
  }
  let l = e.indent + i.indent, c = e.offset + i.length, h10 = 0;
  for (let x = 0; x < a; ++x) {
    const [k, C] = o[x];
    if (C === "" || C === "\r")
      i.indent === 0 && k.length > l && (l = k.length);
    else {
      k.length < l && r(c + k.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i.indent === 0 && (l = k.length), h10 = x, l === 0 && !t15.atRoot && r(c, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    c += k.length + C.length + 1;
  }
  for (let x = o.length - 1; x >= a; --x)
    o[x][0].length > l && (a = x + 1);
  let p = "", m = "", g = false;
  for (let x = 0; x < h10; ++x)
    p += o[x][0].slice(l) + `
`;
  for (let x = h10; x < a; ++x) {
    let [k, C] = o[x];
    c += k.length + C.length + 1;
    const _ = C[C.length - 1] === "\r";
    if (_ && (C = C.slice(0, -1)), C && k.length < l) {
      const $ = `Block scalar lines must not be less indented than their ${i.indent ? "explicit indentation indicator" : "first line"}`;
      r(c - C.length - (_ ? 2 : 1), "BAD_INDENT", $), k = "";
    }
    s === Zt.BLOCK_LITERAL ? (p += m + k.slice(l) + C, m = `
`) : k.length > l || C[0] === "	" ? (m === " " ? m = `
` : !g && m === `
` && (m = `

`), p += m + k.slice(l) + C, m = `
`, g = true) : C === "" ? m === `
` ? p += `
` : m = `
` : (p += m + C, m = " ", g = false);
  }
  switch (i.chomp) {
    case "-":
      break;
    case "+":
      for (let x = a; x < o.length; ++x)
        p += `
` + o[x][0].slice(l);
      p[p.length - 1] !== `
` && (p += `
`);
      break;
    default:
      p += `
`;
  }
  const y = n + i.length + e.source.length;
  return { value: p, type: s, comment: i.comment, range: [n, y, y] };
}
function kL({ offset: t15, props: e }, r, n) {
  if (e[0].type !== "block-scalar-header")
    return n(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: i } = e[0], s = i[0];
  let o = 0, a = "", l = -1;
  for (let m = 1; m < i.length; ++m) {
    const g = i[m];
    if (!a && (g === "-" || g === "+"))
      a = g;
    else {
      const y = Number(g);
      !o && y ? o = y : l === -1 && (l = t15 + m);
    }
  }
  l !== -1 && n(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i}`);
  let c = false, h10 = "", p = i.length;
  for (let m = 1; m < e.length; ++m) {
    const g = e[m];
    switch (g.type) {
      case "space":
        c = true;
      case "newline":
        p += g.source.length;
        break;
      case "comment":
        r && !c && n(g, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), p += g.source.length, h10 = g.source.substring(1);
        break;
      case "error":
        n(g, "UNEXPECTED_TOKEN", g.message), p += g.source.length;
        break;
      default: {
        const y = `Unexpected token in block scalar header: ${g.type}`;
        n(g, "UNEXPECTED_TOKEN", y);
        const x = g.source;
        x && typeof x == "string" && (p += x.length);
      }
    }
  }
  return { mode: s, indent: o, chomp: a, comment: h10, length: p };
}
function vL(t15) {
  const e = t15.split(/\n( *)/), r = e[0], n = r.match(/^( *)/), i = [(n == null ? void 0 : n[1]) ? [n[1], r.slice(n[1].length)] : ["", r]];
  for (let s = 1; s < e.length; s += 2)
    i.push([e[s], e[s + 1]]);
  return i;
}
function _L(t15, e, r) {
  const { offset: n, type: i, source: s, end: o } = t15;
  let a, l;
  const c = (m, g, y) => r(n + m, g, y);
  switch (i) {
    case "scalar":
      a = Zt.PLAIN, l = CL(s, c);
      break;
    case "single-quoted-scalar":
      a = Zt.QUOTE_SINGLE, l = SL(s, c);
      break;
    case "double-quoted-scalar":
      a = Zt.QUOTE_DOUBLE, l = TL(s, c);
      break;
    default:
      return r(t15, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i}`), {
        value: "",
        type: null,
        comment: "",
        range: [n, n + s.length, n + s.length]
      };
  }
  const h10 = n + s.length, p = oc(o, h10, e, r);
  return {
    value: l,
    type: a,
    comment: p.comment,
    range: [n, h10, p.offset]
  };
}
function CL(t15, e) {
  let r = "";
  switch (t15[0]) {
    case "	":
      r = "a tab character";
      break;
    case ",":
      r = "flow indicator character ,";
      break;
    case "%":
      r = "directive indicator character %";
      break;
    case "|":
    case ">": {
      r = `block scalar indicator ${t15[0]}`;
      break;
    }
    case "@":
    case "`": {
      r = `reserved character ${t15[0]}`;
      break;
    }
  }
  return r && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${r}`), I3(t15);
}
function SL(t15, e) {
  return (t15[t15.length - 1] !== "'" || t15.length === 1) && e(t15.length, "MISSING_CHAR", "Missing closing 'quote"), I3(t15.slice(1, -1)).replace(/''/g, "'");
}
function I3(t15) {
  let e, r;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), r = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, r = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let n = e.exec(t15);
  if (!n)
    return t15;
  let i = n[1], s = " ", o = e.lastIndex;
  for (r.lastIndex = o; n = r.exec(t15); )
    n[1] === "" ? s === `
` ? i += s : s = `
` : (i += s + n[1], s = " "), o = r.lastIndex;
  const a = /[ \t]*(.*)/sy;
  return a.lastIndex = o, n = a.exec(t15), i + s + ((n == null ? void 0 : n[1]) ?? "");
}
function TL(t15, e) {
  let r = "";
  for (let n = 1; n < t15.length - 1; ++n) {
    const i = t15[n];
    if (!(i === "\r" && t15[n + 1] === `
`))
      if (i === `
`) {
        const { fold: s, offset: o } = AL(t15, n);
        r += s, n = o;
      } else if (i === "\\") {
        let s = t15[++n];
        const o = $L[s];
        if (o)
          r += o;
        else if (s === `
`)
          for (s = t15[n + 1]; s === " " || s === "	"; )
            s = t15[++n + 1];
        else if (s === "\r" && t15[n + 1] === `
`)
          for (s = t15[++n + 1]; s === " " || s === "	"; )
            s = t15[++n + 1];
        else if (s === "x" || s === "u" || s === "U") {
          const a = { x: 2, u: 4, U: 8 }[s];
          r += EL(t15, n + 1, a, e), n += a;
        } else {
          const a = t15.substr(n - 1, 2);
          e(n - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), r += a;
        }
      } else if (i === " " || i === "	") {
        const s = n;
        let o = t15[n + 1];
        for (; o === " " || o === "	"; )
          o = t15[++n + 1];
        o !== `
` && !(o === "\r" && t15[n + 2] === `
`) && (r += n > s ? t15.slice(s, n + 1) : i);
      } else
        r += i;
  }
  return (t15[t15.length - 1] !== '"' || t15.length === 1) && e(t15.length, "MISSING_CHAR", 'Missing closing "quote'), r;
}
function AL(t15, e) {
  let r = "", n = t15[e + 1];
  for (; (n === " " || n === "	" || n === `
` || n === "\r") && !(n === "\r" && t15[e + 2] !== `
`); )
    n === `
` && (r += `
`), e += 1, n = t15[e + 1];
  return r || (r = " "), { fold: r, offset: e };
}
var $L = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: " ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function EL(t15, e, r, n) {
  const i = t15.substr(e, r), s = i.length === r && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
  if (isNaN(s)) {
    const o = t15.substr(e - 2, r + 2);
    return n(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${o}`), o;
  }
  return String.fromCodePoint(s);
}
function O3(t15, e, r, n) {
  const { value: i, type: s, comment: o, range: a } = e.type === "block-scalar" ? wL(t15, e, n) : _L(e, t15.options.strict, n), l = r ? t15.directives.tagName(r.source, (p) => n(r, "TAG_RESOLVE_FAILED", p)) : null;
  let c;
  t15.options.stringKeys && t15.atKey ? c = t15.schema[ei] : l ? c = ML(t15.schema, i, l, r, n) : e.type === "scalar" ? c = BL(t15, i, e, n) : c = t15.schema[ei];
  let h10;
  try {
    const p = c.resolve(i, (m) => n(r ?? e, "TAG_RESOLVE_FAILED", m), t15.options);
    h10 = Te(p) ? p : new Zt(p);
  } catch (p) {
    const m = p instanceof Error ? p.message : String(p);
    n(r ?? e, "TAG_RESOLVE_FAILED", m), h10 = new Zt(i);
  }
  return h10.range = a, h10.source = i, s && (h10.type = s), l && (h10.tag = l), c.format && (h10.format = c.format), o && (h10.comment = o), h10;
}
function ML(t15, e, r, n, i) {
  var _a2;
  if (r === "!")
    return t15[ei];
  const s = [];
  for (const a of t15.tags)
    if (!a.collection && a.tag === r)
      if (a.default && a.test)
        s.push(a);
      else
        return a;
  for (const a of s)
    if ((_a2 = a.test) == null ? void 0 : _a2.test(e))
      return a;
  const o = t15.knownTags[r];
  return o && !o.collection ? (t15.tags.push(Object.assign({}, o, { default: false, test: void 0 })), o) : (i(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${r}`, r !== "tag:yaml.org,2002:str"), t15[ei]);
}
function BL({ atKey: t15, directives: e, schema: r }, n, i, s) {
  const o = r.tags.find((a) => {
    var _a2;
    return (a.default === true || t15 && a.default === "key") && ((_a2 = a.test) == null ? void 0 : _a2.test(n));
  }) || r[ei];
  if (r.compat) {
    const a = r.compat.find((l) => {
      var _a2;
      return l.default && ((_a2 = l.test) == null ? void 0 : _a2.test(n));
    }) ?? r[ei];
    if (o.tag !== a.tag) {
      const l = e.tagString(o.tag), c = e.tagString(a.tag), h10 = `Value may be parsed as either ${l} or ${c}`;
      s(i, "TAG_RESOLVE_FAILED", h10, true);
    }
  }
  return o;
}
function LL(t15, e, r) {
  if (e) {
    r ?? (r = e.length);
    for (let n = r - 1; n >= 0; --n) {
      let i = e[n];
      switch (i.type) {
        case "space":
        case "comment":
        case "newline":
          t15 -= i.source.length;
          continue;
      }
      for (i = e[++n]; (i == null ? void 0 : i.type) === "space"; )
        t15 += i.source.length, i = e[++n];
      break;
    }
  }
  return t15;
}
var DL = { composeNode: z3, composeEmptyNode: ym };
function z3(t15, e, r, n) {
  const i = t15.atKey, { spaceBefore: s, comment: o, anchor: a, tag: l } = r;
  let c, h10 = true;
  switch (e.type) {
    case "alias":
      c = FL(t15, e, n), (a || l) && n(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      c = O3(t15, e, l, n), a && (c.anchor = a.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      c = xL(DL, t15, e, r, n), a && (c.anchor = a.source.substring(1));
      break;
    default: {
      const p = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      n(e, "UNEXPECTED_TOKEN", p), c = ym(t15, e.offset, void 0, null, r, n), h10 = false;
    }
  }
  return a && c.anchor === "" && n(a, "BAD_ALIAS", "Anchor cannot be an empty string"), i && t15.options.stringKeys && (!Te(c) || typeof c.value != "string" || c.tag && c.tag !== "tag:yaml.org,2002:str") && n(l ?? e, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), s && (c.spaceBefore = true), o && (e.type === "scalar" && e.source === "" ? c.comment = o : c.commentBefore = o), t15.options.keepSourceTokens && h10 && (c.srcToken = e), c;
}
function ym(t15, e, r, n, { spaceBefore: i, comment: s, anchor: o, tag: a, end: l }, c) {
  const h10 = {
    type: "scalar",
    offset: LL(e, r, n),
    indent: -1,
    source: ""
  }, p = O3(t15, h10, a, c);
  return o && (p.anchor = o.source.substring(1), p.anchor === "" && c(o, "BAD_ALIAS", "Anchor cannot be an empty string")), i && (p.spaceBefore = true), s && (p.comment = s, p.range[2] = l), p;
}
function FL({ options: t15 }, { offset: e, source: r, end: n }, i) {
  const s = new om(r.substring(1));
  s.source === "" && i(e, "BAD_ALIAS", "Alias cannot be an empty string"), s.source.endsWith(":") && i(e + r.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const o = e + r.length, a = oc(n, o, t15.strict, i);
  return s.range = [e, o, a.offset], a.comment && (s.comment = a.comment), s;
}
function NL(t15, e, { offset: r, start: n, value: i, end: s }, o) {
  const a = Object.assign({ _directives: e }, t15), l = new L3(void 0, a), c = {
    atKey: false,
    atRoot: true,
    directives: l.directives,
    options: l.options,
    schema: l.schema
  }, h10 = Xo(n, {
    indicator: "doc-start",
    next: i ?? (s == null ? void 0 : s[0]),
    offset: r,
    onError: o,
    parentIndent: 0,
    startOnNewline: true
  });
  h10.found && (l.directives.docStart = true, i && (i.type === "block-map" || i.type === "block-seq") && !h10.hasNewline && o(h10.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l.contents = i ? z3(c, i, h10, o) : ym(c, h10.end, n, null, h10, o);
  const p = l.contents.range[2], m = oc(s, p, false, o);
  return m.comment && (l.comment = m.comment), l.range = [r, p, m.offset], l;
}
function Na(t15) {
  if (typeof t15 == "number")
    return [t15, t15 + 1];
  if (Array.isArray(t15))
    return t15.length === 2 ? t15 : [t15[0], t15[1]];
  const { offset: e, source: r } = t15;
  return [e, e + (typeof r == "string" ? r.length : 1)];
}
function V2(t15) {
  var _a2;
  let e = "", r = false, n = false;
  for (let i = 0; i < t15.length; ++i) {
    const s = t15[i];
    switch (s[0]) {
      case "#":
        e += (e === "" ? "" : n ? `

` : `
`) + (s.substring(1) || " "), r = true, n = false;
        break;
      case "%":
        ((_a2 = t15[i + 1]) == null ? void 0 : _a2[0]) !== "#" && (i += 1), r = false;
        break;
      default:
        r || (n = true), r = false;
    }
  }
  return { comment: e, afterEmptyLine: n };
}
var IL = class {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = false, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (r, n, i, s) => {
      const o = Na(r);
      s ? this.warnings.push(new mL(o, n, i)) : this.errors.push(new rl(o, n, i));
    }, this.directives = new Tr({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, r) {
    const { comment: n, afterEmptyLine: i } = V2(this.prelude);
    if (n) {
      const s = e.contents;
      if (r)
        e.comment = e.comment ? `${e.comment}
${n}` : n;
      else if (i || e.directives.docStart || !s)
        e.commentBefore = n;
      else if (Pe(s) && !s.flow && s.items.length > 0) {
        let o = s.items[0];
        He(o) && (o = o.key);
        const a = o.commentBefore;
        o.commentBefore = a ? `${n}
${a}` : n;
      } else {
        const o = s.commentBefore;
        s.commentBefore = o ? `${n}
${o}` : n;
      }
    }
    r ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: V2(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, r = false, n = -1) {
    for (const i of e)
      yield* this.next(i);
    yield* this.end(r, n);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (r, n, i) => {
          const s = Na(e);
          s[0] += r, this.onError(s, "BAD_DIRECTIVE", n, i);
        }), this.prelude.push(e.source), this.atDirectives = true;
        break;
      case "document": {
        const r = NL(this.options, this.directives, e, this.onError);
        this.atDirectives && !r.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(r, false), this.doc && (yield this.doc), this.doc = r, this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const r = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, n = new rl(Na(e), "UNEXPECTED_TOKEN", r);
        this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const n = "Unexpected doc-end without preceding document";
          this.errors.push(new rl(Na(e), "UNEXPECTED_TOKEN", n));
          break;
        }
        this.doc.directives.docEnd = true;
        const r = oc(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, true), r.comment) {
          const n = this.doc.comment;
          this.doc.comment = n ? `${n}
${r.comment}` : r.comment;
        }
        this.doc.range[2] = r.offset;
        break;
      }
      default:
        this.errors.push(new rl(Na(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = false, r = -1) {
    if (this.doc)
      this.decorate(this.doc, true), yield this.doc, this.doc = null;
    else if (e) {
      const n = Object.assign({ _directives: this.directives }, this.options), i = new L3(void 0, n);
      this.atDirectives && this.onError(r, "MISSING_CHAR", "Missing directives-end indicator line"), i.range = [0, r, r], this.decorate(i, false), yield i;
    }
  }
};
var q3 = "\uFEFF";
var R3 = "";
var P3 = "";
var ff = "";
function OL(t15) {
  switch (t15) {
    case q3:
      return "byte-order-mark";
    case R3:
      return "doc-mode";
    case P3:
      return "flow-error-end";
    case ff:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (t15[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function _n(t15) {
  switch (t15) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var G2 = new Set("0123456789ABCDEFabcdef");
var zL = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var Qc = new Set(",[]{}");
var qL = new Set(` ,[]{}
\r	`);
var Jd = (t15) => !t15 || qL.has(t15);
var RL = class {
  constructor() {
    this.atEnd = false, this.blockScalarIndent = -1, this.blockScalarKeep = false, this.buffer = "", this.flowKey = false, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, r = false) {
    if (e) {
      if (typeof e != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null;
    }
    this.atEnd = !r;
    let n = this.next ?? "stream";
    for (; n && (r || this.hasChars(1)); )
      n = yield* this.parseNext(n);
  }
  atLineEnd() {
    let e = this.pos, r = this.buffer[e];
    for (; r === " " || r === "	"; )
      r = this.buffer[++e];
    return !r || r === "#" || r === `
` ? true : r === "\r" ? this.buffer[e + 1] === `
` : false;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let r = this.buffer[e];
    if (this.indentNext > 0) {
      let n = 0;
      for (; r === " "; )
        r = this.buffer[++n + e];
      if (r === "\r") {
        const i = this.buffer[n + e + 1];
        if (i === `
` || !i && !this.atEnd)
          return e + n + 1;
      }
      return r === `
` || n >= this.indentNext || !r && !this.atEnd ? e + n : -1;
    }
    if (r === "-" || r === ".") {
      const n = this.buffer.substr(e, 3);
      if ((n === "---" || n === "...") && _n(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === q3 && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let r = e.length, n = e.indexOf("#");
      for (; n !== -1; ) {
        const s = e[n - 1];
        if (s === " " || s === "	") {
          r = n - 1;
          break;
        } else
          n = e.indexOf("#", n + 1);
      }
      for (; ; ) {
        const s = e[r - 1];
        if (s === " " || s === "	")
          r -= 1;
        else
          break;
      }
      const i = (yield* this.pushCount(r)) + (yield* this.pushSpaces(true));
      return yield* this.pushCount(e.length - i), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const r = yield* this.pushSpaces(true);
      return yield* this.pushCount(e.length - r), yield* this.pushNewline(), "stream";
    }
    return yield R3, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const r = this.peek(3);
      if ((r === "---" || r === "...") && _n(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, r === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(false), this.indentNext > this.indentValue && !_n(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, r] = this.peek(2);
    if (!r && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && _n(r)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let r = yield* this.pushIndicators();
    switch (e[r]) {
      case "#":
        yield* this.pushCount(e.length - r);
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = false, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(Jd), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return r += yield* this.parseBlockScalarHeader(), r += yield* this.pushSpaces(true), yield* this.pushCount(e.length - r), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, r, n = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (r = yield* this.pushSpaces(false), this.indentValue = n = r) : r = 0, r += yield* this.pushSpaces(true);
    while (e + r > 0);
    const i = this.getLine();
    if (i === null)
      return this.setNext("flow");
    if ((n !== -1 && n < this.indentNext && i[0] !== "#" || n === 0 && (i.startsWith("---") || i.startsWith("...")) && _n(i[3])) && !(n === this.indentNext - 1 && this.flowLevel === 1 && (i[0] === "]" || i[0] === "}")))
      return this.flowLevel = 0, yield P3, yield* this.parseLineStart();
    let s = 0;
    for (; i[s] === ","; )
      s += yield* this.pushCount(1), s += yield* this.pushSpaces(true), this.flowKey = false;
    switch (s += yield* this.pushIndicators(), i[s]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(i.length - s), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = false, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = true, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(Jd), "flow";
      case '"':
      case "'":
        return this.flowKey = true, yield* this.parseQuotedScalar();
      case ":": {
        const o = this.charAt(1);
        if (this.flowKey || _n(o) || o === ",")
          return this.flowKey = false, yield* this.pushCount(1), yield* this.pushSpaces(true), "flow";
      }
      default:
        return this.flowKey = false, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let r = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; r !== -1 && this.buffer[r + 1] === "'"; )
        r = this.buffer.indexOf("'", r + 2);
    else
      for (; r !== -1; ) {
        let s = 0;
        for (; this.buffer[r - 1 - s] === "\\"; )
          s += 1;
        if (s % 2 === 0)
          break;
        r = this.buffer.indexOf('"', r + 1);
      }
    const n = this.buffer.substring(0, r);
    let i = n.indexOf(`
`, this.pos);
    if (i !== -1) {
      for (; i !== -1; ) {
        const s = this.continueScalar(i + 1);
        if (s === -1)
          break;
        i = n.indexOf(`
`, s);
      }
      i !== -1 && (r = i - (n[i - 1] === "\r" ? 2 : 1));
    }
    if (r === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      r = this.buffer.length;
    }
    return yield* this.pushToIndex(r + 1, false), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = false;
    let e = this.pos;
    for (; ; ) {
      const r = this.buffer[++e];
      if (r === "+")
        this.blockScalarKeep = true;
      else if (r > "0" && r <= "9")
        this.blockScalarIndent = Number(r) - 1;
      else if (r !== "-")
        break;
    }
    return yield* this.pushUntil((r) => _n(r) || r === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, r = 0, n;
    t: for (let s = this.pos; n = this.buffer[s]; ++s)
      switch (n) {
        case " ":
          r += 1;
          break;
        case `
`:
          e = s, r = 0;
          break;
        case "\r": {
          const o = this.buffer[s + 1];
          if (!o && !this.atEnd)
            return this.setNext("block-scalar");
          if (o === `
`)
            break;
        }
        default:
          break t;
      }
    if (!n && !this.atEnd)
      return this.setNext("block-scalar");
    if (r >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = r : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const s = this.continueScalar(e + 1);
        if (s === -1)
          break;
        e = this.buffer.indexOf(`
`, s);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    let i = e + 1;
    for (n = this.buffer[i]; n === " "; )
      n = this.buffer[++i];
    if (n === "	") {
      for (; n === "	" || n === " " || n === "\r" || n === `
`; )
        n = this.buffer[++i];
      e = i - 1;
    } else if (!this.blockScalarKeep)
      do {
        let s = e - 1, o = this.buffer[s];
        o === "\r" && (o = this.buffer[--s]);
        const a = s;
        for (; o === " "; )
          o = this.buffer[--s];
        if (o === `
` && s >= this.pos && s + 1 + r > a)
          e = s;
        else
          break;
      } while (true);
    return yield ff, yield* this.pushToIndex(e + 1, true), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let r = this.pos - 1, n = this.pos - 1, i;
    for (; i = this.buffer[++n]; )
      if (i === ":") {
        const s = this.buffer[n + 1];
        if (_n(s) || e && Qc.has(s))
          break;
        r = n;
      } else if (_n(i)) {
        let s = this.buffer[n + 1];
        if (i === "\r" && (s === `
` ? (n += 1, i = `
`, s = this.buffer[n + 1]) : r = n), s === "#" || e && Qc.has(s))
          break;
        if (i === `
`) {
          const o = this.continueScalar(n + 1);
          if (o === -1)
            break;
          n = Math.max(n, o - 2);
        }
      } else {
        if (e && Qc.has(i))
          break;
        r = n;
      }
    return !i && !this.atEnd ? this.setNext("plain-scalar") : (yield ff, yield* this.pushToIndex(r + 1, true), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, r) {
    const n = this.buffer.slice(this.pos, e);
    return n ? (yield n, this.pos += n.length, n.length) : (r && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(Jd)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const e = this.flowLevel > 0, r = this.charAt(1);
        if (_n(r) || e && Qc.has(r))
          return e ? this.flowKey && (this.flowKey = false) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, r = this.buffer[e];
      for (; !_n(r) && r !== ">"; )
        r = this.buffer[++e];
      return yield* this.pushToIndex(r === ">" ? e + 1 : e, false);
    } else {
      let e = this.pos + 1, r = this.buffer[e];
      for (; r; )
        if (zL.has(r))
          r = this.buffer[++e];
        else if (r === "%" && G2.has(this.buffer[e + 1]) && G2.has(this.buffer[e + 2]))
          r = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, false);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let r = this.pos - 1, n;
    do
      n = this.buffer[++r];
    while (n === " " || e && n === "	");
    const i = r - this.pos;
    return i > 0 && (yield this.buffer.substr(this.pos, i), this.pos = r), i;
  }
  *pushUntil(e) {
    let r = this.pos, n = this.buffer[r];
    for (; !e(n); )
      n = this.buffer[++r];
    return yield* this.pushToIndex(r, false);
  }
};
var PL = class {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let r = 0, n = this.lineStarts.length;
      for (; r < n; ) {
        const s = r + n >> 1;
        this.lineStarts[s] < e ? r = s + 1 : n = s;
      }
      if (this.lineStarts[r] === e)
        return { line: r + 1, col: 1 };
      if (r === 0)
        return { line: 0, col: e };
      const i = this.lineStarts[r - 1];
      return { line: r, col: e - i + 1 };
    };
  }
};
function Zi(t15, e) {
  for (let r = 0; r < t15.length; ++r)
    if (t15[r].type === e)
      return true;
  return false;
}
function X2(t15) {
  for (let e = 0; e < t15.length; ++e)
    switch (t15[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function j3(t15) {
  switch (t15 == null ? void 0 : t15.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function Jc(t15) {
  switch (t15.type) {
    case "document":
      return t15.start;
    case "block-map": {
      const e = t15.items[t15.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return t15.items[t15.items.length - 1].start;
    default:
      return [];
  }
}
function Co(t15) {
  var _a2;
  if (t15.length === 0)
    return [];
  let e = t15.length;
  t: for (; --e >= 0; )
    switch (t15[e].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break t;
    }
  for (; ((_a2 = t15[++e]) == null ? void 0 : _a2.type) === "space"; )
    ;
  return t15.splice(e, t15.length);
}
function Y2(t15) {
  if (t15.start.type === "flow-seq-start")
    for (const e of t15.items)
      e.sep && !e.value && !Zi(e.start, "explicit-key-ind") && !Zi(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, j3(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
var jL = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = true, this.atScalar = false, this.indent = 0, this.offset = 0, this.onKeyLine = false, this.stack = [], this.source = "", this.type = "", this.lexer = new RL(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, r = false) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const n of this.lexer.lex(e, r))
      yield* this.next(n);
    r || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = false, yield* this.step(), this.offset += e.length;
      return;
    }
    const r = OL(e);
    if (r)
      if (r === "scalar")
        this.atNewLine = false, this.atScalar = true, this.type = "scalar";
      else {
        switch (this.type = r, yield* this.step(), r) {
          case "newline":
            this.atNewLine = true, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += e.length;
      }
    else {
      const n = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: n, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const r = e ?? this.stack.pop();
    if (!r)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield r;
    else {
      const n = this.peek(1);
      switch (r.type === "block-scalar" ? r.indent = "indent" in n ? n.indent : 0 : r.type === "flow-collection" && n.type === "document" && (r.indent = 0), r.type === "flow-collection" && Y2(r), n.type) {
        case "document":
          n.value = r;
          break;
        case "block-scalar":
          n.props.push(r);
          break;
        case "block-map": {
          const i = n.items[n.items.length - 1];
          if (i.value) {
            n.items.push({ start: [], key: r, sep: [] }), this.onKeyLine = true;
            return;
          } else if (i.sep)
            i.value = r;
          else {
            Object.assign(i, { key: r, sep: [] }), this.onKeyLine = !i.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const i = n.items[n.items.length - 1];
          i.value ? n.items.push({ start: [], value: r }) : i.value = r;
          break;
        }
        case "flow-collection": {
          const i = n.items[n.items.length - 1];
          !i || i.value ? n.items.push({ start: [], key: r, sep: [] }) : i.sep ? i.value = r : Object.assign(i, { key: r, sep: [] });
          return;
        }
        default:
          yield* this.pop(), yield* this.pop(r);
      }
      if ((n.type === "document" || n.type === "block-map" || n.type === "block-seq") && (r.type === "block-map" || r.type === "block-seq")) {
        const i = r.items[r.items.length - 1];
        i && !i.sep && !i.value && i.start.length > 0 && X2(i.start) === -1 && (r.indent === 0 || i.start.every((s) => s.type !== "comment" || s.indent < r.indent)) && (n.type === "document" ? n.end = i.start : n.items.push({ start: i.start }), r.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        X2(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const r = this.startBlockValue(e);
    r ? this.stack.push(r) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const r = Jc(this.peek(2)), n = Co(r);
      let i;
      e.end ? (i = e.end, i.push(this.sourceToken), delete e.end) : i = [this.sourceToken];
      const s = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: n, key: e, sep: i }]
      };
      this.onKeyLine = true, this.stack[this.stack.length - 1] = s;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = true, this.indent = 0, this.onNewLine) {
          let r = this.source.indexOf(`
`) + 1;
          for (; r !== 0; )
            this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    var _a2, _b2, _c;
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = false, r.value) {
          const n = "end" in r.value ? r.value.end : void 0;
          ((_a2 = Array.isArray(n) ? n[n.length - 1] : void 0) == null ? void 0 : _a2.type) === "comment" ? n == null ? void 0 : n.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else if (r.sep)
          r.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const n = (_c = (_b2 = e.items[e.items.length - 2]) == null ? void 0 : _b2.value) == null ? void 0 : _c.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, r.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const n = !this.onKeyLine && this.indent === e.indent, i = n && (r.sep || r.explicitKey) && this.type !== "seq-item-ind";
      let s = [];
      if (i && r.sep && !r.value) {
        const o = [];
        for (let a = 0; a < r.sep.length; ++a) {
          const l = r.sep[a];
          switch (l.type) {
            case "newline":
              o.push(a);
              break;
            case "space":
              break;
            case "comment":
              l.indent > e.indent && (o.length = 0);
              break;
            default:
              o.length = 0;
          }
        }
        o.length >= 2 && (s = r.sep.splice(o[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          i || r.value ? (s.push(this.sourceToken), e.items.push({ start: s }), this.onKeyLine = true) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !r.sep && !r.explicitKey ? (r.start.push(this.sourceToken), r.explicitKey = true) : i || r.value ? (s.push(this.sourceToken), e.items.push({ start: s, explicitKey: true })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: true }]
          }), this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (r.explicitKey)
            if (r.sep)
              if (r.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Zi(r.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: s, key: null, sep: [this.sourceToken] }]
                });
              else if (j3(r.key) && !Zi(r.sep, "newline")) {
                const o = Co(r.start), a = r.key, l = r.sep;
                l.push(this.sourceToken), delete r.key, delete r.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: a, sep: l }]
                });
              } else s.length > 0 ? r.sep = r.sep.concat(s, this.sourceToken) : r.sep.push(this.sourceToken);
            else if (Zi(r.start, "newline"))
              Object.assign(r, { key: null, sep: [this.sourceToken] });
            else {
              const o = Co(r.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: o, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            r.sep ? r.value || i ? e.items.push({ start: s, key: null, sep: [this.sourceToken] }) : Zi(r.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const o = this.flowScalar(this.type);
          i || r.value ? (e.items.push({ start: s, key: o, sep: [] }), this.onKeyLine = true) : r.sep ? this.stack.push(o) : (Object.assign(r, { key: o, sep: [] }), this.onKeyLine = true);
          return;
        }
        default: {
          const o = this.startBlockValue(e);
          if (o) {
            if (o.type === "block-seq") {
              if (!r.explicitKey && r.sep && !Zi(r.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else n && e.items.push({ start: s });
            this.stack.push(o);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    var _a2, _b2, _c;
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (r.value) {
          const n = "end" in r.value ? r.value.end : void 0;
          ((_a2 = Array.isArray(n) ? n[n.length - 1] : void 0) == null ? void 0 : _a2.type) === "comment" ? n == null ? void 0 : n.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const n = (_c = (_b2 = e.items[e.items.length - 2]) == null ? void 0 : _b2.value) == null ? void 0 : _c.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, r.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (r.value || this.indent <= e.indent)
          break;
        r.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        r.value || Zi(r.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const n = this.startBlockValue(e);
      if (n) {
        this.stack.push(n);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const r = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let n;
      do
        yield* this.pop(), n = this.peek(1);
      while (n && n.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !r || r.sep ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !r || r.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !r || r.value ? e.items.push({ start: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          !r || r.value ? e.items.push({ start: [], key: i, sep: [] }) : r.sep ? this.stack.push(i) : Object.assign(r, { key: i, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const n = this.startBlockValue(e);
      n ? this.stack.push(n) : (yield* this.pop(), yield* this.step());
    } else {
      const n = this.peek(2);
      if (n.type === "block-map" && (this.type === "map-value-ind" && n.indent === e.indent || this.type === "newline" && !n.items[n.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && n.type !== "flow-collection") {
        const i = Jc(n), s = Co(i);
        Y2(e);
        const o = e.end.splice(1, e.end.length);
        o.push(this.sourceToken);
        const a = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: s, key: e, sep: o }]
        };
        this.onKeyLine = true, this.stack[this.stack.length - 1] = a;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let r = this.source.indexOf(`
`) + 1;
      for (; r !== 0; )
        this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const r = Jc(e), n = Co(r);
        return n.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const r = Jc(e), n = Co(r);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, r) {
    return this.type !== "comment" || this.indent <= r ? false : e.every((n) => n.type === "newline" || n.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
};
function WL(t15) {
  const e = t15.prettyErrors !== false;
  return { lineCounter: t15.lineCounter || e && new PL() || null, prettyErrors: e };
}
function HL(t15, e = {}) {
  const { lineCounter: r, prettyErrors: n } = WL(e), i = new jL(r == null ? void 0 : r.addNewLine), s = new IL(e);
  let o = null;
  for (const a of s.compose(i.parse(t15), true, t15.length))
    if (!o)
      o = a;
    else if (o.options.logLevel !== "silent") {
      o.errors.push(new rl(a.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return n && r && (o.errors.forEach(H2(t15, r)), o.warnings.forEach(H2(t15, r))), o;
}
function UL(t15, e, r) {
  let n;
  const i = HL(t15, r);
  if (!i)
    return null;
  if (i.warnings.forEach((s) => c3(i.options.logLevel, s)), i.errors.length > 0) {
    if (i.options.logLevel !== "silent")
      throw i.errors[0];
    i.errors = [];
  }
  return i.toJS(Object.assign({ reviver: n }, r));
}
function VL(t15) {
  return t15 && t15.__esModule && Object.prototype.hasOwnProperty.call(t15, "default") ? t15.default : t15;
}
var So = {};
var mf = { exports: {} };
var GL = mf.exports;
var K2;
function XL() {
  return K2 || (K2 = 1, function(t15, e) {
    (function(r, n) {
      t15.exports = n();
    })(typeof self < "u" ? self : GL, function() {
      return (
        /******/
        function() {
          var r = {};
          (function() {
            r.d = function(d, u) {
              for (var f in u)
                r.o(u, f) && !r.o(d, f) && Object.defineProperty(d, f, { enumerable: true, get: u[f] });
            };
          })(), function() {
            r.o = function(d, u) {
              return Object.prototype.hasOwnProperty.call(d, u);
            };
          }();
          var n = {};
          r.d(n, {
            default: function() {
              return (
                /* binding */
                AC
              );
            }
          });
          class i {
            // Error start position based on passed-in Token or ParseNode.
            // Length of affected text based on passed-in Token or ParseNode.
            // The underlying error message without any context added.
            constructor(u, f) {
              this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
              let b = "KaTeX parse error: " + u, w, T;
              const E = f && f.loc;
              if (E && E.start <= E.end) {
                const P = E.lexer.input;
                w = E.start, T = E.end, w === P.length ? b += " at end of input: " : b += " at position " + (w + 1) + ": ";
                const Q = P.slice(w, T).replace(/[^]/g, "$&̲");
                let nt;
                w > 15 ? nt = "…" + P.slice(w - 15, w) : nt = P.slice(0, w);
                let it;
                T + 15 < P.length ? it = P.slice(T, T + 15) + "…" : it = P.slice(T), b += nt + Q + it;
              }
              const D = new Error(b);
              return D.name = "ParseError", D.__proto__ = i.prototype, D.position = w, w != null && T != null && (D.length = T - w), D.rawMessage = u, D;
            }
          }
          i.prototype.__proto__ = Error.prototype;
          var s = i;
          const o = function(d, u) {
            return d.indexOf(u) !== -1;
          }, a = function(d, u) {
            return d === void 0 ? u : d;
          }, l = /([A-Z])/g, c = function(d) {
            return d.replace(l, "-$1").toLowerCase();
          }, h10 = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;",
            "'": "&#x27;"
          }, p = /[&><"']/g;
          function m(d) {
            return String(d).replace(p, (u) => h10[u]);
          }
          const g = function(d) {
            return d.type === "ordgroup" || d.type === "color" ? d.body.length === 1 ? g(d.body[0]) : d : d.type === "font" ? g(d.body) : d;
          }, y = function(d) {
            const u = g(d);
            return u.type === "mathord" || u.type === "textord" || u.type === "atom";
          }, x = function(d) {
            if (!d)
              throw new Error("Expected non-null, but got " + String(d));
            return d;
          };
          var k = {
            contains: o,
            deflt: a,
            escape: m,
            hyphenate: c,
            getBaseElem: g,
            isCharacterBox: y,
            protocolFromUrl: function(d) {
              const u = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(d);
              return u ? u[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(u[1]) ? null : u[1].toLowerCase() : "_relative";
            }
          };
          const C = {
            displayMode: {
              type: "boolean",
              description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
              cli: "-d, --display-mode"
            },
            output: {
              type: {
                enum: ["htmlAndMathml", "html", "mathml"]
              },
              description: "Determines the markup language of the output.",
              cli: "-F, --format <type>"
            },
            leqno: {
              type: "boolean",
              description: "Render display math in leqno style (left-justified tags)."
            },
            fleqn: {
              type: "boolean",
              description: "Render display math flush left."
            },
            throwOnError: {
              type: "boolean",
              default: true,
              cli: "-t, --no-throw-on-error",
              cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
            },
            errorColor: {
              type: "string",
              default: "#cc0000",
              cli: "-c, --error-color <color>",
              cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
              cliProcessor: (d) => "#" + d
            },
            macros: {
              type: "object",
              cli: "-m, --macro <def>",
              cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
              cliDefault: [],
              cliProcessor: (d, u) => (u.push(d), u)
            },
            minRuleThickness: {
              type: "number",
              description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
              processor: (d) => Math.max(0, d),
              cli: "--min-rule-thickness <size>",
              cliProcessor: parseFloat
            },
            colorIsTextColor: {
              type: "boolean",
              description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
              cli: "-b, --color-is-text-color"
            },
            strict: {
              type: [{
                enum: ["warn", "ignore", "error"]
              }, "boolean", "function"],
              description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
              cli: "-S, --strict",
              cliDefault: false
            },
            trust: {
              type: ["boolean", "function"],
              description: "Trust the input, enabling all HTML features such as \\url.",
              cli: "-T, --trust"
            },
            maxSize: {
              type: "number",
              default: 1 / 0,
              description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
              processor: (d) => Math.max(0, d),
              cli: "-s, --max-size <n>",
              cliProcessor: parseInt
            },
            maxExpand: {
              type: "number",
              default: 1e3,
              description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
              processor: (d) => Math.max(0, d),
              cli: "-e, --max-expand <n>",
              cliProcessor: (d) => d === "Infinity" ? 1 / 0 : parseInt(d)
            },
            globalGroup: {
              type: "boolean",
              cli: false
            }
          };
          function _(d) {
            if (d.default)
              return d.default;
            const u = d.type, f = Array.isArray(u) ? u[0] : u;
            if (typeof f != "string")
              return f.enum[0];
            switch (f) {
              case "boolean":
                return false;
              case "string":
                return "";
              case "number":
                return 0;
              case "object":
                return {};
            }
          }
          class $ {
            constructor(u) {
              this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, u = u || {};
              for (const f in C)
                if (C.hasOwnProperty(f)) {
                  const b = C[f];
                  this[f] = u[f] !== void 0 ? b.processor ? b.processor(u[f]) : u[f] : _(b);
                }
            }
            /**
             * Report nonstrict (non-LaTeX-compatible) input.
             * Can safely not be called if `this.strict` is false in JavaScript.
             */
            reportNonstrict(u, f, b) {
              let w = this.strict;
              if (typeof w == "function" && (w = w(u, f, b)), !(!w || w === "ignore")) {
                if (w === true || w === "error")
                  throw new s("LaTeX-incompatible input and strict mode is set to 'error': " + (f + " [" + u + "]"), b);
                w === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (f + " [" + u + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + w + "': " + f + " [" + u + "]"));
              }
            }
            /**
             * Check whether to apply strict (LaTeX-adhering) behavior for unusual
             * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
             * instead, "error" translates to a return value of `true`, while "ignore"
             * translates to a return value of `false`.  May still print a warning:
             * "warn" prints a warning and returns `false`.
             * This is for the second category of `errorCode`s listed in the README.
             */
            useStrictBehavior(u, f, b) {
              let w = this.strict;
              if (typeof w == "function")
                try {
                  w = w(u, f, b);
                } catch {
                  w = "error";
                }
              return !w || w === "ignore" ? false : w === true || w === "error" ? true : w === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (f + " [" + u + "]")), false) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + w + "': " + f + " [" + u + "]")), false);
            }
            /**
             * Check whether to test potentially dangerous input, and return
             * `true` (trusted) or `false` (untrusted).  The sole argument `context`
             * should be an object with `command` field specifying the relevant LaTeX
             * command (as a string starting with `\`), and any other arguments, etc.
             * If `context` has a `url` field, a `protocol` field will automatically
             * get added by this function (changing the specified object).
             */
            isTrusted(u) {
              if (u.url && !u.protocol) {
                const f = k.protocolFromUrl(u.url);
                if (f == null)
                  return false;
                u.protocol = f;
              }
              return !!(typeof this.trust == "function" ? this.trust(u) : this.trust);
            }
          }
          class L {
            constructor(u, f, b) {
              this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = u, this.size = f, this.cramped = b;
            }
            /**
             * Get the style of a superscript given a base in the current style.
             */
            sup() {
              return rt[I[this.id]];
            }
            /**
             * Get the style of a subscript given a base in the current style.
             */
            sub() {
              return rt[j[this.id]];
            }
            /**
             * Get the style of a fraction numerator given the fraction in the current
             * style.
             */
            fracNum() {
              return rt[z[this.id]];
            }
            /**
             * Get the style of a fraction denominator given the fraction in the current
             * style.
             */
            fracDen() {
              return rt[K[this.id]];
            }
            /**
             * Get the cramped version of a style (in particular, cramping a cramped style
             * doesn't change the style).
             */
            cramp() {
              return rt[Y[this.id]];
            }
            /**
             * Get a text or display version of this style.
             */
            text() {
              return rt[at[this.id]];
            }
            /**
             * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
             */
            isTight() {
              return this.size >= 2;
            }
          }
          const B = 0, q = 1, H = 2, G = 3, F = 4, W = 5, R = 6, J = 7, rt = [new L(B, 0, false), new L(q, 0, true), new L(H, 1, false), new L(G, 1, true), new L(F, 2, false), new L(W, 2, true), new L(R, 3, false), new L(J, 3, true)], I = [F, W, F, W, R, J, R, J], j = [W, W, W, W, J, J, J, J], z = [H, G, F, W, R, J, R, J], K = [G, G, W, W, J, J, J, J], Y = [q, q, G, G, W, W, J, J], at = [B, q, H, G, H, G, H, G];
          var et = {
            DISPLAY: rt[B],
            TEXT: rt[H],
            SCRIPT: rt[F],
            SCRIPTSCRIPT: rt[R]
          };
          const ht = [{
            // Latin characters beyond the Latin-1 characters we have metrics for.
            // Needed for Czech, Hungarian and Turkish text, for example.
            name: "latin",
            blocks: [
              [256, 591],
              // Latin Extended-A and Latin Extended-B
              [768, 879]
              // Combining Diacritical marks
            ]
          }, {
            // The Cyrillic script used by Russian and related languages.
            // A Cyrillic subset used to be supported as explicitly defined
            // symbols in symbols.js
            name: "cyrillic",
            blocks: [[1024, 1279]]
          }, {
            // Armenian
            name: "armenian",
            blocks: [[1328, 1423]]
          }, {
            // The Brahmic scripts of South and Southeast Asia
            // Devanagari (0900–097F)
            // Bengali (0980–09FF)
            // Gurmukhi (0A00–0A7F)
            // Gujarati (0A80–0AFF)
            // Oriya (0B00–0B7F)
            // Tamil (0B80–0BFF)
            // Telugu (0C00–0C7F)
            // Kannada (0C80–0CFF)
            // Malayalam (0D00–0D7F)
            // Sinhala (0D80–0DFF)
            // Thai (0E00–0E7F)
            // Lao (0E80–0EFF)
            // Tibetan (0F00–0FFF)
            // Myanmar (1000–109F)
            name: "brahmic",
            blocks: [[2304, 4255]]
          }, {
            name: "georgian",
            blocks: [[4256, 4351]]
          }, {
            // Chinese and Japanese.
            // The "k" in cjk is for Korean, but we've separated Korean out
            name: "cjk",
            blocks: [
              [12288, 12543],
              // CJK symbols and punctuation, Hiragana, Katakana
              [19968, 40879],
              // CJK ideograms
              [65280, 65376]
              // Fullwidth punctuation
              // TODO: add halfwidth Katakana and Romanji glyphs
            ]
          }, {
            // Korean
            name: "hangul",
            blocks: [[44032, 55215]]
          }];
          function X(d) {
            for (let u = 0; u < ht.length; u++) {
              const f = ht[u];
              for (let b = 0; b < f.blocks.length; b++) {
                const w = f.blocks[b];
                if (d >= w[0] && d <= w[1])
                  return f.name;
              }
            }
            return null;
          }
          const ct = [];
          ht.forEach((d) => d.blocks.forEach((u) => ct.push(...u)));
          function gt(d) {
            for (let u = 0; u < ct.length; u += 2)
              if (d >= ct[u] && d <= ct[u + 1])
                return true;
            return false;
          }
          const xt = 80, Yt = function(d, u) {
            return "M95," + (622 + d + u) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + d / 2.075 + " -" + d + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + d) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + d) + " " + u + "h400000v" + (40 + d) + "h-400000z";
          }, U = function(d, u) {
            return "M263," + (601 + d + u) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + d / 2.084 + " -" + d + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + d) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + d) + " " + u + "h400000v" + (40 + d) + "h-400000z";
          }, mt = function(d, u) {
            return "M983 " + (10 + d + u) + `
l` + d / 3.13 + " -" + d + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + d) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + d) + " " + u + "h400000v" + (40 + d) + "h-400000z";
          }, wt = function(d, u) {
            return "M424," + (2398 + d + u) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + d / 4.223 + " -" + d + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + d) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + d) + " " + u + `
h400000v` + (40 + d) + "h-400000z";
          }, Tt = function(d, u) {
            return "M473," + (2713 + d + u) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + d / 5.298 + " -" + d + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + d) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + d) + " " + u + "h400000v" + (40 + d) + "H1017.7z";
          }, Ut = function(d) {
            const u = d / 2;
            return "M400000 " + d + " H0 L" + u + " 0 l65 45 L145 " + (d - 80) + " H400000z";
          }, Ce = function(d, u, f) {
            const b = f - 54 - u - d;
            return "M702 " + (d + u) + "H400000" + (40 + d) + `
H742v` + b + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + u + "H400000v" + (40 + d) + "H742z";
          }, ue = function(d, u, f) {
            u = 1e3 * u;
            let b = "";
            switch (d) {
              case "sqrtMain":
                b = Yt(u, xt);
                break;
              case "sqrtSize1":
                b = U(u, xt);
                break;
              case "sqrtSize2":
                b = mt(u, xt);
                break;
              case "sqrtSize3":
                b = wt(u, xt);
                break;
              case "sqrtSize4":
                b = Tt(u, xt);
                break;
              case "sqrtTall":
                b = Ce(u, xt, f);
            }
            return b;
          }, ci = function(d, u) {
            switch (d) {
              case "⎜":
                return "M291 0 H417 V" + u + " H291z M291 0 H417 V" + u + " H291z";
              case "∣":
                return "M145 0 H188 V" + u + " H145z M145 0 H188 V" + u + " H145z";
              case "∥":
                return "M145 0 H188 V" + u + " H145z M145 0 H188 V" + u + " H145z" + ("M367 0 H410 V" + u + " H367z M367 0 H410 V" + u + " H367z");
              case "⎟":
                return "M457 0 H583 V" + u + " H457z M457 0 H583 V" + u + " H457z";
              case "⎢":
                return "M319 0 H403 V" + u + " H319z M319 0 H403 V" + u + " H319z";
              case "⎥":
                return "M263 0 H347 V" + u + " H263z M263 0 H347 V" + u + " H263z";
              case "⎪":
                return "M384 0 H504 V" + u + " H384z M384 0 H504 V" + u + " H384z";
              case "⏐":
                return "M312 0 H355 V" + u + " H312z M312 0 H355 V" + u + " H312z";
              case "‖":
                return "M257 0 H300 V" + u + " H257z M257 0 H300 V" + u + " H257z" + ("M478 0 H521 V" + u + " H478z M478 0 H521 V" + u + " H478z");
              default:
                return "";
            }
          }, mo = {
            // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
            doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
            // doublerightarrow is from glyph U+21D2 in font KaTeX Main
            doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
            // leftarrow is from glyph U+2190 in font KaTeX Main
            leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
            // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
            leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
            leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
            // overgroup is from the MnSymbol package (public domain)
            leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
            leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
            // Harpoons are from glyph U+21BD in font KaTeX Main
            leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
            leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
            leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
            leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
            // hook is from glyph U+21A9 in font KaTeX Main
            lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
            leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
            leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
            // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
            leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
            longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
            midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
            midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
            oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
            oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
            oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
            oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
            rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
            rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
            rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
            rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
            rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
            rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
            rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
            rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
            rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
            righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
            rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
            rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
            // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
            twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
            twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
            // tilde1 is a modified version of a glyph from the MnSymbol package
            tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
            // ditto tilde2, tilde3, & tilde4
            tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
            tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
            tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
            // vec is from glyph U+20D7 in font KaTeX Main
            vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
            // widehat1 is a modified version of a glyph from the MnSymbol package
            widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
            // ditto widehat2, widehat3, & widehat4
            widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            // widecheck paths are all inverted versions of widehat
            widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
            widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            // The next ten paths support reaction arrows from the mhchem package.
            // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
            // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
            baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
            // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
            rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
            // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
            // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
            baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
            rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
            shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
            shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
          }, va = function(d, u) {
            switch (d) {
              case "lbrack":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + u + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + u + " v1759 h84z";
              case "rbrack":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + u + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + u + " v1759 h84z";
              case "vert":
                return "M145 15 v585 v" + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + u + " v585 h43z";
              case "doublevert":
                return "M145 15 v585 v" + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + u + ` v585 h43z
M367 15 v585 v` + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + u + " v585 h43z";
              case "lfloor":
                return "M319 602 V0 H403 V602 v" + u + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + u + " v1715 H319z";
              case "rfloor":
                return "M319 602 V0 H403 V602 v" + u + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + u + " v1715 H319z";
              case "lceil":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + u + ` v602 h84z
M403 1759 V0 H319 V1759 v` + u + " v602 h84z";
              case "rceil":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + u + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + u + " v602 h84z";
              case "lparen":
                return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (u + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (u + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
              case "rparen":
                return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (u + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (u + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
              default:
                throw new Error("Unknown stretchy delimiter.");
            }
          };
          class sn {
            // HtmlDomNode
            // Never used; needed for satisfying interface.
            constructor(u) {
              this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = u, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            /** Convert the fragment into a node. */
            toNode() {
              const u = document.createDocumentFragment();
              for (let f = 0; f < this.children.length; f++)
                u.appendChild(this.children[f].toNode());
              return u;
            }
            /** Convert the fragment into HTML markup. */
            toMarkup() {
              let u = "";
              for (let f = 0; f < this.children.length; f++)
                u += this.children[f].toMarkup();
              return u;
            }
            /**
             * Converts the math node into a string, similar to innerText. Applies to
             * MathDomNode's only.
             */
            toText() {
              const u = (f) => f.toText();
              return this.children.map(u).join("");
            }
          }
          var wr = {
            "AMS-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.68889, 0, 0, 0.72222],
              66: [0, 0.68889, 0, 0, 0.66667],
              67: [0, 0.68889, 0, 0, 0.72222],
              68: [0, 0.68889, 0, 0, 0.72222],
              69: [0, 0.68889, 0, 0, 0.66667],
              70: [0, 0.68889, 0, 0, 0.61111],
              71: [0, 0.68889, 0, 0, 0.77778],
              72: [0, 0.68889, 0, 0, 0.77778],
              73: [0, 0.68889, 0, 0, 0.38889],
              74: [0.16667, 0.68889, 0, 0, 0.5],
              75: [0, 0.68889, 0, 0, 0.77778],
              76: [0, 0.68889, 0, 0, 0.66667],
              77: [0, 0.68889, 0, 0, 0.94445],
              78: [0, 0.68889, 0, 0, 0.72222],
              79: [0.16667, 0.68889, 0, 0, 0.77778],
              80: [0, 0.68889, 0, 0, 0.61111],
              81: [0.16667, 0.68889, 0, 0, 0.77778],
              82: [0, 0.68889, 0, 0, 0.72222],
              83: [0, 0.68889, 0, 0, 0.55556],
              84: [0, 0.68889, 0, 0, 0.66667],
              85: [0, 0.68889, 0, 0, 0.72222],
              86: [0, 0.68889, 0, 0, 0.72222],
              87: [0, 0.68889, 0, 0, 1],
              88: [0, 0.68889, 0, 0, 0.72222],
              89: [0, 0.68889, 0, 0, 0.72222],
              90: [0, 0.68889, 0, 0, 0.66667],
              107: [0, 0.68889, 0, 0, 0.55556],
              160: [0, 0, 0, 0, 0.25],
              165: [0, 0.675, 0.025, 0, 0.75],
              174: [0.15559, 0.69224, 0, 0, 0.94666],
              240: [0, 0.68889, 0, 0, 0.55556],
              295: [0, 0.68889, 0, 0, 0.54028],
              710: [0, 0.825, 0, 0, 2.33334],
              732: [0, 0.9, 0, 0, 2.33334],
              770: [0, 0.825, 0, 0, 2.33334],
              771: [0, 0.9, 0, 0, 2.33334],
              989: [0.08167, 0.58167, 0, 0, 0.77778],
              1008: [0, 0.43056, 0.04028, 0, 0.66667],
              8245: [0, 0.54986, 0, 0, 0.275],
              8463: [0, 0.68889, 0, 0, 0.54028],
              8487: [0, 0.68889, 0, 0, 0.72222],
              8498: [0, 0.68889, 0, 0, 0.55556],
              8502: [0, 0.68889, 0, 0, 0.66667],
              8503: [0, 0.68889, 0, 0, 0.44445],
              8504: [0, 0.68889, 0, 0, 0.66667],
              8513: [0, 0.68889, 0, 0, 0.63889],
              8592: [-0.03598, 0.46402, 0, 0, 0.5],
              8594: [-0.03598, 0.46402, 0, 0, 0.5],
              8602: [-0.13313, 0.36687, 0, 0, 1],
              8603: [-0.13313, 0.36687, 0, 0, 1],
              8606: [0.01354, 0.52239, 0, 0, 1],
              8608: [0.01354, 0.52239, 0, 0, 1],
              8610: [0.01354, 0.52239, 0, 0, 1.11111],
              8611: [0.01354, 0.52239, 0, 0, 1.11111],
              8619: [0, 0.54986, 0, 0, 1],
              8620: [0, 0.54986, 0, 0, 1],
              8621: [-0.13313, 0.37788, 0, 0, 1.38889],
              8622: [-0.13313, 0.36687, 0, 0, 1],
              8624: [0, 0.69224, 0, 0, 0.5],
              8625: [0, 0.69224, 0, 0, 0.5],
              8630: [0, 0.43056, 0, 0, 1],
              8631: [0, 0.43056, 0, 0, 1],
              8634: [0.08198, 0.58198, 0, 0, 0.77778],
              8635: [0.08198, 0.58198, 0, 0, 0.77778],
              8638: [0.19444, 0.69224, 0, 0, 0.41667],
              8639: [0.19444, 0.69224, 0, 0, 0.41667],
              8642: [0.19444, 0.69224, 0, 0, 0.41667],
              8643: [0.19444, 0.69224, 0, 0, 0.41667],
              8644: [0.1808, 0.675, 0, 0, 1],
              8646: [0.1808, 0.675, 0, 0, 1],
              8647: [0.1808, 0.675, 0, 0, 1],
              8648: [0.19444, 0.69224, 0, 0, 0.83334],
              8649: [0.1808, 0.675, 0, 0, 1],
              8650: [0.19444, 0.69224, 0, 0, 0.83334],
              8651: [0.01354, 0.52239, 0, 0, 1],
              8652: [0.01354, 0.52239, 0, 0, 1],
              8653: [-0.13313, 0.36687, 0, 0, 1],
              8654: [-0.13313, 0.36687, 0, 0, 1],
              8655: [-0.13313, 0.36687, 0, 0, 1],
              8666: [0.13667, 0.63667, 0, 0, 1],
              8667: [0.13667, 0.63667, 0, 0, 1],
              8669: [-0.13313, 0.37788, 0, 0, 1],
              8672: [-0.064, 0.437, 0, 0, 1.334],
              8674: [-0.064, 0.437, 0, 0, 1.334],
              8705: [0, 0.825, 0, 0, 0.5],
              8708: [0, 0.68889, 0, 0, 0.55556],
              8709: [0.08167, 0.58167, 0, 0, 0.77778],
              8717: [0, 0.43056, 0, 0, 0.42917],
              8722: [-0.03598, 0.46402, 0, 0, 0.5],
              8724: [0.08198, 0.69224, 0, 0, 0.77778],
              8726: [0.08167, 0.58167, 0, 0, 0.77778],
              8733: [0, 0.69224, 0, 0, 0.77778],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8737: [0, 0.69224, 0, 0, 0.72222],
              8738: [0.03517, 0.52239, 0, 0, 0.72222],
              8739: [0.08167, 0.58167, 0, 0, 0.22222],
              8740: [0.25142, 0.74111, 0, 0, 0.27778],
              8741: [0.08167, 0.58167, 0, 0, 0.38889],
              8742: [0.25142, 0.74111, 0, 0, 0.5],
              8756: [0, 0.69224, 0, 0, 0.66667],
              8757: [0, 0.69224, 0, 0, 0.66667],
              8764: [-0.13313, 0.36687, 0, 0, 0.77778],
              8765: [-0.13313, 0.37788, 0, 0, 0.77778],
              8769: [-0.13313, 0.36687, 0, 0, 0.77778],
              8770: [-0.03625, 0.46375, 0, 0, 0.77778],
              8774: [0.30274, 0.79383, 0, 0, 0.77778],
              8776: [-0.01688, 0.48312, 0, 0, 0.77778],
              8778: [0.08167, 0.58167, 0, 0, 0.77778],
              8782: [0.06062, 0.54986, 0, 0, 0.77778],
              8783: [0.06062, 0.54986, 0, 0, 0.77778],
              8785: [0.08198, 0.58198, 0, 0, 0.77778],
              8786: [0.08198, 0.58198, 0, 0, 0.77778],
              8787: [0.08198, 0.58198, 0, 0, 0.77778],
              8790: [0, 0.69224, 0, 0, 0.77778],
              8791: [0.22958, 0.72958, 0, 0, 0.77778],
              8796: [0.08198, 0.91667, 0, 0, 0.77778],
              8806: [0.25583, 0.75583, 0, 0, 0.77778],
              8807: [0.25583, 0.75583, 0, 0, 0.77778],
              8808: [0.25142, 0.75726, 0, 0, 0.77778],
              8809: [0.25142, 0.75726, 0, 0, 0.77778],
              8812: [0.25583, 0.75583, 0, 0, 0.5],
              8814: [0.20576, 0.70576, 0, 0, 0.77778],
              8815: [0.20576, 0.70576, 0, 0, 0.77778],
              8816: [0.30274, 0.79383, 0, 0, 0.77778],
              8817: [0.30274, 0.79383, 0, 0, 0.77778],
              8818: [0.22958, 0.72958, 0, 0, 0.77778],
              8819: [0.22958, 0.72958, 0, 0, 0.77778],
              8822: [0.1808, 0.675, 0, 0, 0.77778],
              8823: [0.1808, 0.675, 0, 0, 0.77778],
              8828: [0.13667, 0.63667, 0, 0, 0.77778],
              8829: [0.13667, 0.63667, 0, 0, 0.77778],
              8830: [0.22958, 0.72958, 0, 0, 0.77778],
              8831: [0.22958, 0.72958, 0, 0, 0.77778],
              8832: [0.20576, 0.70576, 0, 0, 0.77778],
              8833: [0.20576, 0.70576, 0, 0, 0.77778],
              8840: [0.30274, 0.79383, 0, 0, 0.77778],
              8841: [0.30274, 0.79383, 0, 0, 0.77778],
              8842: [0.13597, 0.63597, 0, 0, 0.77778],
              8843: [0.13597, 0.63597, 0, 0, 0.77778],
              8847: [0.03517, 0.54986, 0, 0, 0.77778],
              8848: [0.03517, 0.54986, 0, 0, 0.77778],
              8858: [0.08198, 0.58198, 0, 0, 0.77778],
              8859: [0.08198, 0.58198, 0, 0, 0.77778],
              8861: [0.08198, 0.58198, 0, 0, 0.77778],
              8862: [0, 0.675, 0, 0, 0.77778],
              8863: [0, 0.675, 0, 0, 0.77778],
              8864: [0, 0.675, 0, 0, 0.77778],
              8865: [0, 0.675, 0, 0, 0.77778],
              8872: [0, 0.69224, 0, 0, 0.61111],
              8873: [0, 0.69224, 0, 0, 0.72222],
              8874: [0, 0.69224, 0, 0, 0.88889],
              8876: [0, 0.68889, 0, 0, 0.61111],
              8877: [0, 0.68889, 0, 0, 0.61111],
              8878: [0, 0.68889, 0, 0, 0.72222],
              8879: [0, 0.68889, 0, 0, 0.72222],
              8882: [0.03517, 0.54986, 0, 0, 0.77778],
              8883: [0.03517, 0.54986, 0, 0, 0.77778],
              8884: [0.13667, 0.63667, 0, 0, 0.77778],
              8885: [0.13667, 0.63667, 0, 0, 0.77778],
              8888: [0, 0.54986, 0, 0, 1.11111],
              8890: [0.19444, 0.43056, 0, 0, 0.55556],
              8891: [0.19444, 0.69224, 0, 0, 0.61111],
              8892: [0.19444, 0.69224, 0, 0, 0.61111],
              8901: [0, 0.54986, 0, 0, 0.27778],
              8903: [0.08167, 0.58167, 0, 0, 0.77778],
              8905: [0.08167, 0.58167, 0, 0, 0.77778],
              8906: [0.08167, 0.58167, 0, 0, 0.77778],
              8907: [0, 0.69224, 0, 0, 0.77778],
              8908: [0, 0.69224, 0, 0, 0.77778],
              8909: [-0.03598, 0.46402, 0, 0, 0.77778],
              8910: [0, 0.54986, 0, 0, 0.76042],
              8911: [0, 0.54986, 0, 0, 0.76042],
              8912: [0.03517, 0.54986, 0, 0, 0.77778],
              8913: [0.03517, 0.54986, 0, 0, 0.77778],
              8914: [0, 0.54986, 0, 0, 0.66667],
              8915: [0, 0.54986, 0, 0, 0.66667],
              8916: [0, 0.69224, 0, 0, 0.66667],
              8918: [0.0391, 0.5391, 0, 0, 0.77778],
              8919: [0.0391, 0.5391, 0, 0, 0.77778],
              8920: [0.03517, 0.54986, 0, 0, 1.33334],
              8921: [0.03517, 0.54986, 0, 0, 1.33334],
              8922: [0.38569, 0.88569, 0, 0, 0.77778],
              8923: [0.38569, 0.88569, 0, 0, 0.77778],
              8926: [0.13667, 0.63667, 0, 0, 0.77778],
              8927: [0.13667, 0.63667, 0, 0, 0.77778],
              8928: [0.30274, 0.79383, 0, 0, 0.77778],
              8929: [0.30274, 0.79383, 0, 0, 0.77778],
              8934: [0.23222, 0.74111, 0, 0, 0.77778],
              8935: [0.23222, 0.74111, 0, 0, 0.77778],
              8936: [0.23222, 0.74111, 0, 0, 0.77778],
              8937: [0.23222, 0.74111, 0, 0, 0.77778],
              8938: [0.20576, 0.70576, 0, 0, 0.77778],
              8939: [0.20576, 0.70576, 0, 0, 0.77778],
              8940: [0.30274, 0.79383, 0, 0, 0.77778],
              8941: [0.30274, 0.79383, 0, 0, 0.77778],
              8994: [0.19444, 0.69224, 0, 0, 0.77778],
              8995: [0.19444, 0.69224, 0, 0, 0.77778],
              9416: [0.15559, 0.69224, 0, 0, 0.90222],
              9484: [0, 0.69224, 0, 0, 0.5],
              9488: [0, 0.69224, 0, 0, 0.5],
              9492: [0, 0.37788, 0, 0, 0.5],
              9496: [0, 0.37788, 0, 0, 0.5],
              9585: [0.19444, 0.68889, 0, 0, 0.88889],
              9586: [0.19444, 0.74111, 0, 0, 0.88889],
              9632: [0, 0.675, 0, 0, 0.77778],
              9633: [0, 0.675, 0, 0, 0.77778],
              9650: [0, 0.54986, 0, 0, 0.72222],
              9651: [0, 0.54986, 0, 0, 0.72222],
              9654: [0.03517, 0.54986, 0, 0, 0.77778],
              9660: [0, 0.54986, 0, 0, 0.72222],
              9661: [0, 0.54986, 0, 0, 0.72222],
              9664: [0.03517, 0.54986, 0, 0, 0.77778],
              9674: [0.11111, 0.69224, 0, 0, 0.66667],
              9733: [0.19444, 0.69224, 0, 0, 0.94445],
              10003: [0, 0.69224, 0, 0, 0.83334],
              10016: [0, 0.69224, 0, 0, 0.83334],
              10731: [0.11111, 0.69224, 0, 0, 0.66667],
              10846: [0.19444, 0.75583, 0, 0, 0.61111],
              10877: [0.13667, 0.63667, 0, 0, 0.77778],
              10878: [0.13667, 0.63667, 0, 0, 0.77778],
              10885: [0.25583, 0.75583, 0, 0, 0.77778],
              10886: [0.25583, 0.75583, 0, 0, 0.77778],
              10887: [0.13597, 0.63597, 0, 0, 0.77778],
              10888: [0.13597, 0.63597, 0, 0, 0.77778],
              10889: [0.26167, 0.75726, 0, 0, 0.77778],
              10890: [0.26167, 0.75726, 0, 0, 0.77778],
              10891: [0.48256, 0.98256, 0, 0, 0.77778],
              10892: [0.48256, 0.98256, 0, 0, 0.77778],
              10901: [0.13667, 0.63667, 0, 0, 0.77778],
              10902: [0.13667, 0.63667, 0, 0, 0.77778],
              10933: [0.25142, 0.75726, 0, 0, 0.77778],
              10934: [0.25142, 0.75726, 0, 0, 0.77778],
              10935: [0.26167, 0.75726, 0, 0, 0.77778],
              10936: [0.26167, 0.75726, 0, 0, 0.77778],
              10937: [0.26167, 0.75726, 0, 0, 0.77778],
              10938: [0.26167, 0.75726, 0, 0, 0.77778],
              10949: [0.25583, 0.75583, 0, 0, 0.77778],
              10950: [0.25583, 0.75583, 0, 0, 0.77778],
              10955: [0.28481, 0.79383, 0, 0, 0.77778],
              10956: [0.28481, 0.79383, 0, 0, 0.77778],
              57350: [0.08167, 0.58167, 0, 0, 0.22222],
              57351: [0.08167, 0.58167, 0, 0, 0.38889],
              57352: [0.08167, 0.58167, 0, 0, 0.77778],
              57353: [0, 0.43056, 0.04028, 0, 0.66667],
              57356: [0.25142, 0.75726, 0, 0, 0.77778],
              57357: [0.25142, 0.75726, 0, 0, 0.77778],
              57358: [0.41951, 0.91951, 0, 0, 0.77778],
              57359: [0.30274, 0.79383, 0, 0, 0.77778],
              57360: [0.30274, 0.79383, 0, 0, 0.77778],
              57361: [0.41951, 0.91951, 0, 0, 0.77778],
              57366: [0.25142, 0.75726, 0, 0, 0.77778],
              57367: [0.25142, 0.75726, 0, 0, 0.77778],
              57368: [0.25142, 0.75726, 0, 0, 0.77778],
              57369: [0.25142, 0.75726, 0, 0, 0.77778],
              57370: [0.13597, 0.63597, 0, 0, 0.77778],
              57371: [0.13597, 0.63597, 0, 0, 0.77778]
            },
            "Caligraphic-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.68333, 0, 0.19445, 0.79847],
              66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
              67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
              68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
              69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
              70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
              71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
              72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
              73: [0, 0.68333, 0.07382, 0, 0.54452],
              74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
              75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
              76: [0, 0.68333, 0, 0.13889, 0.68972],
              77: [0, 0.68333, 0, 0.13889, 1.2009],
              78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
              79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
              80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
              81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
              82: [0, 0.68333, 0, 0.08334, 0.8475],
              83: [0, 0.68333, 0.075, 0.13889, 0.60556],
              84: [0, 0.68333, 0.25417, 0, 0.54464],
              85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
              86: [0, 0.68333, 0.08222, 0, 0.61278],
              87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
              88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
              89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
              90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
              160: [0, 0, 0, 0, 0.25]
            },
            "Fraktur-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69141, 0, 0, 0.29574],
              34: [0, 0.69141, 0, 0, 0.21471],
              38: [0, 0.69141, 0, 0, 0.73786],
              39: [0, 0.69141, 0, 0, 0.21201],
              40: [0.24982, 0.74947, 0, 0, 0.38865],
              41: [0.24982, 0.74947, 0, 0, 0.38865],
              42: [0, 0.62119, 0, 0, 0.27764],
              43: [0.08319, 0.58283, 0, 0, 0.75623],
              44: [0, 0.10803, 0, 0, 0.27764],
              45: [0.08319, 0.58283, 0, 0, 0.75623],
              46: [0, 0.10803, 0, 0, 0.27764],
              47: [0.24982, 0.74947, 0, 0, 0.50181],
              48: [0, 0.47534, 0, 0, 0.50181],
              49: [0, 0.47534, 0, 0, 0.50181],
              50: [0, 0.47534, 0, 0, 0.50181],
              51: [0.18906, 0.47534, 0, 0, 0.50181],
              52: [0.18906, 0.47534, 0, 0, 0.50181],
              53: [0.18906, 0.47534, 0, 0, 0.50181],
              54: [0, 0.69141, 0, 0, 0.50181],
              55: [0.18906, 0.47534, 0, 0, 0.50181],
              56: [0, 0.69141, 0, 0, 0.50181],
              57: [0.18906, 0.47534, 0, 0, 0.50181],
              58: [0, 0.47534, 0, 0, 0.21606],
              59: [0.12604, 0.47534, 0, 0, 0.21606],
              61: [-0.13099, 0.36866, 0, 0, 0.75623],
              63: [0, 0.69141, 0, 0, 0.36245],
              65: [0, 0.69141, 0, 0, 0.7176],
              66: [0, 0.69141, 0, 0, 0.88397],
              67: [0, 0.69141, 0, 0, 0.61254],
              68: [0, 0.69141, 0, 0, 0.83158],
              69: [0, 0.69141, 0, 0, 0.66278],
              70: [0.12604, 0.69141, 0, 0, 0.61119],
              71: [0, 0.69141, 0, 0, 0.78539],
              72: [0.06302, 0.69141, 0, 0, 0.7203],
              73: [0, 0.69141, 0, 0, 0.55448],
              74: [0.12604, 0.69141, 0, 0, 0.55231],
              75: [0, 0.69141, 0, 0, 0.66845],
              76: [0, 0.69141, 0, 0, 0.66602],
              77: [0, 0.69141, 0, 0, 1.04953],
              78: [0, 0.69141, 0, 0, 0.83212],
              79: [0, 0.69141, 0, 0, 0.82699],
              80: [0.18906, 0.69141, 0, 0, 0.82753],
              81: [0.03781, 0.69141, 0, 0, 0.82699],
              82: [0, 0.69141, 0, 0, 0.82807],
              83: [0, 0.69141, 0, 0, 0.82861],
              84: [0, 0.69141, 0, 0, 0.66899],
              85: [0, 0.69141, 0, 0, 0.64576],
              86: [0, 0.69141, 0, 0, 0.83131],
              87: [0, 0.69141, 0, 0, 1.04602],
              88: [0, 0.69141, 0, 0, 0.71922],
              89: [0.18906, 0.69141, 0, 0, 0.83293],
              90: [0.12604, 0.69141, 0, 0, 0.60201],
              91: [0.24982, 0.74947, 0, 0, 0.27764],
              93: [0.24982, 0.74947, 0, 0, 0.27764],
              94: [0, 0.69141, 0, 0, 0.49965],
              97: [0, 0.47534, 0, 0, 0.50046],
              98: [0, 0.69141, 0, 0, 0.51315],
              99: [0, 0.47534, 0, 0, 0.38946],
              100: [0, 0.62119, 0, 0, 0.49857],
              101: [0, 0.47534, 0, 0, 0.40053],
              102: [0.18906, 0.69141, 0, 0, 0.32626],
              103: [0.18906, 0.47534, 0, 0, 0.5037],
              104: [0.18906, 0.69141, 0, 0, 0.52126],
              105: [0, 0.69141, 0, 0, 0.27899],
              106: [0, 0.69141, 0, 0, 0.28088],
              107: [0, 0.69141, 0, 0, 0.38946],
              108: [0, 0.69141, 0, 0, 0.27953],
              109: [0, 0.47534, 0, 0, 0.76676],
              110: [0, 0.47534, 0, 0, 0.52666],
              111: [0, 0.47534, 0, 0, 0.48885],
              112: [0.18906, 0.52396, 0, 0, 0.50046],
              113: [0.18906, 0.47534, 0, 0, 0.48912],
              114: [0, 0.47534, 0, 0, 0.38919],
              115: [0, 0.47534, 0, 0, 0.44266],
              116: [0, 0.62119, 0, 0, 0.33301],
              117: [0, 0.47534, 0, 0, 0.5172],
              118: [0, 0.52396, 0, 0, 0.5118],
              119: [0, 0.52396, 0, 0, 0.77351],
              120: [0.18906, 0.47534, 0, 0, 0.38865],
              121: [0.18906, 0.47534, 0, 0, 0.49884],
              122: [0.18906, 0.47534, 0, 0, 0.39054],
              160: [0, 0, 0, 0, 0.25],
              8216: [0, 0.69141, 0, 0, 0.21471],
              8217: [0, 0.69141, 0, 0, 0.21471],
              58112: [0, 0.62119, 0, 0, 0.49749],
              58113: [0, 0.62119, 0, 0, 0.4983],
              58114: [0.18906, 0.69141, 0, 0, 0.33328],
              58115: [0.18906, 0.69141, 0, 0, 0.32923],
              58116: [0.18906, 0.47534, 0, 0, 0.50343],
              58117: [0, 0.69141, 0, 0, 0.33301],
              58118: [0, 0.62119, 0, 0, 0.33409],
              58119: [0, 0.47534, 0, 0, 0.50073]
            },
            "Main-Bold": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.35],
              34: [0, 0.69444, 0, 0, 0.60278],
              35: [0.19444, 0.69444, 0, 0, 0.95833],
              36: [0.05556, 0.75, 0, 0, 0.575],
              37: [0.05556, 0.75, 0, 0, 0.95833],
              38: [0, 0.69444, 0, 0, 0.89444],
              39: [0, 0.69444, 0, 0, 0.31944],
              40: [0.25, 0.75, 0, 0, 0.44722],
              41: [0.25, 0.75, 0, 0, 0.44722],
              42: [0, 0.75, 0, 0, 0.575],
              43: [0.13333, 0.63333, 0, 0, 0.89444],
              44: [0.19444, 0.15556, 0, 0, 0.31944],
              45: [0, 0.44444, 0, 0, 0.38333],
              46: [0, 0.15556, 0, 0, 0.31944],
              47: [0.25, 0.75, 0, 0, 0.575],
              48: [0, 0.64444, 0, 0, 0.575],
              49: [0, 0.64444, 0, 0, 0.575],
              50: [0, 0.64444, 0, 0, 0.575],
              51: [0, 0.64444, 0, 0, 0.575],
              52: [0, 0.64444, 0, 0, 0.575],
              53: [0, 0.64444, 0, 0, 0.575],
              54: [0, 0.64444, 0, 0, 0.575],
              55: [0, 0.64444, 0, 0, 0.575],
              56: [0, 0.64444, 0, 0, 0.575],
              57: [0, 0.64444, 0, 0, 0.575],
              58: [0, 0.44444, 0, 0, 0.31944],
              59: [0.19444, 0.44444, 0, 0, 0.31944],
              60: [0.08556, 0.58556, 0, 0, 0.89444],
              61: [-0.10889, 0.39111, 0, 0, 0.89444],
              62: [0.08556, 0.58556, 0, 0, 0.89444],
              63: [0, 0.69444, 0, 0, 0.54305],
              64: [0, 0.69444, 0, 0, 0.89444],
              65: [0, 0.68611, 0, 0, 0.86944],
              66: [0, 0.68611, 0, 0, 0.81805],
              67: [0, 0.68611, 0, 0, 0.83055],
              68: [0, 0.68611, 0, 0, 0.88194],
              69: [0, 0.68611, 0, 0, 0.75555],
              70: [0, 0.68611, 0, 0, 0.72361],
              71: [0, 0.68611, 0, 0, 0.90416],
              72: [0, 0.68611, 0, 0, 0.9],
              73: [0, 0.68611, 0, 0, 0.43611],
              74: [0, 0.68611, 0, 0, 0.59444],
              75: [0, 0.68611, 0, 0, 0.90138],
              76: [0, 0.68611, 0, 0, 0.69166],
              77: [0, 0.68611, 0, 0, 1.09166],
              78: [0, 0.68611, 0, 0, 0.9],
              79: [0, 0.68611, 0, 0, 0.86388],
              80: [0, 0.68611, 0, 0, 0.78611],
              81: [0.19444, 0.68611, 0, 0, 0.86388],
              82: [0, 0.68611, 0, 0, 0.8625],
              83: [0, 0.68611, 0, 0, 0.63889],
              84: [0, 0.68611, 0, 0, 0.8],
              85: [0, 0.68611, 0, 0, 0.88472],
              86: [0, 0.68611, 0.01597, 0, 0.86944],
              87: [0, 0.68611, 0.01597, 0, 1.18888],
              88: [0, 0.68611, 0, 0, 0.86944],
              89: [0, 0.68611, 0.02875, 0, 0.86944],
              90: [0, 0.68611, 0, 0, 0.70277],
              91: [0.25, 0.75, 0, 0, 0.31944],
              92: [0.25, 0.75, 0, 0, 0.575],
              93: [0.25, 0.75, 0, 0, 0.31944],
              94: [0, 0.69444, 0, 0, 0.575],
              95: [0.31, 0.13444, 0.03194, 0, 0.575],
              97: [0, 0.44444, 0, 0, 0.55902],
              98: [0, 0.69444, 0, 0, 0.63889],
              99: [0, 0.44444, 0, 0, 0.51111],
              100: [0, 0.69444, 0, 0, 0.63889],
              101: [0, 0.44444, 0, 0, 0.52708],
              102: [0, 0.69444, 0.10903, 0, 0.35139],
              103: [0.19444, 0.44444, 0.01597, 0, 0.575],
              104: [0, 0.69444, 0, 0, 0.63889],
              105: [0, 0.69444, 0, 0, 0.31944],
              106: [0.19444, 0.69444, 0, 0, 0.35139],
              107: [0, 0.69444, 0, 0, 0.60694],
              108: [0, 0.69444, 0, 0, 0.31944],
              109: [0, 0.44444, 0, 0, 0.95833],
              110: [0, 0.44444, 0, 0, 0.63889],
              111: [0, 0.44444, 0, 0, 0.575],
              112: [0.19444, 0.44444, 0, 0, 0.63889],
              113: [0.19444, 0.44444, 0, 0, 0.60694],
              114: [0, 0.44444, 0, 0, 0.47361],
              115: [0, 0.44444, 0, 0, 0.45361],
              116: [0, 0.63492, 0, 0, 0.44722],
              117: [0, 0.44444, 0, 0, 0.63889],
              118: [0, 0.44444, 0.01597, 0, 0.60694],
              119: [0, 0.44444, 0.01597, 0, 0.83055],
              120: [0, 0.44444, 0, 0, 0.60694],
              121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
              122: [0, 0.44444, 0, 0, 0.51111],
              123: [0.25, 0.75, 0, 0, 0.575],
              124: [0.25, 0.75, 0, 0, 0.31944],
              125: [0.25, 0.75, 0, 0, 0.575],
              126: [0.35, 0.34444, 0, 0, 0.575],
              160: [0, 0, 0, 0, 0.25],
              163: [0, 0.69444, 0, 0, 0.86853],
              168: [0, 0.69444, 0, 0, 0.575],
              172: [0, 0.44444, 0, 0, 0.76666],
              176: [0, 0.69444, 0, 0, 0.86944],
              177: [0.13333, 0.63333, 0, 0, 0.89444],
              184: [0.17014, 0, 0, 0, 0.51111],
              198: [0, 0.68611, 0, 0, 1.04166],
              215: [0.13333, 0.63333, 0, 0, 0.89444],
              216: [0.04861, 0.73472, 0, 0, 0.89444],
              223: [0, 0.69444, 0, 0, 0.59722],
              230: [0, 0.44444, 0, 0, 0.83055],
              247: [0.13333, 0.63333, 0, 0, 0.89444],
              248: [0.09722, 0.54167, 0, 0, 0.575],
              305: [0, 0.44444, 0, 0, 0.31944],
              338: [0, 0.68611, 0, 0, 1.16944],
              339: [0, 0.44444, 0, 0, 0.89444],
              567: [0.19444, 0.44444, 0, 0, 0.35139],
              710: [0, 0.69444, 0, 0, 0.575],
              711: [0, 0.63194, 0, 0, 0.575],
              713: [0, 0.59611, 0, 0, 0.575],
              714: [0, 0.69444, 0, 0, 0.575],
              715: [0, 0.69444, 0, 0, 0.575],
              728: [0, 0.69444, 0, 0, 0.575],
              729: [0, 0.69444, 0, 0, 0.31944],
              730: [0, 0.69444, 0, 0, 0.86944],
              732: [0, 0.69444, 0, 0, 0.575],
              733: [0, 0.69444, 0, 0, 0.575],
              915: [0, 0.68611, 0, 0, 0.69166],
              916: [0, 0.68611, 0, 0, 0.95833],
              920: [0, 0.68611, 0, 0, 0.89444],
              923: [0, 0.68611, 0, 0, 0.80555],
              926: [0, 0.68611, 0, 0, 0.76666],
              928: [0, 0.68611, 0, 0, 0.9],
              931: [0, 0.68611, 0, 0, 0.83055],
              933: [0, 0.68611, 0, 0, 0.89444],
              934: [0, 0.68611, 0, 0, 0.83055],
              936: [0, 0.68611, 0, 0, 0.89444],
              937: [0, 0.68611, 0, 0, 0.83055],
              8211: [0, 0.44444, 0.03194, 0, 0.575],
              8212: [0, 0.44444, 0.03194, 0, 1.14999],
              8216: [0, 0.69444, 0, 0, 0.31944],
              8217: [0, 0.69444, 0, 0, 0.31944],
              8220: [0, 0.69444, 0, 0, 0.60278],
              8221: [0, 0.69444, 0, 0, 0.60278],
              8224: [0.19444, 0.69444, 0, 0, 0.51111],
              8225: [0.19444, 0.69444, 0, 0, 0.51111],
              8242: [0, 0.55556, 0, 0, 0.34444],
              8407: [0, 0.72444, 0.15486, 0, 0.575],
              8463: [0, 0.69444, 0, 0, 0.66759],
              8465: [0, 0.69444, 0, 0, 0.83055],
              8467: [0, 0.69444, 0, 0, 0.47361],
              8472: [0.19444, 0.44444, 0, 0, 0.74027],
              8476: [0, 0.69444, 0, 0, 0.83055],
              8501: [0, 0.69444, 0, 0, 0.70277],
              8592: [-0.10889, 0.39111, 0, 0, 1.14999],
              8593: [0.19444, 0.69444, 0, 0, 0.575],
              8594: [-0.10889, 0.39111, 0, 0, 1.14999],
              8595: [0.19444, 0.69444, 0, 0, 0.575],
              8596: [-0.10889, 0.39111, 0, 0, 1.14999],
              8597: [0.25, 0.75, 0, 0, 0.575],
              8598: [0.19444, 0.69444, 0, 0, 1.14999],
              8599: [0.19444, 0.69444, 0, 0, 1.14999],
              8600: [0.19444, 0.69444, 0, 0, 1.14999],
              8601: [0.19444, 0.69444, 0, 0, 1.14999],
              8636: [-0.10889, 0.39111, 0, 0, 1.14999],
              8637: [-0.10889, 0.39111, 0, 0, 1.14999],
              8640: [-0.10889, 0.39111, 0, 0, 1.14999],
              8641: [-0.10889, 0.39111, 0, 0, 1.14999],
              8656: [-0.10889, 0.39111, 0, 0, 1.14999],
              8657: [0.19444, 0.69444, 0, 0, 0.70277],
              8658: [-0.10889, 0.39111, 0, 0, 1.14999],
              8659: [0.19444, 0.69444, 0, 0, 0.70277],
              8660: [-0.10889, 0.39111, 0, 0, 1.14999],
              8661: [0.25, 0.75, 0, 0, 0.70277],
              8704: [0, 0.69444, 0, 0, 0.63889],
              8706: [0, 0.69444, 0.06389, 0, 0.62847],
              8707: [0, 0.69444, 0, 0, 0.63889],
              8709: [0.05556, 0.75, 0, 0, 0.575],
              8711: [0, 0.68611, 0, 0, 0.95833],
              8712: [0.08556, 0.58556, 0, 0, 0.76666],
              8715: [0.08556, 0.58556, 0, 0, 0.76666],
              8722: [0.13333, 0.63333, 0, 0, 0.89444],
              8723: [0.13333, 0.63333, 0, 0, 0.89444],
              8725: [0.25, 0.75, 0, 0, 0.575],
              8726: [0.25, 0.75, 0, 0, 0.575],
              8727: [-0.02778, 0.47222, 0, 0, 0.575],
              8728: [-0.02639, 0.47361, 0, 0, 0.575],
              8729: [-0.02639, 0.47361, 0, 0, 0.575],
              8730: [0.18, 0.82, 0, 0, 0.95833],
              8733: [0, 0.44444, 0, 0, 0.89444],
              8734: [0, 0.44444, 0, 0, 1.14999],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8739: [0.25, 0.75, 0, 0, 0.31944],
              8741: [0.25, 0.75, 0, 0, 0.575],
              8743: [0, 0.55556, 0, 0, 0.76666],
              8744: [0, 0.55556, 0, 0, 0.76666],
              8745: [0, 0.55556, 0, 0, 0.76666],
              8746: [0, 0.55556, 0, 0, 0.76666],
              8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
              8764: [-0.10889, 0.39111, 0, 0, 0.89444],
              8768: [0.19444, 0.69444, 0, 0, 0.31944],
              8771: [222e-5, 0.50222, 0, 0, 0.89444],
              8773: [0.027, 0.638, 0, 0, 0.894],
              8776: [0.02444, 0.52444, 0, 0, 0.89444],
              8781: [222e-5, 0.50222, 0, 0, 0.89444],
              8801: [222e-5, 0.50222, 0, 0, 0.89444],
              8804: [0.19667, 0.69667, 0, 0, 0.89444],
              8805: [0.19667, 0.69667, 0, 0, 0.89444],
              8810: [0.08556, 0.58556, 0, 0, 1.14999],
              8811: [0.08556, 0.58556, 0, 0, 1.14999],
              8826: [0.08556, 0.58556, 0, 0, 0.89444],
              8827: [0.08556, 0.58556, 0, 0, 0.89444],
              8834: [0.08556, 0.58556, 0, 0, 0.89444],
              8835: [0.08556, 0.58556, 0, 0, 0.89444],
              8838: [0.19667, 0.69667, 0, 0, 0.89444],
              8839: [0.19667, 0.69667, 0, 0, 0.89444],
              8846: [0, 0.55556, 0, 0, 0.76666],
              8849: [0.19667, 0.69667, 0, 0, 0.89444],
              8850: [0.19667, 0.69667, 0, 0, 0.89444],
              8851: [0, 0.55556, 0, 0, 0.76666],
              8852: [0, 0.55556, 0, 0, 0.76666],
              8853: [0.13333, 0.63333, 0, 0, 0.89444],
              8854: [0.13333, 0.63333, 0, 0, 0.89444],
              8855: [0.13333, 0.63333, 0, 0, 0.89444],
              8856: [0.13333, 0.63333, 0, 0, 0.89444],
              8857: [0.13333, 0.63333, 0, 0, 0.89444],
              8866: [0, 0.69444, 0, 0, 0.70277],
              8867: [0, 0.69444, 0, 0, 0.70277],
              8868: [0, 0.69444, 0, 0, 0.89444],
              8869: [0, 0.69444, 0, 0, 0.89444],
              8900: [-0.02639, 0.47361, 0, 0, 0.575],
              8901: [-0.02639, 0.47361, 0, 0, 0.31944],
              8902: [-0.02778, 0.47222, 0, 0, 0.575],
              8968: [0.25, 0.75, 0, 0, 0.51111],
              8969: [0.25, 0.75, 0, 0, 0.51111],
              8970: [0.25, 0.75, 0, 0, 0.51111],
              8971: [0.25, 0.75, 0, 0, 0.51111],
              8994: [-0.13889, 0.36111, 0, 0, 1.14999],
              8995: [-0.13889, 0.36111, 0, 0, 1.14999],
              9651: [0.19444, 0.69444, 0, 0, 1.02222],
              9657: [-0.02778, 0.47222, 0, 0, 0.575],
              9661: [0.19444, 0.69444, 0, 0, 1.02222],
              9667: [-0.02778, 0.47222, 0, 0, 0.575],
              9711: [0.19444, 0.69444, 0, 0, 1.14999],
              9824: [0.12963, 0.69444, 0, 0, 0.89444],
              9825: [0.12963, 0.69444, 0, 0, 0.89444],
              9826: [0.12963, 0.69444, 0, 0, 0.89444],
              9827: [0.12963, 0.69444, 0, 0, 0.89444],
              9837: [0, 0.75, 0, 0, 0.44722],
              9838: [0.19444, 0.69444, 0, 0, 0.44722],
              9839: [0.19444, 0.69444, 0, 0, 0.44722],
              10216: [0.25, 0.75, 0, 0, 0.44722],
              10217: [0.25, 0.75, 0, 0, 0.44722],
              10815: [0, 0.68611, 0, 0, 0.9],
              10927: [0.19667, 0.69667, 0, 0, 0.89444],
              10928: [0.19667, 0.69667, 0, 0, 0.89444],
              57376: [0.19444, 0.69444, 0, 0, 0]
            },
            "Main-BoldItalic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.11417, 0, 0.38611],
              34: [0, 0.69444, 0.07939, 0, 0.62055],
              35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
              37: [0.05556, 0.75, 0.12861, 0, 0.94444],
              38: [0, 0.69444, 0.08528, 0, 0.88555],
              39: [0, 0.69444, 0.12945, 0, 0.35555],
              40: [0.25, 0.75, 0.15806, 0, 0.47333],
              41: [0.25, 0.75, 0.03306, 0, 0.47333],
              42: [0, 0.75, 0.14333, 0, 0.59111],
              43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
              44: [0.19444, 0.14722, 0, 0, 0.35555],
              45: [0, 0.44444, 0.02611, 0, 0.41444],
              46: [0, 0.14722, 0, 0, 0.35555],
              47: [0.25, 0.75, 0.15806, 0, 0.59111],
              48: [0, 0.64444, 0.13167, 0, 0.59111],
              49: [0, 0.64444, 0.13167, 0, 0.59111],
              50: [0, 0.64444, 0.13167, 0, 0.59111],
              51: [0, 0.64444, 0.13167, 0, 0.59111],
              52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
              53: [0, 0.64444, 0.13167, 0, 0.59111],
              54: [0, 0.64444, 0.13167, 0, 0.59111],
              55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
              56: [0, 0.64444, 0.13167, 0, 0.59111],
              57: [0, 0.64444, 0.13167, 0, 0.59111],
              58: [0, 0.44444, 0.06695, 0, 0.35555],
              59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
              61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
              63: [0, 0.69444, 0.11472, 0, 0.59111],
              64: [0, 0.69444, 0.09208, 0, 0.88555],
              65: [0, 0.68611, 0, 0, 0.86555],
              66: [0, 0.68611, 0.0992, 0, 0.81666],
              67: [0, 0.68611, 0.14208, 0, 0.82666],
              68: [0, 0.68611, 0.09062, 0, 0.87555],
              69: [0, 0.68611, 0.11431, 0, 0.75666],
              70: [0, 0.68611, 0.12903, 0, 0.72722],
              71: [0, 0.68611, 0.07347, 0, 0.89527],
              72: [0, 0.68611, 0.17208, 0, 0.8961],
              73: [0, 0.68611, 0.15681, 0, 0.47166],
              74: [0, 0.68611, 0.145, 0, 0.61055],
              75: [0, 0.68611, 0.14208, 0, 0.89499],
              76: [0, 0.68611, 0, 0, 0.69777],
              77: [0, 0.68611, 0.17208, 0, 1.07277],
              78: [0, 0.68611, 0.17208, 0, 0.8961],
              79: [0, 0.68611, 0.09062, 0, 0.85499],
              80: [0, 0.68611, 0.0992, 0, 0.78721],
              81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
              82: [0, 0.68611, 0.02559, 0, 0.85944],
              83: [0, 0.68611, 0.11264, 0, 0.64999],
              84: [0, 0.68611, 0.12903, 0, 0.7961],
              85: [0, 0.68611, 0.17208, 0, 0.88083],
              86: [0, 0.68611, 0.18625, 0, 0.86555],
              87: [0, 0.68611, 0.18625, 0, 1.15999],
              88: [0, 0.68611, 0.15681, 0, 0.86555],
              89: [0, 0.68611, 0.19803, 0, 0.86555],
              90: [0, 0.68611, 0.14208, 0, 0.70888],
              91: [0.25, 0.75, 0.1875, 0, 0.35611],
              93: [0.25, 0.75, 0.09972, 0, 0.35611],
              94: [0, 0.69444, 0.06709, 0, 0.59111],
              95: [0.31, 0.13444, 0.09811, 0, 0.59111],
              97: [0, 0.44444, 0.09426, 0, 0.59111],
              98: [0, 0.69444, 0.07861, 0, 0.53222],
              99: [0, 0.44444, 0.05222, 0, 0.53222],
              100: [0, 0.69444, 0.10861, 0, 0.59111],
              101: [0, 0.44444, 0.085, 0, 0.53222],
              102: [0.19444, 0.69444, 0.21778, 0, 0.4],
              103: [0.19444, 0.44444, 0.105, 0, 0.53222],
              104: [0, 0.69444, 0.09426, 0, 0.59111],
              105: [0, 0.69326, 0.11387, 0, 0.35555],
              106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
              107: [0, 0.69444, 0.11111, 0, 0.53222],
              108: [0, 0.69444, 0.10861, 0, 0.29666],
              109: [0, 0.44444, 0.09426, 0, 0.94444],
              110: [0, 0.44444, 0.09426, 0, 0.64999],
              111: [0, 0.44444, 0.07861, 0, 0.59111],
              112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
              113: [0.19444, 0.44444, 0.105, 0, 0.53222],
              114: [0, 0.44444, 0.11111, 0, 0.50167],
              115: [0, 0.44444, 0.08167, 0, 0.48694],
              116: [0, 0.63492, 0.09639, 0, 0.385],
              117: [0, 0.44444, 0.09426, 0, 0.62055],
              118: [0, 0.44444, 0.11111, 0, 0.53222],
              119: [0, 0.44444, 0.11111, 0, 0.76777],
              120: [0, 0.44444, 0.12583, 0, 0.56055],
              121: [0.19444, 0.44444, 0.105, 0, 0.56166],
              122: [0, 0.44444, 0.13889, 0, 0.49055],
              126: [0.35, 0.34444, 0.11472, 0, 0.59111],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.69444, 0.11473, 0, 0.59111],
              176: [0, 0.69444, 0, 0, 0.94888],
              184: [0.17014, 0, 0, 0, 0.53222],
              198: [0, 0.68611, 0.11431, 0, 1.02277],
              216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
              223: [0.19444, 0.69444, 0.09736, 0, 0.665],
              230: [0, 0.44444, 0.085, 0, 0.82666],
              248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
              305: [0, 0.44444, 0.09426, 0, 0.35555],
              338: [0, 0.68611, 0.11431, 0, 1.14054],
              339: [0, 0.44444, 0.085, 0, 0.82666],
              567: [0.19444, 0.44444, 0.04611, 0, 0.385],
              710: [0, 0.69444, 0.06709, 0, 0.59111],
              711: [0, 0.63194, 0.08271, 0, 0.59111],
              713: [0, 0.59444, 0.10444, 0, 0.59111],
              714: [0, 0.69444, 0.08528, 0, 0.59111],
              715: [0, 0.69444, 0, 0, 0.59111],
              728: [0, 0.69444, 0.10333, 0, 0.59111],
              729: [0, 0.69444, 0.12945, 0, 0.35555],
              730: [0, 0.69444, 0, 0, 0.94888],
              732: [0, 0.69444, 0.11472, 0, 0.59111],
              733: [0, 0.69444, 0.11472, 0, 0.59111],
              915: [0, 0.68611, 0.12903, 0, 0.69777],
              916: [0, 0.68611, 0, 0, 0.94444],
              920: [0, 0.68611, 0.09062, 0, 0.88555],
              923: [0, 0.68611, 0, 0, 0.80666],
              926: [0, 0.68611, 0.15092, 0, 0.76777],
              928: [0, 0.68611, 0.17208, 0, 0.8961],
              931: [0, 0.68611, 0.11431, 0, 0.82666],
              933: [0, 0.68611, 0.10778, 0, 0.88555],
              934: [0, 0.68611, 0.05632, 0, 0.82666],
              936: [0, 0.68611, 0.10778, 0, 0.88555],
              937: [0, 0.68611, 0.0992, 0, 0.82666],
              8211: [0, 0.44444, 0.09811, 0, 0.59111],
              8212: [0, 0.44444, 0.09811, 0, 1.18221],
              8216: [0, 0.69444, 0.12945, 0, 0.35555],
              8217: [0, 0.69444, 0.12945, 0, 0.35555],
              8220: [0, 0.69444, 0.16772, 0, 0.62055],
              8221: [0, 0.69444, 0.07939, 0, 0.62055]
            },
            "Main-Italic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.12417, 0, 0.30667],
              34: [0, 0.69444, 0.06961, 0, 0.51444],
              35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
              37: [0.05556, 0.75, 0.13639, 0, 0.81777],
              38: [0, 0.69444, 0.09694, 0, 0.76666],
              39: [0, 0.69444, 0.12417, 0, 0.30667],
              40: [0.25, 0.75, 0.16194, 0, 0.40889],
              41: [0.25, 0.75, 0.03694, 0, 0.40889],
              42: [0, 0.75, 0.14917, 0, 0.51111],
              43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
              44: [0.19444, 0.10556, 0, 0, 0.30667],
              45: [0, 0.43056, 0.02826, 0, 0.35778],
              46: [0, 0.10556, 0, 0, 0.30667],
              47: [0.25, 0.75, 0.16194, 0, 0.51111],
              48: [0, 0.64444, 0.13556, 0, 0.51111],
              49: [0, 0.64444, 0.13556, 0, 0.51111],
              50: [0, 0.64444, 0.13556, 0, 0.51111],
              51: [0, 0.64444, 0.13556, 0, 0.51111],
              52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
              53: [0, 0.64444, 0.13556, 0, 0.51111],
              54: [0, 0.64444, 0.13556, 0, 0.51111],
              55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
              56: [0, 0.64444, 0.13556, 0, 0.51111],
              57: [0, 0.64444, 0.13556, 0, 0.51111],
              58: [0, 0.43056, 0.0582, 0, 0.30667],
              59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
              61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
              63: [0, 0.69444, 0.1225, 0, 0.51111],
              64: [0, 0.69444, 0.09597, 0, 0.76666],
              65: [0, 0.68333, 0, 0, 0.74333],
              66: [0, 0.68333, 0.10257, 0, 0.70389],
              67: [0, 0.68333, 0.14528, 0, 0.71555],
              68: [0, 0.68333, 0.09403, 0, 0.755],
              69: [0, 0.68333, 0.12028, 0, 0.67833],
              70: [0, 0.68333, 0.13305, 0, 0.65277],
              71: [0, 0.68333, 0.08722, 0, 0.77361],
              72: [0, 0.68333, 0.16389, 0, 0.74333],
              73: [0, 0.68333, 0.15806, 0, 0.38555],
              74: [0, 0.68333, 0.14028, 0, 0.525],
              75: [0, 0.68333, 0.14528, 0, 0.76888],
              76: [0, 0.68333, 0, 0, 0.62722],
              77: [0, 0.68333, 0.16389, 0, 0.89666],
              78: [0, 0.68333, 0.16389, 0, 0.74333],
              79: [0, 0.68333, 0.09403, 0, 0.76666],
              80: [0, 0.68333, 0.10257, 0, 0.67833],
              81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
              82: [0, 0.68333, 0.03868, 0, 0.72944],
              83: [0, 0.68333, 0.11972, 0, 0.56222],
              84: [0, 0.68333, 0.13305, 0, 0.71555],
              85: [0, 0.68333, 0.16389, 0, 0.74333],
              86: [0, 0.68333, 0.18361, 0, 0.74333],
              87: [0, 0.68333, 0.18361, 0, 0.99888],
              88: [0, 0.68333, 0.15806, 0, 0.74333],
              89: [0, 0.68333, 0.19383, 0, 0.74333],
              90: [0, 0.68333, 0.14528, 0, 0.61333],
              91: [0.25, 0.75, 0.1875, 0, 0.30667],
              93: [0.25, 0.75, 0.10528, 0, 0.30667],
              94: [0, 0.69444, 0.06646, 0, 0.51111],
              95: [0.31, 0.12056, 0.09208, 0, 0.51111],
              97: [0, 0.43056, 0.07671, 0, 0.51111],
              98: [0, 0.69444, 0.06312, 0, 0.46],
              99: [0, 0.43056, 0.05653, 0, 0.46],
              100: [0, 0.69444, 0.10333, 0, 0.51111],
              101: [0, 0.43056, 0.07514, 0, 0.46],
              102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
              103: [0.19444, 0.43056, 0.08847, 0, 0.46],
              104: [0, 0.69444, 0.07671, 0, 0.51111],
              105: [0, 0.65536, 0.1019, 0, 0.30667],
              106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
              107: [0, 0.69444, 0.10764, 0, 0.46],
              108: [0, 0.69444, 0.10333, 0, 0.25555],
              109: [0, 0.43056, 0.07671, 0, 0.81777],
              110: [0, 0.43056, 0.07671, 0, 0.56222],
              111: [0, 0.43056, 0.06312, 0, 0.51111],
              112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
              113: [0.19444, 0.43056, 0.08847, 0, 0.46],
              114: [0, 0.43056, 0.10764, 0, 0.42166],
              115: [0, 0.43056, 0.08208, 0, 0.40889],
              116: [0, 0.61508, 0.09486, 0, 0.33222],
              117: [0, 0.43056, 0.07671, 0, 0.53666],
              118: [0, 0.43056, 0.10764, 0, 0.46],
              119: [0, 0.43056, 0.10764, 0, 0.66444],
              120: [0, 0.43056, 0.12042, 0, 0.46389],
              121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
              122: [0, 0.43056, 0.12292, 0, 0.40889],
              126: [0.35, 0.31786, 0.11585, 0, 0.51111],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.66786, 0.10474, 0, 0.51111],
              176: [0, 0.69444, 0, 0, 0.83129],
              184: [0.17014, 0, 0, 0, 0.46],
              198: [0, 0.68333, 0.12028, 0, 0.88277],
              216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
              223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
              230: [0, 0.43056, 0.07514, 0, 0.71555],
              248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
              338: [0, 0.68333, 0.12028, 0, 0.98499],
              339: [0, 0.43056, 0.07514, 0, 0.71555],
              710: [0, 0.69444, 0.06646, 0, 0.51111],
              711: [0, 0.62847, 0.08295, 0, 0.51111],
              713: [0, 0.56167, 0.10333, 0, 0.51111],
              714: [0, 0.69444, 0.09694, 0, 0.51111],
              715: [0, 0.69444, 0, 0, 0.51111],
              728: [0, 0.69444, 0.10806, 0, 0.51111],
              729: [0, 0.66786, 0.11752, 0, 0.30667],
              730: [0, 0.69444, 0, 0, 0.83129],
              732: [0, 0.66786, 0.11585, 0, 0.51111],
              733: [0, 0.69444, 0.1225, 0, 0.51111],
              915: [0, 0.68333, 0.13305, 0, 0.62722],
              916: [0, 0.68333, 0, 0, 0.81777],
              920: [0, 0.68333, 0.09403, 0, 0.76666],
              923: [0, 0.68333, 0, 0, 0.69222],
              926: [0, 0.68333, 0.15294, 0, 0.66444],
              928: [0, 0.68333, 0.16389, 0, 0.74333],
              931: [0, 0.68333, 0.12028, 0, 0.71555],
              933: [0, 0.68333, 0.11111, 0, 0.76666],
              934: [0, 0.68333, 0.05986, 0, 0.71555],
              936: [0, 0.68333, 0.11111, 0, 0.76666],
              937: [0, 0.68333, 0.10257, 0, 0.71555],
              8211: [0, 0.43056, 0.09208, 0, 0.51111],
              8212: [0, 0.43056, 0.09208, 0, 1.02222],
              8216: [0, 0.69444, 0.12417, 0, 0.30667],
              8217: [0, 0.69444, 0.12417, 0, 0.30667],
              8220: [0, 0.69444, 0.1685, 0, 0.51444],
              8221: [0, 0.69444, 0.06961, 0, 0.51444],
              8463: [0, 0.68889, 0, 0, 0.54028]
            },
            "Main-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.27778],
              34: [0, 0.69444, 0, 0, 0.5],
              35: [0.19444, 0.69444, 0, 0, 0.83334],
              36: [0.05556, 0.75, 0, 0, 0.5],
              37: [0.05556, 0.75, 0, 0, 0.83334],
              38: [0, 0.69444, 0, 0, 0.77778],
              39: [0, 0.69444, 0, 0, 0.27778],
              40: [0.25, 0.75, 0, 0, 0.38889],
              41: [0.25, 0.75, 0, 0, 0.38889],
              42: [0, 0.75, 0, 0, 0.5],
              43: [0.08333, 0.58333, 0, 0, 0.77778],
              44: [0.19444, 0.10556, 0, 0, 0.27778],
              45: [0, 0.43056, 0, 0, 0.33333],
              46: [0, 0.10556, 0, 0, 0.27778],
              47: [0.25, 0.75, 0, 0, 0.5],
              48: [0, 0.64444, 0, 0, 0.5],
              49: [0, 0.64444, 0, 0, 0.5],
              50: [0, 0.64444, 0, 0, 0.5],
              51: [0, 0.64444, 0, 0, 0.5],
              52: [0, 0.64444, 0, 0, 0.5],
              53: [0, 0.64444, 0, 0, 0.5],
              54: [0, 0.64444, 0, 0, 0.5],
              55: [0, 0.64444, 0, 0, 0.5],
              56: [0, 0.64444, 0, 0, 0.5],
              57: [0, 0.64444, 0, 0, 0.5],
              58: [0, 0.43056, 0, 0, 0.27778],
              59: [0.19444, 0.43056, 0, 0, 0.27778],
              60: [0.0391, 0.5391, 0, 0, 0.77778],
              61: [-0.13313, 0.36687, 0, 0, 0.77778],
              62: [0.0391, 0.5391, 0, 0, 0.77778],
              63: [0, 0.69444, 0, 0, 0.47222],
              64: [0, 0.69444, 0, 0, 0.77778],
              65: [0, 0.68333, 0, 0, 0.75],
              66: [0, 0.68333, 0, 0, 0.70834],
              67: [0, 0.68333, 0, 0, 0.72222],
              68: [0, 0.68333, 0, 0, 0.76389],
              69: [0, 0.68333, 0, 0, 0.68056],
              70: [0, 0.68333, 0, 0, 0.65278],
              71: [0, 0.68333, 0, 0, 0.78472],
              72: [0, 0.68333, 0, 0, 0.75],
              73: [0, 0.68333, 0, 0, 0.36111],
              74: [0, 0.68333, 0, 0, 0.51389],
              75: [0, 0.68333, 0, 0, 0.77778],
              76: [0, 0.68333, 0, 0, 0.625],
              77: [0, 0.68333, 0, 0, 0.91667],
              78: [0, 0.68333, 0, 0, 0.75],
              79: [0, 0.68333, 0, 0, 0.77778],
              80: [0, 0.68333, 0, 0, 0.68056],
              81: [0.19444, 0.68333, 0, 0, 0.77778],
              82: [0, 0.68333, 0, 0, 0.73611],
              83: [0, 0.68333, 0, 0, 0.55556],
              84: [0, 0.68333, 0, 0, 0.72222],
              85: [0, 0.68333, 0, 0, 0.75],
              86: [0, 0.68333, 0.01389, 0, 0.75],
              87: [0, 0.68333, 0.01389, 0, 1.02778],
              88: [0, 0.68333, 0, 0, 0.75],
              89: [0, 0.68333, 0.025, 0, 0.75],
              90: [0, 0.68333, 0, 0, 0.61111],
              91: [0.25, 0.75, 0, 0, 0.27778],
              92: [0.25, 0.75, 0, 0, 0.5],
              93: [0.25, 0.75, 0, 0, 0.27778],
              94: [0, 0.69444, 0, 0, 0.5],
              95: [0.31, 0.12056, 0.02778, 0, 0.5],
              97: [0, 0.43056, 0, 0, 0.5],
              98: [0, 0.69444, 0, 0, 0.55556],
              99: [0, 0.43056, 0, 0, 0.44445],
              100: [0, 0.69444, 0, 0, 0.55556],
              101: [0, 0.43056, 0, 0, 0.44445],
              102: [0, 0.69444, 0.07778, 0, 0.30556],
              103: [0.19444, 0.43056, 0.01389, 0, 0.5],
              104: [0, 0.69444, 0, 0, 0.55556],
              105: [0, 0.66786, 0, 0, 0.27778],
              106: [0.19444, 0.66786, 0, 0, 0.30556],
              107: [0, 0.69444, 0, 0, 0.52778],
              108: [0, 0.69444, 0, 0, 0.27778],
              109: [0, 0.43056, 0, 0, 0.83334],
              110: [0, 0.43056, 0, 0, 0.55556],
              111: [0, 0.43056, 0, 0, 0.5],
              112: [0.19444, 0.43056, 0, 0, 0.55556],
              113: [0.19444, 0.43056, 0, 0, 0.52778],
              114: [0, 0.43056, 0, 0, 0.39167],
              115: [0, 0.43056, 0, 0, 0.39445],
              116: [0, 0.61508, 0, 0, 0.38889],
              117: [0, 0.43056, 0, 0, 0.55556],
              118: [0, 0.43056, 0.01389, 0, 0.52778],
              119: [0, 0.43056, 0.01389, 0, 0.72222],
              120: [0, 0.43056, 0, 0, 0.52778],
              121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
              122: [0, 0.43056, 0, 0, 0.44445],
              123: [0.25, 0.75, 0, 0, 0.5],
              124: [0.25, 0.75, 0, 0, 0.27778],
              125: [0.25, 0.75, 0, 0, 0.5],
              126: [0.35, 0.31786, 0, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              163: [0, 0.69444, 0, 0, 0.76909],
              167: [0.19444, 0.69444, 0, 0, 0.44445],
              168: [0, 0.66786, 0, 0, 0.5],
              172: [0, 0.43056, 0, 0, 0.66667],
              176: [0, 0.69444, 0, 0, 0.75],
              177: [0.08333, 0.58333, 0, 0, 0.77778],
              182: [0.19444, 0.69444, 0, 0, 0.61111],
              184: [0.17014, 0, 0, 0, 0.44445],
              198: [0, 0.68333, 0, 0, 0.90278],
              215: [0.08333, 0.58333, 0, 0, 0.77778],
              216: [0.04861, 0.73194, 0, 0, 0.77778],
              223: [0, 0.69444, 0, 0, 0.5],
              230: [0, 0.43056, 0, 0, 0.72222],
              247: [0.08333, 0.58333, 0, 0, 0.77778],
              248: [0.09722, 0.52778, 0, 0, 0.5],
              305: [0, 0.43056, 0, 0, 0.27778],
              338: [0, 0.68333, 0, 0, 1.01389],
              339: [0, 0.43056, 0, 0, 0.77778],
              567: [0.19444, 0.43056, 0, 0, 0.30556],
              710: [0, 0.69444, 0, 0, 0.5],
              711: [0, 0.62847, 0, 0, 0.5],
              713: [0, 0.56778, 0, 0, 0.5],
              714: [0, 0.69444, 0, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0, 0, 0.5],
              729: [0, 0.66786, 0, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.75],
              732: [0, 0.66786, 0, 0, 0.5],
              733: [0, 0.69444, 0, 0, 0.5],
              915: [0, 0.68333, 0, 0, 0.625],
              916: [0, 0.68333, 0, 0, 0.83334],
              920: [0, 0.68333, 0, 0, 0.77778],
              923: [0, 0.68333, 0, 0, 0.69445],
              926: [0, 0.68333, 0, 0, 0.66667],
              928: [0, 0.68333, 0, 0, 0.75],
              931: [0, 0.68333, 0, 0, 0.72222],
              933: [0, 0.68333, 0, 0, 0.77778],
              934: [0, 0.68333, 0, 0, 0.72222],
              936: [0, 0.68333, 0, 0, 0.77778],
              937: [0, 0.68333, 0, 0, 0.72222],
              8211: [0, 0.43056, 0.02778, 0, 0.5],
              8212: [0, 0.43056, 0.02778, 0, 1],
              8216: [0, 0.69444, 0, 0, 0.27778],
              8217: [0, 0.69444, 0, 0, 0.27778],
              8220: [0, 0.69444, 0, 0, 0.5],
              8221: [0, 0.69444, 0, 0, 0.5],
              8224: [0.19444, 0.69444, 0, 0, 0.44445],
              8225: [0.19444, 0.69444, 0, 0, 0.44445],
              8230: [0, 0.123, 0, 0, 1.172],
              8242: [0, 0.55556, 0, 0, 0.275],
              8407: [0, 0.71444, 0.15382, 0, 0.5],
              8463: [0, 0.68889, 0, 0, 0.54028],
              8465: [0, 0.69444, 0, 0, 0.72222],
              8467: [0, 0.69444, 0, 0.11111, 0.41667],
              8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
              8476: [0, 0.69444, 0, 0, 0.72222],
              8501: [0, 0.69444, 0, 0, 0.61111],
              8592: [-0.13313, 0.36687, 0, 0, 1],
              8593: [0.19444, 0.69444, 0, 0, 0.5],
              8594: [-0.13313, 0.36687, 0, 0, 1],
              8595: [0.19444, 0.69444, 0, 0, 0.5],
              8596: [-0.13313, 0.36687, 0, 0, 1],
              8597: [0.25, 0.75, 0, 0, 0.5],
              8598: [0.19444, 0.69444, 0, 0, 1],
              8599: [0.19444, 0.69444, 0, 0, 1],
              8600: [0.19444, 0.69444, 0, 0, 1],
              8601: [0.19444, 0.69444, 0, 0, 1],
              8614: [0.011, 0.511, 0, 0, 1],
              8617: [0.011, 0.511, 0, 0, 1.126],
              8618: [0.011, 0.511, 0, 0, 1.126],
              8636: [-0.13313, 0.36687, 0, 0, 1],
              8637: [-0.13313, 0.36687, 0, 0, 1],
              8640: [-0.13313, 0.36687, 0, 0, 1],
              8641: [-0.13313, 0.36687, 0, 0, 1],
              8652: [0.011, 0.671, 0, 0, 1],
              8656: [-0.13313, 0.36687, 0, 0, 1],
              8657: [0.19444, 0.69444, 0, 0, 0.61111],
              8658: [-0.13313, 0.36687, 0, 0, 1],
              8659: [0.19444, 0.69444, 0, 0, 0.61111],
              8660: [-0.13313, 0.36687, 0, 0, 1],
              8661: [0.25, 0.75, 0, 0, 0.61111],
              8704: [0, 0.69444, 0, 0, 0.55556],
              8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
              8707: [0, 0.69444, 0, 0, 0.55556],
              8709: [0.05556, 0.75, 0, 0, 0.5],
              8711: [0, 0.68333, 0, 0, 0.83334],
              8712: [0.0391, 0.5391, 0, 0, 0.66667],
              8715: [0.0391, 0.5391, 0, 0, 0.66667],
              8722: [0.08333, 0.58333, 0, 0, 0.77778],
              8723: [0.08333, 0.58333, 0, 0, 0.77778],
              8725: [0.25, 0.75, 0, 0, 0.5],
              8726: [0.25, 0.75, 0, 0, 0.5],
              8727: [-0.03472, 0.46528, 0, 0, 0.5],
              8728: [-0.05555, 0.44445, 0, 0, 0.5],
              8729: [-0.05555, 0.44445, 0, 0, 0.5],
              8730: [0.2, 0.8, 0, 0, 0.83334],
              8733: [0, 0.43056, 0, 0, 0.77778],
              8734: [0, 0.43056, 0, 0, 1],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8739: [0.25, 0.75, 0, 0, 0.27778],
              8741: [0.25, 0.75, 0, 0, 0.5],
              8743: [0, 0.55556, 0, 0, 0.66667],
              8744: [0, 0.55556, 0, 0, 0.66667],
              8745: [0, 0.55556, 0, 0, 0.66667],
              8746: [0, 0.55556, 0, 0, 0.66667],
              8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
              8764: [-0.13313, 0.36687, 0, 0, 0.77778],
              8768: [0.19444, 0.69444, 0, 0, 0.27778],
              8771: [-0.03625, 0.46375, 0, 0, 0.77778],
              8773: [-0.022, 0.589, 0, 0, 0.778],
              8776: [-0.01688, 0.48312, 0, 0, 0.77778],
              8781: [-0.03625, 0.46375, 0, 0, 0.77778],
              8784: [-0.133, 0.673, 0, 0, 0.778],
              8801: [-0.03625, 0.46375, 0, 0, 0.77778],
              8804: [0.13597, 0.63597, 0, 0, 0.77778],
              8805: [0.13597, 0.63597, 0, 0, 0.77778],
              8810: [0.0391, 0.5391, 0, 0, 1],
              8811: [0.0391, 0.5391, 0, 0, 1],
              8826: [0.0391, 0.5391, 0, 0, 0.77778],
              8827: [0.0391, 0.5391, 0, 0, 0.77778],
              8834: [0.0391, 0.5391, 0, 0, 0.77778],
              8835: [0.0391, 0.5391, 0, 0, 0.77778],
              8838: [0.13597, 0.63597, 0, 0, 0.77778],
              8839: [0.13597, 0.63597, 0, 0, 0.77778],
              8846: [0, 0.55556, 0, 0, 0.66667],
              8849: [0.13597, 0.63597, 0, 0, 0.77778],
              8850: [0.13597, 0.63597, 0, 0, 0.77778],
              8851: [0, 0.55556, 0, 0, 0.66667],
              8852: [0, 0.55556, 0, 0, 0.66667],
              8853: [0.08333, 0.58333, 0, 0, 0.77778],
              8854: [0.08333, 0.58333, 0, 0, 0.77778],
              8855: [0.08333, 0.58333, 0, 0, 0.77778],
              8856: [0.08333, 0.58333, 0, 0, 0.77778],
              8857: [0.08333, 0.58333, 0, 0, 0.77778],
              8866: [0, 0.69444, 0, 0, 0.61111],
              8867: [0, 0.69444, 0, 0, 0.61111],
              8868: [0, 0.69444, 0, 0, 0.77778],
              8869: [0, 0.69444, 0, 0, 0.77778],
              8872: [0.249, 0.75, 0, 0, 0.867],
              8900: [-0.05555, 0.44445, 0, 0, 0.5],
              8901: [-0.05555, 0.44445, 0, 0, 0.27778],
              8902: [-0.03472, 0.46528, 0, 0, 0.5],
              8904: [5e-3, 0.505, 0, 0, 0.9],
              8942: [0.03, 0.903, 0, 0, 0.278],
              8943: [-0.19, 0.313, 0, 0, 1.172],
              8945: [-0.1, 0.823, 0, 0, 1.282],
              8968: [0.25, 0.75, 0, 0, 0.44445],
              8969: [0.25, 0.75, 0, 0, 0.44445],
              8970: [0.25, 0.75, 0, 0, 0.44445],
              8971: [0.25, 0.75, 0, 0, 0.44445],
              8994: [-0.14236, 0.35764, 0, 0, 1],
              8995: [-0.14236, 0.35764, 0, 0, 1],
              9136: [0.244, 0.744, 0, 0, 0.412],
              9137: [0.244, 0.745, 0, 0, 0.412],
              9651: [0.19444, 0.69444, 0, 0, 0.88889],
              9657: [-0.03472, 0.46528, 0, 0, 0.5],
              9661: [0.19444, 0.69444, 0, 0, 0.88889],
              9667: [-0.03472, 0.46528, 0, 0, 0.5],
              9711: [0.19444, 0.69444, 0, 0, 1],
              9824: [0.12963, 0.69444, 0, 0, 0.77778],
              9825: [0.12963, 0.69444, 0, 0, 0.77778],
              9826: [0.12963, 0.69444, 0, 0, 0.77778],
              9827: [0.12963, 0.69444, 0, 0, 0.77778],
              9837: [0, 0.75, 0, 0, 0.38889],
              9838: [0.19444, 0.69444, 0, 0, 0.38889],
              9839: [0.19444, 0.69444, 0, 0, 0.38889],
              10216: [0.25, 0.75, 0, 0, 0.38889],
              10217: [0.25, 0.75, 0, 0, 0.38889],
              10222: [0.244, 0.744, 0, 0, 0.412],
              10223: [0.244, 0.745, 0, 0, 0.412],
              10229: [0.011, 0.511, 0, 0, 1.609],
              10230: [0.011, 0.511, 0, 0, 1.638],
              10231: [0.011, 0.511, 0, 0, 1.859],
              10232: [0.024, 0.525, 0, 0, 1.609],
              10233: [0.024, 0.525, 0, 0, 1.638],
              10234: [0.024, 0.525, 0, 0, 1.858],
              10236: [0.011, 0.511, 0, 0, 1.638],
              10815: [0, 0.68333, 0, 0, 0.75],
              10927: [0.13597, 0.63597, 0, 0, 0.77778],
              10928: [0.13597, 0.63597, 0, 0, 0.77778],
              57376: [0.19444, 0.69444, 0, 0, 0]
            },
            "Math-BoldItalic": {
              32: [0, 0, 0, 0, 0.25],
              48: [0, 0.44444, 0, 0, 0.575],
              49: [0, 0.44444, 0, 0, 0.575],
              50: [0, 0.44444, 0, 0, 0.575],
              51: [0.19444, 0.44444, 0, 0, 0.575],
              52: [0.19444, 0.44444, 0, 0, 0.575],
              53: [0.19444, 0.44444, 0, 0, 0.575],
              54: [0, 0.64444, 0, 0, 0.575],
              55: [0.19444, 0.44444, 0, 0, 0.575],
              56: [0, 0.64444, 0, 0, 0.575],
              57: [0.19444, 0.44444, 0, 0, 0.575],
              65: [0, 0.68611, 0, 0, 0.86944],
              66: [0, 0.68611, 0.04835, 0, 0.8664],
              67: [0, 0.68611, 0.06979, 0, 0.81694],
              68: [0, 0.68611, 0.03194, 0, 0.93812],
              69: [0, 0.68611, 0.05451, 0, 0.81007],
              70: [0, 0.68611, 0.15972, 0, 0.68889],
              71: [0, 0.68611, 0, 0, 0.88673],
              72: [0, 0.68611, 0.08229, 0, 0.98229],
              73: [0, 0.68611, 0.07778, 0, 0.51111],
              74: [0, 0.68611, 0.10069, 0, 0.63125],
              75: [0, 0.68611, 0.06979, 0, 0.97118],
              76: [0, 0.68611, 0, 0, 0.75555],
              77: [0, 0.68611, 0.11424, 0, 1.14201],
              78: [0, 0.68611, 0.11424, 0, 0.95034],
              79: [0, 0.68611, 0.03194, 0, 0.83666],
              80: [0, 0.68611, 0.15972, 0, 0.72309],
              81: [0.19444, 0.68611, 0, 0, 0.86861],
              82: [0, 0.68611, 421e-5, 0, 0.87235],
              83: [0, 0.68611, 0.05382, 0, 0.69271],
              84: [0, 0.68611, 0.15972, 0, 0.63663],
              85: [0, 0.68611, 0.11424, 0, 0.80027],
              86: [0, 0.68611, 0.25555, 0, 0.67778],
              87: [0, 0.68611, 0.15972, 0, 1.09305],
              88: [0, 0.68611, 0.07778, 0, 0.94722],
              89: [0, 0.68611, 0.25555, 0, 0.67458],
              90: [0, 0.68611, 0.06979, 0, 0.77257],
              97: [0, 0.44444, 0, 0, 0.63287],
              98: [0, 0.69444, 0, 0, 0.52083],
              99: [0, 0.44444, 0, 0, 0.51342],
              100: [0, 0.69444, 0, 0, 0.60972],
              101: [0, 0.44444, 0, 0, 0.55361],
              102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
              103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
              104: [0, 0.69444, 0, 0, 0.66759],
              105: [0, 0.69326, 0, 0, 0.4048],
              106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
              107: [0, 0.69444, 0.01852, 0, 0.6037],
              108: [0, 0.69444, 88e-4, 0, 0.34815],
              109: [0, 0.44444, 0, 0, 1.0324],
              110: [0, 0.44444, 0, 0, 0.71296],
              111: [0, 0.44444, 0, 0, 0.58472],
              112: [0.19444, 0.44444, 0, 0, 0.60092],
              113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
              114: [0, 0.44444, 0.03194, 0, 0.5287],
              115: [0, 0.44444, 0, 0, 0.53125],
              116: [0, 0.63492, 0, 0, 0.41528],
              117: [0, 0.44444, 0, 0, 0.68102],
              118: [0, 0.44444, 0.03704, 0, 0.56666],
              119: [0, 0.44444, 0.02778, 0, 0.83148],
              120: [0, 0.44444, 0, 0, 0.65903],
              121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
              122: [0, 0.44444, 0.04213, 0, 0.55509],
              160: [0, 0, 0, 0, 0.25],
              915: [0, 0.68611, 0.15972, 0, 0.65694],
              916: [0, 0.68611, 0, 0, 0.95833],
              920: [0, 0.68611, 0.03194, 0, 0.86722],
              923: [0, 0.68611, 0, 0, 0.80555],
              926: [0, 0.68611, 0.07458, 0, 0.84125],
              928: [0, 0.68611, 0.08229, 0, 0.98229],
              931: [0, 0.68611, 0.05451, 0, 0.88507],
              933: [0, 0.68611, 0.15972, 0, 0.67083],
              934: [0, 0.68611, 0, 0, 0.76666],
              936: [0, 0.68611, 0.11653, 0, 0.71402],
              937: [0, 0.68611, 0.04835, 0, 0.8789],
              945: [0, 0.44444, 0, 0, 0.76064],
              946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
              947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
              948: [0, 0.69444, 0.03819, 0, 0.52222],
              949: [0, 0.44444, 0, 0, 0.52882],
              950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
              951: [0.19444, 0.44444, 0.03704, 0, 0.6],
              952: [0, 0.69444, 0.03194, 0, 0.5618],
              953: [0, 0.44444, 0, 0, 0.41204],
              954: [0, 0.44444, 0, 0, 0.66759],
              955: [0, 0.69444, 0, 0, 0.67083],
              956: [0.19444, 0.44444, 0, 0, 0.70787],
              957: [0, 0.44444, 0.06898, 0, 0.57685],
              958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
              959: [0, 0.44444, 0, 0, 0.58472],
              960: [0, 0.44444, 0.03704, 0, 0.68241],
              961: [0.19444, 0.44444, 0, 0, 0.6118],
              962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
              963: [0, 0.44444, 0.03704, 0, 0.68588],
              964: [0, 0.44444, 0.13472, 0, 0.52083],
              965: [0, 0.44444, 0.03704, 0, 0.63055],
              966: [0.19444, 0.44444, 0, 0, 0.74722],
              967: [0.19444, 0.44444, 0, 0, 0.71805],
              968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
              969: [0, 0.44444, 0.03704, 0, 0.71782],
              977: [0, 0.69444, 0, 0, 0.69155],
              981: [0.19444, 0.69444, 0, 0, 0.7125],
              982: [0, 0.44444, 0.03194, 0, 0.975],
              1009: [0.19444, 0.44444, 0, 0, 0.6118],
              1013: [0, 0.44444, 0, 0, 0.48333],
              57649: [0, 0.44444, 0, 0, 0.39352],
              57911: [0.19444, 0.44444, 0, 0, 0.43889]
            },
            "Math-Italic": {
              32: [0, 0, 0, 0, 0.25],
              48: [0, 0.43056, 0, 0, 0.5],
              49: [0, 0.43056, 0, 0, 0.5],
              50: [0, 0.43056, 0, 0, 0.5],
              51: [0.19444, 0.43056, 0, 0, 0.5],
              52: [0.19444, 0.43056, 0, 0, 0.5],
              53: [0.19444, 0.43056, 0, 0, 0.5],
              54: [0, 0.64444, 0, 0, 0.5],
              55: [0.19444, 0.43056, 0, 0, 0.5],
              56: [0, 0.64444, 0, 0, 0.5],
              57: [0.19444, 0.43056, 0, 0, 0.5],
              65: [0, 0.68333, 0, 0.13889, 0.75],
              66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
              67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
              68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
              69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
              70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
              71: [0, 0.68333, 0, 0.08334, 0.78625],
              72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
              73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
              74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
              75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
              76: [0, 0.68333, 0, 0.02778, 0.68056],
              77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
              78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
              79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
              80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
              81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
              82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
              83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
              84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
              85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
              86: [0, 0.68333, 0.22222, 0, 0.58333],
              87: [0, 0.68333, 0.13889, 0, 0.94445],
              88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
              89: [0, 0.68333, 0.22222, 0, 0.58056],
              90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
              97: [0, 0.43056, 0, 0, 0.52859],
              98: [0, 0.69444, 0, 0, 0.42917],
              99: [0, 0.43056, 0, 0.05556, 0.43276],
              100: [0, 0.69444, 0, 0.16667, 0.52049],
              101: [0, 0.43056, 0, 0.05556, 0.46563],
              102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
              103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
              104: [0, 0.69444, 0, 0, 0.57616],
              105: [0, 0.65952, 0, 0, 0.34451],
              106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
              107: [0, 0.69444, 0.03148, 0, 0.5206],
              108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
              109: [0, 0.43056, 0, 0, 0.87801],
              110: [0, 0.43056, 0, 0, 0.60023],
              111: [0, 0.43056, 0, 0.05556, 0.48472],
              112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
              113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
              114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
              115: [0, 0.43056, 0, 0.05556, 0.46875],
              116: [0, 0.61508, 0, 0.08334, 0.36111],
              117: [0, 0.43056, 0, 0.02778, 0.57246],
              118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
              119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
              120: [0, 0.43056, 0, 0.02778, 0.57153],
              121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
              122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
              160: [0, 0, 0, 0, 0.25],
              915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
              916: [0, 0.68333, 0, 0.16667, 0.83334],
              920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
              923: [0, 0.68333, 0, 0.16667, 0.69445],
              926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
              928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
              931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
              933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
              934: [0, 0.68333, 0, 0.08334, 0.66667],
              936: [0, 0.68333, 0.11, 0.05556, 0.61222],
              937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
              945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
              946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
              947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
              948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
              949: [0, 0.43056, 0, 0.08334, 0.46632],
              950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
              951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
              952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
              953: [0, 0.43056, 0, 0.05556, 0.35394],
              954: [0, 0.43056, 0, 0, 0.57616],
              955: [0, 0.69444, 0, 0, 0.58334],
              956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
              957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
              958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
              959: [0, 0.43056, 0, 0.05556, 0.48472],
              960: [0, 0.43056, 0.03588, 0, 0.57003],
              961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
              962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
              963: [0, 0.43056, 0.03588, 0, 0.57141],
              964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
              965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
              966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
              967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
              968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
              969: [0, 0.43056, 0.03588, 0, 0.62245],
              977: [0, 0.69444, 0, 0.08334, 0.59144],
              981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
              982: [0, 0.43056, 0.02778, 0, 0.82813],
              1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
              1013: [0, 0.43056, 0, 0.05556, 0.4059],
              57649: [0, 0.43056, 0, 0.02778, 0.32246],
              57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
            },
            "SansSerif-Bold": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.36667],
              34: [0, 0.69444, 0, 0, 0.55834],
              35: [0.19444, 0.69444, 0, 0, 0.91667],
              36: [0.05556, 0.75, 0, 0, 0.55],
              37: [0.05556, 0.75, 0, 0, 1.02912],
              38: [0, 0.69444, 0, 0, 0.83056],
              39: [0, 0.69444, 0, 0, 0.30556],
              40: [0.25, 0.75, 0, 0, 0.42778],
              41: [0.25, 0.75, 0, 0, 0.42778],
              42: [0, 0.75, 0, 0, 0.55],
              43: [0.11667, 0.61667, 0, 0, 0.85556],
              44: [0.10556, 0.13056, 0, 0, 0.30556],
              45: [0, 0.45833, 0, 0, 0.36667],
              46: [0, 0.13056, 0, 0, 0.30556],
              47: [0.25, 0.75, 0, 0, 0.55],
              48: [0, 0.69444, 0, 0, 0.55],
              49: [0, 0.69444, 0, 0, 0.55],
              50: [0, 0.69444, 0, 0, 0.55],
              51: [0, 0.69444, 0, 0, 0.55],
              52: [0, 0.69444, 0, 0, 0.55],
              53: [0, 0.69444, 0, 0, 0.55],
              54: [0, 0.69444, 0, 0, 0.55],
              55: [0, 0.69444, 0, 0, 0.55],
              56: [0, 0.69444, 0, 0, 0.55],
              57: [0, 0.69444, 0, 0, 0.55],
              58: [0, 0.45833, 0, 0, 0.30556],
              59: [0.10556, 0.45833, 0, 0, 0.30556],
              61: [-0.09375, 0.40625, 0, 0, 0.85556],
              63: [0, 0.69444, 0, 0, 0.51945],
              64: [0, 0.69444, 0, 0, 0.73334],
              65: [0, 0.69444, 0, 0, 0.73334],
              66: [0, 0.69444, 0, 0, 0.73334],
              67: [0, 0.69444, 0, 0, 0.70278],
              68: [0, 0.69444, 0, 0, 0.79445],
              69: [0, 0.69444, 0, 0, 0.64167],
              70: [0, 0.69444, 0, 0, 0.61111],
              71: [0, 0.69444, 0, 0, 0.73334],
              72: [0, 0.69444, 0, 0, 0.79445],
              73: [0, 0.69444, 0, 0, 0.33056],
              74: [0, 0.69444, 0, 0, 0.51945],
              75: [0, 0.69444, 0, 0, 0.76389],
              76: [0, 0.69444, 0, 0, 0.58056],
              77: [0, 0.69444, 0, 0, 0.97778],
              78: [0, 0.69444, 0, 0, 0.79445],
              79: [0, 0.69444, 0, 0, 0.79445],
              80: [0, 0.69444, 0, 0, 0.70278],
              81: [0.10556, 0.69444, 0, 0, 0.79445],
              82: [0, 0.69444, 0, 0, 0.70278],
              83: [0, 0.69444, 0, 0, 0.61111],
              84: [0, 0.69444, 0, 0, 0.73334],
              85: [0, 0.69444, 0, 0, 0.76389],
              86: [0, 0.69444, 0.01528, 0, 0.73334],
              87: [0, 0.69444, 0.01528, 0, 1.03889],
              88: [0, 0.69444, 0, 0, 0.73334],
              89: [0, 0.69444, 0.0275, 0, 0.73334],
              90: [0, 0.69444, 0, 0, 0.67223],
              91: [0.25, 0.75, 0, 0, 0.34306],
              93: [0.25, 0.75, 0, 0, 0.34306],
              94: [0, 0.69444, 0, 0, 0.55],
              95: [0.35, 0.10833, 0.03056, 0, 0.55],
              97: [0, 0.45833, 0, 0, 0.525],
              98: [0, 0.69444, 0, 0, 0.56111],
              99: [0, 0.45833, 0, 0, 0.48889],
              100: [0, 0.69444, 0, 0, 0.56111],
              101: [0, 0.45833, 0, 0, 0.51111],
              102: [0, 0.69444, 0.07639, 0, 0.33611],
              103: [0.19444, 0.45833, 0.01528, 0, 0.55],
              104: [0, 0.69444, 0, 0, 0.56111],
              105: [0, 0.69444, 0, 0, 0.25556],
              106: [0.19444, 0.69444, 0, 0, 0.28611],
              107: [0, 0.69444, 0, 0, 0.53056],
              108: [0, 0.69444, 0, 0, 0.25556],
              109: [0, 0.45833, 0, 0, 0.86667],
              110: [0, 0.45833, 0, 0, 0.56111],
              111: [0, 0.45833, 0, 0, 0.55],
              112: [0.19444, 0.45833, 0, 0, 0.56111],
              113: [0.19444, 0.45833, 0, 0, 0.56111],
              114: [0, 0.45833, 0.01528, 0, 0.37222],
              115: [0, 0.45833, 0, 0, 0.42167],
              116: [0, 0.58929, 0, 0, 0.40417],
              117: [0, 0.45833, 0, 0, 0.56111],
              118: [0, 0.45833, 0.01528, 0, 0.5],
              119: [0, 0.45833, 0.01528, 0, 0.74445],
              120: [0, 0.45833, 0, 0, 0.5],
              121: [0.19444, 0.45833, 0.01528, 0, 0.5],
              122: [0, 0.45833, 0, 0, 0.47639],
              126: [0.35, 0.34444, 0, 0, 0.55],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.69444, 0, 0, 0.55],
              176: [0, 0.69444, 0, 0, 0.73334],
              180: [0, 0.69444, 0, 0, 0.55],
              184: [0.17014, 0, 0, 0, 0.48889],
              305: [0, 0.45833, 0, 0, 0.25556],
              567: [0.19444, 0.45833, 0, 0, 0.28611],
              710: [0, 0.69444, 0, 0, 0.55],
              711: [0, 0.63542, 0, 0, 0.55],
              713: [0, 0.63778, 0, 0, 0.55],
              728: [0, 0.69444, 0, 0, 0.55],
              729: [0, 0.69444, 0, 0, 0.30556],
              730: [0, 0.69444, 0, 0, 0.73334],
              732: [0, 0.69444, 0, 0, 0.55],
              733: [0, 0.69444, 0, 0, 0.55],
              915: [0, 0.69444, 0, 0, 0.58056],
              916: [0, 0.69444, 0, 0, 0.91667],
              920: [0, 0.69444, 0, 0, 0.85556],
              923: [0, 0.69444, 0, 0, 0.67223],
              926: [0, 0.69444, 0, 0, 0.73334],
              928: [0, 0.69444, 0, 0, 0.79445],
              931: [0, 0.69444, 0, 0, 0.79445],
              933: [0, 0.69444, 0, 0, 0.85556],
              934: [0, 0.69444, 0, 0, 0.79445],
              936: [0, 0.69444, 0, 0, 0.85556],
              937: [0, 0.69444, 0, 0, 0.79445],
              8211: [0, 0.45833, 0.03056, 0, 0.55],
              8212: [0, 0.45833, 0.03056, 0, 1.10001],
              8216: [0, 0.69444, 0, 0, 0.30556],
              8217: [0, 0.69444, 0, 0, 0.30556],
              8220: [0, 0.69444, 0, 0, 0.55834],
              8221: [0, 0.69444, 0, 0, 0.55834]
            },
            "SansSerif-Italic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.05733, 0, 0.31945],
              34: [0, 0.69444, 316e-5, 0, 0.5],
              35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
              36: [0.05556, 0.75, 0.11156, 0, 0.5],
              37: [0.05556, 0.75, 0.03126, 0, 0.83334],
              38: [0, 0.69444, 0.03058, 0, 0.75834],
              39: [0, 0.69444, 0.07816, 0, 0.27778],
              40: [0.25, 0.75, 0.13164, 0, 0.38889],
              41: [0.25, 0.75, 0.02536, 0, 0.38889],
              42: [0, 0.75, 0.11775, 0, 0.5],
              43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
              44: [0.125, 0.08333, 0, 0, 0.27778],
              45: [0, 0.44444, 0.01946, 0, 0.33333],
              46: [0, 0.08333, 0, 0, 0.27778],
              47: [0.25, 0.75, 0.13164, 0, 0.5],
              48: [0, 0.65556, 0.11156, 0, 0.5],
              49: [0, 0.65556, 0.11156, 0, 0.5],
              50: [0, 0.65556, 0.11156, 0, 0.5],
              51: [0, 0.65556, 0.11156, 0, 0.5],
              52: [0, 0.65556, 0.11156, 0, 0.5],
              53: [0, 0.65556, 0.11156, 0, 0.5],
              54: [0, 0.65556, 0.11156, 0, 0.5],
              55: [0, 0.65556, 0.11156, 0, 0.5],
              56: [0, 0.65556, 0.11156, 0, 0.5],
              57: [0, 0.65556, 0.11156, 0, 0.5],
              58: [0, 0.44444, 0.02502, 0, 0.27778],
              59: [0.125, 0.44444, 0.02502, 0, 0.27778],
              61: [-0.13, 0.37, 0.05087, 0, 0.77778],
              63: [0, 0.69444, 0.11809, 0, 0.47222],
              64: [0, 0.69444, 0.07555, 0, 0.66667],
              65: [0, 0.69444, 0, 0, 0.66667],
              66: [0, 0.69444, 0.08293, 0, 0.66667],
              67: [0, 0.69444, 0.11983, 0, 0.63889],
              68: [0, 0.69444, 0.07555, 0, 0.72223],
              69: [0, 0.69444, 0.11983, 0, 0.59722],
              70: [0, 0.69444, 0.13372, 0, 0.56945],
              71: [0, 0.69444, 0.11983, 0, 0.66667],
              72: [0, 0.69444, 0.08094, 0, 0.70834],
              73: [0, 0.69444, 0.13372, 0, 0.27778],
              74: [0, 0.69444, 0.08094, 0, 0.47222],
              75: [0, 0.69444, 0.11983, 0, 0.69445],
              76: [0, 0.69444, 0, 0, 0.54167],
              77: [0, 0.69444, 0.08094, 0, 0.875],
              78: [0, 0.69444, 0.08094, 0, 0.70834],
              79: [0, 0.69444, 0.07555, 0, 0.73611],
              80: [0, 0.69444, 0.08293, 0, 0.63889],
              81: [0.125, 0.69444, 0.07555, 0, 0.73611],
              82: [0, 0.69444, 0.08293, 0, 0.64584],
              83: [0, 0.69444, 0.09205, 0, 0.55556],
              84: [0, 0.69444, 0.13372, 0, 0.68056],
              85: [0, 0.69444, 0.08094, 0, 0.6875],
              86: [0, 0.69444, 0.1615, 0, 0.66667],
              87: [0, 0.69444, 0.1615, 0, 0.94445],
              88: [0, 0.69444, 0.13372, 0, 0.66667],
              89: [0, 0.69444, 0.17261, 0, 0.66667],
              90: [0, 0.69444, 0.11983, 0, 0.61111],
              91: [0.25, 0.75, 0.15942, 0, 0.28889],
              93: [0.25, 0.75, 0.08719, 0, 0.28889],
              94: [0, 0.69444, 0.0799, 0, 0.5],
              95: [0.35, 0.09444, 0.08616, 0, 0.5],
              97: [0, 0.44444, 981e-5, 0, 0.48056],
              98: [0, 0.69444, 0.03057, 0, 0.51667],
              99: [0, 0.44444, 0.08336, 0, 0.44445],
              100: [0, 0.69444, 0.09483, 0, 0.51667],
              101: [0, 0.44444, 0.06778, 0, 0.44445],
              102: [0, 0.69444, 0.21705, 0, 0.30556],
              103: [0.19444, 0.44444, 0.10836, 0, 0.5],
              104: [0, 0.69444, 0.01778, 0, 0.51667],
              105: [0, 0.67937, 0.09718, 0, 0.23889],
              106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
              107: [0, 0.69444, 0.08336, 0, 0.48889],
              108: [0, 0.69444, 0.09483, 0, 0.23889],
              109: [0, 0.44444, 0.01778, 0, 0.79445],
              110: [0, 0.44444, 0.01778, 0, 0.51667],
              111: [0, 0.44444, 0.06613, 0, 0.5],
              112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
              113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
              114: [0, 0.44444, 0.10836, 0, 0.34167],
              115: [0, 0.44444, 0.0778, 0, 0.38333],
              116: [0, 0.57143, 0.07225, 0, 0.36111],
              117: [0, 0.44444, 0.04169, 0, 0.51667],
              118: [0, 0.44444, 0.10836, 0, 0.46111],
              119: [0, 0.44444, 0.10836, 0, 0.68334],
              120: [0, 0.44444, 0.09169, 0, 0.46111],
              121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
              122: [0, 0.44444, 0.08752, 0, 0.43472],
              126: [0.35, 0.32659, 0.08826, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.67937, 0.06385, 0, 0.5],
              176: [0, 0.69444, 0, 0, 0.73752],
              184: [0.17014, 0, 0, 0, 0.44445],
              305: [0, 0.44444, 0.04169, 0, 0.23889],
              567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
              710: [0, 0.69444, 0.0799, 0, 0.5],
              711: [0, 0.63194, 0.08432, 0, 0.5],
              713: [0, 0.60889, 0.08776, 0, 0.5],
              714: [0, 0.69444, 0.09205, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0.09483, 0, 0.5],
              729: [0, 0.67937, 0.07774, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.73752],
              732: [0, 0.67659, 0.08826, 0, 0.5],
              733: [0, 0.69444, 0.09205, 0, 0.5],
              915: [0, 0.69444, 0.13372, 0, 0.54167],
              916: [0, 0.69444, 0, 0, 0.83334],
              920: [0, 0.69444, 0.07555, 0, 0.77778],
              923: [0, 0.69444, 0, 0, 0.61111],
              926: [0, 0.69444, 0.12816, 0, 0.66667],
              928: [0, 0.69444, 0.08094, 0, 0.70834],
              931: [0, 0.69444, 0.11983, 0, 0.72222],
              933: [0, 0.69444, 0.09031, 0, 0.77778],
              934: [0, 0.69444, 0.04603, 0, 0.72222],
              936: [0, 0.69444, 0.09031, 0, 0.77778],
              937: [0, 0.69444, 0.08293, 0, 0.72222],
              8211: [0, 0.44444, 0.08616, 0, 0.5],
              8212: [0, 0.44444, 0.08616, 0, 1],
              8216: [0, 0.69444, 0.07816, 0, 0.27778],
              8217: [0, 0.69444, 0.07816, 0, 0.27778],
              8220: [0, 0.69444, 0.14205, 0, 0.5],
              8221: [0, 0.69444, 316e-5, 0, 0.5]
            },
            "SansSerif-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.31945],
              34: [0, 0.69444, 0, 0, 0.5],
              35: [0.19444, 0.69444, 0, 0, 0.83334],
              36: [0.05556, 0.75, 0, 0, 0.5],
              37: [0.05556, 0.75, 0, 0, 0.83334],
              38: [0, 0.69444, 0, 0, 0.75834],
              39: [0, 0.69444, 0, 0, 0.27778],
              40: [0.25, 0.75, 0, 0, 0.38889],
              41: [0.25, 0.75, 0, 0, 0.38889],
              42: [0, 0.75, 0, 0, 0.5],
              43: [0.08333, 0.58333, 0, 0, 0.77778],
              44: [0.125, 0.08333, 0, 0, 0.27778],
              45: [0, 0.44444, 0, 0, 0.33333],
              46: [0, 0.08333, 0, 0, 0.27778],
              47: [0.25, 0.75, 0, 0, 0.5],
              48: [0, 0.65556, 0, 0, 0.5],
              49: [0, 0.65556, 0, 0, 0.5],
              50: [0, 0.65556, 0, 0, 0.5],
              51: [0, 0.65556, 0, 0, 0.5],
              52: [0, 0.65556, 0, 0, 0.5],
              53: [0, 0.65556, 0, 0, 0.5],
              54: [0, 0.65556, 0, 0, 0.5],
              55: [0, 0.65556, 0, 0, 0.5],
              56: [0, 0.65556, 0, 0, 0.5],
              57: [0, 0.65556, 0, 0, 0.5],
              58: [0, 0.44444, 0, 0, 0.27778],
              59: [0.125, 0.44444, 0, 0, 0.27778],
              61: [-0.13, 0.37, 0, 0, 0.77778],
              63: [0, 0.69444, 0, 0, 0.47222],
              64: [0, 0.69444, 0, 0, 0.66667],
              65: [0, 0.69444, 0, 0, 0.66667],
              66: [0, 0.69444, 0, 0, 0.66667],
              67: [0, 0.69444, 0, 0, 0.63889],
              68: [0, 0.69444, 0, 0, 0.72223],
              69: [0, 0.69444, 0, 0, 0.59722],
              70: [0, 0.69444, 0, 0, 0.56945],
              71: [0, 0.69444, 0, 0, 0.66667],
              72: [0, 0.69444, 0, 0, 0.70834],
              73: [0, 0.69444, 0, 0, 0.27778],
              74: [0, 0.69444, 0, 0, 0.47222],
              75: [0, 0.69444, 0, 0, 0.69445],
              76: [0, 0.69444, 0, 0, 0.54167],
              77: [0, 0.69444, 0, 0, 0.875],
              78: [0, 0.69444, 0, 0, 0.70834],
              79: [0, 0.69444, 0, 0, 0.73611],
              80: [0, 0.69444, 0, 0, 0.63889],
              81: [0.125, 0.69444, 0, 0, 0.73611],
              82: [0, 0.69444, 0, 0, 0.64584],
              83: [0, 0.69444, 0, 0, 0.55556],
              84: [0, 0.69444, 0, 0, 0.68056],
              85: [0, 0.69444, 0, 0, 0.6875],
              86: [0, 0.69444, 0.01389, 0, 0.66667],
              87: [0, 0.69444, 0.01389, 0, 0.94445],
              88: [0, 0.69444, 0, 0, 0.66667],
              89: [0, 0.69444, 0.025, 0, 0.66667],
              90: [0, 0.69444, 0, 0, 0.61111],
              91: [0.25, 0.75, 0, 0, 0.28889],
              93: [0.25, 0.75, 0, 0, 0.28889],
              94: [0, 0.69444, 0, 0, 0.5],
              95: [0.35, 0.09444, 0.02778, 0, 0.5],
              97: [0, 0.44444, 0, 0, 0.48056],
              98: [0, 0.69444, 0, 0, 0.51667],
              99: [0, 0.44444, 0, 0, 0.44445],
              100: [0, 0.69444, 0, 0, 0.51667],
              101: [0, 0.44444, 0, 0, 0.44445],
              102: [0, 0.69444, 0.06944, 0, 0.30556],
              103: [0.19444, 0.44444, 0.01389, 0, 0.5],
              104: [0, 0.69444, 0, 0, 0.51667],
              105: [0, 0.67937, 0, 0, 0.23889],
              106: [0.19444, 0.67937, 0, 0, 0.26667],
              107: [0, 0.69444, 0, 0, 0.48889],
              108: [0, 0.69444, 0, 0, 0.23889],
              109: [0, 0.44444, 0, 0, 0.79445],
              110: [0, 0.44444, 0, 0, 0.51667],
              111: [0, 0.44444, 0, 0, 0.5],
              112: [0.19444, 0.44444, 0, 0, 0.51667],
              113: [0.19444, 0.44444, 0, 0, 0.51667],
              114: [0, 0.44444, 0.01389, 0, 0.34167],
              115: [0, 0.44444, 0, 0, 0.38333],
              116: [0, 0.57143, 0, 0, 0.36111],
              117: [0, 0.44444, 0, 0, 0.51667],
              118: [0, 0.44444, 0.01389, 0, 0.46111],
              119: [0, 0.44444, 0.01389, 0, 0.68334],
              120: [0, 0.44444, 0, 0, 0.46111],
              121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
              122: [0, 0.44444, 0, 0, 0.43472],
              126: [0.35, 0.32659, 0, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.67937, 0, 0, 0.5],
              176: [0, 0.69444, 0, 0, 0.66667],
              184: [0.17014, 0, 0, 0, 0.44445],
              305: [0, 0.44444, 0, 0, 0.23889],
              567: [0.19444, 0.44444, 0, 0, 0.26667],
              710: [0, 0.69444, 0, 0, 0.5],
              711: [0, 0.63194, 0, 0, 0.5],
              713: [0, 0.60889, 0, 0, 0.5],
              714: [0, 0.69444, 0, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0, 0, 0.5],
              729: [0, 0.67937, 0, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.66667],
              732: [0, 0.67659, 0, 0, 0.5],
              733: [0, 0.69444, 0, 0, 0.5],
              915: [0, 0.69444, 0, 0, 0.54167],
              916: [0, 0.69444, 0, 0, 0.83334],
              920: [0, 0.69444, 0, 0, 0.77778],
              923: [0, 0.69444, 0, 0, 0.61111],
              926: [0, 0.69444, 0, 0, 0.66667],
              928: [0, 0.69444, 0, 0, 0.70834],
              931: [0, 0.69444, 0, 0, 0.72222],
              933: [0, 0.69444, 0, 0, 0.77778],
              934: [0, 0.69444, 0, 0, 0.72222],
              936: [0, 0.69444, 0, 0, 0.77778],
              937: [0, 0.69444, 0, 0, 0.72222],
              8211: [0, 0.44444, 0.02778, 0, 0.5],
              8212: [0, 0.44444, 0.02778, 0, 1],
              8216: [0, 0.69444, 0, 0, 0.27778],
              8217: [0, 0.69444, 0, 0, 0.27778],
              8220: [0, 0.69444, 0, 0, 0.5],
              8221: [0, 0.69444, 0, 0, 0.5]
            },
            "Script-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.7, 0.22925, 0, 0.80253],
              66: [0, 0.7, 0.04087, 0, 0.90757],
              67: [0, 0.7, 0.1689, 0, 0.66619],
              68: [0, 0.7, 0.09371, 0, 0.77443],
              69: [0, 0.7, 0.18583, 0, 0.56162],
              70: [0, 0.7, 0.13634, 0, 0.89544],
              71: [0, 0.7, 0.17322, 0, 0.60961],
              72: [0, 0.7, 0.29694, 0, 0.96919],
              73: [0, 0.7, 0.19189, 0, 0.80907],
              74: [0.27778, 0.7, 0.19189, 0, 1.05159],
              75: [0, 0.7, 0.31259, 0, 0.91364],
              76: [0, 0.7, 0.19189, 0, 0.87373],
              77: [0, 0.7, 0.15981, 0, 1.08031],
              78: [0, 0.7, 0.3525, 0, 0.9015],
              79: [0, 0.7, 0.08078, 0, 0.73787],
              80: [0, 0.7, 0.08078, 0, 1.01262],
              81: [0, 0.7, 0.03305, 0, 0.88282],
              82: [0, 0.7, 0.06259, 0, 0.85],
              83: [0, 0.7, 0.19189, 0, 0.86767],
              84: [0, 0.7, 0.29087, 0, 0.74697],
              85: [0, 0.7, 0.25815, 0, 0.79996],
              86: [0, 0.7, 0.27523, 0, 0.62204],
              87: [0, 0.7, 0.27523, 0, 0.80532],
              88: [0, 0.7, 0.26006, 0, 0.94445],
              89: [0, 0.7, 0.2939, 0, 0.70961],
              90: [0, 0.7, 0.24037, 0, 0.8212],
              160: [0, 0, 0, 0, 0.25]
            },
            "Size1-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.35001, 0.85, 0, 0, 0.45834],
              41: [0.35001, 0.85, 0, 0, 0.45834],
              47: [0.35001, 0.85, 0, 0, 0.57778],
              91: [0.35001, 0.85, 0, 0, 0.41667],
              92: [0.35001, 0.85, 0, 0, 0.57778],
              93: [0.35001, 0.85, 0, 0, 0.41667],
              123: [0.35001, 0.85, 0, 0, 0.58334],
              125: [0.35001, 0.85, 0, 0, 0.58334],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.72222, 0, 0, 0.55556],
              732: [0, 0.72222, 0, 0, 0.55556],
              770: [0, 0.72222, 0, 0, 0.55556],
              771: [0, 0.72222, 0, 0, 0.55556],
              8214: [-99e-5, 0.601, 0, 0, 0.77778],
              8593: [1e-5, 0.6, 0, 0, 0.66667],
              8595: [1e-5, 0.6, 0, 0, 0.66667],
              8657: [1e-5, 0.6, 0, 0, 0.77778],
              8659: [1e-5, 0.6, 0, 0, 0.77778],
              8719: [0.25001, 0.75, 0, 0, 0.94445],
              8720: [0.25001, 0.75, 0, 0, 0.94445],
              8721: [0.25001, 0.75, 0, 0, 1.05556],
              8730: [0.35001, 0.85, 0, 0, 1],
              8739: [-599e-5, 0.606, 0, 0, 0.33333],
              8741: [-599e-5, 0.606, 0, 0, 0.55556],
              8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
              8748: [0.306, 0.805, 0.19445, 0, 0.47222],
              8749: [0.306, 0.805, 0.19445, 0, 0.47222],
              8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
              8896: [0.25001, 0.75, 0, 0, 0.83334],
              8897: [0.25001, 0.75, 0, 0, 0.83334],
              8898: [0.25001, 0.75, 0, 0, 0.83334],
              8899: [0.25001, 0.75, 0, 0, 0.83334],
              8968: [0.35001, 0.85, 0, 0, 0.47222],
              8969: [0.35001, 0.85, 0, 0, 0.47222],
              8970: [0.35001, 0.85, 0, 0, 0.47222],
              8971: [0.35001, 0.85, 0, 0, 0.47222],
              9168: [-99e-5, 0.601, 0, 0, 0.66667],
              10216: [0.35001, 0.85, 0, 0, 0.47222],
              10217: [0.35001, 0.85, 0, 0, 0.47222],
              10752: [0.25001, 0.75, 0, 0, 1.11111],
              10753: [0.25001, 0.75, 0, 0, 1.11111],
              10754: [0.25001, 0.75, 0, 0, 1.11111],
              10756: [0.25001, 0.75, 0, 0, 0.83334],
              10758: [0.25001, 0.75, 0, 0, 0.83334]
            },
            "Size2-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.65002, 1.15, 0, 0, 0.59722],
              41: [0.65002, 1.15, 0, 0, 0.59722],
              47: [0.65002, 1.15, 0, 0, 0.81111],
              91: [0.65002, 1.15, 0, 0, 0.47222],
              92: [0.65002, 1.15, 0, 0, 0.81111],
              93: [0.65002, 1.15, 0, 0, 0.47222],
              123: [0.65002, 1.15, 0, 0, 0.66667],
              125: [0.65002, 1.15, 0, 0, 0.66667],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.75, 0, 0, 1],
              732: [0, 0.75, 0, 0, 1],
              770: [0, 0.75, 0, 0, 1],
              771: [0, 0.75, 0, 0, 1],
              8719: [0.55001, 1.05, 0, 0, 1.27778],
              8720: [0.55001, 1.05, 0, 0, 1.27778],
              8721: [0.55001, 1.05, 0, 0, 1.44445],
              8730: [0.65002, 1.15, 0, 0, 1],
              8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
              8748: [0.862, 1.36, 0.44445, 0, 0.55556],
              8749: [0.862, 1.36, 0.44445, 0, 0.55556],
              8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
              8896: [0.55001, 1.05, 0, 0, 1.11111],
              8897: [0.55001, 1.05, 0, 0, 1.11111],
              8898: [0.55001, 1.05, 0, 0, 1.11111],
              8899: [0.55001, 1.05, 0, 0, 1.11111],
              8968: [0.65002, 1.15, 0, 0, 0.52778],
              8969: [0.65002, 1.15, 0, 0, 0.52778],
              8970: [0.65002, 1.15, 0, 0, 0.52778],
              8971: [0.65002, 1.15, 0, 0, 0.52778],
              10216: [0.65002, 1.15, 0, 0, 0.61111],
              10217: [0.65002, 1.15, 0, 0, 0.61111],
              10752: [0.55001, 1.05, 0, 0, 1.51112],
              10753: [0.55001, 1.05, 0, 0, 1.51112],
              10754: [0.55001, 1.05, 0, 0, 1.51112],
              10756: [0.55001, 1.05, 0, 0, 1.11111],
              10758: [0.55001, 1.05, 0, 0, 1.11111]
            },
            "Size3-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.95003, 1.45, 0, 0, 0.73611],
              41: [0.95003, 1.45, 0, 0, 0.73611],
              47: [0.95003, 1.45, 0, 0, 1.04445],
              91: [0.95003, 1.45, 0, 0, 0.52778],
              92: [0.95003, 1.45, 0, 0, 1.04445],
              93: [0.95003, 1.45, 0, 0, 0.52778],
              123: [0.95003, 1.45, 0, 0, 0.75],
              125: [0.95003, 1.45, 0, 0, 0.75],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.75, 0, 0, 1.44445],
              732: [0, 0.75, 0, 0, 1.44445],
              770: [0, 0.75, 0, 0, 1.44445],
              771: [0, 0.75, 0, 0, 1.44445],
              8730: [0.95003, 1.45, 0, 0, 1],
              8968: [0.95003, 1.45, 0, 0, 0.58334],
              8969: [0.95003, 1.45, 0, 0, 0.58334],
              8970: [0.95003, 1.45, 0, 0, 0.58334],
              8971: [0.95003, 1.45, 0, 0, 0.58334],
              10216: [0.95003, 1.45, 0, 0, 0.75],
              10217: [0.95003, 1.45, 0, 0, 0.75]
            },
            "Size4-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [1.25003, 1.75, 0, 0, 0.79167],
              41: [1.25003, 1.75, 0, 0, 0.79167],
              47: [1.25003, 1.75, 0, 0, 1.27778],
              91: [1.25003, 1.75, 0, 0, 0.58334],
              92: [1.25003, 1.75, 0, 0, 1.27778],
              93: [1.25003, 1.75, 0, 0, 0.58334],
              123: [1.25003, 1.75, 0, 0, 0.80556],
              125: [1.25003, 1.75, 0, 0, 0.80556],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.825, 0, 0, 1.8889],
              732: [0, 0.825, 0, 0, 1.8889],
              770: [0, 0.825, 0, 0, 1.8889],
              771: [0, 0.825, 0, 0, 1.8889],
              8730: [1.25003, 1.75, 0, 0, 1],
              8968: [1.25003, 1.75, 0, 0, 0.63889],
              8969: [1.25003, 1.75, 0, 0, 0.63889],
              8970: [1.25003, 1.75, 0, 0, 0.63889],
              8971: [1.25003, 1.75, 0, 0, 0.63889],
              9115: [0.64502, 1.155, 0, 0, 0.875],
              9116: [1e-5, 0.6, 0, 0, 0.875],
              9117: [0.64502, 1.155, 0, 0, 0.875],
              9118: [0.64502, 1.155, 0, 0, 0.875],
              9119: [1e-5, 0.6, 0, 0, 0.875],
              9120: [0.64502, 1.155, 0, 0, 0.875],
              9121: [0.64502, 1.155, 0, 0, 0.66667],
              9122: [-99e-5, 0.601, 0, 0, 0.66667],
              9123: [0.64502, 1.155, 0, 0, 0.66667],
              9124: [0.64502, 1.155, 0, 0, 0.66667],
              9125: [-99e-5, 0.601, 0, 0, 0.66667],
              9126: [0.64502, 1.155, 0, 0, 0.66667],
              9127: [1e-5, 0.9, 0, 0, 0.88889],
              9128: [0.65002, 1.15, 0, 0, 0.88889],
              9129: [0.90001, 0, 0, 0, 0.88889],
              9130: [0, 0.3, 0, 0, 0.88889],
              9131: [1e-5, 0.9, 0, 0, 0.88889],
              9132: [0.65002, 1.15, 0, 0, 0.88889],
              9133: [0.90001, 0, 0, 0, 0.88889],
              9143: [0.88502, 0.915, 0, 0, 1.05556],
              10216: [1.25003, 1.75, 0, 0, 0.80556],
              10217: [1.25003, 1.75, 0, 0, 0.80556],
              57344: [-499e-5, 0.605, 0, 0, 1.05556],
              57345: [-499e-5, 0.605, 0, 0, 1.05556],
              57680: [0, 0.12, 0, 0, 0.45],
              57681: [0, 0.12, 0, 0, 0.45],
              57682: [0, 0.12, 0, 0, 0.45],
              57683: [0, 0.12, 0, 0, 0.45]
            },
            "Typewriter-Regular": {
              32: [0, 0, 0, 0, 0.525],
              33: [0, 0.61111, 0, 0, 0.525],
              34: [0, 0.61111, 0, 0, 0.525],
              35: [0, 0.61111, 0, 0, 0.525],
              36: [0.08333, 0.69444, 0, 0, 0.525],
              37: [0.08333, 0.69444, 0, 0, 0.525],
              38: [0, 0.61111, 0, 0, 0.525],
              39: [0, 0.61111, 0, 0, 0.525],
              40: [0.08333, 0.69444, 0, 0, 0.525],
              41: [0.08333, 0.69444, 0, 0, 0.525],
              42: [0, 0.52083, 0, 0, 0.525],
              43: [-0.08056, 0.53055, 0, 0, 0.525],
              44: [0.13889, 0.125, 0, 0, 0.525],
              45: [-0.08056, 0.53055, 0, 0, 0.525],
              46: [0, 0.125, 0, 0, 0.525],
              47: [0.08333, 0.69444, 0, 0, 0.525],
              48: [0, 0.61111, 0, 0, 0.525],
              49: [0, 0.61111, 0, 0, 0.525],
              50: [0, 0.61111, 0, 0, 0.525],
              51: [0, 0.61111, 0, 0, 0.525],
              52: [0, 0.61111, 0, 0, 0.525],
              53: [0, 0.61111, 0, 0, 0.525],
              54: [0, 0.61111, 0, 0, 0.525],
              55: [0, 0.61111, 0, 0, 0.525],
              56: [0, 0.61111, 0, 0, 0.525],
              57: [0, 0.61111, 0, 0, 0.525],
              58: [0, 0.43056, 0, 0, 0.525],
              59: [0.13889, 0.43056, 0, 0, 0.525],
              60: [-0.05556, 0.55556, 0, 0, 0.525],
              61: [-0.19549, 0.41562, 0, 0, 0.525],
              62: [-0.05556, 0.55556, 0, 0, 0.525],
              63: [0, 0.61111, 0, 0, 0.525],
              64: [0, 0.61111, 0, 0, 0.525],
              65: [0, 0.61111, 0, 0, 0.525],
              66: [0, 0.61111, 0, 0, 0.525],
              67: [0, 0.61111, 0, 0, 0.525],
              68: [0, 0.61111, 0, 0, 0.525],
              69: [0, 0.61111, 0, 0, 0.525],
              70: [0, 0.61111, 0, 0, 0.525],
              71: [0, 0.61111, 0, 0, 0.525],
              72: [0, 0.61111, 0, 0, 0.525],
              73: [0, 0.61111, 0, 0, 0.525],
              74: [0, 0.61111, 0, 0, 0.525],
              75: [0, 0.61111, 0, 0, 0.525],
              76: [0, 0.61111, 0, 0, 0.525],
              77: [0, 0.61111, 0, 0, 0.525],
              78: [0, 0.61111, 0, 0, 0.525],
              79: [0, 0.61111, 0, 0, 0.525],
              80: [0, 0.61111, 0, 0, 0.525],
              81: [0.13889, 0.61111, 0, 0, 0.525],
              82: [0, 0.61111, 0, 0, 0.525],
              83: [0, 0.61111, 0, 0, 0.525],
              84: [0, 0.61111, 0, 0, 0.525],
              85: [0, 0.61111, 0, 0, 0.525],
              86: [0, 0.61111, 0, 0, 0.525],
              87: [0, 0.61111, 0, 0, 0.525],
              88: [0, 0.61111, 0, 0, 0.525],
              89: [0, 0.61111, 0, 0, 0.525],
              90: [0, 0.61111, 0, 0, 0.525],
              91: [0.08333, 0.69444, 0, 0, 0.525],
              92: [0.08333, 0.69444, 0, 0, 0.525],
              93: [0.08333, 0.69444, 0, 0, 0.525],
              94: [0, 0.61111, 0, 0, 0.525],
              95: [0.09514, 0, 0, 0, 0.525],
              96: [0, 0.61111, 0, 0, 0.525],
              97: [0, 0.43056, 0, 0, 0.525],
              98: [0, 0.61111, 0, 0, 0.525],
              99: [0, 0.43056, 0, 0, 0.525],
              100: [0, 0.61111, 0, 0, 0.525],
              101: [0, 0.43056, 0, 0, 0.525],
              102: [0, 0.61111, 0, 0, 0.525],
              103: [0.22222, 0.43056, 0, 0, 0.525],
              104: [0, 0.61111, 0, 0, 0.525],
              105: [0, 0.61111, 0, 0, 0.525],
              106: [0.22222, 0.61111, 0, 0, 0.525],
              107: [0, 0.61111, 0, 0, 0.525],
              108: [0, 0.61111, 0, 0, 0.525],
              109: [0, 0.43056, 0, 0, 0.525],
              110: [0, 0.43056, 0, 0, 0.525],
              111: [0, 0.43056, 0, 0, 0.525],
              112: [0.22222, 0.43056, 0, 0, 0.525],
              113: [0.22222, 0.43056, 0, 0, 0.525],
              114: [0, 0.43056, 0, 0, 0.525],
              115: [0, 0.43056, 0, 0, 0.525],
              116: [0, 0.55358, 0, 0, 0.525],
              117: [0, 0.43056, 0, 0, 0.525],
              118: [0, 0.43056, 0, 0, 0.525],
              119: [0, 0.43056, 0, 0, 0.525],
              120: [0, 0.43056, 0, 0, 0.525],
              121: [0.22222, 0.43056, 0, 0, 0.525],
              122: [0, 0.43056, 0, 0, 0.525],
              123: [0.08333, 0.69444, 0, 0, 0.525],
              124: [0.08333, 0.69444, 0, 0, 0.525],
              125: [0.08333, 0.69444, 0, 0, 0.525],
              126: [0, 0.61111, 0, 0, 0.525],
              127: [0, 0.61111, 0, 0, 0.525],
              160: [0, 0, 0, 0, 0.525],
              176: [0, 0.61111, 0, 0, 0.525],
              184: [0.19445, 0, 0, 0, 0.525],
              305: [0, 0.43056, 0, 0, 0.525],
              567: [0.22222, 0.43056, 0, 0, 0.525],
              711: [0, 0.56597, 0, 0, 0.525],
              713: [0, 0.56555, 0, 0, 0.525],
              714: [0, 0.61111, 0, 0, 0.525],
              715: [0, 0.61111, 0, 0, 0.525],
              728: [0, 0.61111, 0, 0, 0.525],
              730: [0, 0.61111, 0, 0, 0.525],
              770: [0, 0.61111, 0, 0, 0.525],
              771: [0, 0.61111, 0, 0, 0.525],
              776: [0, 0.61111, 0, 0, 0.525],
              915: [0, 0.61111, 0, 0, 0.525],
              916: [0, 0.61111, 0, 0, 0.525],
              920: [0, 0.61111, 0, 0, 0.525],
              923: [0, 0.61111, 0, 0, 0.525],
              926: [0, 0.61111, 0, 0, 0.525],
              928: [0, 0.61111, 0, 0, 0.525],
              931: [0, 0.61111, 0, 0, 0.525],
              933: [0, 0.61111, 0, 0, 0.525],
              934: [0, 0.61111, 0, 0, 0.525],
              936: [0, 0.61111, 0, 0, 0.525],
              937: [0, 0.61111, 0, 0, 0.525],
              8216: [0, 0.61111, 0, 0, 0.525],
              8217: [0, 0.61111, 0, 0, 0.525],
              8242: [0, 0.61111, 0, 0, 0.525],
              9251: [0.11111, 0.21944, 0, 0, 0.525]
            }
          };
          const hi = {
            slant: [0.25, 0.25, 0.25],
            // sigma1
            space: [0, 0, 0],
            // sigma2
            stretch: [0, 0, 0],
            // sigma3
            shrink: [0, 0, 0],
            // sigma4
            xHeight: [0.431, 0.431, 0.431],
            // sigma5
            quad: [1, 1.171, 1.472],
            // sigma6
            extraSpace: [0, 0, 0],
            // sigma7
            num1: [0.677, 0.732, 0.925],
            // sigma8
            num2: [0.394, 0.384, 0.387],
            // sigma9
            num3: [0.444, 0.471, 0.504],
            // sigma10
            denom1: [0.686, 0.752, 1.025],
            // sigma11
            denom2: [0.345, 0.344, 0.532],
            // sigma12
            sup1: [0.413, 0.503, 0.504],
            // sigma13
            sup2: [0.363, 0.431, 0.404],
            // sigma14
            sup3: [0.289, 0.286, 0.294],
            // sigma15
            sub1: [0.15, 0.143, 0.2],
            // sigma16
            sub2: [0.247, 0.286, 0.4],
            // sigma17
            supDrop: [0.386, 0.353, 0.494],
            // sigma18
            subDrop: [0.05, 0.071, 0.1],
            // sigma19
            delim1: [2.39, 1.7, 1.98],
            // sigma20
            delim2: [1.01, 1.157, 1.42],
            // sigma21
            axisHeight: [0.25, 0.25, 0.25],
            // sigma22
            // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
            // they correspond to the font parameters of the extension fonts (family 3).
            // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
            // match cmex7, we'd use cmex7.tfm values for script and scriptscript
            // values.
            defaultRuleThickness: [0.04, 0.049, 0.049],
            // xi8; cmex7: 0.049
            bigOpSpacing1: [0.111, 0.111, 0.111],
            // xi9
            bigOpSpacing2: [0.166, 0.166, 0.166],
            // xi10
            bigOpSpacing3: [0.2, 0.2, 0.2],
            // xi11
            bigOpSpacing4: [0.6, 0.611, 0.611],
            // xi12; cmex7: 0.611
            bigOpSpacing5: [0.1, 0.143, 0.143],
            // xi13; cmex7: 0.143
            // The \sqrt rule width is taken from the height of the surd character.
            // Since we use the same font at all sizes, this thickness doesn't scale.
            sqrtRuleThickness: [0.04, 0.04, 0.04],
            // This value determines how large a pt is, for metrics which are defined
            // in terms of pts.
            // This value is also used in katex.scss; if you change it make sure the
            // values match.
            ptPerEm: [10, 10, 10],
            // The space between adjacent `|` columns in an array definition. From
            // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
            doubleRuleSep: [0.2, 0.2, 0.2],
            // The width of separator lines in {array} environments. From
            // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
            arrayRuleWidth: [0.04, 0.04, 0.04],
            // Two values from LaTeX source2e:
            fboxsep: [0.3, 0.3, 0.3],
            //        3 pt / ptPerEm
            fboxrule: [0.04, 0.04, 0.04]
            // 0.4 pt / ptPerEm
          }, _a2 = {
            // Latin-1
            Å: "A",
            Ð: "D",
            Þ: "o",
            å: "a",
            ð: "d",
            þ: "o",
            // Cyrillic
            А: "A",
            Б: "B",
            В: "B",
            Г: "F",
            Д: "A",
            Е: "E",
            Ж: "K",
            З: "3",
            И: "N",
            Й: "N",
            К: "K",
            Л: "N",
            М: "M",
            Н: "H",
            О: "O",
            П: "N",
            Р: "P",
            С: "C",
            Т: "T",
            У: "y",
            Ф: "O",
            Х: "X",
            Ц: "U",
            Ч: "h",
            Ш: "W",
            Щ: "W",
            Ъ: "B",
            Ы: "X",
            Ь: "B",
            Э: "3",
            Ю: "X",
            Я: "R",
            а: "a",
            б: "b",
            в: "a",
            г: "r",
            д: "y",
            е: "e",
            ж: "m",
            з: "e",
            и: "n",
            й: "n",
            к: "n",
            л: "n",
            м: "m",
            н: "n",
            о: "o",
            п: "n",
            р: "p",
            с: "c",
            т: "o",
            у: "y",
            ф: "b",
            х: "x",
            ц: "n",
            ч: "n",
            ш: "w",
            щ: "w",
            ъ: "a",
            ы: "m",
            ь: "a",
            э: "e",
            ю: "m",
            я: "r"
          };
          function _c(d, u) {
            wr[d] = u;
          }
          function Ca(d, u, f) {
            if (!wr[u])
              throw new Error("Font metrics not found for font: " + u + ".");
            let b = d.charCodeAt(0), w = wr[u][b];
            if (!w && d[0] in _a2 && (b = _a2[d[0]].charCodeAt(0), w = wr[u][b]), !w && f === "text" && gt(b) && (w = wr[u][77]), w)
              return {
                depth: w[0],
                height: w[1],
                italic: w[2],
                skew: w[3],
                width: w[4]
              };
          }
          const bs = {};
          function xs(d) {
            let u;
            if (d >= 5 ? u = 0 : d >= 3 ? u = 1 : u = 2, !bs[u]) {
              const f = bs[u] = {
                cssEmPerMu: hi.quad[u] / 18
              };
              for (const b in hi)
                hi.hasOwnProperty(b) && (f[b] = hi[b][u]);
            }
            return bs[u];
          }
          const Pi = [
            // Each element contains [textsize, scriptsize, scriptscriptsize].
            // The size mappings are taken from TeX with \normalsize=10pt.
            [1, 1, 1],
            // size1: [5, 5, 5]              \tiny
            [2, 1, 1],
            // size2: [6, 5, 5]
            [3, 1, 1],
            // size3: [7, 5, 5]              \scriptsize
            [4, 2, 1],
            // size4: [8, 6, 5]              \footnotesize
            [5, 2, 1],
            // size5: [9, 6, 5]              \small
            [6, 3, 1],
            // size6: [10, 7, 5]             \normalsize
            [7, 4, 2],
            // size7: [12, 8, 6]             \large
            [8, 6, 3],
            // size8: [14.4, 10, 7]          \Large
            [9, 7, 6],
            // size9: [17.28, 12, 10]        \LARGE
            [10, 8, 7],
            // size10: [20.74, 14.4, 12]     \huge
            [11, 10, 9]
            // size11: [24.88, 20.74, 17.28] \HUGE
          ], ui = [
            // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
            // you change size indexes, change that function.
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            1,
            1.2,
            1.44,
            1.728,
            2.074,
            2.488
          ], Sa = function(d, u) {
            return u.size < 2 ? d : Pi[d - 1][u.size - 1];
          };
          class on {
            // A font family applies to a group of fonts (i.e. SansSerif), while a font
            // represents a specific font (i.e. SansSerif Bold).
            // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
            /**
             * The base size index.
             */
            constructor(u) {
              this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = u.style, this.color = u.color, this.size = u.size || on.BASESIZE, this.textSize = u.textSize || this.size, this.phantom = !!u.phantom, this.font = u.font || "", this.fontFamily = u.fontFamily || "", this.fontWeight = u.fontWeight || "", this.fontShape = u.fontShape || "", this.sizeMultiplier = ui[this.size - 1], this.maxSize = u.maxSize, this.minRuleThickness = u.minRuleThickness, this._fontMetrics = void 0;
            }
            /**
             * Returns a new options object with the same properties as "this".  Properties
             * from "extension" will be copied to the new options object.
             */
            extend(u) {
              const f = {
                style: this.style,
                size: this.size,
                textSize: this.textSize,
                color: this.color,
                phantom: this.phantom,
                font: this.font,
                fontFamily: this.fontFamily,
                fontWeight: this.fontWeight,
                fontShape: this.fontShape,
                maxSize: this.maxSize,
                minRuleThickness: this.minRuleThickness
              };
              for (const b in u)
                u.hasOwnProperty(b) && (f[b] = u[b]);
              return new on(f);
            }
            /**
             * Return an options object with the given style. If `this.style === style`,
             * returns `this`.
             */
            havingStyle(u) {
              return this.style === u ? this : this.extend({
                style: u,
                size: Sa(this.textSize, u)
              });
            }
            /**
             * Return an options object with a cramped version of the current style. If
             * the current style is cramped, returns `this`.
             */
            havingCrampedStyle() {
              return this.havingStyle(this.style.cramp());
            }
            /**
             * Return an options object with the given size and in at least `\textstyle`.
             * Returns `this` if appropriate.
             */
            havingSize(u) {
              return this.size === u && this.textSize === u ? this : this.extend({
                style: this.style.text(),
                size: u,
                textSize: u,
                sizeMultiplier: ui[u - 1]
              });
            }
            /**
             * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
             * changes to at least `\textstyle`.
             */
            havingBaseStyle(u) {
              u = u || this.style.text();
              const f = Sa(on.BASESIZE, u);
              return this.size === f && this.textSize === on.BASESIZE && this.style === u ? this : this.extend({
                style: u,
                size: f
              });
            }
            /**
             * Remove the effect of sizing changes such as \Huge.
             * Keep the effect of the current style, such as \scriptstyle.
             */
            havingBaseSizing() {
              let u;
              switch (this.style.id) {
                case 4:
                case 5:
                  u = 3;
                  break;
                case 6:
                case 7:
                  u = 1;
                  break;
                default:
                  u = 6;
              }
              return this.extend({
                style: this.style.text(),
                size: u
              });
            }
            /**
             * Create a new options object with the given color.
             */
            withColor(u) {
              return this.extend({
                color: u
              });
            }
            /**
             * Create a new options object with "phantom" set to true.
             */
            withPhantom() {
              return this.extend({
                phantom: true
              });
            }
            /**
             * Creates a new options object with the given math font or old text font.
             * @type {[type]}
             */
            withFont(u) {
              return this.extend({
                font: u
              });
            }
            /**
             * Create a new options objects with the given fontFamily.
             */
            withTextFontFamily(u) {
              return this.extend({
                fontFamily: u,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontWeight(u) {
              return this.extend({
                fontWeight: u,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontShape(u) {
              return this.extend({
                fontShape: u,
                font: ""
              });
            }
            /**
             * Return the CSS sizing classes required to switch from enclosing options
             * `oldOptions` to `this`. Returns an array of classes.
             */
            sizingClasses(u) {
              return u.size !== this.size ? ["sizing", "reset-size" + u.size, "size" + this.size] : [];
            }
            /**
             * Return the CSS sizing classes required to switch to the base size. Like
             * `this.havingSize(BASESIZE).sizingClasses(this)`.
             */
            baseSizingClasses() {
              return this.size !== on.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + on.BASESIZE] : [];
            }
            /**
             * Return the font metrics for this size.
             */
            fontMetrics() {
              return this._fontMetrics || (this._fontMetrics = xs(this.size)), this._fontMetrics;
            }
            /**
             * Gets the CSS color of the current options object
             */
            getColor() {
              return this.phantom ? "transparent" : this.color;
            }
          }
          on.BASESIZE = 6;
          var Cc = on;
          const ws = {
            // https://en.wikibooks.org/wiki/LaTeX/Lengths and
            // https://tex.stackexchange.com/a/8263
            pt: 1,
            // TeX point
            mm: 7227 / 2540,
            // millimeter
            cm: 7227 / 254,
            // centimeter
            in: 72.27,
            // inch
            bp: 803 / 800,
            // big (PostScript) points
            pc: 12,
            // pica
            dd: 1238 / 1157,
            // didot
            cc: 14856 / 1157,
            // cicero (12 didot)
            nd: 685 / 642,
            // new didot
            nc: 1370 / 107,
            // new cicero (12 new didot)
            sp: 1 / 65536,
            // scaled point (TeX's internal smallest unit)
            // https://tex.stackexchange.com/a/41371
            px: 803 / 800
            // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
          }, Sc = {
            ex: true,
            em: true,
            mu: true
          }, ks = function(d) {
            return typeof d != "string" && (d = d.unit), d in ws || d in Sc || d === "ex";
          }, we = function(d, u) {
            let f;
            if (d.unit in ws)
              f = ws[d.unit] / u.fontMetrics().ptPerEm / u.sizeMultiplier;
            else if (d.unit === "mu")
              f = u.fontMetrics().cssEmPerMu;
            else {
              let b;
              if (u.style.isTight() ? b = u.havingStyle(u.style.text()) : b = u, d.unit === "ex")
                f = b.fontMetrics().xHeight;
              else if (d.unit === "em")
                f = b.fontMetrics().quad;
              else
                throw new s("Invalid unit: '" + d.unit + "'");
              b !== u && (f *= b.sizeMultiplier / u.sizeMultiplier);
            }
            return Math.min(d.number * f, u.maxSize);
          }, bt = function(d) {
            return +d.toFixed(4) + "em";
          }, kr = function(d) {
            return d.filter((u) => u).join(" ");
          }, go = function(d, u, f) {
            if (this.classes = d || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = f || {}, u) {
              u.style.isTight() && this.classes.push("mtight");
              const b = u.getColor();
              b && (this.style.color = b);
            }
          }, yo = function(d) {
            const u = document.createElement(d);
            u.className = kr(this.classes);
            for (const f in this.style)
              this.style.hasOwnProperty(f) && (u.style[f] = this.style[f]);
            for (const f in this.attributes)
              this.attributes.hasOwnProperty(f) && u.setAttribute(f, this.attributes[f]);
            for (let f = 0; f < this.children.length; f++)
              u.appendChild(this.children[f].toNode());
            return u;
          }, Z0 = /[\s"'>/=\x00-\x1f]/, vs = function(d) {
            let u = "<" + d;
            this.classes.length && (u += ' class="' + k.escape(kr(this.classes)) + '"');
            let f = "";
            for (const b in this.style)
              this.style.hasOwnProperty(b) && (f += k.hyphenate(b) + ":" + this.style[b] + ";");
            f && (u += ' style="' + k.escape(f) + '"');
            for (const b in this.attributes)
              if (this.attributes.hasOwnProperty(b)) {
                if (Z0.test(b))
                  throw new s("Invalid attribute name '" + b + "'");
                u += " " + b + '="' + k.escape(this.attributes[b]) + '"';
              }
            u += ">";
            for (let b = 0; b < this.children.length; b++)
              u += this.children[b].toMarkup();
            return u += "</" + d + ">", u;
          };
          class Nn {
            constructor(u, f, b, w) {
              this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, go.call(this, u, b, w), this.children = f || [];
            }
            /**
             * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
             * all browsers support attributes the same, and having too many custom
             * attributes is probably bad.
             */
            setAttribute(u, f) {
              this.attributes[u] = f;
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            toNode() {
              return yo.call(this, "span");
            }
            toMarkup() {
              return vs.call(this, "span");
            }
          }
          class Ta {
            constructor(u, f, b, w) {
              this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, go.call(this, f, w), this.children = b || [], this.setAttribute("href", u);
            }
            setAttribute(u, f) {
              this.attributes[u] = f;
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            toNode() {
              return yo.call(this, "a");
            }
            toMarkup() {
              return vs.call(this, "a");
            }
          }
          class _s {
            constructor(u, f, b) {
              this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = f, this.src = u, this.classes = ["mord"], this.style = b;
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            toNode() {
              const u = document.createElement("img");
              u.src = this.src, u.alt = this.alt, u.className = "mord";
              for (const f in this.style)
                this.style.hasOwnProperty(f) && (u.style[f] = this.style[f]);
              return u;
            }
            toMarkup() {
              let u = '<img src="' + k.escape(this.src) + '"' + (' alt="' + k.escape(this.alt) + '"'), f = "";
              for (const b in this.style)
                this.style.hasOwnProperty(b) && (f += k.hyphenate(b) + ":" + this.style[b] + ";");
              return f && (u += ' style="' + k.escape(f) + '"'), u += "'/>", u;
            }
          }
          const Q0 = {
            î: "ı̂",
            ï: "ı̈",
            í: "ı́",
            // 'ī': '\u0131\u0304', // enable when we add Extended Latin
            ì: "ı̀"
          };
          class Dr {
            constructor(u, f, b, w, T, E, D, P) {
              this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = u, this.height = f || 0, this.depth = b || 0, this.italic = w || 0, this.skew = T || 0, this.width = E || 0, this.classes = D || [], this.style = P || {}, this.maxFontSize = 0;
              const Q = X(this.text.charCodeAt(0));
              Q && this.classes.push(Q + "_fallback"), /[îïíì]/.test(this.text) && (this.text = Q0[this.text]);
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            /**
             * Creates a text node or span from a symbol node. Note that a span is only
             * created if it is needed.
             */
            toNode() {
              const u = document.createTextNode(this.text);
              let f = null;
              this.italic > 0 && (f = document.createElement("span"), f.style.marginRight = bt(this.italic)), this.classes.length > 0 && (f = f || document.createElement("span"), f.className = kr(this.classes));
              for (const b in this.style)
                this.style.hasOwnProperty(b) && (f = f || document.createElement("span"), f.style[b] = this.style[b]);
              return f ? (f.appendChild(u), f) : u;
            }
            /**
             * Creates markup for a symbol node.
             */
            toMarkup() {
              let u = false, f = "<span";
              this.classes.length && (u = true, f += ' class="', f += k.escape(kr(this.classes)), f += '"');
              let b = "";
              this.italic > 0 && (b += "margin-right:" + this.italic + "em;");
              for (const T in this.style)
                this.style.hasOwnProperty(T) && (b += k.hyphenate(T) + ":" + this.style[T] + ";");
              b && (u = true, f += ' style="' + k.escape(b) + '"');
              const w = k.escape(this.text);
              return u ? (f += ">", f += w, f += "</span>", f) : w;
            }
          }
          class ke {
            constructor(u, f) {
              this.children = void 0, this.attributes = void 0, this.children = u || [], this.attributes = f || {};
            }
            toNode() {
              const u = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && u.setAttribute(f, this.attributes[f]);
              for (let f = 0; f < this.children.length; f++)
                u.appendChild(this.children[f].toNode());
              return u;
            }
            toMarkup() {
              let u = '<svg xmlns="http://www.w3.org/2000/svg"';
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && (u += " " + f + '="' + k.escape(this.attributes[f]) + '"');
              u += ">";
              for (let f = 0; f < this.children.length; f++)
                u += this.children[f].toMarkup();
              return u += "</svg>", u;
            }
          }
          class vr {
            constructor(u, f) {
              this.pathName = void 0, this.alternate = void 0, this.pathName = u, this.alternate = f;
            }
            toNode() {
              const u = document.createElementNS("http://www.w3.org/2000/svg", "path");
              return this.alternate ? u.setAttribute("d", this.alternate) : u.setAttribute("d", mo[this.pathName]), u;
            }
            toMarkup() {
              return this.alternate ? '<path d="' + k.escape(this.alternate) + '"/>' : '<path d="' + k.escape(mo[this.pathName]) + '"/>';
            }
          }
          class Aa {
            constructor(u) {
              this.attributes = void 0, this.attributes = u || {};
            }
            toNode() {
              const u = document.createElementNS("http://www.w3.org/2000/svg", "line");
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && u.setAttribute(f, this.attributes[f]);
              return u;
            }
            toMarkup() {
              let u = "<line";
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && (u += " " + f + '="' + k.escape(this.attributes[f]) + '"');
              return u += "/>", u;
            }
          }
          function $a(d) {
            if (d instanceof Dr)
              return d;
            throw new Error("Expected symbolNode but got " + String(d) + ".");
          }
          function Ea(d) {
            if (d instanceof Nn)
              return d;
            throw new Error("Expected span<HtmlDomNode> but got " + String(d) + ".");
          }
          const Tc = {
            bin: 1,
            close: 1,
            inner: 1,
            open: 1,
            punct: 1,
            rel: 1
          }, Ac = {
            "accent-token": 1,
            mathord: 1,
            "op-token": 1,
            spacing: 1,
            textord: 1
          }, bo = {
            math: {},
            text: {}
          };
          var fe = bo;
          function v(d, u, f, b, w, T) {
            bo[d][w] = {
              font: u,
              group: f,
              replace: b
            }, T && b && (bo[d][b] = bo[d][w]);
          }
          const A = "math", dt = "text", M = "main", V = "ams", se = "accent-token", St = "bin", tr = "close", di = "inner", Ot = "mathord", ze = "op-token", Z = "open", _t = "punct", O = "rel", te = "spacing", tt = "textord";
          v(A, M, O, "≡", "\\equiv", true), v(A, M, O, "≺", "\\prec", true), v(A, M, O, "≻", "\\succ", true), v(A, M, O, "∼", "\\sim", true), v(A, M, O, "⊥", "\\perp"), v(A, M, O, "⪯", "\\preceq", true), v(A, M, O, "⪰", "\\succeq", true), v(A, M, O, "≃", "\\simeq", true), v(A, M, O, "∣", "\\mid", true), v(A, M, O, "≪", "\\ll", true), v(A, M, O, "≫", "\\gg", true), v(A, M, O, "≍", "\\asymp", true), v(A, M, O, "∥", "\\parallel"), v(A, M, O, "⋈", "\\bowtie", true), v(A, M, O, "⌣", "\\smile", true), v(A, M, O, "⊑", "\\sqsubseteq", true), v(A, M, O, "⊒", "\\sqsupseteq", true), v(A, M, O, "≐", "\\doteq", true), v(A, M, O, "⌢", "\\frown", true), v(A, M, O, "∋", "\\ni", true), v(A, M, O, "∝", "\\propto", true), v(A, M, O, "⊢", "\\vdash", true), v(A, M, O, "⊣", "\\dashv", true), v(A, M, O, "∋", "\\owns"), v(A, M, _t, ".", "\\ldotp"), v(A, M, _t, "⋅", "\\cdotp"), v(A, M, tt, "#", "\\#"), v(dt, M, tt, "#", "\\#"), v(A, M, tt, "&", "\\&"), v(dt, M, tt, "&", "\\&"), v(A, M, tt, "ℵ", "\\aleph", true), v(A, M, tt, "∀", "\\forall", true), v(A, M, tt, "ℏ", "\\hbar", true), v(A, M, tt, "∃", "\\exists", true), v(A, M, tt, "∇", "\\nabla", true), v(A, M, tt, "♭", "\\flat", true), v(A, M, tt, "ℓ", "\\ell", true), v(A, M, tt, "♮", "\\natural", true), v(A, M, tt, "♣", "\\clubsuit", true), v(A, M, tt, "℘", "\\wp", true), v(A, M, tt, "♯", "\\sharp", true), v(A, M, tt, "♢", "\\diamondsuit", true), v(A, M, tt, "ℜ", "\\Re", true), v(A, M, tt, "♡", "\\heartsuit", true), v(A, M, tt, "ℑ", "\\Im", true), v(A, M, tt, "♠", "\\spadesuit", true), v(A, M, tt, "§", "\\S", true), v(dt, M, tt, "§", "\\S"), v(A, M, tt, "¶", "\\P", true), v(dt, M, tt, "¶", "\\P"), v(A, M, tt, "†", "\\dag"), v(dt, M, tt, "†", "\\dag"), v(dt, M, tt, "†", "\\textdagger"), v(A, M, tt, "‡", "\\ddag"), v(dt, M, tt, "‡", "\\ddag"), v(dt, M, tt, "‡", "\\textdaggerdbl"), v(A, M, tr, "⎱", "\\rmoustache", true), v(A, M, Z, "⎰", "\\lmoustache", true), v(A, M, tr, "⟯", "\\rgroup", true), v(A, M, Z, "⟮", "\\lgroup", true), v(A, M, St, "∓", "\\mp", true), v(A, M, St, "⊖", "\\ominus", true), v(A, M, St, "⊎", "\\uplus", true), v(A, M, St, "⊓", "\\sqcap", true), v(A, M, St, "∗", "\\ast"), v(A, M, St, "⊔", "\\sqcup", true), v(A, M, St, "◯", "\\bigcirc", true), v(A, M, St, "∙", "\\bullet", true), v(A, M, St, "‡", "\\ddagger"), v(A, M, St, "≀", "\\wr", true), v(A, M, St, "⨿", "\\amalg"), v(A, M, St, "&", "\\And"), v(A, M, O, "⟵", "\\longleftarrow", true), v(A, M, O, "⇐", "\\Leftarrow", true), v(A, M, O, "⟸", "\\Longleftarrow", true), v(A, M, O, "⟶", "\\longrightarrow", true), v(A, M, O, "⇒", "\\Rightarrow", true), v(A, M, O, "⟹", "\\Longrightarrow", true), v(A, M, O, "↔", "\\leftrightarrow", true), v(A, M, O, "⟷", "\\longleftrightarrow", true), v(A, M, O, "⇔", "\\Leftrightarrow", true), v(A, M, O, "⟺", "\\Longleftrightarrow", true), v(A, M, O, "↦", "\\mapsto", true), v(A, M, O, "⟼", "\\longmapsto", true), v(A, M, O, "↗", "\\nearrow", true), v(A, M, O, "↩", "\\hookleftarrow", true), v(A, M, O, "↪", "\\hookrightarrow", true), v(A, M, O, "↘", "\\searrow", true), v(A, M, O, "↼", "\\leftharpoonup", true), v(A, M, O, "⇀", "\\rightharpoonup", true), v(A, M, O, "↙", "\\swarrow", true), v(A, M, O, "↽", "\\leftharpoondown", true), v(A, M, O, "⇁", "\\rightharpoondown", true), v(A, M, O, "↖", "\\nwarrow", true), v(A, M, O, "⇌", "\\rightleftharpoons", true), v(A, V, O, "≮", "\\nless", true), v(A, V, O, "", "\\@nleqslant"), v(A, V, O, "", "\\@nleqq"), v(A, V, O, "⪇", "\\lneq", true), v(A, V, O, "≨", "\\lneqq", true), v(A, V, O, "", "\\@lvertneqq"), v(A, V, O, "⋦", "\\lnsim", true), v(A, V, O, "⪉", "\\lnapprox", true), v(A, V, O, "⊀", "\\nprec", true), v(A, V, O, "⋠", "\\npreceq", true), v(A, V, O, "⋨", "\\precnsim", true), v(A, V, O, "⪹", "\\precnapprox", true), v(A, V, O, "≁", "\\nsim", true), v(A, V, O, "", "\\@nshortmid"), v(A, V, O, "∤", "\\nmid", true), v(A, V, O, "⊬", "\\nvdash", true), v(A, V, O, "⊭", "\\nvDash", true), v(A, V, O, "⋪", "\\ntriangleleft"), v(A, V, O, "⋬", "\\ntrianglelefteq", true), v(A, V, O, "⊊", "\\subsetneq", true), v(A, V, O, "", "\\@varsubsetneq"), v(A, V, O, "⫋", "\\subsetneqq", true), v(A, V, O, "", "\\@varsubsetneqq"), v(A, V, O, "≯", "\\ngtr", true), v(A, V, O, "", "\\@ngeqslant"), v(A, V, O, "", "\\@ngeqq"), v(A, V, O, "⪈", "\\gneq", true), v(A, V, O, "≩", "\\gneqq", true), v(A, V, O, "", "\\@gvertneqq"), v(A, V, O, "⋧", "\\gnsim", true), v(A, V, O, "⪊", "\\gnapprox", true), v(A, V, O, "⊁", "\\nsucc", true), v(A, V, O, "⋡", "\\nsucceq", true), v(A, V, O, "⋩", "\\succnsim", true), v(A, V, O, "⪺", "\\succnapprox", true), v(A, V, O, "≆", "\\ncong", true), v(A, V, O, "", "\\@nshortparallel"), v(A, V, O, "∦", "\\nparallel", true), v(A, V, O, "⊯", "\\nVDash", true), v(A, V, O, "⋫", "\\ntriangleright"), v(A, V, O, "⋭", "\\ntrianglerighteq", true), v(A, V, O, "", "\\@nsupseteqq"), v(A, V, O, "⊋", "\\supsetneq", true), v(A, V, O, "", "\\@varsupsetneq"), v(A, V, O, "⫌", "\\supsetneqq", true), v(A, V, O, "", "\\@varsupsetneqq"), v(A, V, O, "⊮", "\\nVdash", true), v(A, V, O, "⪵", "\\precneqq", true), v(A, V, O, "⪶", "\\succneqq", true), v(A, V, O, "", "\\@nsubseteqq"), v(A, V, St, "⊴", "\\unlhd"), v(A, V, St, "⊵", "\\unrhd"), v(A, V, O, "↚", "\\nleftarrow", true), v(A, V, O, "↛", "\\nrightarrow", true), v(A, V, O, "⇍", "\\nLeftarrow", true), v(A, V, O, "⇏", "\\nRightarrow", true), v(A, V, O, "↮", "\\nleftrightarrow", true), v(A, V, O, "⇎", "\\nLeftrightarrow", true), v(A, V, O, "△", "\\vartriangle"), v(A, V, tt, "ℏ", "\\hslash"), v(A, V, tt, "▽", "\\triangledown"), v(A, V, tt, "◊", "\\lozenge"), v(A, V, tt, "Ⓢ", "\\circledS"), v(A, V, tt, "®", "\\circledR"), v(dt, V, tt, "®", "\\circledR"), v(A, V, tt, "∡", "\\measuredangle", true), v(A, V, tt, "∄", "\\nexists"), v(A, V, tt, "℧", "\\mho"), v(A, V, tt, "Ⅎ", "\\Finv", true), v(A, V, tt, "⅁", "\\Game", true), v(A, V, tt, "‵", "\\backprime"), v(A, V, tt, "▲", "\\blacktriangle"), v(A, V, tt, "▼", "\\blacktriangledown"), v(A, V, tt, "■", "\\blacksquare"), v(A, V, tt, "⧫", "\\blacklozenge"), v(A, V, tt, "★", "\\bigstar"), v(A, V, tt, "∢", "\\sphericalangle", true), v(A, V, tt, "∁", "\\complement", true), v(A, V, tt, "ð", "\\eth", true), v(dt, M, tt, "ð", "ð"), v(A, V, tt, "╱", "\\diagup"), v(A, V, tt, "╲", "\\diagdown"), v(A, V, tt, "□", "\\square"), v(A, V, tt, "□", "\\Box"), v(A, V, tt, "◊", "\\Diamond"), v(A, V, tt, "¥", "\\yen", true), v(dt, V, tt, "¥", "\\yen", true), v(A, V, tt, "✓", "\\checkmark", true), v(dt, V, tt, "✓", "\\checkmark"), v(A, V, tt, "ℶ", "\\beth", true), v(A, V, tt, "ℸ", "\\daleth", true), v(A, V, tt, "ℷ", "\\gimel", true), v(A, V, tt, "ϝ", "\\digamma", true), v(A, V, tt, "ϰ", "\\varkappa"), v(A, V, Z, "┌", "\\@ulcorner", true), v(A, V, tr, "┐", "\\@urcorner", true), v(A, V, Z, "└", "\\@llcorner", true), v(A, V, tr, "┘", "\\@lrcorner", true), v(A, V, O, "≦", "\\leqq", true), v(A, V, O, "⩽", "\\leqslant", true), v(A, V, O, "⪕", "\\eqslantless", true), v(A, V, O, "≲", "\\lesssim", true), v(A, V, O, "⪅", "\\lessapprox", true), v(A, V, O, "≊", "\\approxeq", true), v(A, V, St, "⋖", "\\lessdot"), v(A, V, O, "⋘", "\\lll", true), v(A, V, O, "≶", "\\lessgtr", true), v(A, V, O, "⋚", "\\lesseqgtr", true), v(A, V, O, "⪋", "\\lesseqqgtr", true), v(A, V, O, "≑", "\\doteqdot"), v(A, V, O, "≓", "\\risingdotseq", true), v(A, V, O, "≒", "\\fallingdotseq", true), v(A, V, O, "∽", "\\backsim", true), v(A, V, O, "⋍", "\\backsimeq", true), v(A, V, O, "⫅", "\\subseteqq", true), v(A, V, O, "⋐", "\\Subset", true), v(A, V, O, "⊏", "\\sqsubset", true), v(A, V, O, "≼", "\\preccurlyeq", true), v(A, V, O, "⋞", "\\curlyeqprec", true), v(A, V, O, "≾", "\\precsim", true), v(A, V, O, "⪷", "\\precapprox", true), v(A, V, O, "⊲", "\\vartriangleleft"), v(A, V, O, "⊴", "\\trianglelefteq"), v(A, V, O, "⊨", "\\vDash", true), v(A, V, O, "⊪", "\\Vvdash", true), v(A, V, O, "⌣", "\\smallsmile"), v(A, V, O, "⌢", "\\smallfrown"), v(A, V, O, "≏", "\\bumpeq", true), v(A, V, O, "≎", "\\Bumpeq", true), v(A, V, O, "≧", "\\geqq", true), v(A, V, O, "⩾", "\\geqslant", true), v(A, V, O, "⪖", "\\eqslantgtr", true), v(A, V, O, "≳", "\\gtrsim", true), v(A, V, O, "⪆", "\\gtrapprox", true), v(A, V, St, "⋗", "\\gtrdot"), v(A, V, O, "⋙", "\\ggg", true), v(A, V, O, "≷", "\\gtrless", true), v(A, V, O, "⋛", "\\gtreqless", true), v(A, V, O, "⪌", "\\gtreqqless", true), v(A, V, O, "≖", "\\eqcirc", true), v(A, V, O, "≗", "\\circeq", true), v(A, V, O, "≜", "\\triangleq", true), v(A, V, O, "∼", "\\thicksim"), v(A, V, O, "≈", "\\thickapprox"), v(A, V, O, "⫆", "\\supseteqq", true), v(A, V, O, "⋑", "\\Supset", true), v(A, V, O, "⊐", "\\sqsupset", true), v(A, V, O, "≽", "\\succcurlyeq", true), v(A, V, O, "⋟", "\\curlyeqsucc", true), v(A, V, O, "≿", "\\succsim", true), v(A, V, O, "⪸", "\\succapprox", true), v(A, V, O, "⊳", "\\vartriangleright"), v(A, V, O, "⊵", "\\trianglerighteq"), v(A, V, O, "⊩", "\\Vdash", true), v(A, V, O, "∣", "\\shortmid"), v(A, V, O, "∥", "\\shortparallel"), v(A, V, O, "≬", "\\between", true), v(A, V, O, "⋔", "\\pitchfork", true), v(A, V, O, "∝", "\\varpropto"), v(A, V, O, "◀", "\\blacktriangleleft"), v(A, V, O, "∴", "\\therefore", true), v(A, V, O, "∍", "\\backepsilon"), v(A, V, O, "▶", "\\blacktriangleright"), v(A, V, O, "∵", "\\because", true), v(A, V, O, "⋘", "\\llless"), v(A, V, O, "⋙", "\\gggtr"), v(A, V, St, "⊲", "\\lhd"), v(A, V, St, "⊳", "\\rhd"), v(A, V, O, "≂", "\\eqsim", true), v(A, M, O, "⋈", "\\Join"), v(A, V, O, "≑", "\\Doteq", true), v(A, V, St, "∔", "\\dotplus", true), v(A, V, St, "∖", "\\smallsetminus"), v(A, V, St, "⋒", "\\Cap", true), v(A, V, St, "⋓", "\\Cup", true), v(A, V, St, "⩞", "\\doublebarwedge", true), v(A, V, St, "⊟", "\\boxminus", true), v(A, V, St, "⊞", "\\boxplus", true), v(A, V, St, "⋇", "\\divideontimes", true), v(A, V, St, "⋉", "\\ltimes", true), v(A, V, St, "⋊", "\\rtimes", true), v(A, V, St, "⋋", "\\leftthreetimes", true), v(A, V, St, "⋌", "\\rightthreetimes", true), v(A, V, St, "⋏", "\\curlywedge", true), v(A, V, St, "⋎", "\\curlyvee", true), v(A, V, St, "⊝", "\\circleddash", true), v(A, V, St, "⊛", "\\circledast", true), v(A, V, St, "⋅", "\\centerdot"), v(A, V, St, "⊺", "\\intercal", true), v(A, V, St, "⋒", "\\doublecap"), v(A, V, St, "⋓", "\\doublecup"), v(A, V, St, "⊠", "\\boxtimes", true), v(A, V, O, "⇢", "\\dashrightarrow", true), v(A, V, O, "⇠", "\\dashleftarrow", true), v(A, V, O, "⇇", "\\leftleftarrows", true), v(A, V, O, "⇆", "\\leftrightarrows", true), v(A, V, O, "⇚", "\\Lleftarrow", true), v(A, V, O, "↞", "\\twoheadleftarrow", true), v(A, V, O, "↢", "\\leftarrowtail", true), v(A, V, O, "↫", "\\looparrowleft", true), v(A, V, O, "⇋", "\\leftrightharpoons", true), v(A, V, O, "↶", "\\curvearrowleft", true), v(A, V, O, "↺", "\\circlearrowleft", true), v(A, V, O, "↰", "\\Lsh", true), v(A, V, O, "⇈", "\\upuparrows", true), v(A, V, O, "↿", "\\upharpoonleft", true), v(A, V, O, "⇃", "\\downharpoonleft", true), v(A, M, O, "⊶", "\\origof", true), v(A, M, O, "⊷", "\\imageof", true), v(A, V, O, "⊸", "\\multimap", true), v(A, V, O, "↭", "\\leftrightsquigarrow", true), v(A, V, O, "⇉", "\\rightrightarrows", true), v(A, V, O, "⇄", "\\rightleftarrows", true), v(A, V, O, "↠", "\\twoheadrightarrow", true), v(A, V, O, "↣", "\\rightarrowtail", true), v(A, V, O, "↬", "\\looparrowright", true), v(A, V, O, "↷", "\\curvearrowright", true), v(A, V, O, "↻", "\\circlearrowright", true), v(A, V, O, "↱", "\\Rsh", true), v(A, V, O, "⇊", "\\downdownarrows", true), v(A, V, O, "↾", "\\upharpoonright", true), v(A, V, O, "⇂", "\\downharpoonright", true), v(A, V, O, "⇝", "\\rightsquigarrow", true), v(A, V, O, "⇝", "\\leadsto"), v(A, V, O, "⇛", "\\Rrightarrow", true), v(A, V, O, "↾", "\\restriction"), v(A, M, tt, "‘", "`"), v(A, M, tt, "$", "\\$"), v(dt, M, tt, "$", "\\$"), v(dt, M, tt, "$", "\\textdollar"), v(A, M, tt, "%", "\\%"), v(dt, M, tt, "%", "\\%"), v(A, M, tt, "_", "\\_"), v(dt, M, tt, "_", "\\_"), v(dt, M, tt, "_", "\\textunderscore"), v(A, M, tt, "∠", "\\angle", true), v(A, M, tt, "∞", "\\infty", true), v(A, M, tt, "′", "\\prime"), v(A, M, tt, "△", "\\triangle"), v(A, M, tt, "Γ", "\\Gamma", true), v(A, M, tt, "Δ", "\\Delta", true), v(A, M, tt, "Θ", "\\Theta", true), v(A, M, tt, "Λ", "\\Lambda", true), v(A, M, tt, "Ξ", "\\Xi", true), v(A, M, tt, "Π", "\\Pi", true), v(A, M, tt, "Σ", "\\Sigma", true), v(A, M, tt, "Υ", "\\Upsilon", true), v(A, M, tt, "Φ", "\\Phi", true), v(A, M, tt, "Ψ", "\\Psi", true), v(A, M, tt, "Ω", "\\Omega", true), v(A, M, tt, "A", "Α"), v(A, M, tt, "B", "Β"), v(A, M, tt, "E", "Ε"), v(A, M, tt, "Z", "Ζ"), v(A, M, tt, "H", "Η"), v(A, M, tt, "I", "Ι"), v(A, M, tt, "K", "Κ"), v(A, M, tt, "M", "Μ"), v(A, M, tt, "N", "Ν"), v(A, M, tt, "O", "Ο"), v(A, M, tt, "P", "Ρ"), v(A, M, tt, "T", "Τ"), v(A, M, tt, "X", "Χ"), v(A, M, tt, "¬", "\\neg", true), v(A, M, tt, "¬", "\\lnot"), v(A, M, tt, "⊤", "\\top"), v(A, M, tt, "⊥", "\\bot"), v(A, M, tt, "∅", "\\emptyset"), v(A, V, tt, "∅", "\\varnothing"), v(A, M, Ot, "α", "\\alpha", true), v(A, M, Ot, "β", "\\beta", true), v(A, M, Ot, "γ", "\\gamma", true), v(A, M, Ot, "δ", "\\delta", true), v(A, M, Ot, "ϵ", "\\epsilon", true), v(A, M, Ot, "ζ", "\\zeta", true), v(A, M, Ot, "η", "\\eta", true), v(A, M, Ot, "θ", "\\theta", true), v(A, M, Ot, "ι", "\\iota", true), v(A, M, Ot, "κ", "\\kappa", true), v(A, M, Ot, "λ", "\\lambda", true), v(A, M, Ot, "μ", "\\mu", true), v(A, M, Ot, "ν", "\\nu", true), v(A, M, Ot, "ξ", "\\xi", true), v(A, M, Ot, "ο", "\\omicron", true), v(A, M, Ot, "π", "\\pi", true), v(A, M, Ot, "ρ", "\\rho", true), v(A, M, Ot, "σ", "\\sigma", true), v(A, M, Ot, "τ", "\\tau", true), v(A, M, Ot, "υ", "\\upsilon", true), v(A, M, Ot, "ϕ", "\\phi", true), v(A, M, Ot, "χ", "\\chi", true), v(A, M, Ot, "ψ", "\\psi", true), v(A, M, Ot, "ω", "\\omega", true), v(A, M, Ot, "ε", "\\varepsilon", true), v(A, M, Ot, "ϑ", "\\vartheta", true), v(A, M, Ot, "ϖ", "\\varpi", true), v(A, M, Ot, "ϱ", "\\varrho", true), v(A, M, Ot, "ς", "\\varsigma", true), v(A, M, Ot, "φ", "\\varphi", true), v(A, M, St, "∗", "*", true), v(A, M, St, "+", "+"), v(A, M, St, "−", "-", true), v(A, M, St, "⋅", "\\cdot", true), v(A, M, St, "∘", "\\circ", true), v(A, M, St, "÷", "\\div", true), v(A, M, St, "±", "\\pm", true), v(A, M, St, "×", "\\times", true), v(A, M, St, "∩", "\\cap", true), v(A, M, St, "∪", "\\cup", true), v(A, M, St, "∖", "\\setminus", true), v(A, M, St, "∧", "\\land"), v(A, M, St, "∨", "\\lor"), v(A, M, St, "∧", "\\wedge", true), v(A, M, St, "∨", "\\vee", true), v(A, M, tt, "√", "\\surd"), v(A, M, Z, "⟨", "\\langle", true), v(A, M, Z, "∣", "\\lvert"), v(A, M, Z, "∥", "\\lVert"), v(A, M, tr, "?", "?"), v(A, M, tr, "!", "!"), v(A, M, tr, "⟩", "\\rangle", true), v(A, M, tr, "∣", "\\rvert"), v(A, M, tr, "∥", "\\rVert"), v(A, M, O, "=", "="), v(A, M, O, ":", ":"), v(A, M, O, "≈", "\\approx", true), v(A, M, O, "≅", "\\cong", true), v(A, M, O, "≥", "\\ge"), v(A, M, O, "≥", "\\geq", true), v(A, M, O, "←", "\\gets"), v(A, M, O, ">", "\\gt", true), v(A, M, O, "∈", "\\in", true), v(A, M, O, "", "\\@not"), v(A, M, O, "⊂", "\\subset", true), v(A, M, O, "⊃", "\\supset", true), v(A, M, O, "⊆", "\\subseteq", true), v(A, M, O, "⊇", "\\supseteq", true), v(A, V, O, "⊈", "\\nsubseteq", true), v(A, V, O, "⊉", "\\nsupseteq", true), v(A, M, O, "⊨", "\\models"), v(A, M, O, "←", "\\leftarrow", true), v(A, M, O, "≤", "\\le"), v(A, M, O, "≤", "\\leq", true), v(A, M, O, "<", "\\lt", true), v(A, M, O, "→", "\\rightarrow", true), v(A, M, O, "→", "\\to"), v(A, V, O, "≱", "\\ngeq", true), v(A, V, O, "≰", "\\nleq", true), v(A, M, te, " ", "\\ "), v(A, M, te, " ", "\\space"), v(A, M, te, " ", "\\nobreakspace"), v(dt, M, te, " ", "\\ "), v(dt, M, te, " ", " "), v(dt, M, te, " ", "\\space"), v(dt, M, te, " ", "\\nobreakspace"), v(A, M, te, null, "\\nobreak"), v(A, M, te, null, "\\allowbreak"), v(A, M, _t, ",", ","), v(A, M, _t, ";", ";"), v(A, V, St, "⊼", "\\barwedge", true), v(A, V, St, "⊻", "\\veebar", true), v(A, M, St, "⊙", "\\odot", true), v(A, M, St, "⊕", "\\oplus", true), v(A, M, St, "⊗", "\\otimes", true), v(A, M, tt, "∂", "\\partial", true), v(A, M, St, "⊘", "\\oslash", true), v(A, V, St, "⊚", "\\circledcirc", true), v(A, V, St, "⊡", "\\boxdot", true), v(A, M, St, "△", "\\bigtriangleup"), v(A, M, St, "▽", "\\bigtriangledown"), v(A, M, St, "†", "\\dagger"), v(A, M, St, "⋄", "\\diamond"), v(A, M, St, "⋆", "\\star"), v(A, M, St, "◃", "\\triangleleft"), v(A, M, St, "▹", "\\triangleright"), v(A, M, Z, "{", "\\{"), v(dt, M, tt, "{", "\\{"), v(dt, M, tt, "{", "\\textbraceleft"), v(A, M, tr, "}", "\\}"), v(dt, M, tt, "}", "\\}"), v(dt, M, tt, "}", "\\textbraceright"), v(A, M, Z, "{", "\\lbrace"), v(A, M, tr, "}", "\\rbrace"), v(A, M, Z, "[", "\\lbrack", true), v(dt, M, tt, "[", "\\lbrack", true), v(A, M, tr, "]", "\\rbrack", true), v(dt, M, tt, "]", "\\rbrack", true), v(A, M, Z, "(", "\\lparen", true), v(A, M, tr, ")", "\\rparen", true), v(dt, M, tt, "<", "\\textless", true), v(dt, M, tt, ">", "\\textgreater", true), v(A, M, Z, "⌊", "\\lfloor", true), v(A, M, tr, "⌋", "\\rfloor", true), v(A, M, Z, "⌈", "\\lceil", true), v(A, M, tr, "⌉", "\\rceil", true), v(A, M, tt, "\\", "\\backslash"), v(A, M, tt, "∣", "|"), v(A, M, tt, "∣", "\\vert"), v(dt, M, tt, "|", "\\textbar", true), v(A, M, tt, "∥", "\\|"), v(A, M, tt, "∥", "\\Vert"), v(dt, M, tt, "∥", "\\textbardbl"), v(dt, M, tt, "~", "\\textasciitilde"), v(dt, M, tt, "\\", "\\textbackslash"), v(dt, M, tt, "^", "\\textasciicircum"), v(A, M, O, "↑", "\\uparrow", true), v(A, M, O, "⇑", "\\Uparrow", true), v(A, M, O, "↓", "\\downarrow", true), v(A, M, O, "⇓", "\\Downarrow", true), v(A, M, O, "↕", "\\updownarrow", true), v(A, M, O, "⇕", "\\Updownarrow", true), v(A, M, ze, "∐", "\\coprod"), v(A, M, ze, "⋁", "\\bigvee"), v(A, M, ze, "⋀", "\\bigwedge"), v(A, M, ze, "⨄", "\\biguplus"), v(A, M, ze, "⋂", "\\bigcap"), v(A, M, ze, "⋃", "\\bigcup"), v(A, M, ze, "∫", "\\int"), v(A, M, ze, "∫", "\\intop"), v(A, M, ze, "∬", "\\iint"), v(A, M, ze, "∭", "\\iiint"), v(A, M, ze, "∏", "\\prod"), v(A, M, ze, "∑", "\\sum"), v(A, M, ze, "⨂", "\\bigotimes"), v(A, M, ze, "⨁", "\\bigoplus"), v(A, M, ze, "⨀", "\\bigodot"), v(A, M, ze, "∮", "\\oint"), v(A, M, ze, "∯", "\\oiint"), v(A, M, ze, "∰", "\\oiiint"), v(A, M, ze, "⨆", "\\bigsqcup"), v(A, M, ze, "∫", "\\smallint"), v(dt, M, di, "…", "\\textellipsis"), v(A, M, di, "…", "\\mathellipsis"), v(dt, M, di, "…", "\\ldots", true), v(A, M, di, "…", "\\ldots", true), v(A, M, di, "⋯", "\\@cdots", true), v(A, M, di, "⋱", "\\ddots", true), v(A, M, tt, "⋮", "\\varvdots"), v(dt, M, tt, "⋮", "\\varvdots"), v(A, M, se, "ˊ", "\\acute"), v(A, M, se, "ˋ", "\\grave"), v(A, M, se, "¨", "\\ddot"), v(A, M, se, "~", "\\tilde"), v(A, M, se, "ˉ", "\\bar"), v(A, M, se, "˘", "\\breve"), v(A, M, se, "ˇ", "\\check"), v(A, M, se, "^", "\\hat"), v(A, M, se, "⃗", "\\vec"), v(A, M, se, "˙", "\\dot"), v(A, M, se, "˚", "\\mathring"), v(A, M, Ot, "", "\\@imath"), v(A, M, Ot, "", "\\@jmath"), v(A, M, tt, "ı", "ı"), v(A, M, tt, "ȷ", "ȷ"), v(dt, M, tt, "ı", "\\i", true), v(dt, M, tt, "ȷ", "\\j", true), v(dt, M, tt, "ß", "\\ss", true), v(dt, M, tt, "æ", "\\ae", true), v(dt, M, tt, "œ", "\\oe", true), v(dt, M, tt, "ø", "\\o", true), v(dt, M, tt, "Æ", "\\AE", true), v(dt, M, tt, "Œ", "\\OE", true), v(dt, M, tt, "Ø", "\\O", true), v(dt, M, se, "ˊ", "\\'"), v(dt, M, se, "ˋ", "\\`"), v(dt, M, se, "ˆ", "\\^"), v(dt, M, se, "˜", "\\~"), v(dt, M, se, "ˉ", "\\="), v(dt, M, se, "˘", "\\u"), v(dt, M, se, "˙", "\\."), v(dt, M, se, "¸", "\\c"), v(dt, M, se, "˚", "\\r"), v(dt, M, se, "ˇ", "\\v"), v(dt, M, se, "¨", '\\"'), v(dt, M, se, "˝", "\\H"), v(dt, M, se, "◯", "\\textcircled");
          const Ae = {
            "--": true,
            "---": true,
            "``": true,
            "''": true
          };
          v(dt, M, tt, "–", "--", true), v(dt, M, tt, "–", "\\textendash"), v(dt, M, tt, "—", "---", true), v(dt, M, tt, "—", "\\textemdash"), v(dt, M, tt, "‘", "`", true), v(dt, M, tt, "‘", "\\textquoteleft"), v(dt, M, tt, "’", "'", true), v(dt, M, tt, "’", "\\textquoteright"), v(dt, M, tt, "“", "``", true), v(dt, M, tt, "“", "\\textquotedblleft"), v(dt, M, tt, "”", "''", true), v(dt, M, tt, "”", "\\textquotedblright"), v(A, M, tt, "°", "\\degree", true), v(dt, M, tt, "°", "\\degree"), v(dt, M, tt, "°", "\\textdegree", true), v(A, M, tt, "£", "\\pounds"), v(A, M, tt, "£", "\\mathsterling", true), v(dt, M, tt, "£", "\\pounds"), v(dt, M, tt, "£", "\\textsterling", true), v(A, V, tt, "✠", "\\maltese"), v(dt, V, tt, "✠", "\\maltese");
          const an = '0123456789/@."';
          for (let d = 0; d < an.length; d++) {
            const u = an.charAt(d);
            v(A, M, tt, u, u);
          }
          const Fr = '0123456789!@*()-=+";:?/.,';
          for (let d = 0; d < Fr.length; d++) {
            const u = Fr.charAt(d);
            v(dt, M, tt, u, u);
          }
          const _r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          for (let d = 0; d < _r.length; d++) {
            const u = _r.charAt(d);
            v(A, M, Ot, u, u), v(dt, M, tt, u, u);
          }
          v(A, V, tt, "C", "ℂ"), v(dt, V, tt, "C", "ℂ"), v(A, V, tt, "H", "ℍ"), v(dt, V, tt, "H", "ℍ"), v(A, V, tt, "N", "ℕ"), v(dt, V, tt, "N", "ℕ"), v(A, V, tt, "P", "ℙ"), v(dt, V, tt, "P", "ℙ"), v(A, V, tt, "Q", "ℚ"), v(dt, V, tt, "Q", "ℚ"), v(A, V, tt, "R", "ℝ"), v(dt, V, tt, "R", "ℝ"), v(A, V, tt, "Z", "ℤ"), v(dt, V, tt, "Z", "ℤ"), v(A, M, Ot, "h", "ℎ"), v(dt, M, Ot, "h", "ℎ");
          let qt = "";
          for (let d = 0; d < _r.length; d++) {
            const u = _r.charAt(d);
            qt = String.fromCharCode(55349, 56320 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56372 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56424 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56580 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56684 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56736 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56788 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56840 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56944 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), d < 26 && (qt = String.fromCharCode(55349, 56632 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 56476 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt));
          }
          qt = "𝕜", v(A, M, Ot, "k", qt), v(dt, M, tt, "k", qt);
          for (let d = 0; d < 10; d++) {
            const u = d.toString();
            qt = String.fromCharCode(55349, 57294 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 57314 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 57324 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt), qt = String.fromCharCode(55349, 57334 + d), v(A, M, Ot, u, qt), v(dt, M, tt, u, qt);
          }
          const Ue = "ÐÞþ";
          for (let d = 0; d < Ue.length; d++) {
            const u = Ue.charAt(d);
            v(A, M, Ot, u, u), v(dt, M, tt, u, u);
          }
          const Cs = [
            ["mathbf", "textbf", "Main-Bold"],
            // A-Z bold upright
            ["mathbf", "textbf", "Main-Bold"],
            // a-z bold upright
            ["mathnormal", "textit", "Math-Italic"],
            // A-Z italic
            ["mathnormal", "textit", "Math-Italic"],
            // a-z italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // A-Z bold italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // a-z bold italic
            // Map fancy A-Z letters to script, not calligraphic.
            // This aligns with unicode-math and math fonts (except Cambria Math).
            ["mathscr", "textscr", "Script-Regular"],
            // A-Z script
            ["", "", ""],
            // a-z script.  No font
            ["", "", ""],
            // A-Z bold script. No font
            ["", "", ""],
            // a-z bold script. No font
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // A-Z Fraktur
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // a-z Fraktur
            ["mathbb", "textbb", "AMS-Regular"],
            // A-Z double-struck
            ["mathbb", "textbb", "AMS-Regular"],
            // k double-struck
            // Note that we are using a bold font, but font metrics for regular Fraktur.
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // A-Z bold Fraktur
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // a-z bold Fraktur
            ["mathsf", "textsf", "SansSerif-Regular"],
            // A-Z sans-serif
            ["mathsf", "textsf", "SansSerif-Regular"],
            // a-z sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // A-Z bold sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // a-z bold sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // A-Z italic sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // a-z italic sans-serif
            ["", "", ""],
            // A-Z bold italic sans. No font
            ["", "", ""],
            // a-z bold italic sans. No font
            ["mathtt", "texttt", "Typewriter-Regular"],
            // A-Z monospace
            ["mathtt", "texttt", "Typewriter-Regular"]
            // a-z monospace
          ], $c = [
            ["mathbf", "textbf", "Main-Bold"],
            // 0-9 bold
            ["", "", ""],
            // 0-9 double-struck. No KaTeX font.
            ["mathsf", "textsf", "SansSerif-Regular"],
            // 0-9 sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // 0-9 bold sans-serif
            ["mathtt", "texttt", "Typewriter-Regular"]
            // 0-9 monospace
          ], k_ = function(d, u) {
            const f = d.charCodeAt(0), b = d.charCodeAt(1), w = (f - 55296) * 1024 + (b - 56320) + 65536, T = u === "math" ? 0 : 1;
            if (119808 <= w && w < 120484) {
              const E = Math.floor((w - 119808) / 26);
              return [Cs[E][2], Cs[E][T]];
            } else if (120782 <= w && w <= 120831) {
              const E = Math.floor((w - 120782) / 10);
              return [$c[E][2], $c[E][T]];
            } else {
              if (w === 120485 || w === 120486)
                return [Cs[0][2], Cs[0][T]];
              if (120486 < w && w < 120782)
                return ["", ""];
              throw new s("Unsupported character: " + d);
            }
          }, Ec = function(d, u, f) {
            return fe[f][d] && fe[f][d].replace && (d = fe[f][d].replace), {
              value: d,
              metrics: Ca(d, u, f)
            };
          }, vn = function(d, u, f, b, w) {
            const T = Ec(d, u, f), E = T.metrics;
            d = T.value;
            let D;
            if (E) {
              let P = E.italic;
              (f === "text" || b && b.font === "mathit") && (P = 0), D = new Dr(d, E.height, E.depth, P, E.skew, E.width, w);
            } else
              typeof console < "u" && console.warn("No character metrics " + ("for '" + d + "' in style '" + u + "' and mode '" + f + "'")), D = new Dr(d, 0, 0, 0, 0, 0, w);
            if (b) {
              D.maxFontSize = b.sizeMultiplier, b.style.isTight() && D.classes.push("mtight");
              const P = b.getColor();
              P && (D.style.color = P);
            }
            return D;
          }, v_ = function(d, u, f, b) {
            return b === void 0 && (b = []), f.font === "boldsymbol" && Ec(d, "Main-Bold", u).metrics ? vn(d, "Main-Bold", u, f, b.concat(["mathbf"])) : d === "\\" || fe[u][d].font === "main" ? vn(d, "Main-Regular", u, f, b) : vn(d, "AMS-Regular", u, f, b.concat(["amsrm"]));
          }, __ = function(d, u, f, b, w) {
            return w !== "textord" && Ec(d, "Math-BoldItalic", u).metrics ? {
              fontName: "Math-BoldItalic",
              fontClass: "boldsymbol"
            } : {
              fontName: "Main-Bold",
              fontClass: "mathbf"
            };
          }, C_ = function(d, u, f) {
            const b = d.mode, w = d.text, T = ["mord"], E = b === "math" || b === "text" && u.font, D = E ? u.font : u.fontFamily;
            let P = "", Q = "";
            if (w.charCodeAt(0) === 55349 && ([P, Q] = k_(w, b)), P.length > 0)
              return vn(w, P, b, u, T.concat(Q));
            if (D) {
              let nt, it;
              if (D === "boldsymbol") {
                const lt = __(w, b, u, T, f);
                nt = lt.fontName, it = [lt.fontClass];
              } else E ? (nt = zg[D].fontName, it = [D]) : (nt = Mc(D, u.fontWeight, u.fontShape), it = [D, u.fontWeight, u.fontShape]);
              if (Ec(w, nt, b).metrics)
                return vn(w, nt, b, u, T.concat(it));
              if (Ae.hasOwnProperty(w) && nt.slice(0, 10) === "Typewriter") {
                const lt = [];
                for (let yt = 0; yt < w.length; yt++)
                  lt.push(vn(w[yt], nt, b, u, T.concat(it)));
                return Og(lt);
              }
            }
            if (f === "mathord")
              return vn(w, "Math-Italic", b, u, T.concat(["mathnormal"]));
            if (f === "textord") {
              const nt = fe[b][w] && fe[b][w].font;
              if (nt === "ams") {
                const it = Mc("amsrm", u.fontWeight, u.fontShape);
                return vn(w, it, b, u, T.concat("amsrm", u.fontWeight, u.fontShape));
              } else if (nt === "main" || !nt) {
                const it = Mc("textrm", u.fontWeight, u.fontShape);
                return vn(w, it, b, u, T.concat(u.fontWeight, u.fontShape));
              } else {
                const it = Mc(nt, u.fontWeight, u.fontShape);
                return vn(w, it, b, u, T.concat(it, u.fontWeight, u.fontShape));
              }
            } else
              throw new Error("unexpected type: " + f + " in makeOrd");
          }, S_ = (d, u) => {
            if (kr(d.classes) !== kr(u.classes) || d.skew !== u.skew || d.maxFontSize !== u.maxFontSize)
              return false;
            if (d.classes.length === 1) {
              const f = d.classes[0];
              if (f === "mbin" || f === "mord")
                return false;
            }
            for (const f in d.style)
              if (d.style.hasOwnProperty(f) && d.style[f] !== u.style[f])
                return false;
            for (const f in u.style)
              if (u.style.hasOwnProperty(f) && d.style[f] !== u.style[f])
                return false;
            return true;
          }, T_ = (d) => {
            for (let u = 0; u < d.length - 1; u++) {
              const f = d[u], b = d[u + 1];
              f instanceof Dr && b instanceof Dr && S_(f, b) && (f.text += b.text, f.height = Math.max(f.height, b.height), f.depth = Math.max(f.depth, b.depth), f.italic = b.italic, d.splice(u + 1, 1), u--);
            }
            return d;
          }, J0 = function(d) {
            let u = 0, f = 0, b = 0;
            for (let w = 0; w < d.children.length; w++) {
              const T = d.children[w];
              T.height > u && (u = T.height), T.depth > f && (f = T.depth), T.maxFontSize > b && (b = T.maxFontSize);
            }
            d.height = u, d.depth = f, d.maxFontSize = b;
          }, Nr = function(d, u, f, b) {
            const w = new Nn(d, u, f, b);
            return J0(w), w;
          }, Ig = (d, u, f, b) => new Nn(d, u, f, b), A_ = function(d, u, f) {
            const b = Nr([d], [], u);
            return b.height = Math.max(f || u.fontMetrics().defaultRuleThickness, u.minRuleThickness), b.style.borderBottomWidth = bt(b.height), b.maxFontSize = 1, b;
          }, $_ = function(d, u, f, b) {
            const w = new Ta(d, u, f, b);
            return J0(w), w;
          }, Og = function(d) {
            const u = new sn(d);
            return J0(u), u;
          }, E_ = function(d, u) {
            return d instanceof sn ? Nr([], [d], u) : d;
          }, M_ = function(d) {
            if (d.positionType === "individualShift") {
              const f = d.children, b = [f[0]], w = -f[0].shift - f[0].elem.depth;
              let T = w;
              for (let E = 1; E < f.length; E++) {
                const D = -f[E].shift - T - f[E].elem.depth, P = D - (f[E - 1].elem.height + f[E - 1].elem.depth);
                T = T + D, b.push({
                  type: "kern",
                  size: P
                }), b.push(f[E]);
              }
              return {
                children: b,
                depth: w
              };
            }
            let u;
            if (d.positionType === "top") {
              let f = d.positionData;
              for (let b = 0; b < d.children.length; b++) {
                const w = d.children[b];
                f -= w.type === "kern" ? w.size : w.elem.height + w.elem.depth;
              }
              u = f;
            } else if (d.positionType === "bottom")
              u = -d.positionData;
            else {
              const f = d.children[0];
              if (f.type !== "elem")
                throw new Error('First child must have type "elem".');
              if (d.positionType === "shift")
                u = -f.elem.depth - d.positionData;
              else if (d.positionType === "firstBaseline")
                u = -f.elem.depth;
              else
                throw new Error("Invalid positionType " + d.positionType + ".");
            }
            return {
              children: d.children,
              depth: u
            };
          }, B_ = function(d, u) {
            const {
              children: f,
              depth: b
            } = M_(d);
            let w = 0;
            for (let yt = 0; yt < f.length; yt++) {
              const kt = f[yt];
              if (kt.type === "elem") {
                const Kt = kt.elem;
                w = Math.max(w, Kt.maxFontSize, Kt.height);
              }
            }
            w += 2;
            const T = Nr(["pstrut"], []);
            T.style.height = bt(w);
            const E = [];
            let D = b, P = b, Q = b;
            for (let yt = 0; yt < f.length; yt++) {
              const kt = f[yt];
              if (kt.type === "kern")
                Q += kt.size;
              else {
                const Kt = kt.elem, ie = kt.wrapperClasses || [], ee = kt.wrapperStyle || {}, de = Nr(ie, [T, Kt], void 0, ee);
                de.style.top = bt(-w - Q - Kt.depth), kt.marginLeft && (de.style.marginLeft = kt.marginLeft), kt.marginRight && (de.style.marginRight = kt.marginRight), E.push(de), Q += Kt.height + Kt.depth;
              }
              D = Math.min(D, Q), P = Math.max(P, Q);
            }
            const nt = Nr(["vlist"], E);
            nt.style.height = bt(P);
            let it;
            if (D < 0) {
              const yt = Nr([], []), kt = Nr(["vlist"], [yt]);
              kt.style.height = bt(-D);
              const Kt = Nr(["vlist-s"], [new Dr("​")]);
              it = [Nr(["vlist-r"], [nt, Kt]), Nr(["vlist-r"], [kt])];
            } else
              it = [Nr(["vlist-r"], [nt])];
            const lt = Nr(["vlist-t"], it);
            return it.length === 2 && lt.classes.push("vlist-t2"), lt.height = P, lt.depth = -D, lt;
          }, L_ = (d, u) => {
            const f = Nr(["mspace"], [], u), b = we(d, u);
            return f.style.marginRight = bt(b), f;
          }, Mc = function(d, u, f) {
            let b = "";
            switch (d) {
              case "amsrm":
                b = "AMS";
                break;
              case "textrm":
                b = "Main";
                break;
              case "textsf":
                b = "SansSerif";
                break;
              case "texttt":
                b = "Typewriter";
                break;
              default:
                b = d;
            }
            let w;
            return u === "textbf" && f === "textit" ? w = "BoldItalic" : u === "textbf" ? w = "Bold" : u === "textit" ? w = "Italic" : w = "Regular", b + "-" + w;
          }, zg = {
            // styles
            mathbf: {
              variant: "bold",
              fontName: "Main-Bold"
            },
            mathrm: {
              variant: "normal",
              fontName: "Main-Regular"
            },
            textit: {
              variant: "italic",
              fontName: "Main-Italic"
            },
            mathit: {
              variant: "italic",
              fontName: "Main-Italic"
            },
            mathnormal: {
              variant: "italic",
              fontName: "Math-Italic"
            },
            mathsfit: {
              variant: "sans-serif-italic",
              fontName: "SansSerif-Italic"
            },
            // "boldsymbol" is missing because they require the use of multiple fonts:
            // Math-BoldItalic and Main-Bold.  This is handled by a special case in
            // makeOrd which ends up calling boldsymbol.
            // families
            mathbb: {
              variant: "double-struck",
              fontName: "AMS-Regular"
            },
            mathcal: {
              variant: "script",
              fontName: "Caligraphic-Regular"
            },
            mathfrak: {
              variant: "fraktur",
              fontName: "Fraktur-Regular"
            },
            mathscr: {
              variant: "script",
              fontName: "Script-Regular"
            },
            mathsf: {
              variant: "sans-serif",
              fontName: "SansSerif-Regular"
            },
            mathtt: {
              variant: "monospace",
              fontName: "Typewriter-Regular"
            }
          }, qg = {
            //   path, width, height
            vec: ["vec", 0.471, 0.714],
            // values from the font glyph
            oiintSize1: ["oiintSize1", 0.957, 0.499],
            // oval to overlay the integrand
            oiintSize2: ["oiintSize2", 1.472, 0.659],
            oiiintSize1: ["oiiintSize1", 1.304, 0.499],
            oiiintSize2: ["oiiintSize2", 1.98, 0.659]
          };
          var ot = {
            fontMap: zg,
            makeSymbol: vn,
            mathsym: v_,
            makeSpan: Nr,
            makeSvgSpan: Ig,
            makeLineSpan: A_,
            makeAnchor: $_,
            makeFragment: Og,
            wrapFragment: E_,
            makeVList: B_,
            makeOrd: C_,
            makeGlue: L_,
            staticSvg: function(d, u) {
              const [f, b, w] = qg[d], T = new vr(f), E = new ke([T], {
                width: bt(b),
                height: bt(w),
                // Override CSS rule `.katex svg { width: 100% }`
                style: "width:" + bt(b),
                viewBox: "0 0 " + 1e3 * b + " " + 1e3 * w,
                preserveAspectRatio: "xMinYMin"
              }), D = Ig(["overlay"], [E], u);
              return D.height = w, D.style.height = bt(w), D.style.width = bt(b), D;
            },
            svgData: qg,
            tryCombineChars: T_
          };
          const Fe = {
            number: 3,
            unit: "mu"
          }, Ss = {
            number: 4,
            unit: "mu"
          }, pi = {
            number: 5,
            unit: "mu"
          }, D_ = {
            mord: {
              mop: Fe,
              mbin: Ss,
              mrel: pi,
              minner: Fe
            },
            mop: {
              mord: Fe,
              mop: Fe,
              mrel: pi,
              minner: Fe
            },
            mbin: {
              mord: Ss,
              mop: Ss,
              mopen: Ss,
              minner: Ss
            },
            mrel: {
              mord: pi,
              mop: pi,
              mopen: pi,
              minner: pi
            },
            mopen: {},
            mclose: {
              mop: Fe,
              mbin: Ss,
              mrel: pi,
              minner: Fe
            },
            mpunct: {
              mord: Fe,
              mop: Fe,
              mrel: pi,
              mopen: Fe,
              mclose: Fe,
              mpunct: Fe,
              minner: Fe
            },
            minner: {
              mord: Fe,
              mop: Fe,
              mbin: Ss,
              mrel: pi,
              mopen: Fe,
              mpunct: Fe,
              minner: Fe
            }
          }, F_ = {
            mord: {
              mop: Fe
            },
            mop: {
              mord: Fe,
              mop: Fe
            },
            mbin: {},
            mrel: {},
            mopen: {},
            mclose: {
              mop: Fe
            },
            mpunct: {},
            minner: {
              mop: Fe
            }
          }, Rg = {}, Bc = {}, Lc = {};
          function Ct(d) {
            let {
              type: u,
              names: f,
              props: b,
              handler: w,
              htmlBuilder: T,
              mathmlBuilder: E
            } = d;
            const D = {
              type: u,
              numArgs: b.numArgs,
              argTypes: b.argTypes,
              allowedInArgument: !!b.allowedInArgument,
              allowedInText: !!b.allowedInText,
              allowedInMath: b.allowedInMath === void 0 ? true : b.allowedInMath,
              numOptionalArgs: b.numOptionalArgs || 0,
              infix: !!b.infix,
              primitive: !!b.primitive,
              handler: w
            };
            for (let P = 0; P < f.length; ++P)
              Rg[f[P]] = D;
            u && (T && (Bc[u] = T), E && (Lc[u] = E));
          }
          function Ts(d) {
            let {
              type: u,
              htmlBuilder: f,
              mathmlBuilder: b
            } = d;
            Ct({
              type: u,
              names: [],
              props: {
                numArgs: 0
              },
              handler() {
                throw new Error("Should never be called.");
              },
              htmlBuilder: f,
              mathmlBuilder: b
            });
          }
          const Dc = function(d) {
            return d.type === "ordgroup" && d.body.length === 1 ? d.body[0] : d;
          }, Re = function(d) {
            return d.type === "ordgroup" ? d.body : [d];
          }, fi = ot.makeSpan, N_ = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], I_ = ["rightmost", "mrel", "mclose", "mpunct"], O_ = {
            display: et.DISPLAY,
            text: et.TEXT,
            script: et.SCRIPT,
            scriptscript: et.SCRIPTSCRIPT
          }, z_ = {
            mord: "mord",
            mop: "mop",
            mbin: "mbin",
            mrel: "mrel",
            mopen: "mopen",
            mclose: "mclose",
            mpunct: "mpunct",
            minner: "minner"
          }, Ge = function(d, u, f, b) {
            b === void 0 && (b = [null, null]);
            const w = [];
            for (let Q = 0; Q < d.length; Q++) {
              const nt = ce(d[Q], u);
              if (nt instanceof sn) {
                const it = nt.children;
                w.push(...it);
              } else
                w.push(nt);
            }
            if (ot.tryCombineChars(w), !f)
              return w;
            let T = u;
            if (d.length === 1) {
              const Q = d[0];
              Q.type === "sizing" ? T = u.havingSize(Q.size) : Q.type === "styling" && (T = u.havingStyle(O_[Q.style]));
            }
            const E = fi([b[0] || "leftmost"], [], u), D = fi([b[1] || "rightmost"], [], u), P = f === "root";
            return td(w, (Q, nt) => {
              const it = nt.classes[0], lt = Q.classes[0];
              it === "mbin" && k.contains(I_, lt) ? nt.classes[0] = "mord" : lt === "mbin" && k.contains(N_, it) && (Q.classes[0] = "mord");
            }, {
              node: E
            }, D, P), td(w, (Q, nt) => {
              const it = rd(nt), lt = rd(Q), yt = it && lt ? Q.hasClass("mtight") ? F_[it][lt] : D_[it][lt] : null;
              if (yt)
                return ot.makeGlue(yt, T);
            }, {
              node: E
            }, D, P), w;
          }, td = function(d, u, f, b, w) {
            b && d.push(b);
            let T = 0;
            for (; T < d.length; T++) {
              const E = d[T], D = Pg(E);
              if (D) {
                td(D.children, u, f, null, w);
                continue;
              }
              const P = !E.hasClass("mspace");
              if (P) {
                const Q = u(E, f.node);
                Q && (f.insertAfter ? f.insertAfter(Q) : (d.unshift(Q), T++));
              }
              P ? f.node = E : w && E.hasClass("newline") && (f.node = fi(["leftmost"])), f.insertAfter = /* @__PURE__ */ ((Q) => (nt) => {
                d.splice(Q + 1, 0, nt), T++;
              })(T);
            }
            b && d.pop();
          }, Pg = function(d) {
            return d instanceof sn || d instanceof Ta || d instanceof Nn && d.hasClass("enclosing") ? d : null;
          }, ed = function(d, u) {
            const f = Pg(d);
            if (f) {
              const b = f.children;
              if (b.length) {
                if (u === "right")
                  return ed(b[b.length - 1], "right");
                if (u === "left")
                  return ed(b[0], "left");
              }
            }
            return d;
          }, rd = function(d, u) {
            return d ? (u && (d = ed(d, u)), z_[d.classes[0]] || null) : null;
          }, Ma = function(d, u) {
            const f = ["nulldelimiter"].concat(d.baseSizingClasses());
            return fi(u.concat(f));
          }, ce = function(d, u, f) {
            if (!d)
              return fi();
            if (Bc[d.type]) {
              let b = Bc[d.type](d, u);
              if (f && u.size !== f.size) {
                b = fi(u.sizingClasses(f), [b], u);
                const w = u.sizeMultiplier / f.sizeMultiplier;
                b.height *= w, b.depth *= w;
              }
              return b;
            } else
              throw new s("Got group of unknown type: '" + d.type + "'");
          };
          function Fc(d, u) {
            const f = fi(["base"], d, u), b = fi(["strut"]);
            return b.style.height = bt(f.height + f.depth), f.depth && (b.style.verticalAlign = bt(-f.depth)), f.children.unshift(b), f;
          }
          function nd(d, u) {
            let f = null;
            d.length === 1 && d[0].type === "tag" && (f = d[0].tag, d = d[0].body);
            const b = Ge(d, u, "root");
            let w;
            b.length === 2 && b[1].hasClass("tag") && (w = b.pop());
            const T = [];
            let E = [];
            for (let Q = 0; Q < b.length; Q++)
              if (E.push(b[Q]), b[Q].hasClass("mbin") || b[Q].hasClass("mrel") || b[Q].hasClass("allowbreak")) {
                let nt = false;
                for (; Q < b.length - 1 && b[Q + 1].hasClass("mspace") && !b[Q + 1].hasClass("newline"); )
                  Q++, E.push(b[Q]), b[Q].hasClass("nobreak") && (nt = true);
                nt || (T.push(Fc(E, u)), E = []);
              } else b[Q].hasClass("newline") && (E.pop(), E.length > 0 && (T.push(Fc(E, u)), E = []), T.push(b[Q]));
            E.length > 0 && T.push(Fc(E, u));
            let D;
            f ? (D = Fc(Ge(f, u, true)), D.classes = ["tag"], T.push(D)) : w && T.push(w);
            const P = fi(["katex-html"], T);
            if (P.setAttribute("aria-hidden", "true"), D) {
              const Q = D.children[0];
              Q.style.height = bt(P.height + P.depth), P.depth && (Q.style.verticalAlign = bt(-P.depth));
            }
            return P;
          }
          function jg(d) {
            return new sn(d);
          }
          class Xr {
            constructor(u, f, b) {
              this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = u, this.attributes = {}, this.children = f || [], this.classes = b || [];
            }
            /**
             * Sets an attribute on a MathML node. MathML depends on attributes to convey a
             * semantic content, so this is used heavily.
             */
            setAttribute(u, f) {
              this.attributes[u] = f;
            }
            /**
             * Gets an attribute on a MathML node.
             */
            getAttribute(u) {
              return this.attributes[u];
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              const u = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && u.setAttribute(f, this.attributes[f]);
              this.classes.length > 0 && (u.className = kr(this.classes));
              for (let f = 0; f < this.children.length; f++)
                if (this.children[f] instanceof In && this.children[f + 1] instanceof In) {
                  let b = this.children[f].toText() + this.children[++f].toText();
                  for (; this.children[f + 1] instanceof In; )
                    b += this.children[++f].toText();
                  u.appendChild(new In(b).toNode());
                } else
                  u.appendChild(this.children[f].toNode());
              return u;
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              let u = "<" + this.type;
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && (u += " " + f + '="', u += k.escape(this.attributes[f]), u += '"');
              this.classes.length > 0 && (u += ' class ="' + k.escape(kr(this.classes)) + '"'), u += ">";
              for (let f = 0; f < this.children.length; f++)
                u += this.children[f].toMarkup();
              return u += "</" + this.type + ">", u;
            }
            /**
             * Converts the math node into a string, similar to innerText, but escaped.
             */
            toText() {
              return this.children.map((u) => u.toText()).join("");
            }
          }
          class In {
            constructor(u) {
              this.text = void 0, this.text = u;
            }
            /**
             * Converts the text node into a DOM text node.
             */
            toNode() {
              return document.createTextNode(this.text);
            }
            /**
             * Converts the text node into escaped HTML markup
             * (representing the text itself).
             */
            toMarkup() {
              return k.escape(this.toText());
            }
            /**
             * Converts the text node into a string
             * (representing the text itself).
             */
            toText() {
              return this.text;
            }
          }
          class q_ {
            /**
             * Create a Space node with width given in CSS ems.
             */
            constructor(u) {
              this.width = void 0, this.character = void 0, this.width = u, u >= 0.05555 && u <= 0.05556 ? this.character = " " : u >= 0.1666 && u <= 0.1667 ? this.character = " " : u >= 0.2222 && u <= 0.2223 ? this.character = " " : u >= 0.2777 && u <= 0.2778 ? this.character = "  " : u >= -0.05556 && u <= -0.05555 ? this.character = " ⁣" : u >= -0.1667 && u <= -0.1666 ? this.character = " ⁣" : u >= -0.2223 && u <= -0.2222 ? this.character = " ⁣" : u >= -0.2778 && u <= -0.2777 ? this.character = " ⁣" : this.character = null;
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              if (this.character)
                return document.createTextNode(this.character);
              {
                const u = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                return u.setAttribute("width", bt(this.width)), u;
              }
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + bt(this.width) + '"/>';
            }
            /**
             * Converts the math node into a string, similar to innerText.
             */
            toText() {
              return this.character ? this.character : " ";
            }
          }
          var ft = {
            MathNode: Xr,
            TextNode: In,
            SpaceNode: q_,
            newDocumentFragment: jg
          };
          const ln = function(d, u, f) {
            return fe[u][d] && fe[u][d].replace && d.charCodeAt(0) !== 55349 && !(Ae.hasOwnProperty(d) && f && (f.fontFamily && f.fontFamily.slice(4, 6) === "tt" || f.font && f.font.slice(4, 6) === "tt")) && (d = fe[u][d].replace), new ft.TextNode(d);
          }, id = function(d) {
            return d.length === 1 ? d[0] : new ft.MathNode("mrow", d);
          }, sd = function(d, u) {
            if (u.fontFamily === "texttt")
              return "monospace";
            if (u.fontFamily === "textsf")
              return u.fontShape === "textit" && u.fontWeight === "textbf" ? "sans-serif-bold-italic" : u.fontShape === "textit" ? "sans-serif-italic" : u.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
            if (u.fontShape === "textit" && u.fontWeight === "textbf")
              return "bold-italic";
            if (u.fontShape === "textit")
              return "italic";
            if (u.fontWeight === "textbf")
              return "bold";
            const f = u.font;
            if (!f || f === "mathnormal")
              return null;
            const b = d.mode;
            if (f === "mathit")
              return "italic";
            if (f === "boldsymbol")
              return d.type === "textord" ? "bold" : "bold-italic";
            if (f === "mathbf")
              return "bold";
            if (f === "mathbb")
              return "double-struck";
            if (f === "mathsfit")
              return "sans-serif-italic";
            if (f === "mathfrak")
              return "fraktur";
            if (f === "mathscr" || f === "mathcal")
              return "script";
            if (f === "mathsf")
              return "sans-serif";
            if (f === "mathtt")
              return "monospace";
            let w = d.text;
            if (k.contains(["\\imath", "\\jmath"], w))
              return null;
            fe[b][w] && fe[b][w].replace && (w = fe[b][w].replace);
            const T = ot.fontMap[f].fontName;
            return Ca(w, T, b) ? ot.fontMap[f].variant : null;
          };
          function od(d) {
            if (!d)
              return false;
            if (d.type === "mi" && d.children.length === 1) {
              const u = d.children[0];
              return u instanceof In && u.text === ".";
            } else if (d.type === "mo" && d.children.length === 1 && d.getAttribute("separator") === "true" && d.getAttribute("lspace") === "0em" && d.getAttribute("rspace") === "0em") {
              const u = d.children[0];
              return u instanceof In && u.text === ",";
            } else
              return false;
          }
          const Ir = function(d, u, f) {
            if (d.length === 1) {
              const T = _e(d[0], u);
              return f && T instanceof Xr && T.type === "mo" && (T.setAttribute("lspace", "0em"), T.setAttribute("rspace", "0em")), [T];
            }
            const b = [];
            let w;
            for (let T = 0; T < d.length; T++) {
              const E = _e(d[T], u);
              if (E instanceof Xr && w instanceof Xr) {
                if (E.type === "mtext" && w.type === "mtext" && E.getAttribute("mathvariant") === w.getAttribute("mathvariant")) {
                  w.children.push(...E.children);
                  continue;
                } else if (E.type === "mn" && w.type === "mn") {
                  w.children.push(...E.children);
                  continue;
                } else if (od(E) && w.type === "mn") {
                  w.children.push(...E.children);
                  continue;
                } else if (E.type === "mn" && od(w))
                  E.children = [...w.children, ...E.children], b.pop();
                else if ((E.type === "msup" || E.type === "msub") && E.children.length >= 1 && (w.type === "mn" || od(w))) {
                  const D = E.children[0];
                  D instanceof Xr && D.type === "mn" && (D.children = [...w.children, ...D.children], b.pop());
                } else if (w.type === "mi" && w.children.length === 1) {
                  const D = w.children[0];
                  if (D instanceof In && D.text === "̸" && (E.type === "mo" || E.type === "mi" || E.type === "mn")) {
                    const P = E.children[0];
                    P instanceof In && P.text.length > 0 && (P.text = P.text.slice(0, 1) + "̸" + P.text.slice(1), b.pop());
                  }
                }
              }
              b.push(E), w = E;
            }
            return b;
          }, ji = function(d, u, f) {
            return id(Ir(d, u, f));
          }, _e = function(d, u) {
            if (!d)
              return new ft.MathNode("mrow");
            if (Lc[d.type])
              return Lc[d.type](d, u);
            throw new s("Got group of unknown type: '" + d.type + "'");
          };
          function Wg(d, u, f, b, w) {
            const T = Ir(d, f);
            let E;
            T.length === 1 && T[0] instanceof Xr && k.contains(["mrow", "mtable"], T[0].type) ? E = T[0] : E = new ft.MathNode("mrow", T);
            const D = new ft.MathNode("annotation", [new ft.TextNode(u)]);
            D.setAttribute("encoding", "application/x-tex");
            const P = new ft.MathNode("semantics", [E, D]), Q = new ft.MathNode("math", [P]);
            Q.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), b && Q.setAttribute("display", "block");
            const nt = w ? "katex" : "katex-mathml";
            return ot.makeSpan([nt], [Q]);
          }
          const Hg = function(d) {
            return new Cc({
              style: d.displayMode ? et.DISPLAY : et.TEXT,
              maxSize: d.maxSize,
              minRuleThickness: d.minRuleThickness
            });
          }, Ug = function(d, u) {
            if (u.displayMode) {
              const f = ["katex-display"];
              u.leqno && f.push("leqno"), u.fleqn && f.push("fleqn"), d = ot.makeSpan(f, [d]);
            }
            return d;
          }, R_ = function(d, u, f) {
            const b = Hg(f);
            let w;
            if (f.output === "mathml")
              return Wg(d, u, b, f.displayMode, true);
            if (f.output === "html") {
              const T = nd(d, b);
              w = ot.makeSpan(["katex"], [T]);
            } else {
              const T = Wg(d, u, b, f.displayMode, false), E = nd(d, b);
              w = ot.makeSpan(["katex"], [T, E]);
            }
            return Ug(w, f);
          }, P_ = function(d, u, f) {
            const b = Hg(f), w = nd(d, b), T = ot.makeSpan(["katex"], [w]);
            return Ug(T, f);
          }, j_ = {
            widehat: "^",
            widecheck: "ˇ",
            widetilde: "~",
            utilde: "~",
            overleftarrow: "←",
            underleftarrow: "←",
            xleftarrow: "←",
            overrightarrow: "→",
            underrightarrow: "→",
            xrightarrow: "→",
            underbrace: "⏟",
            overbrace: "⏞",
            overgroup: "⏠",
            undergroup: "⏡",
            overleftrightarrow: "↔",
            underleftrightarrow: "↔",
            xleftrightarrow: "↔",
            Overrightarrow: "⇒",
            xRightarrow: "⇒",
            overleftharpoon: "↼",
            xleftharpoonup: "↼",
            overrightharpoon: "⇀",
            xrightharpoonup: "⇀",
            xLeftarrow: "⇐",
            xLeftrightarrow: "⇔",
            xhookleftarrow: "↩",
            xhookrightarrow: "↪",
            xmapsto: "↦",
            xrightharpoondown: "⇁",
            xleftharpoondown: "↽",
            xrightleftharpoons: "⇌",
            xleftrightharpoons: "⇋",
            xtwoheadleftarrow: "↞",
            xtwoheadrightarrow: "↠",
            xlongequal: "=",
            xtofrom: "⇄",
            xrightleftarrows: "⇄",
            xrightequilibrium: "⇌",
            // Not a perfect match.
            xleftequilibrium: "⇋",
            // None better available.
            "\\cdrightarrow": "→",
            "\\cdleftarrow": "←",
            "\\cdlongequal": "="
          }, W_ = function(d) {
            const u = new ft.MathNode("mo", [new ft.TextNode(j_[d.replace(/^\\/, "")])]);
            return u.setAttribute("stretchy", "true"), u;
          }, H_ = {
            //   path(s), minWidth, height, align
            overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
            "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
            // CD minwwidth2.5pc
            xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
            "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
            Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
            xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
            xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
            overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
            overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
            xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
            "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
            xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
            xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
            overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
            underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
            underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
            xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
            xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
            xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
            xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
            xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
            overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
            undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
            xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
            xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
            // The next three arrows are from the mhchem package.
            // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
            // document as \xrightarrow or \xrightleftharpoons. Those have
            // min-length = 1.75em, so we set min-length on these next three to match.
            xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
            xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
            xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
          }, U_ = function(d) {
            return d.type === "ordgroup" ? d.body.length : 1;
          };
          var mi = {
            encloseSpan: function(d, u, f, b, w) {
              let T;
              const E = d.height + d.depth + f + b;
              if (/fbox|color|angl/.test(u)) {
                if (T = ot.makeSpan(["stretchy", u], [], w), u === "fbox") {
                  const D = w.color && w.getColor();
                  D && (T.style.borderColor = D);
                }
              } else {
                const D = [];
                /^[bx]cancel$/.test(u) && D.push(new Aa({
                  x1: "0",
                  y1: "0",
                  x2: "100%",
                  y2: "100%",
                  "stroke-width": "0.046em"
                })), /^x?cancel$/.test(u) && D.push(new Aa({
                  x1: "0",
                  y1: "100%",
                  x2: "100%",
                  y2: "0",
                  "stroke-width": "0.046em"
                }));
                const P = new ke(D, {
                  width: "100%",
                  height: bt(E)
                });
                T = ot.makeSvgSpan([], [P], w);
              }
              return T.height = E, T.style.height = bt(E), T;
            },
            mathMLnode: W_,
            svgSpan: function(d, u) {
              function f() {
                let E = 4e5;
                const D = d.label.slice(1);
                if (k.contains(["widehat", "widecheck", "widetilde", "utilde"], D)) {
                  const P = U_(d.base);
                  let Q, nt, it;
                  if (P > 5)
                    D === "widehat" || D === "widecheck" ? (Q = 420, E = 2364, it = 0.42, nt = D + "4") : (Q = 312, E = 2340, it = 0.34, nt = "tilde4");
                  else {
                    const kt = [1, 1, 2, 2, 3, 3][P];
                    D === "widehat" || D === "widecheck" ? (E = [0, 1062, 2364, 2364, 2364][kt], Q = [0, 239, 300, 360, 420][kt], it = [0, 0.24, 0.3, 0.3, 0.36, 0.42][kt], nt = D + kt) : (E = [0, 600, 1033, 2339, 2340][kt], Q = [0, 260, 286, 306, 312][kt], it = [0, 0.26, 0.286, 0.3, 0.306, 0.34][kt], nt = "tilde" + kt);
                  }
                  const lt = new vr(nt), yt = new ke([lt], {
                    width: "100%",
                    height: bt(it),
                    viewBox: "0 0 " + E + " " + Q,
                    preserveAspectRatio: "none"
                  });
                  return {
                    span: ot.makeSvgSpan([], [yt], u),
                    minWidth: 0,
                    height: it
                  };
                } else {
                  const P = [], Q = H_[D], [nt, it, lt] = Q, yt = lt / 1e3, kt = nt.length;
                  let Kt, ie;
                  if (kt === 1) {
                    const ee = Q[3];
                    Kt = ["hide-tail"], ie = [ee];
                  } else if (kt === 2)
                    Kt = ["halfarrow-left", "halfarrow-right"], ie = ["xMinYMin", "xMaxYMin"];
                  else if (kt === 3)
                    Kt = ["brace-left", "brace-center", "brace-right"], ie = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                  else
                    throw new Error(`Correct katexImagesData or update code here to support
                    ` + kt + " children.");
                  for (let ee = 0; ee < kt; ee++) {
                    const de = new vr(nt[ee]), he = new ke([de], {
                      width: "400em",
                      height: bt(yt),
                      viewBox: "0 0 " + E + " " + lt,
                      preserveAspectRatio: ie[ee] + " slice"
                    }), $e = ot.makeSvgSpan([Kt[ee]], [he], u);
                    if (kt === 1)
                      return {
                        span: $e,
                        minWidth: it,
                        height: yt
                      };
                    $e.style.height = bt(yt), P.push($e);
                  }
                  return {
                    span: ot.makeSpan(["stretchy"], P, u),
                    minWidth: it,
                    height: yt
                  };
                }
              }
              const {
                span: b,
                minWidth: w,
                height: T
              } = f();
              return b.height = T, b.style.height = bt(T), w > 0 && (b.style.minWidth = bt(w)), b;
            }
          };
          function Jt(d, u) {
            if (!d || d.type !== u)
              throw new Error("Expected node of type " + u + ", but got " + (d ? "node of type " + d.type : String(d)));
            return d;
          }
          function ad(d) {
            const u = Nc(d);
            if (!u)
              throw new Error("Expected node of symbol group type, but got " + (d ? "node of type " + d.type : String(d)));
            return u;
          }
          function Nc(d) {
            return d && (d.type === "atom" || Ac.hasOwnProperty(d.type)) ? d : null;
          }
          const ld = (d, u) => {
            let f, b, w;
            d && d.type === "supsub" ? (b = Jt(d.base, "accent"), f = b.base, d.base = f, w = Ea(ce(d, u)), d.base = b) : (b = Jt(d, "accent"), f = b.base);
            const T = ce(f, u.havingCrampedStyle()), E = b.isShifty && k.isCharacterBox(f);
            let D = 0;
            if (E) {
              const lt = k.getBaseElem(f), yt = ce(lt, u.havingCrampedStyle());
              D = $a(yt).skew;
            }
            const P = b.label === "\\c";
            let Q = P ? T.height + T.depth : Math.min(T.height, u.fontMetrics().xHeight), nt;
            if (b.isStretchy)
              nt = mi.svgSpan(b, u), nt = ot.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: T
                }, {
                  type: "elem",
                  elem: nt,
                  wrapperClasses: ["svg-align"],
                  wrapperStyle: D > 0 ? {
                    width: "calc(100% - " + bt(2 * D) + ")",
                    marginLeft: bt(2 * D)
                  } : void 0
                }]
              }, u);
            else {
              let lt, yt;
              b.label === "\\vec" ? (lt = ot.staticSvg("vec", u), yt = ot.svgData.vec[1]) : (lt = ot.makeOrd({
                mode: b.mode,
                text: b.label
              }, u, "textord"), lt = $a(lt), lt.italic = 0, yt = lt.width, P && (Q += lt.depth)), nt = ot.makeSpan(["accent-body"], [lt]);
              const kt = b.label === "\\textcircled";
              kt && (nt.classes.push("accent-full"), Q = T.height);
              let Kt = D;
              kt || (Kt -= yt / 2), nt.style.left = bt(Kt), b.label === "\\textcircled" && (nt.style.top = ".2em"), nt = ot.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: T
                }, {
                  type: "kern",
                  size: -Q
                }, {
                  type: "elem",
                  elem: nt
                }]
              }, u);
            }
            const it = ot.makeSpan(["mord", "accent"], [nt], u);
            return w ? (w.children[0] = it, w.height = Math.max(it.height, w.height), w.classes[0] = "mord", w) : it;
          }, Vg = (d, u) => {
            const f = d.isStretchy ? mi.mathMLnode(d.label) : new ft.MathNode("mo", [ln(d.label, d.mode)]), b = new ft.MathNode("mover", [_e(d.base, u), f]);
            return b.setAttribute("accent", "true"), b;
          }, V_ = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((d) => "\\" + d).join("|"));
          Ct({
            type: "accent",
            names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
            props: {
              numArgs: 1
            },
            handler: (d, u) => {
              const f = Dc(u[0]), b = !V_.test(d.funcName), w = !b || d.funcName === "\\widehat" || d.funcName === "\\widetilde" || d.funcName === "\\widecheck";
              return {
                type: "accent",
                mode: d.parser.mode,
                label: d.funcName,
                isStretchy: b,
                isShifty: w,
                base: f
              };
            },
            htmlBuilder: ld,
            mathmlBuilder: Vg
          }), Ct({
            type: "accent",
            names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
            props: {
              numArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              // unless in strict mode
              argTypes: ["primitive"]
            },
            handler: (d, u) => {
              const f = u[0];
              let b = d.parser.mode;
              return b === "math" && (d.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + d.funcName + " works only in text mode"), b = "text"), {
                type: "accent",
                mode: b,
                label: d.funcName,
                isStretchy: false,
                isShifty: true,
                base: f
              };
            },
            htmlBuilder: ld,
            mathmlBuilder: Vg
          }), Ct({
            type: "accentUnder",
            names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
            props: {
              numArgs: 1
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "accentUnder",
                mode: f.mode,
                label: b,
                base: w
              };
            },
            htmlBuilder: (d, u) => {
              const f = ce(d.base, u), b = mi.svgSpan(d, u), w = d.label === "\\utilde" ? 0.12 : 0, T = ot.makeVList({
                positionType: "top",
                positionData: f.height,
                children: [{
                  type: "elem",
                  elem: b,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: w
                }, {
                  type: "elem",
                  elem: f
                }]
              }, u);
              return ot.makeSpan(["mord", "accentunder"], [T], u);
            },
            mathmlBuilder: (d, u) => {
              const f = mi.mathMLnode(d.label), b = new ft.MathNode("munder", [_e(d.base, u), f]);
              return b.setAttribute("accentunder", "true"), b;
            }
          });
          const Ic = (d) => {
            const u = new ft.MathNode("mpadded", d ? [d] : []);
            return u.setAttribute("width", "+0.6em"), u.setAttribute("lspace", "0.3em"), u;
          };
          Ct({
            type: "xArrow",
            names: [
              "\\xleftarrow",
              "\\xrightarrow",
              "\\xLeftarrow",
              "\\xRightarrow",
              "\\xleftrightarrow",
              "\\xLeftrightarrow",
              "\\xhookleftarrow",
              "\\xhookrightarrow",
              "\\xmapsto",
              "\\xrightharpoondown",
              "\\xrightharpoonup",
              "\\xleftharpoondown",
              "\\xleftharpoonup",
              "\\xrightleftharpoons",
              "\\xleftrightharpoons",
              "\\xlongequal",
              "\\xtwoheadrightarrow",
              "\\xtwoheadleftarrow",
              "\\xtofrom",
              // The next 3 functions are here to support the mhchem extension.
              // Direct use of these functions is discouraged and may break someday.
              "\\xrightleftarrows",
              "\\xrightequilibrium",
              "\\xleftequilibrium",
              // The next 3 functions are here only to support the {CD} environment.
              "\\\\cdrightarrow",
              "\\\\cdleftarrow",
              "\\\\cdlongequal"
            ],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(d, u, f) {
              let {
                parser: b,
                funcName: w
              } = d;
              return {
                type: "xArrow",
                mode: b.mode,
                label: w,
                body: u[0],
                below: f[0]
              };
            },
            // Flow is unable to correctly infer the type of `group`, even though it's
            // unambiguously determined from the passed-in `type` above.
            htmlBuilder(d, u) {
              const f = u.style;
              let b = u.havingStyle(f.sup());
              const w = ot.wrapFragment(ce(d.body, b, u), u), T = d.label.slice(0, 2) === "\\x" ? "x" : "cd";
              w.classes.push(T + "-arrow-pad");
              let E;
              d.below && (b = u.havingStyle(f.sub()), E = ot.wrapFragment(ce(d.below, b, u), u), E.classes.push(T + "-arrow-pad"));
              const D = mi.svgSpan(d, u), P = -u.fontMetrics().axisHeight + 0.5 * D.height;
              let Q = -u.fontMetrics().axisHeight - 0.5 * D.height - 0.111;
              (w.depth > 0.25 || d.label === "\\xleftequilibrium") && (Q -= w.depth);
              let nt;
              if (E) {
                const it = -u.fontMetrics().axisHeight + E.height + 0.5 * D.height + 0.111;
                nt = ot.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: w,
                    shift: Q
                  }, {
                    type: "elem",
                    elem: D,
                    shift: P
                  }, {
                    type: "elem",
                    elem: E,
                    shift: it
                  }]
                }, u);
              } else
                nt = ot.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: w,
                    shift: Q
                  }, {
                    type: "elem",
                    elem: D,
                    shift: P
                  }]
                }, u);
              return nt.children[0].children[0].children[1].classes.push("svg-align"), ot.makeSpan(["mrel", "x-arrow"], [nt], u);
            },
            mathmlBuilder(d, u) {
              const f = mi.mathMLnode(d.label);
              f.setAttribute("minsize", d.label.charAt(0) === "x" ? "1.75em" : "3.0em");
              let b;
              if (d.body) {
                const w = Ic(_e(d.body, u));
                if (d.below) {
                  const T = Ic(_e(d.below, u));
                  b = new ft.MathNode("munderover", [f, T, w]);
                } else
                  b = new ft.MathNode("mover", [f, w]);
              } else if (d.below) {
                const w = Ic(_e(d.below, u));
                b = new ft.MathNode("munder", [f, w]);
              } else
                b = Ic(), b = new ft.MathNode("mover", [f, b]);
              return b;
            }
          });
          const G_ = ot.makeSpan;
          function Gg(d, u) {
            const f = Ge(d.body, u, true);
            return G_([d.mclass], f, u);
          }
          function Xg(d, u) {
            let f;
            const b = Ir(d.body, u);
            return d.mclass === "minner" ? f = new ft.MathNode("mpadded", b) : d.mclass === "mord" ? d.isCharacterBox ? (f = b[0], f.type = "mi") : f = new ft.MathNode("mi", b) : (d.isCharacterBox ? (f = b[0], f.type = "mo") : f = new ft.MathNode("mo", b), d.mclass === "mbin" ? (f.attributes.lspace = "0.22em", f.attributes.rspace = "0.22em") : d.mclass === "mpunct" ? (f.attributes.lspace = "0em", f.attributes.rspace = "0.17em") : d.mclass === "mopen" || d.mclass === "mclose" ? (f.attributes.lspace = "0em", f.attributes.rspace = "0em") : d.mclass === "minner" && (f.attributes.lspace = "0.0556em", f.attributes.width = "+0.1111em")), f;
          }
          Ct({
            type: "mclass",
            names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "mclass",
                mode: f.mode,
                mclass: "m" + b.slice(5),
                // TODO(kevinb): don't prefix with 'm'
                body: Re(w),
                isCharacterBox: k.isCharacterBox(w)
              };
            },
            htmlBuilder: Gg,
            mathmlBuilder: Xg
          });
          const Oc = (d) => {
            const u = d.type === "ordgroup" && d.body.length ? d.body[0] : d;
            return u.type === "atom" && (u.family === "bin" || u.family === "rel") ? "m" + u.family : "mord";
          };
          Ct({
            type: "mclass",
            names: ["\\@binrel"],
            props: {
              numArgs: 2
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "mclass",
                mode: f.mode,
                mclass: Oc(u[0]),
                body: Re(u[1]),
                isCharacterBox: k.isCharacterBox(u[1])
              };
            }
          }), Ct({
            type: "mclass",
            names: ["\\stackrel", "\\overset", "\\underset"],
            props: {
              numArgs: 2
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[1], T = u[0];
              let E;
              b !== "\\stackrel" ? E = Oc(w) : E = "mrel";
              const D = {
                type: "op",
                mode: w.mode,
                limits: true,
                alwaysHandleSupSub: true,
                parentIsSupSub: false,
                symbol: false,
                suppressBaseShift: b !== "\\stackrel",
                body: Re(w)
              }, P = {
                type: "supsub",
                mode: T.mode,
                base: D,
                sup: b === "\\underset" ? null : T,
                sub: b === "\\underset" ? T : null
              };
              return {
                type: "mclass",
                mode: f.mode,
                mclass: E,
                body: [P],
                isCharacterBox: k.isCharacterBox(P)
              };
            },
            htmlBuilder: Gg,
            mathmlBuilder: Xg
          }), Ct({
            type: "pmb",
            names: ["\\pmb"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "pmb",
                mode: f.mode,
                mclass: Oc(u[0]),
                body: Re(u[0])
              };
            },
            htmlBuilder(d, u) {
              const f = Ge(d.body, u, true), b = ot.makeSpan([d.mclass], f, u);
              return b.style.textShadow = "0.02em 0.01em 0.04px", b;
            },
            mathmlBuilder(d, u) {
              const f = Ir(d.body, u), b = new ft.MathNode("mstyle", f);
              return b.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), b;
            }
          });
          const X_ = {
            ">": "\\\\cdrightarrow",
            "<": "\\\\cdleftarrow",
            "=": "\\\\cdlongequal",
            A: "\\uparrow",
            V: "\\downarrow",
            "|": "\\Vert",
            ".": "no arrow"
          }, Yg = () => ({
            type: "styling",
            body: [],
            mode: "math",
            style: "display"
          }), Kg = (d) => d.type === "textord" && d.text === "@", Y_ = (d, u) => (d.type === "mathord" || d.type === "atom") && d.text === u;
          function K_(d, u, f) {
            const b = X_[d];
            switch (b) {
              case "\\\\cdrightarrow":
              case "\\\\cdleftarrow":
                return f.callFunction(b, [u[0]], [u[1]]);
              case "\\uparrow":
              case "\\downarrow": {
                const w = f.callFunction("\\\\cdleft", [u[0]], []), T = {
                  type: "atom",
                  text: b,
                  mode: "math",
                  family: "rel"
                }, E = f.callFunction("\\Big", [T], []), D = f.callFunction("\\\\cdright", [u[1]], []), P = {
                  type: "ordgroup",
                  mode: "math",
                  body: [w, E, D]
                };
                return f.callFunction("\\\\cdparent", [P], []);
              }
              case "\\\\cdlongequal":
                return f.callFunction("\\\\cdlongequal", [], []);
              case "\\Vert": {
                const w = {
                  type: "textord",
                  text: "\\Vert",
                  mode: "math"
                };
                return f.callFunction("\\Big", [w], []);
              }
              default:
                return {
                  type: "textord",
                  text: " ",
                  mode: "math"
                };
            }
          }
          function Z_(d) {
            const u = [];
            for (d.gullet.beginGroup(), d.gullet.macros.set("\\cr", "\\\\\\relax"), d.gullet.beginGroup(); ; ) {
              u.push(d.parseExpression(false, "\\\\")), d.gullet.endGroup(), d.gullet.beginGroup();
              const T = d.fetch().text;
              if (T === "&" || T === "\\\\")
                d.consume();
              else if (T === "\\end") {
                u[u.length - 1].length === 0 && u.pop();
                break;
              } else
                throw new s("Expected \\\\ or \\cr or \\end", d.nextToken);
            }
            let f = [];
            const b = [f];
            for (let T = 0; T < u.length; T++) {
              const E = u[T];
              let D = Yg();
              for (let P = 0; P < E.length; P++)
                if (!Kg(E[P]))
                  D.body.push(E[P]);
                else {
                  f.push(D), P += 1;
                  const Q = ad(E[P]).text, nt = new Array(2);
                  if (nt[0] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  }, nt[1] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  }, !("=|.".indexOf(Q) > -1)) if ("<>AV".indexOf(Q) > -1)
                    for (let lt = 0; lt < 2; lt++) {
                      let yt = true;
                      for (let kt = P + 1; kt < E.length; kt++) {
                        if (Y_(E[kt], Q)) {
                          yt = false, P = kt;
                          break;
                        }
                        if (Kg(E[kt]))
                          throw new s("Missing a " + Q + " character to complete a CD arrow.", E[kt]);
                        nt[lt].body.push(E[kt]);
                      }
                      if (yt)
                        throw new s("Missing a " + Q + " character to complete a CD arrow.", E[P]);
                    }
                  else
                    throw new s('Expected one of "<>AV=|." after @', E[P]);
                  const it = {
                    type: "styling",
                    body: [K_(Q, nt, d)],
                    mode: "math",
                    style: "display"
                    // CD is always displaystyle.
                  };
                  f.push(it), D = Yg();
                }
              T % 2 === 0 ? f.push(D) : f.shift(), f = [], b.push(f);
            }
            d.gullet.endGroup(), d.gullet.endGroup();
            const w = new Array(b[0].length).fill({
              type: "align",
              align: "c",
              pregap: 0.25,
              // CD package sets \enskip between columns.
              postgap: 0.25
              // So pre and post each get half an \enskip, i.e. 0.25em.
            });
            return {
              type: "array",
              mode: "math",
              body: b,
              arraystretch: 1,
              addJot: true,
              rowGaps: [null],
              cols: w,
              colSeparationType: "CD",
              hLinesBeforeRow: new Array(b.length + 1).fill([])
            };
          }
          Ct({
            type: "cdlabel",
            names: ["\\\\cdleft", "\\\\cdright"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              return {
                type: "cdlabel",
                mode: f.mode,
                side: b.slice(4),
                label: u[0]
              };
            },
            htmlBuilder(d, u) {
              const f = u.havingStyle(u.style.sup()), b = ot.wrapFragment(ce(d.label, f, u), u);
              return b.classes.push("cd-label-" + d.side), b.style.bottom = bt(0.8 - b.depth), b.height = 0, b.depth = 0, b;
            },
            mathmlBuilder(d, u) {
              let f = new ft.MathNode("mrow", [_e(d.label, u)]);
              return f = new ft.MathNode("mpadded", [f]), f.setAttribute("width", "0"), d.side === "left" && f.setAttribute("lspace", "-1width"), f.setAttribute("voffset", "0.7em"), f = new ft.MathNode("mstyle", [f]), f.setAttribute("displaystyle", "false"), f.setAttribute("scriptlevel", "1"), f;
            }
          }), Ct({
            type: "cdlabelparent",
            names: ["\\\\cdparent"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "cdlabelparent",
                mode: f.mode,
                fragment: u[0]
              };
            },
            htmlBuilder(d, u) {
              const f = ot.wrapFragment(ce(d.fragment, u), u);
              return f.classes.push("cd-vert-arrow"), f;
            },
            mathmlBuilder(d, u) {
              return new ft.MathNode("mrow", [_e(d.fragment, u)]);
            }
          }), Ct({
            type: "textord",
            names: ["\\@char"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = Jt(u[0], "ordgroup").body;
              let w = "";
              for (let D = 0; D < b.length; D++) {
                const P = Jt(b[D], "textord");
                w += P.text;
              }
              let T = parseInt(w), E;
              if (isNaN(T))
                throw new s("\\@char has non-numeric argument " + w);
              if (T < 0 || T >= 1114111)
                throw new s("\\@char with invalid code point " + w);
              return T <= 65535 ? E = String.fromCharCode(T) : (T -= 65536, E = String.fromCharCode((T >> 10) + 55296, (T & 1023) + 56320)), {
                type: "textord",
                mode: f.mode,
                text: E
              };
            }
          });
          const Zg = (d, u) => {
            const f = Ge(d.body, u.withColor(d.color), false);
            return ot.makeFragment(f);
          }, Qg = (d, u) => {
            const f = Ir(d.body, u.withColor(d.color)), b = new ft.MathNode("mstyle", f);
            return b.setAttribute("mathcolor", d.color), b;
          };
          Ct({
            type: "color",
            names: ["\\textcolor"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "original"]
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = Jt(u[0], "color-token").color, w = u[1];
              return {
                type: "color",
                mode: f.mode,
                color: b,
                body: Re(w)
              };
            },
            htmlBuilder: Zg,
            mathmlBuilder: Qg
          }), Ct({
            type: "color",
            names: ["\\color"],
            props: {
              numArgs: 1,
              allowedInText: true,
              argTypes: ["color"]
            },
            handler(d, u) {
              let {
                parser: f,
                breakOnTokenText: b
              } = d;
              const w = Jt(u[0], "color-token").color;
              f.gullet.macros.set("\\current@color", w);
              const T = f.parseExpression(true, b);
              return {
                type: "color",
                mode: f.mode,
                color: w,
                body: T
              };
            },
            htmlBuilder: Zg,
            mathmlBuilder: Qg
          }), Ct({
            type: "cr",
            names: ["\\\\"],
            props: {
              numArgs: 0,
              numOptionalArgs: 0,
              allowedInText: true
            },
            handler(d, u, f) {
              let {
                parser: b
              } = d;
              const w = b.gullet.future().text === "[" ? b.parseSizeGroup(true) : null, T = !b.settings.displayMode || !b.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
              return {
                type: "cr",
                mode: b.mode,
                newLine: T,
                size: w && Jt(w, "size").value
              };
            },
            // The following builders are called only at the top level,
            // not within tabular/array environments.
            htmlBuilder(d, u) {
              const f = ot.makeSpan(["mspace"], [], u);
              return d.newLine && (f.classes.push("newline"), d.size && (f.style.marginTop = bt(we(d.size, u)))), f;
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mspace");
              return d.newLine && (f.setAttribute("linebreak", "newline"), d.size && f.setAttribute("height", bt(we(d.size, u)))), f;
            }
          });
          const cd = {
            "\\global": "\\global",
            "\\long": "\\\\globallong",
            "\\\\globallong": "\\\\globallong",
            "\\def": "\\gdef",
            "\\gdef": "\\gdef",
            "\\edef": "\\xdef",
            "\\xdef": "\\xdef",
            "\\let": "\\\\globallet",
            "\\futurelet": "\\\\globalfuture"
          }, Jg = (d) => {
            const u = d.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(u))
              throw new s("Expected a control sequence", d);
            return u;
          }, Q_ = (d) => {
            let u = d.gullet.popToken();
            return u.text === "=" && (u = d.gullet.popToken(), u.text === " " && (u = d.gullet.popToken())), u;
          }, ty = (d, u, f, b) => {
            let w = d.gullet.macros.get(f.text);
            w == null && (f.noexpand = true, w = {
              tokens: [f],
              numArgs: 0,
              // reproduce the same behavior in expansion
              unexpandable: !d.gullet.isExpandable(f.text)
            }), d.gullet.macros.set(u, w, b);
          };
          Ct({
            type: "internal",
            names: [
              "\\global",
              "\\long",
              "\\\\globallong"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              u.consumeSpaces();
              const b = u.fetch();
              if (cd[b.text])
                return (f === "\\global" || f === "\\\\globallong") && (b.text = cd[b.text]), Jt(u.parseFunction(), "internal");
              throw new s("Invalid token after macro prefix", b);
            }
          }), Ct({
            type: "internal",
            names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d, b = u.gullet.popToken();
              const w = b.text;
              if (/^(?:[\\{}$&#^_]|EOF)$/.test(w))
                throw new s("Expected a control sequence", b);
              let T = 0, E;
              const D = [[]];
              for (; u.gullet.future().text !== "{"; )
                if (b = u.gullet.popToken(), b.text === "#") {
                  if (u.gullet.future().text === "{") {
                    E = u.gullet.future(), D[T].push("{");
                    break;
                  }
                  if (b = u.gullet.popToken(), !/^[1-9]$/.test(b.text))
                    throw new s('Invalid argument number "' + b.text + '"');
                  if (parseInt(b.text) !== T + 1)
                    throw new s('Argument number "' + b.text + '" out of order');
                  T++, D.push([]);
                } else {
                  if (b.text === "EOF")
                    throw new s("Expected a macro definition");
                  D[T].push(b.text);
                }
              let {
                tokens: P
              } = u.gullet.consumeArg();
              return E && P.unshift(E), (f === "\\edef" || f === "\\xdef") && (P = u.gullet.expandTokens(P), P.reverse()), u.gullet.macros.set(w, {
                tokens: P,
                numArgs: T,
                delimiters: D
              }, f === cd[f]), {
                type: "internal",
                mode: u.mode
              };
            }
          }), Ct({
            type: "internal",
            names: [
              "\\let",
              "\\\\globallet"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              const b = Jg(u.gullet.popToken());
              u.gullet.consumeSpaces();
              const w = Q_(u);
              return ty(u, b, w, f === "\\\\globallet"), {
                type: "internal",
                mode: u.mode
              };
            }
          }), Ct({
            type: "internal",
            names: [
              "\\futurelet",
              "\\\\globalfuture"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              const b = Jg(u.gullet.popToken()), w = u.gullet.popToken(), T = u.gullet.popToken();
              return ty(u, b, T, f === "\\\\globalfuture"), u.gullet.pushToken(T), u.gullet.pushToken(w), {
                type: "internal",
                mode: u.mode
              };
            }
          });
          const Ba = function(d, u, f) {
            const b = fe.math[d] && fe.math[d].replace, w = Ca(b || d, u, f);
            if (!w)
              throw new Error("Unsupported symbol " + d + " and font size " + u + ".");
            return w;
          }, hd = function(d, u, f, b) {
            const w = f.havingBaseStyle(u), T = ot.makeSpan(b.concat(w.sizingClasses(f)), [d], f), E = w.sizeMultiplier / f.sizeMultiplier;
            return T.height *= E, T.depth *= E, T.maxFontSize = w.sizeMultiplier, T;
          }, ey = function(d, u, f) {
            const b = u.havingBaseStyle(f), w = (1 - u.sizeMultiplier / b.sizeMultiplier) * u.fontMetrics().axisHeight;
            d.classes.push("delimcenter"), d.style.top = bt(w), d.height -= w, d.depth += w;
          }, J_ = function(d, u, f, b, w, T) {
            const E = ot.makeSymbol(d, "Main-Regular", w, b), D = hd(E, u, b, T);
            return f && ey(D, b, u), D;
          }, tC = function(d, u, f, b) {
            return ot.makeSymbol(d, "Size" + u + "-Regular", f, b);
          }, ry = function(d, u, f, b, w, T) {
            const E = tC(d, u, w, b), D = hd(ot.makeSpan(["delimsizing", "size" + u], [E], b), et.TEXT, b, T);
            return f && ey(D, b, et.TEXT), D;
          }, ud = function(d, u, f) {
            let b;
            return u === "Size1-Regular" ? b = "delim-size1" : b = "delim-size4", {
              type: "elem",
              elem: ot.makeSpan(["delimsizinginner", b], [ot.makeSpan([], [ot.makeSymbol(d, u, f)])])
            };
          }, dd = function(d, u, f) {
            const b = wr["Size4-Regular"][d.charCodeAt(0)] ? wr["Size4-Regular"][d.charCodeAt(0)][4] : wr["Size1-Regular"][d.charCodeAt(0)][4], w = new vr("inner", ci(d, Math.round(1e3 * u))), T = new ke([w], {
              width: bt(b),
              height: bt(u),
              // Override CSS rule `.katex svg { width: 100% }`
              style: "width:" + bt(b),
              viewBox: "0 0 " + 1e3 * b + " " + Math.round(1e3 * u),
              preserveAspectRatio: "xMinYMin"
            }), E = ot.makeSvgSpan([], [T], f);
            return E.height = u, E.style.height = bt(u), E.style.width = bt(b), {
              type: "elem",
              elem: E
            };
          }, pd = 8e-3, zc = {
            type: "kern",
            size: -1 * pd
          }, eC = ["|", "\\lvert", "\\rvert", "\\vert"], rC = ["\\|", "\\lVert", "\\rVert", "\\Vert"], ny = function(d, u, f, b, w, T) {
            let E, D, P, Q, nt = "", it = 0;
            E = P = Q = d, D = null;
            let lt = "Size1-Regular";
            d === "\\uparrow" ? P = Q = "⏐" : d === "\\Uparrow" ? P = Q = "‖" : d === "\\downarrow" ? E = P = "⏐" : d === "\\Downarrow" ? E = P = "‖" : d === "\\updownarrow" ? (E = "\\uparrow", P = "⏐", Q = "\\downarrow") : d === "\\Updownarrow" ? (E = "\\Uparrow", P = "‖", Q = "\\Downarrow") : k.contains(eC, d) ? (P = "∣", nt = "vert", it = 333) : k.contains(rC, d) ? (P = "∥", nt = "doublevert", it = 556) : d === "[" || d === "\\lbrack" ? (E = "⎡", P = "⎢", Q = "⎣", lt = "Size4-Regular", nt = "lbrack", it = 667) : d === "]" || d === "\\rbrack" ? (E = "⎤", P = "⎥", Q = "⎦", lt = "Size4-Regular", nt = "rbrack", it = 667) : d === "\\lfloor" || d === "⌊" ? (P = E = "⎢", Q = "⎣", lt = "Size4-Regular", nt = "lfloor", it = 667) : d === "\\lceil" || d === "⌈" ? (E = "⎡", P = Q = "⎢", lt = "Size4-Regular", nt = "lceil", it = 667) : d === "\\rfloor" || d === "⌋" ? (P = E = "⎥", Q = "⎦", lt = "Size4-Regular", nt = "rfloor", it = 667) : d === "\\rceil" || d === "⌉" ? (E = "⎤", P = Q = "⎥", lt = "Size4-Regular", nt = "rceil", it = 667) : d === "(" || d === "\\lparen" ? (E = "⎛", P = "⎜", Q = "⎝", lt = "Size4-Regular", nt = "lparen", it = 875) : d === ")" || d === "\\rparen" ? (E = "⎞", P = "⎟", Q = "⎠", lt = "Size4-Regular", nt = "rparen", it = 875) : d === "\\{" || d === "\\lbrace" ? (E = "⎧", D = "⎨", Q = "⎩", P = "⎪", lt = "Size4-Regular") : d === "\\}" || d === "\\rbrace" ? (E = "⎫", D = "⎬", Q = "⎭", P = "⎪", lt = "Size4-Regular") : d === "\\lgroup" || d === "⟮" ? (E = "⎧", Q = "⎩", P = "⎪", lt = "Size4-Regular") : d === "\\rgroup" || d === "⟯" ? (E = "⎫", Q = "⎭", P = "⎪", lt = "Size4-Regular") : d === "\\lmoustache" || d === "⎰" ? (E = "⎧", Q = "⎭", P = "⎪", lt = "Size4-Regular") : (d === "\\rmoustache" || d === "⎱") && (E = "⎫", Q = "⎩", P = "⎪", lt = "Size4-Regular");
            const yt = Ba(E, lt, w), kt = yt.height + yt.depth, Kt = Ba(P, lt, w), ie = Kt.height + Kt.depth, ee = Ba(Q, lt, w), de = ee.height + ee.depth;
            let he = 0, $e = 1;
            if (D !== null) {
              const qe = Ba(D, lt, w);
              he = qe.height + qe.depth, $e = 2;
            }
            const cr = kt + de + he, Cr = Math.max(0, Math.ceil((u - cr) / ($e * ie))), hn = cr + Cr * $e * ie;
            let wo = b.fontMetrics().axisHeight;
            f && (wo *= b.sizeMultiplier);
            const pe = hn / 2 - wo, xe = [];
            if (nt.length > 0) {
              const qe = hn - kt - de, Ne = Math.round(hn * 1e3), un = va(nt, Math.round(qe * 1e3)), $C = new vr(nt, un), Gy = (it / 1e3).toFixed(3) + "em", Xy = (Ne / 1e3).toFixed(3) + "em", EC = new ke([$C], {
                width: Gy,
                height: Xy,
                viewBox: "0 0 " + it + " " + Ne
              }), Wc = ot.makeSvgSpan([], [EC], b);
              Wc.height = Ne / 1e3, Wc.style.width = Gy, Wc.style.height = Xy, xe.push({
                type: "elem",
                elem: Wc
              });
            } else {
              if (xe.push(ud(Q, lt, w)), xe.push(zc), D === null) {
                const qe = hn - kt - de + 2 * pd;
                xe.push(dd(P, qe, b));
              } else {
                const qe = (hn - kt - de - he) / 2 + 2 * pd;
                xe.push(dd(P, qe, b)), xe.push(zc), xe.push(ud(D, lt, w)), xe.push(zc), xe.push(dd(P, qe, b));
              }
              xe.push(zc), xe.push(ud(E, lt, w));
            }
            const Ee = b.havingBaseStyle(et.TEXT), Be = ot.makeVList({
              positionType: "bottom",
              positionData: pe,
              children: xe
            }, Ee);
            return hd(ot.makeSpan(["delimsizing", "mult"], [Be], Ee), et.TEXT, b, T);
          }, fd = 80, md = 0.08, gd = function(d, u, f, b, w) {
            const T = ue(d, b, f), E = new vr(d, T), D = new ke([E], {
              // Note: 1000:1 ratio of viewBox to document em width.
              width: "400em",
              height: bt(u),
              viewBox: "0 0 400000 " + f,
              preserveAspectRatio: "xMinYMin slice"
            });
            return ot.makeSvgSpan(["hide-tail"], [D], w);
          }, nC = function(d, u) {
            const f = u.havingBaseSizing(), b = ay("\\surd", d * f.sizeMultiplier, oy, f);
            let w = f.sizeMultiplier;
            const T = Math.max(0, u.minRuleThickness - u.fontMetrics().sqrtRuleThickness);
            let E, D = 0, P = 0, Q = 0, nt;
            return b.type === "small" ? (Q = 1e3 + 1e3 * T + fd, d < 1 ? w = 1 : d < 1.4 && (w = 0.7), D = (1 + T + md) / w, P = (1 + T) / w, E = gd("sqrtMain", D, Q, T, u), E.style.minWidth = "0.853em", nt = 0.833 / w) : b.type === "large" ? (Q = (1e3 + fd) * La[b.size], P = (La[b.size] + T) / w, D = (La[b.size] + T + md) / w, E = gd("sqrtSize" + b.size, D, Q, T, u), E.style.minWidth = "1.02em", nt = 1 / w) : (D = d + T + md, P = d + T, Q = Math.floor(1e3 * d + T) + fd, E = gd("sqrtTall", D, Q, T, u), E.style.minWidth = "0.742em", nt = 1.056), E.height = P, E.style.height = bt(D), {
              span: E,
              advanceWidth: nt,
              // Calculate the actual line width.
              // This actually should depend on the chosen font -- e.g. \boldmath
              // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
              // have thicker rules.
              ruleWidth: (u.fontMetrics().sqrtRuleThickness + T) * w
            };
          }, iy = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], iC = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], sy = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], La = [0, 1.2, 1.8, 2.4, 3], sC = function(d, u, f, b, w) {
            if (d === "<" || d === "\\lt" || d === "⟨" ? d = "\\langle" : (d === ">" || d === "\\gt" || d === "⟩") && (d = "\\rangle"), k.contains(iy, d) || k.contains(sy, d))
              return ry(d, u, false, f, b, w);
            if (k.contains(iC, d))
              return ny(d, La[u], false, f, b, w);
            throw new s("Illegal delimiter: '" + d + "'");
          }, oC = [{
            type: "small",
            style: et.SCRIPTSCRIPT
          }, {
            type: "small",
            style: et.SCRIPT
          }, {
            type: "small",
            style: et.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }], aC = [{
            type: "small",
            style: et.SCRIPTSCRIPT
          }, {
            type: "small",
            style: et.SCRIPT
          }, {
            type: "small",
            style: et.TEXT
          }, {
            type: "stack"
          }], oy = [{
            type: "small",
            style: et.SCRIPTSCRIPT
          }, {
            type: "small",
            style: et.SCRIPT
          }, {
            type: "small",
            style: et.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }, {
            type: "stack"
          }], lC = function(d) {
            if (d.type === "small")
              return "Main-Regular";
            if (d.type === "large")
              return "Size" + d.size + "-Regular";
            if (d.type === "stack")
              return "Size4-Regular";
            throw new Error("Add support for delim type '" + d.type + "' here.");
          }, ay = function(d, u, f, b) {
            const w = Math.min(2, 3 - b.style.size);
            for (let T = w; T < f.length && f[T].type !== "stack"; T++) {
              const E = Ba(d, lC(f[T]), "math");
              let D = E.height + E.depth;
              if (f[T].type === "small") {
                const P = b.havingBaseStyle(f[T].style);
                D *= P.sizeMultiplier;
              }
              if (D > u)
                return f[T];
            }
            return f[f.length - 1];
          }, ly = function(d, u, f, b, w, T) {
            d === "<" || d === "\\lt" || d === "⟨" ? d = "\\langle" : (d === ">" || d === "\\gt" || d === "⟩") && (d = "\\rangle");
            let E;
            k.contains(sy, d) ? E = oC : k.contains(iy, d) ? E = oy : E = aC;
            const D = ay(d, u, E, b);
            return D.type === "small" ? J_(d, D.style, f, b, w, T) : D.type === "large" ? ry(d, D.size, f, b, w, T) : ny(d, u, f, b, w, T);
          };
          var gi = {
            sqrtImage: nC,
            sizedDelim: sC,
            sizeToMaxHeight: La,
            customSizedDelim: ly,
            leftRightDelim: function(d, u, f, b, w, T) {
              const E = b.fontMetrics().axisHeight * b.sizeMultiplier, D = 901, P = 5 / b.fontMetrics().ptPerEm, Q = Math.max(u - E, f + E), nt = Math.max(
                // In real TeX, calculations are done using integral values which are
                // 65536 per pt, or 655360 per em. So, the division here truncates in
                // TeX but doesn't here, producing different results. If we wanted to
                // exactly match TeX's calculation, we could do
                //   Math.floor(655360 * maxDistFromAxis / 500) *
                //    delimiterFactor / 655360
                // (To see the difference, compare
                //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
                // in TeX and KaTeX)
                Q / 500 * D,
                2 * Q - P
              );
              return ly(d, nt, true, b, w, T);
            }
          };
          const cy = {
            "\\bigl": {
              mclass: "mopen",
              size: 1
            },
            "\\Bigl": {
              mclass: "mopen",
              size: 2
            },
            "\\biggl": {
              mclass: "mopen",
              size: 3
            },
            "\\Biggl": {
              mclass: "mopen",
              size: 4
            },
            "\\bigr": {
              mclass: "mclose",
              size: 1
            },
            "\\Bigr": {
              mclass: "mclose",
              size: 2
            },
            "\\biggr": {
              mclass: "mclose",
              size: 3
            },
            "\\Biggr": {
              mclass: "mclose",
              size: 4
            },
            "\\bigm": {
              mclass: "mrel",
              size: 1
            },
            "\\Bigm": {
              mclass: "mrel",
              size: 2
            },
            "\\biggm": {
              mclass: "mrel",
              size: 3
            },
            "\\Biggm": {
              mclass: "mrel",
              size: 4
            },
            "\\big": {
              mclass: "mord",
              size: 1
            },
            "\\Big": {
              mclass: "mord",
              size: 2
            },
            "\\bigg": {
              mclass: "mord",
              size: 3
            },
            "\\Bigg": {
              mclass: "mord",
              size: 4
            }
          }, cC = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
          function qc(d, u) {
            const f = Nc(d);
            if (f && k.contains(cC, f.text))
              return f;
            throw f ? new s("Invalid delimiter '" + f.text + "' after '" + u.funcName + "'", d) : new s("Invalid delimiter type '" + d.type + "'", d);
          }
          Ct({
            type: "delimsizing",
            names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
            props: {
              numArgs: 1,
              argTypes: ["primitive"]
            },
            handler: (d, u) => {
              const f = qc(u[0], d);
              return {
                type: "delimsizing",
                mode: d.parser.mode,
                size: cy[d.funcName].size,
                mclass: cy[d.funcName].mclass,
                delim: f.text
              };
            },
            htmlBuilder: (d, u) => d.delim === "." ? ot.makeSpan([d.mclass]) : gi.sizedDelim(d.delim, d.size, u, d.mode, [d.mclass]),
            mathmlBuilder: (d) => {
              const u = [];
              d.delim !== "." && u.push(ln(d.delim, d.mode));
              const f = new ft.MathNode("mo", u);
              d.mclass === "mopen" || d.mclass === "mclose" ? f.setAttribute("fence", "true") : f.setAttribute("fence", "false"), f.setAttribute("stretchy", "true");
              const b = bt(gi.sizeToMaxHeight[d.size]);
              return f.setAttribute("minsize", b), f.setAttribute("maxsize", b), f;
            }
          });
          function hy(d) {
            if (!d.body)
              throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
          }
          Ct({
            type: "leftright-right",
            names: ["\\right"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (d, u) => {
              const f = d.parser.gullet.macros.get("\\current@color");
              if (f && typeof f != "string")
                throw new s("\\current@color set to non-string in \\right");
              return {
                type: "leftright-right",
                mode: d.parser.mode,
                delim: qc(u[0], d).text,
                color: f
                // undefined if not set via \color
              };
            }
          }), Ct({
            type: "leftright",
            names: ["\\left"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (d, u) => {
              const f = qc(u[0], d), b = d.parser;
              ++b.leftrightDepth;
              const w = b.parseExpression(false);
              --b.leftrightDepth, b.expect("\\right", false);
              const T = Jt(b.parseFunction(), "leftright-right");
              return {
                type: "leftright",
                mode: b.mode,
                body: w,
                left: f.text,
                right: T.delim,
                rightColor: T.color
              };
            },
            htmlBuilder: (d, u) => {
              hy(d);
              const f = Ge(d.body, u, true, ["mopen", "mclose"]);
              let b = 0, w = 0, T = false;
              for (let P = 0; P < f.length; P++)
                f[P].isMiddle ? T = true : (b = Math.max(f[P].height, b), w = Math.max(f[P].depth, w));
              b *= u.sizeMultiplier, w *= u.sizeMultiplier;
              let E;
              if (d.left === "." ? E = Ma(u, ["mopen"]) : E = gi.leftRightDelim(d.left, b, w, u, d.mode, ["mopen"]), f.unshift(E), T)
                for (let P = 1; P < f.length; P++) {
                  const Q = f[P].isMiddle;
                  Q && (f[P] = gi.leftRightDelim(Q.delim, b, w, Q.options, d.mode, []));
                }
              let D;
              if (d.right === ".")
                D = Ma(u, ["mclose"]);
              else {
                const P = d.rightColor ? u.withColor(d.rightColor) : u;
                D = gi.leftRightDelim(d.right, b, w, P, d.mode, ["mclose"]);
              }
              return f.push(D), ot.makeSpan(["minner"], f, u);
            },
            mathmlBuilder: (d, u) => {
              hy(d);
              const f = Ir(d.body, u);
              if (d.left !== ".") {
                const b = new ft.MathNode("mo", [ln(d.left, d.mode)]);
                b.setAttribute("fence", "true"), f.unshift(b);
              }
              if (d.right !== ".") {
                const b = new ft.MathNode("mo", [ln(d.right, d.mode)]);
                b.setAttribute("fence", "true"), d.rightColor && b.setAttribute("mathcolor", d.rightColor), f.push(b);
              }
              return id(f);
            }
          }), Ct({
            type: "middle",
            names: ["\\middle"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (d, u) => {
              const f = qc(u[0], d);
              if (!d.parser.leftrightDepth)
                throw new s("\\middle without preceding \\left", f);
              return {
                type: "middle",
                mode: d.parser.mode,
                delim: f.text
              };
            },
            htmlBuilder: (d, u) => {
              let f;
              if (d.delim === ".")
                f = Ma(u, []);
              else {
                f = gi.sizedDelim(d.delim, 1, u, d.mode, []);
                const b = {
                  delim: d.delim,
                  options: u
                };
                f.isMiddle = b;
              }
              return f;
            },
            mathmlBuilder: (d, u) => {
              const f = d.delim === "\\vert" || d.delim === "|" ? ln("|", "text") : ln(d.delim, d.mode), b = new ft.MathNode("mo", [f]);
              return b.setAttribute("fence", "true"), b.setAttribute("lspace", "0.05em"), b.setAttribute("rspace", "0.05em"), b;
            }
          });
          const yd = (d, u) => {
            const f = ot.wrapFragment(ce(d.body, u), u), b = d.label.slice(1);
            let w = u.sizeMultiplier, T, E = 0;
            const D = k.isCharacterBox(d.body);
            if (b === "sout")
              T = ot.makeSpan(["stretchy", "sout"]), T.height = u.fontMetrics().defaultRuleThickness / w, E = -0.5 * u.fontMetrics().xHeight;
            else if (b === "phase") {
              const Q = we({
                number: 0.6,
                unit: "pt"
              }, u), nt = we({
                number: 0.35,
                unit: "ex"
              }, u), it = u.havingBaseSizing();
              w = w / it.sizeMultiplier;
              const lt = f.height + f.depth + Q + nt;
              f.style.paddingLeft = bt(lt / 2 + Q);
              const yt = Math.floor(1e3 * lt * w), kt = Ut(yt), Kt = new ke([new vr("phase", kt)], {
                width: "400em",
                height: bt(yt / 1e3),
                viewBox: "0 0 400000 " + yt,
                preserveAspectRatio: "xMinYMin slice"
              });
              T = ot.makeSvgSpan(["hide-tail"], [Kt], u), T.style.height = bt(lt), E = f.depth + Q + nt;
            } else {
              /cancel/.test(b) ? D || f.classes.push("cancel-pad") : b === "angl" ? f.classes.push("anglpad") : f.classes.push("boxpad");
              let Q = 0, nt = 0, it = 0;
              /box/.test(b) ? (it = Math.max(
                u.fontMetrics().fboxrule,
                // default
                u.minRuleThickness
                // User override.
              ), Q = u.fontMetrics().fboxsep + (b === "colorbox" ? 0 : it), nt = Q) : b === "angl" ? (it = Math.max(u.fontMetrics().defaultRuleThickness, u.minRuleThickness), Q = 4 * it, nt = Math.max(0, 0.25 - f.depth)) : (Q = D ? 0.2 : 0, nt = Q), T = mi.encloseSpan(f, b, Q, nt, u), /fbox|boxed|fcolorbox/.test(b) ? (T.style.borderStyle = "solid", T.style.borderWidth = bt(it)) : b === "angl" && it !== 0.049 && (T.style.borderTopWidth = bt(it), T.style.borderRightWidth = bt(it)), E = f.depth + nt, d.backgroundColor && (T.style.backgroundColor = d.backgroundColor, d.borderColor && (T.style.borderColor = d.borderColor));
            }
            let P;
            if (d.backgroundColor)
              P = ot.makeVList({
                positionType: "individualShift",
                children: [
                  // Put the color background behind inner;
                  {
                    type: "elem",
                    elem: T,
                    shift: E
                  },
                  {
                    type: "elem",
                    elem: f,
                    shift: 0
                  }
                ]
              }, u);
            else {
              const Q = /cancel|phase/.test(b) ? ["svg-align"] : [];
              P = ot.makeVList({
                positionType: "individualShift",
                children: [
                  // Write the \cancel stroke on top of inner.
                  {
                    type: "elem",
                    elem: f,
                    shift: 0
                  },
                  {
                    type: "elem",
                    elem: T,
                    shift: E,
                    wrapperClasses: Q
                  }
                ]
              }, u);
            }
            return /cancel/.test(b) && (P.height = f.height, P.depth = f.depth), /cancel/.test(b) && !D ? ot.makeSpan(["mord", "cancel-lap"], [P], u) : ot.makeSpan(["mord"], [P], u);
          }, bd = (d, u) => {
            let f = 0;
            const b = new ft.MathNode(d.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [_e(d.body, u)]);
            switch (d.label) {
              case "\\cancel":
                b.setAttribute("notation", "updiagonalstrike");
                break;
              case "\\bcancel":
                b.setAttribute("notation", "downdiagonalstrike");
                break;
              case "\\phase":
                b.setAttribute("notation", "phasorangle");
                break;
              case "\\sout":
                b.setAttribute("notation", "horizontalstrike");
                break;
              case "\\fbox":
                b.setAttribute("notation", "box");
                break;
              case "\\angl":
                b.setAttribute("notation", "actuarial");
                break;
              case "\\fcolorbox":
              case "\\colorbox":
                if (f = u.fontMetrics().fboxsep * u.fontMetrics().ptPerEm, b.setAttribute("width", "+" + 2 * f + "pt"), b.setAttribute("height", "+" + 2 * f + "pt"), b.setAttribute("lspace", f + "pt"), b.setAttribute("voffset", f + "pt"), d.label === "\\fcolorbox") {
                  const w = Math.max(
                    u.fontMetrics().fboxrule,
                    // default
                    u.minRuleThickness
                    // user override
                  );
                  b.setAttribute("style", "border: " + w + "em solid " + String(d.borderColor));
                }
                break;
              case "\\xcancel":
                b.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                break;
            }
            return d.backgroundColor && b.setAttribute("mathbackground", d.backgroundColor), b;
          };
          Ct({
            type: "enclose",
            names: ["\\colorbox"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "text"]
            },
            handler(d, u, f) {
              let {
                parser: b,
                funcName: w
              } = d;
              const T = Jt(u[0], "color-token").color, E = u[1];
              return {
                type: "enclose",
                mode: b.mode,
                label: w,
                backgroundColor: T,
                body: E
              };
            },
            htmlBuilder: yd,
            mathmlBuilder: bd
          }), Ct({
            type: "enclose",
            names: ["\\fcolorbox"],
            props: {
              numArgs: 3,
              allowedInText: true,
              argTypes: ["color", "color", "text"]
            },
            handler(d, u, f) {
              let {
                parser: b,
                funcName: w
              } = d;
              const T = Jt(u[0], "color-token").color, E = Jt(u[1], "color-token").color, D = u[2];
              return {
                type: "enclose",
                mode: b.mode,
                label: w,
                backgroundColor: E,
                borderColor: T,
                body: D
              };
            },
            htmlBuilder: yd,
            mathmlBuilder: bd
          }), Ct({
            type: "enclose",
            names: ["\\fbox"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "enclose",
                mode: f.mode,
                label: "\\fbox",
                body: u[0]
              };
            }
          }), Ct({
            type: "enclose",
            names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "enclose",
                mode: f.mode,
                label: b,
                body: w
              };
            },
            htmlBuilder: yd,
            mathmlBuilder: bd
          }), Ct({
            type: "enclose",
            names: ["\\angl"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: false
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "enclose",
                mode: f.mode,
                label: "\\angl",
                body: u[0]
              };
            }
          });
          const uy = {};
          function On(d) {
            let {
              type: u,
              names: f,
              props: b,
              handler: w,
              htmlBuilder: T,
              mathmlBuilder: E
            } = d;
            const D = {
              type: u,
              numArgs: b.numArgs || 0,
              allowedInText: false,
              numOptionalArgs: 0,
              handler: w
            };
            for (let P = 0; P < f.length; ++P)
              uy[f[P]] = D;
            T && (Bc[u] = T), E && (Lc[u] = E);
          }
          const dy = {};
          function N(d, u) {
            dy[d] = u;
          }
          class Yr {
            // The + prefix indicates that these fields aren't writeable
            // Lexer holding the input string.
            // Start offset, zero-based inclusive.
            // End offset, zero-based exclusive.
            constructor(u, f, b) {
              this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = u, this.start = f, this.end = b;
            }
            /**
             * Merges two `SourceLocation`s from location providers, given they are
             * provided in order of appearance.
             * - Returns the first one's location if only the first is provided.
             * - Returns a merged range of the first and the last if both are provided
             *   and their lexers match.
             * - Otherwise, returns null.
             */
            static range(u, f) {
              return f ? !u || !u.loc || !f.loc || u.loc.lexer !== f.loc.lexer ? null : new Yr(u.loc.lexer, u.loc.start, f.loc.end) : u && u.loc;
            }
          }
          class cn {
            // don't expand the token
            // used in \noexpand
            constructor(u, f) {
              this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = u, this.loc = f;
            }
            /**
             * Given a pair of tokens (this and endToken), compute a `Token` encompassing
             * the whole input range enclosed by these two.
             */
            range(u, f) {
              return new cn(f, Yr.range(this, u));
            }
          }
          function py(d) {
            const u = [];
            d.consumeSpaces();
            let f = d.fetch().text;
            for (f === "\\relax" && (d.consume(), d.consumeSpaces(), f = d.fetch().text); f === "\\hline" || f === "\\hdashline"; )
              d.consume(), u.push(f === "\\hdashline"), d.consumeSpaces(), f = d.fetch().text;
            return u;
          }
          const Rc = (d) => {
            if (!d.parser.settings.displayMode)
              throw new s("{" + d.envName + "} can be used only in display mode.");
          };
          function xd(d) {
            if (d.indexOf("ed") === -1)
              return d.indexOf("*") === -1;
          }
          function Wi(d, u, f) {
            let {
              hskipBeforeAndAfter: b,
              addJot: w,
              cols: T,
              arraystretch: E,
              colSeparationType: D,
              autoTag: P,
              singleRow: Q,
              emptySingleRow: nt,
              maxNumCols: it,
              leqno: lt
            } = u;
            if (d.gullet.beginGroup(), Q || d.gullet.macros.set("\\cr", "\\\\\\relax"), !E) {
              const $e = d.gullet.expandMacroAsText("\\arraystretch");
              if ($e == null)
                E = 1;
              else if (E = parseFloat($e), !E || E < 0)
                throw new s("Invalid \\arraystretch: " + $e);
            }
            d.gullet.beginGroup();
            let yt = [];
            const kt = [yt], Kt = [], ie = [], ee = P != null ? [] : void 0;
            function de() {
              P && d.gullet.macros.set("\\@eqnsw", "1", true);
            }
            function he() {
              ee && (d.gullet.macros.get("\\df@tag") ? (ee.push(d.subparse([new cn("\\df@tag")])), d.gullet.macros.set("\\df@tag", void 0, true)) : ee.push(!!P && d.gullet.macros.get("\\@eqnsw") === "1"));
            }
            for (de(), ie.push(py(d)); ; ) {
              let $e = d.parseExpression(false, Q ? "\\end" : "\\\\");
              d.gullet.endGroup(), d.gullet.beginGroup(), $e = {
                type: "ordgroup",
                mode: d.mode,
                body: $e
              }, f && ($e = {
                type: "styling",
                mode: d.mode,
                style: f,
                body: [$e]
              }), yt.push($e);
              const cr = d.fetch().text;
              if (cr === "&") {
                if (it && yt.length === it) {
                  if (Q || D)
                    throw new s("Too many tab characters: &", d.nextToken);
                  d.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                }
                d.consume();
              } else if (cr === "\\end") {
                he(), yt.length === 1 && $e.type === "styling" && $e.body[0].body.length === 0 && (kt.length > 1 || !nt) && kt.pop(), ie.length < kt.length + 1 && ie.push([]);
                break;
              } else if (cr === "\\\\") {
                d.consume();
                let Cr;
                d.gullet.future().text !== " " && (Cr = d.parseSizeGroup(true)), Kt.push(Cr ? Cr.value : null), he(), ie.push(py(d)), yt = [], kt.push(yt), de();
              } else
                throw new s("Expected & or \\\\ or \\cr or \\end", d.nextToken);
            }
            return d.gullet.endGroup(), d.gullet.endGroup(), {
              type: "array",
              mode: d.mode,
              addJot: w,
              arraystretch: E,
              body: kt,
              cols: T,
              rowGaps: Kt,
              hskipBeforeAndAfter: b,
              hLinesBeforeRow: ie,
              colSeparationType: D,
              tags: ee,
              leqno: lt
            };
          }
          function wd(d) {
            return d.slice(0, 1) === "d" ? "display" : "text";
          }
          const zn = function(d, u) {
            let f, b;
            const w = d.body.length, T = d.hLinesBeforeRow;
            let E = 0, D = new Array(w);
            const P = [], Q = Math.max(
              // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
              u.fontMetrics().arrayRuleWidth,
              u.minRuleThickness
              // User override.
            ), nt = 1 / u.fontMetrics().ptPerEm;
            let it = 5 * nt;
            d.colSeparationType && d.colSeparationType === "small" && (it = 0.2778 * (u.havingStyle(et.SCRIPT).sizeMultiplier / u.sizeMultiplier));
            const lt = d.colSeparationType === "CD" ? we({
              number: 3,
              unit: "ex"
            }, u) : 12 * nt, yt = 3 * nt, kt = d.arraystretch * lt, Kt = 0.7 * kt, ie = 0.3 * kt;
            let ee = 0;
            function de(pe) {
              for (let xe = 0; xe < pe.length; ++xe)
                xe > 0 && (ee += 0.25), P.push({
                  pos: ee,
                  isDashed: pe[xe]
                });
            }
            for (de(T[0]), f = 0; f < d.body.length; ++f) {
              const pe = d.body[f];
              let xe = Kt, Ee = ie;
              E < pe.length && (E = pe.length);
              const Be = new Array(pe.length);
              for (b = 0; b < pe.length; ++b) {
                const un = ce(pe[b], u);
                Ee < un.depth && (Ee = un.depth), xe < un.height && (xe = un.height), Be[b] = un;
              }
              const qe = d.rowGaps[f];
              let Ne = 0;
              qe && (Ne = we(qe, u), Ne > 0 && (Ne += ie, Ee < Ne && (Ee = Ne), Ne = 0)), d.addJot && (Ee += yt), Be.height = xe, Be.depth = Ee, ee += xe, Be.pos = ee, ee += Ee + Ne, D[f] = Be, de(T[f + 1]);
            }
            const he = ee / 2 + u.fontMetrics().axisHeight, $e = d.cols || [], cr = [];
            let Cr, hn;
            const wo = [];
            if (d.tags && d.tags.some((pe) => pe))
              for (f = 0; f < w; ++f) {
                const pe = D[f], xe = pe.pos - he, Ee = d.tags[f];
                let Be;
                Ee === true ? Be = ot.makeSpan(["eqn-num"], [], u) : Ee === false ? Be = ot.makeSpan([], [], u) : Be = ot.makeSpan([], Ge(Ee, u, true), u), Be.depth = pe.depth, Be.height = pe.height, wo.push({
                  type: "elem",
                  elem: Be,
                  shift: xe
                });
              }
            for (
              b = 0, hn = 0;
              // Continue while either there are more columns or more column
              // descriptions, so trailing separators don't get lost.
              b < E || hn < $e.length;
              ++b, ++hn
            ) {
              let pe = $e[hn] || {}, xe = true;
              for (; pe.type === "separator"; ) {
                if (xe || (Cr = ot.makeSpan(["arraycolsep"], []), Cr.style.width = bt(u.fontMetrics().doubleRuleSep), cr.push(Cr)), pe.separator === "|" || pe.separator === ":") {
                  const qe = pe.separator === "|" ? "solid" : "dashed", Ne = ot.makeSpan(["vertical-separator"], [], u);
                  Ne.style.height = bt(ee), Ne.style.borderRightWidth = bt(Q), Ne.style.borderRightStyle = qe, Ne.style.margin = "0 " + bt(-Q / 2);
                  const un = ee - he;
                  un && (Ne.style.verticalAlign = bt(-un)), cr.push(Ne);
                } else
                  throw new s("Invalid separator type: " + pe.separator);
                hn++, pe = $e[hn] || {}, xe = false;
              }
              if (b >= E)
                continue;
              let Ee;
              (b > 0 || d.hskipBeforeAndAfter) && (Ee = k.deflt(pe.pregap, it), Ee !== 0 && (Cr = ot.makeSpan(["arraycolsep"], []), Cr.style.width = bt(Ee), cr.push(Cr)));
              let Be = [];
              for (f = 0; f < w; ++f) {
                const qe = D[f], Ne = qe[b];
                if (!Ne)
                  continue;
                const un = qe.pos - he;
                Ne.depth = qe.depth, Ne.height = qe.height, Be.push({
                  type: "elem",
                  elem: Ne,
                  shift: un
                });
              }
              Be = ot.makeVList({
                positionType: "individualShift",
                children: Be
              }, u), Be = ot.makeSpan(["col-align-" + (pe.align || "c")], [Be]), cr.push(Be), (b < E - 1 || d.hskipBeforeAndAfter) && (Ee = k.deflt(pe.postgap, it), Ee !== 0 && (Cr = ot.makeSpan(["arraycolsep"], []), Cr.style.width = bt(Ee), cr.push(Cr)));
            }
            if (D = ot.makeSpan(["mtable"], cr), P.length > 0) {
              const pe = ot.makeLineSpan("hline", u, Q), xe = ot.makeLineSpan("hdashline", u, Q), Ee = [{
                type: "elem",
                elem: D,
                shift: 0
              }];
              for (; P.length > 0; ) {
                const Be = P.pop(), qe = Be.pos - he;
                Be.isDashed ? Ee.push({
                  type: "elem",
                  elem: xe,
                  shift: qe
                }) : Ee.push({
                  type: "elem",
                  elem: pe,
                  shift: qe
                });
              }
              D = ot.makeVList({
                positionType: "individualShift",
                children: Ee
              }, u);
            }
            if (wo.length === 0)
              return ot.makeSpan(["mord"], [D], u);
            {
              let pe = ot.makeVList({
                positionType: "individualShift",
                children: wo
              }, u);
              return pe = ot.makeSpan(["tag"], [pe], u), ot.makeFragment([D, pe]);
            }
          }, hC = {
            c: "center ",
            l: "left ",
            r: "right "
          }, qn = function(d, u) {
            const f = [], b = new ft.MathNode("mtd", [], ["mtr-glue"]), w = new ft.MathNode("mtd", [], ["mml-eqn-num"]);
            for (let it = 0; it < d.body.length; it++) {
              const lt = d.body[it], yt = [];
              for (let kt = 0; kt < lt.length; kt++)
                yt.push(new ft.MathNode("mtd", [_e(lt[kt], u)]));
              d.tags && d.tags[it] && (yt.unshift(b), yt.push(b), d.leqno ? yt.unshift(w) : yt.push(w)), f.push(new ft.MathNode("mtr", yt));
            }
            let T = new ft.MathNode("mtable", f);
            const E = d.arraystretch === 0.5 ? 0.1 : 0.16 + d.arraystretch - 1 + (d.addJot ? 0.09 : 0);
            T.setAttribute("rowspacing", bt(E));
            let D = "", P = "";
            if (d.cols && d.cols.length > 0) {
              const it = d.cols;
              let lt = "", yt = false, kt = 0, Kt = it.length;
              it[0].type === "separator" && (D += "top ", kt = 1), it[it.length - 1].type === "separator" && (D += "bottom ", Kt -= 1);
              for (let ie = kt; ie < Kt; ie++)
                it[ie].type === "align" ? (P += hC[it[ie].align], yt && (lt += "none "), yt = true) : it[ie].type === "separator" && yt && (lt += it[ie].separator === "|" ? "solid " : "dashed ", yt = false);
              T.setAttribute("columnalign", P.trim()), /[sd]/.test(lt) && T.setAttribute("columnlines", lt.trim());
            }
            if (d.colSeparationType === "align") {
              const it = d.cols || [];
              let lt = "";
              for (let yt = 1; yt < it.length; yt++)
                lt += yt % 2 ? "0em " : "1em ";
              T.setAttribute("columnspacing", lt.trim());
            } else d.colSeparationType === "alignat" || d.colSeparationType === "gather" ? T.setAttribute("columnspacing", "0em") : d.colSeparationType === "small" ? T.setAttribute("columnspacing", "0.2778em") : d.colSeparationType === "CD" ? T.setAttribute("columnspacing", "0.5em") : T.setAttribute("columnspacing", "1em");
            let Q = "";
            const nt = d.hLinesBeforeRow;
            D += nt[0].length > 0 ? "left " : "", D += nt[nt.length - 1].length > 0 ? "right " : "";
            for (let it = 1; it < nt.length - 1; it++)
              Q += nt[it].length === 0 ? "none " : nt[it][0] ? "dashed " : "solid ";
            return /[sd]/.test(Q) && T.setAttribute("rowlines", Q.trim()), D !== "" && (T = new ft.MathNode("menclose", [T]), T.setAttribute("notation", D.trim())), d.arraystretch && d.arraystretch < 1 && (T = new ft.MathNode("mstyle", [T]), T.setAttribute("scriptlevel", "1")), T;
          }, fy = function(d, u) {
            d.envName.indexOf("ed") === -1 && Rc(d);
            const f = [], b = d.envName.indexOf("at") > -1 ? "alignat" : "align", w = d.envName === "split", T = Wi(d.parser, {
              cols: f,
              addJot: true,
              autoTag: w ? void 0 : xd(d.envName),
              emptySingleRow: true,
              colSeparationType: b,
              maxNumCols: w ? 2 : void 0,
              leqno: d.parser.settings.leqno
            }, "display");
            let E, D = 0;
            const P = {
              type: "ordgroup",
              mode: d.mode,
              body: []
            };
            if (u[0] && u[0].type === "ordgroup") {
              let nt = "";
              for (let it = 0; it < u[0].body.length; it++) {
                const lt = Jt(u[0].body[it], "textord");
                nt += lt.text;
              }
              E = Number(nt), D = E * 2;
            }
            const Q = !D;
            T.body.forEach(function(nt) {
              for (let it = 1; it < nt.length; it += 2) {
                const lt = Jt(nt[it], "styling");
                Jt(lt.body[0], "ordgroup").body.unshift(P);
              }
              if (Q)
                D < nt.length && (D = nt.length);
              else {
                const it = nt.length / 2;
                if (E < it)
                  throw new s("Too many math in a row: " + ("expected " + E + ", but got " + it), nt[0]);
              }
            });
            for (let nt = 0; nt < D; ++nt) {
              let it = "r", lt = 0;
              nt % 2 === 1 ? it = "l" : nt > 0 && Q && (lt = 1), f[nt] = {
                type: "align",
                align: it,
                pregap: lt,
                postgap: 0
              };
            }
            return T.colSeparationType = Q ? "align" : "alignat", T;
          };
          On({
            type: "array",
            names: ["array", "darray"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              const f = (Nc(u[0]) ? [u[0]] : Jt(u[0], "ordgroup").body).map(function(w) {
                const T = ad(w).text;
                if ("lcr".indexOf(T) !== -1)
                  return {
                    type: "align",
                    align: T
                  };
                if (T === "|")
                  return {
                    type: "separator",
                    separator: "|"
                  };
                if (T === ":")
                  return {
                    type: "separator",
                    separator: ":"
                  };
                throw new s("Unknown column alignment: " + T, w);
              }), b = {
                cols: f,
                hskipBeforeAndAfter: true,
                // \@preamble in lttab.dtx
                maxNumCols: f.length
              };
              return Wi(d.parser, b, wd(d.envName));
            },
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
            props: {
              numArgs: 0
            },
            handler(d) {
              const u = {
                matrix: null,
                pmatrix: ["(", ")"],
                bmatrix: ["[", "]"],
                Bmatrix: ["\\{", "\\}"],
                vmatrix: ["|", "|"],
                Vmatrix: ["\\Vert", "\\Vert"]
              }[d.envName.replace("*", "")];
              let f = "c";
              const b = {
                hskipBeforeAndAfter: false,
                cols: [{
                  type: "align",
                  align: f
                }]
              };
              if (d.envName.charAt(d.envName.length - 1) === "*") {
                const E = d.parser;
                if (E.consumeSpaces(), E.fetch().text === "[") {
                  if (E.consume(), E.consumeSpaces(), f = E.fetch().text, "lcr".indexOf(f) === -1)
                    throw new s("Expected l or c or r", E.nextToken);
                  E.consume(), E.consumeSpaces(), E.expect("]"), E.consume(), b.cols = [{
                    type: "align",
                    align: f
                  }];
                }
              }
              const w = Wi(d.parser, b, wd(d.envName)), T = Math.max(0, ...w.body.map((E) => E.length));
              return w.cols = new Array(T).fill({
                type: "align",
                align: f
              }), u ? {
                type: "leftright",
                mode: d.mode,
                body: [w],
                left: u[0],
                right: u[1],
                rightColor: void 0
                // \right uninfluenced by \color in array
              } : w;
            },
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["smallmatrix"],
            props: {
              numArgs: 0
            },
            handler(d) {
              const u = {
                arraystretch: 0.5
              }, f = Wi(d.parser, u, "script");
              return f.colSeparationType = "small", f;
            },
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["subarray"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              const f = (Nc(u[0]) ? [u[0]] : Jt(u[0], "ordgroup").body).map(function(w) {
                const T = ad(w).text;
                if ("lc".indexOf(T) !== -1)
                  return {
                    type: "align",
                    align: T
                  };
                throw new s("Unknown column alignment: " + T, w);
              });
              if (f.length > 1)
                throw new s("{subarray} can contain only one column");
              let b = {
                cols: f,
                hskipBeforeAndAfter: false,
                arraystretch: 0.5
              };
              if (b = Wi(d.parser, b, "script"), b.body.length > 0 && b.body[0].length > 1)
                throw new s("{subarray} can contain only one column");
              return b;
            },
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["cases", "dcases", "rcases", "drcases"],
            props: {
              numArgs: 0
            },
            handler(d) {
              const u = {
                arraystretch: 1.2,
                cols: [{
                  type: "align",
                  align: "l",
                  pregap: 0,
                  // TODO(kevinb) get the current style.
                  // For now we use the metrics for TEXT style which is what we were
                  // doing before.  Before attempting to get the current style we
                  // should look at TeX's behavior especially for \over and matrices.
                  postgap: 1
                  /* 1em quad */
                }, {
                  type: "align",
                  align: "l",
                  pregap: 0,
                  postgap: 0
                }]
              }, f = Wi(d.parser, u, wd(d.envName));
              return {
                type: "leftright",
                mode: d.mode,
                body: [f],
                left: d.envName.indexOf("r") > -1 ? "." : "\\{",
                right: d.envName.indexOf("r") > -1 ? "\\}" : ".",
                rightColor: void 0
              };
            },
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["align", "align*", "aligned", "split"],
            props: {
              numArgs: 0
            },
            handler: fy,
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["gathered", "gather", "gather*"],
            props: {
              numArgs: 0
            },
            handler(d) {
              k.contains(["gather", "gather*"], d.envName) && Rc(d);
              const u = {
                cols: [{
                  type: "align",
                  align: "c"
                }],
                addJot: true,
                colSeparationType: "gather",
                autoTag: xd(d.envName),
                emptySingleRow: true,
                leqno: d.parser.settings.leqno
              };
              return Wi(d.parser, u, "display");
            },
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["alignat", "alignat*", "alignedat"],
            props: {
              numArgs: 1
            },
            handler: fy,
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["equation", "equation*"],
            props: {
              numArgs: 0
            },
            handler(d) {
              Rc(d);
              const u = {
                autoTag: xd(d.envName),
                emptySingleRow: true,
                singleRow: true,
                maxNumCols: 1,
                leqno: d.parser.settings.leqno
              };
              return Wi(d.parser, u, "display");
            },
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), On({
            type: "array",
            names: ["CD"],
            props: {
              numArgs: 0
            },
            handler(d) {
              return Rc(d), Z_(d.parser);
            },
            htmlBuilder: zn,
            mathmlBuilder: qn
          }), N("\\nonumber", "\\gdef\\@eqnsw{0}"), N("\\notag", "\\nonumber"), Ct({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\hline", "\\hdashline"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: true
            },
            handler(d, u) {
              throw new s(d.funcName + " valid only within array environment");
            }
          });
          var my = uy;
          Ct({
            type: "environment",
            names: ["\\begin", "\\end"],
            props: {
              numArgs: 1,
              argTypes: ["text"]
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              if (w.type !== "ordgroup")
                throw new s("Invalid environment name", w);
              let T = "";
              for (let E = 0; E < w.body.length; ++E)
                T += Jt(w.body[E], "textord").text;
              if (b === "\\begin") {
                if (!my.hasOwnProperty(T))
                  throw new s("No such environment: " + T, w);
                const E = my[T], {
                  args: D,
                  optArgs: P
                } = f.parseArguments("\\begin{" + T + "}", E), Q = {
                  mode: f.mode,
                  envName: T,
                  parser: f
                }, nt = E.handler(Q, D, P);
                f.expect("\\end", false);
                const it = f.nextToken, lt = Jt(f.parseFunction(), "environment");
                if (lt.name !== T)
                  throw new s("Mismatch: \\begin{" + T + "} matched by \\end{" + lt.name + "}", it);
                return nt;
              }
              return {
                type: "environment",
                mode: f.mode,
                name: T,
                nameGroup: w
              };
            }
          });
          const gy = (d, u) => {
            const f = d.font, b = u.withFont(f);
            return ce(d.body, b);
          }, yy = (d, u) => {
            const f = d.font, b = u.withFont(f);
            return _e(d.body, b);
          }, by = {
            "\\Bbb": "\\mathbb",
            "\\bold": "\\mathbf",
            "\\frak": "\\mathfrak",
            "\\bm": "\\boldsymbol"
          };
          Ct({
            type: "font",
            names: [
              // styles, except \boldsymbol defined below
              "\\mathrm",
              "\\mathit",
              "\\mathbf",
              "\\mathnormal",
              "\\mathsfit",
              // families
              "\\mathbb",
              "\\mathcal",
              "\\mathfrak",
              "\\mathscr",
              "\\mathsf",
              "\\mathtt",
              // aliases, except \bm defined below
              "\\Bbb",
              "\\bold",
              "\\frak"
            ],
            props: {
              numArgs: 1,
              allowedInArgument: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = Dc(u[0]);
              let T = b;
              return T in by && (T = by[T]), {
                type: "font",
                mode: f.mode,
                font: T.slice(1),
                body: w
              };
            },
            htmlBuilder: gy,
            mathmlBuilder: yy
          }), Ct({
            type: "mclass",
            names: ["\\boldsymbol", "\\bm"],
            props: {
              numArgs: 1
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0], w = k.isCharacterBox(b);
              return {
                type: "mclass",
                mode: f.mode,
                mclass: Oc(b),
                body: [{
                  type: "font",
                  mode: f.mode,
                  font: "boldsymbol",
                  body: b
                }],
                isCharacterBox: w
              };
            }
          }), Ct({
            type: "font",
            names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b,
                breakOnTokenText: w
              } = d;
              const {
                mode: T
              } = f, E = f.parseExpression(true, w), D = "math" + b.slice(1);
              return {
                type: "font",
                mode: T,
                font: D,
                body: {
                  type: "ordgroup",
                  mode: f.mode,
                  body: E
                }
              };
            },
            htmlBuilder: gy,
            mathmlBuilder: yy
          });
          const xy = (d, u) => {
            let f = u;
            return d === "display" ? f = f.id >= et.SCRIPT.id ? f.text() : et.DISPLAY : d === "text" && f.size === et.DISPLAY.size ? f = et.TEXT : d === "script" ? f = et.SCRIPT : d === "scriptscript" && (f = et.SCRIPTSCRIPT), f;
          }, kd = (d, u) => {
            const f = xy(d.size, u.style), b = f.fracNum(), w = f.fracDen();
            let T;
            T = u.havingStyle(b);
            const E = ce(d.numer, T, u);
            if (d.continued) {
              const de = 8.5 / u.fontMetrics().ptPerEm, he = 3.5 / u.fontMetrics().ptPerEm;
              E.height = E.height < de ? de : E.height, E.depth = E.depth < he ? he : E.depth;
            }
            T = u.havingStyle(w);
            const D = ce(d.denom, T, u);
            let P, Q, nt;
            d.hasBarLine ? (d.barSize ? (Q = we(d.barSize, u), P = ot.makeLineSpan("frac-line", u, Q)) : P = ot.makeLineSpan("frac-line", u), Q = P.height, nt = P.height) : (P = null, Q = 0, nt = u.fontMetrics().defaultRuleThickness);
            let it, lt, yt;
            f.size === et.DISPLAY.size || d.size === "display" ? (it = u.fontMetrics().num1, Q > 0 ? lt = 3 * nt : lt = 7 * nt, yt = u.fontMetrics().denom1) : (Q > 0 ? (it = u.fontMetrics().num2, lt = nt) : (it = u.fontMetrics().num3, lt = 3 * nt), yt = u.fontMetrics().denom2);
            let kt;
            if (P) {
              const de = u.fontMetrics().axisHeight;
              it - E.depth - (de + 0.5 * Q) < lt && (it += lt - (it - E.depth - (de + 0.5 * Q))), de - 0.5 * Q - (D.height - yt) < lt && (yt += lt - (de - 0.5 * Q - (D.height - yt)));
              const he = -(de - 0.5 * Q);
              kt = ot.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: D,
                  shift: yt
                }, {
                  type: "elem",
                  elem: P,
                  shift: he
                }, {
                  type: "elem",
                  elem: E,
                  shift: -it
                }]
              }, u);
            } else {
              const de = it - E.depth - (D.height - yt);
              de < lt && (it += 0.5 * (lt - de), yt += 0.5 * (lt - de)), kt = ot.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: D,
                  shift: yt
                }, {
                  type: "elem",
                  elem: E,
                  shift: -it
                }]
              }, u);
            }
            T = u.havingStyle(f), kt.height *= T.sizeMultiplier / u.sizeMultiplier, kt.depth *= T.sizeMultiplier / u.sizeMultiplier;
            let Kt;
            f.size === et.DISPLAY.size ? Kt = u.fontMetrics().delim1 : f.size === et.SCRIPTSCRIPT.size ? Kt = u.havingStyle(et.SCRIPT).fontMetrics().delim2 : Kt = u.fontMetrics().delim2;
            let ie, ee;
            return d.leftDelim == null ? ie = Ma(u, ["mopen"]) : ie = gi.customSizedDelim(d.leftDelim, Kt, true, u.havingStyle(f), d.mode, ["mopen"]), d.continued ? ee = ot.makeSpan([]) : d.rightDelim == null ? ee = Ma(u, ["mclose"]) : ee = gi.customSizedDelim(d.rightDelim, Kt, true, u.havingStyle(f), d.mode, ["mclose"]), ot.makeSpan(["mord"].concat(T.sizingClasses(u)), [ie, ot.makeSpan(["mfrac"], [kt]), ee], u);
          }, vd = (d, u) => {
            let f = new ft.MathNode("mfrac", [_e(d.numer, u), _e(d.denom, u)]);
            if (!d.hasBarLine)
              f.setAttribute("linethickness", "0px");
            else if (d.barSize) {
              const w = we(d.barSize, u);
              f.setAttribute("linethickness", bt(w));
            }
            const b = xy(d.size, u.style);
            if (b.size !== u.style.size) {
              f = new ft.MathNode("mstyle", [f]);
              const w = b.size === et.DISPLAY.size ? "true" : "false";
              f.setAttribute("displaystyle", w), f.setAttribute("scriptlevel", "0");
            }
            if (d.leftDelim != null || d.rightDelim != null) {
              const w = [];
              if (d.leftDelim != null) {
                const T = new ft.MathNode("mo", [new ft.TextNode(d.leftDelim.replace("\\", ""))]);
                T.setAttribute("fence", "true"), w.push(T);
              }
              if (w.push(f), d.rightDelim != null) {
                const T = new ft.MathNode("mo", [new ft.TextNode(d.rightDelim.replace("\\", ""))]);
                T.setAttribute("fence", "true"), w.push(T);
              }
              return id(w);
            }
            return f;
          };
          Ct({
            type: "genfrac",
            names: [
              "\\dfrac",
              "\\frac",
              "\\tfrac",
              "\\dbinom",
              "\\binom",
              "\\tbinom",
              "\\\\atopfrac",
              // can’t be entered directly
              "\\\\bracefrac",
              "\\\\brackfrac"
              // ditto
            ],
            props: {
              numArgs: 2,
              allowedInArgument: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0], T = u[1];
              let E, D = null, P = null, Q = "auto";
              switch (b) {
                case "\\dfrac":
                case "\\frac":
                case "\\tfrac":
                  E = true;
                  break;
                case "\\\\atopfrac":
                  E = false;
                  break;
                case "\\dbinom":
                case "\\binom":
                case "\\tbinom":
                  E = false, D = "(", P = ")";
                  break;
                case "\\\\bracefrac":
                  E = false, D = "\\{", P = "\\}";
                  break;
                case "\\\\brackfrac":
                  E = false, D = "[", P = "]";
                  break;
                default:
                  throw new Error("Unrecognized genfrac command");
              }
              switch (b) {
                case "\\dfrac":
                case "\\dbinom":
                  Q = "display";
                  break;
                case "\\tfrac":
                case "\\tbinom":
                  Q = "text";
                  break;
              }
              return {
                type: "genfrac",
                mode: f.mode,
                continued: false,
                numer: w,
                denom: T,
                hasBarLine: E,
                leftDelim: D,
                rightDelim: P,
                size: Q,
                barSize: null
              };
            },
            htmlBuilder: kd,
            mathmlBuilder: vd
          }), Ct({
            type: "genfrac",
            names: ["\\cfrac"],
            props: {
              numArgs: 2
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0], T = u[1];
              return {
                type: "genfrac",
                mode: f.mode,
                continued: true,
                numer: w,
                denom: T,
                hasBarLine: true,
                leftDelim: null,
                rightDelim: null,
                size: "display",
                barSize: null
              };
            }
          }), Ct({
            type: "infix",
            names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
            props: {
              numArgs: 0,
              infix: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f,
                token: b
              } = d, w;
              switch (f) {
                case "\\over":
                  w = "\\frac";
                  break;
                case "\\choose":
                  w = "\\binom";
                  break;
                case "\\atop":
                  w = "\\\\atopfrac";
                  break;
                case "\\brace":
                  w = "\\\\bracefrac";
                  break;
                case "\\brack":
                  w = "\\\\brackfrac";
                  break;
                default:
                  throw new Error("Unrecognized infix genfrac command");
              }
              return {
                type: "infix",
                mode: u.mode,
                replaceWith: w,
                token: b
              };
            }
          });
          const wy = ["display", "text", "script", "scriptscript"], ky = function(d) {
            let u = null;
            return d.length > 0 && (u = d, u = u === "." ? null : u), u;
          };
          Ct({
            type: "genfrac",
            names: ["\\genfrac"],
            props: {
              numArgs: 6,
              allowedInArgument: true,
              argTypes: ["math", "math", "size", "text", "math", "math"]
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = u[4], w = u[5], T = Dc(u[0]), E = T.type === "atom" && T.family === "open" ? ky(T.text) : null, D = Dc(u[1]), P = D.type === "atom" && D.family === "close" ? ky(D.text) : null, Q = Jt(u[2], "size");
              let nt, it = null;
              Q.isBlank ? nt = true : (it = Q.value, nt = it.number > 0);
              let lt = "auto", yt = u[3];
              if (yt.type === "ordgroup") {
                if (yt.body.length > 0) {
                  const kt = Jt(yt.body[0], "textord");
                  lt = wy[Number(kt.text)];
                }
              } else
                yt = Jt(yt, "textord"), lt = wy[Number(yt.text)];
              return {
                type: "genfrac",
                mode: f.mode,
                numer: b,
                denom: w,
                continued: false,
                hasBarLine: nt,
                barSize: it,
                leftDelim: E,
                rightDelim: P,
                size: lt
              };
            },
            htmlBuilder: kd,
            mathmlBuilder: vd
          }), Ct({
            type: "infix",
            names: ["\\above"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              infix: true
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b,
                token: w
              } = d;
              return {
                type: "infix",
                mode: f.mode,
                replaceWith: "\\\\abovefrac",
                size: Jt(u[0], "size").value,
                token: w
              };
            }
          }), Ct({
            type: "genfrac",
            names: ["\\\\abovefrac"],
            props: {
              numArgs: 3,
              argTypes: ["math", "size", "math"]
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0], T = x(Jt(u[1], "infix").size), E = u[2], D = T.number > 0;
              return {
                type: "genfrac",
                mode: f.mode,
                numer: w,
                denom: E,
                continued: false,
                hasBarLine: D,
                barSize: T,
                leftDelim: null,
                rightDelim: null,
                size: "auto"
              };
            },
            htmlBuilder: kd,
            mathmlBuilder: vd
          });
          const vy = (d, u) => {
            const f = u.style;
            let b, w;
            d.type === "supsub" ? (b = d.sup ? ce(d.sup, u.havingStyle(f.sup()), u) : ce(d.sub, u.havingStyle(f.sub()), u), w = Jt(d.base, "horizBrace")) : w = Jt(d, "horizBrace");
            const T = ce(w.base, u.havingBaseStyle(et.DISPLAY)), E = mi.svgSpan(w, u);
            let D;
            if (w.isOver ? (D = ot.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: T
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: E
              }]
            }, u), D.children[0].children[0].children[1].classes.push("svg-align")) : (D = ot.makeVList({
              positionType: "bottom",
              positionData: T.depth + 0.1 + E.height,
              children: [{
                type: "elem",
                elem: E
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: T
              }]
            }, u), D.children[0].children[0].children[0].classes.push("svg-align")), b) {
              const P = ot.makeSpan(["mord", w.isOver ? "mover" : "munder"], [D], u);
              w.isOver ? D = ot.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: P
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: b
                }]
              }, u) : D = ot.makeVList({
                positionType: "bottom",
                positionData: P.depth + 0.2 + b.height + b.depth,
                children: [{
                  type: "elem",
                  elem: b
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: P
                }]
              }, u);
            }
            return ot.makeSpan(["mord", w.isOver ? "mover" : "munder"], [D], u);
          };
          Ct({
            type: "horizBrace",
            names: ["\\overbrace", "\\underbrace"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              return {
                type: "horizBrace",
                mode: f.mode,
                label: b,
                isOver: /^\\over/.test(b),
                base: u[0]
              };
            },
            htmlBuilder: vy,
            mathmlBuilder: (d, u) => {
              const f = mi.mathMLnode(d.label);
              return new ft.MathNode(d.isOver ? "mover" : "munder", [_e(d.base, u), f]);
            }
          }), Ct({
            type: "href",
            names: ["\\href"],
            props: {
              numArgs: 2,
              argTypes: ["url", "original"],
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[1], w = Jt(u[0], "url").url;
              return f.settings.isTrusted({
                command: "\\href",
                url: w
              }) ? {
                type: "href",
                mode: f.mode,
                href: w,
                body: Re(b)
              } : f.formatUnsupportedCmd("\\href");
            },
            htmlBuilder: (d, u) => {
              const f = Ge(d.body, u, false);
              return ot.makeAnchor(d.href, [], f, u);
            },
            mathmlBuilder: (d, u) => {
              let f = ji(d.body, u);
              return f instanceof Xr || (f = new Xr("mrow", [f])), f.setAttribute("href", d.href), f;
            }
          }), Ct({
            type: "href",
            names: ["\\url"],
            props: {
              numArgs: 1,
              argTypes: ["url"],
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = Jt(u[0], "url").url;
              if (!f.settings.isTrusted({
                command: "\\url",
                url: b
              }))
                return f.formatUnsupportedCmd("\\url");
              const w = [];
              for (let E = 0; E < b.length; E++) {
                let D = b[E];
                D === "~" && (D = "\\textasciitilde"), w.push({
                  type: "textord",
                  mode: "text",
                  text: D
                });
              }
              const T = {
                type: "text",
                mode: f.mode,
                font: "\\texttt",
                body: w
              };
              return {
                type: "href",
                mode: f.mode,
                href: b,
                body: Re(T)
              };
            }
          }), Ct({
            type: "hbox",
            names: ["\\hbox"],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInText: true,
              primitive: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "hbox",
                mode: f.mode,
                body: Re(u[0])
              };
            },
            htmlBuilder(d, u) {
              const f = Ge(d.body, u, false);
              return ot.makeFragment(f);
            },
            mathmlBuilder(d, u) {
              return new ft.MathNode("mrow", Ir(d.body, u));
            }
          }), Ct({
            type: "html",
            names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
            props: {
              numArgs: 2,
              argTypes: ["raw", "original"],
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b,
                token: w
              } = d;
              const T = Jt(u[0], "raw").string, E = u[1];
              f.settings.strict && f.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
              let D;
              const P = {};
              switch (b) {
                case "\\htmlClass":
                  P.class = T, D = {
                    command: "\\htmlClass",
                    class: T
                  };
                  break;
                case "\\htmlId":
                  P.id = T, D = {
                    command: "\\htmlId",
                    id: T
                  };
                  break;
                case "\\htmlStyle":
                  P.style = T, D = {
                    command: "\\htmlStyle",
                    style: T
                  };
                  break;
                case "\\htmlData": {
                  const Q = T.split(",");
                  for (let nt = 0; nt < Q.length; nt++) {
                    const it = Q[nt].split("=");
                    if (it.length !== 2)
                      throw new s("Error parsing key-value for \\htmlData");
                    P["data-" + it[0].trim()] = it[1].trim();
                  }
                  D = {
                    command: "\\htmlData",
                    attributes: P
                  };
                  break;
                }
                default:
                  throw new Error("Unrecognized html command");
              }
              return f.settings.isTrusted(D) ? {
                type: "html",
                mode: f.mode,
                attributes: P,
                body: Re(E)
              } : f.formatUnsupportedCmd(b);
            },
            htmlBuilder: (d, u) => {
              const f = Ge(d.body, u, false), b = ["enclosing"];
              d.attributes.class && b.push(...d.attributes.class.trim().split(/\s+/));
              const w = ot.makeSpan(b, f, u);
              for (const T in d.attributes)
                T !== "class" && d.attributes.hasOwnProperty(T) && w.setAttribute(T, d.attributes[T]);
              return w;
            },
            mathmlBuilder: (d, u) => ji(d.body, u)
          }), Ct({
            type: "htmlmathml",
            names: ["\\html@mathml"],
            props: {
              numArgs: 2,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              return {
                type: "htmlmathml",
                mode: f.mode,
                html: Re(u[0]),
                mathml: Re(u[1])
              };
            },
            htmlBuilder: (d, u) => {
              const f = Ge(d.html, u, false);
              return ot.makeFragment(f);
            },
            mathmlBuilder: (d, u) => ji(d.mathml, u)
          });
          const _d = function(d) {
            if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(d))
              return {
                number: +d,
                unit: "bp"
              };
            {
              const u = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(d);
              if (!u)
                throw new s("Invalid size: '" + d + "' in \\includegraphics");
              const f = {
                number: +(u[1] + u[2]),
                // sign + magnitude, cast to number
                unit: u[3]
              };
              if (!ks(f))
                throw new s("Invalid unit: '" + f.unit + "' in \\includegraphics.");
              return f;
            }
          };
          Ct({
            type: "includegraphics",
            names: ["\\includegraphics"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              argTypes: ["raw", "url"],
              allowedInText: false
            },
            handler: (d, u, f) => {
              let {
                parser: b
              } = d, w = {
                number: 0,
                unit: "em"
              }, T = {
                number: 0.9,
                unit: "em"
              }, E = {
                number: 0,
                unit: "em"
              }, D = "";
              if (f[0]) {
                const Q = Jt(f[0], "raw").string.split(",");
                for (let nt = 0; nt < Q.length; nt++) {
                  const it = Q[nt].split("=");
                  if (it.length === 2) {
                    const lt = it[1].trim();
                    switch (it[0].trim()) {
                      case "alt":
                        D = lt;
                        break;
                      case "width":
                        w = _d(lt);
                        break;
                      case "height":
                        T = _d(lt);
                        break;
                      case "totalheight":
                        E = _d(lt);
                        break;
                      default:
                        throw new s("Invalid key: '" + it[0] + "' in \\includegraphics.");
                    }
                  }
                }
              }
              const P = Jt(u[0], "url").url;
              return D === "" && (D = P, D = D.replace(/^.*[\\/]/, ""), D = D.substring(0, D.lastIndexOf("."))), b.settings.isTrusted({
                command: "\\includegraphics",
                url: P
              }) ? {
                type: "includegraphics",
                mode: b.mode,
                alt: D,
                width: w,
                height: T,
                totalheight: E,
                src: P
              } : b.formatUnsupportedCmd("\\includegraphics");
            },
            htmlBuilder: (d, u) => {
              const f = we(d.height, u);
              let b = 0;
              d.totalheight.number > 0 && (b = we(d.totalheight, u) - f);
              let w = 0;
              d.width.number > 0 && (w = we(d.width, u));
              const T = {
                height: bt(f + b)
              };
              w > 0 && (T.width = bt(w)), b > 0 && (T.verticalAlign = bt(-b));
              const E = new _s(d.src, d.alt, T);
              return E.height = f, E.depth = b, E;
            },
            mathmlBuilder: (d, u) => {
              const f = new ft.MathNode("mglyph", []);
              f.setAttribute("alt", d.alt);
              const b = we(d.height, u);
              let w = 0;
              if (d.totalheight.number > 0 && (w = we(d.totalheight, u) - b, f.setAttribute("valign", bt(-w))), f.setAttribute("height", bt(b + w)), d.width.number > 0) {
                const T = we(d.width, u);
                f.setAttribute("width", bt(T));
              }
              return f.setAttribute("src", d.src), f;
            }
          }), Ct({
            type: "kern",
            names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              primitive: true,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = Jt(u[0], "size");
              if (f.settings.strict) {
                const T = b[1] === "m", E = w.value.unit === "mu";
                T ? (E || f.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + b + " supports only mu units, " + ("not " + w.value.unit + " units")), f.mode !== "math" && f.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + b + " works only in math mode")) : E && f.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + b + " doesn't support mu units");
              }
              return {
                type: "kern",
                mode: f.mode,
                dimension: w.value
              };
            },
            htmlBuilder(d, u) {
              return ot.makeGlue(d.dimension, u);
            },
            mathmlBuilder(d, u) {
              const f = we(d.dimension, u);
              return new ft.SpaceNode(f);
            }
          }), Ct({
            type: "lap",
            names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "lap",
                mode: f.mode,
                alignment: b.slice(5),
                body: w
              };
            },
            htmlBuilder: (d, u) => {
              let f;
              d.alignment === "clap" ? (f = ot.makeSpan([], [ce(d.body, u)]), f = ot.makeSpan(["inner"], [f], u)) : f = ot.makeSpan(["inner"], [ce(d.body, u)]);
              const b = ot.makeSpan(["fix"], []);
              let w = ot.makeSpan([d.alignment], [f, b], u);
              const T = ot.makeSpan(["strut"]);
              return T.style.height = bt(w.height + w.depth), w.depth && (T.style.verticalAlign = bt(-w.depth)), w.children.unshift(T), w = ot.makeSpan(["thinbox"], [w], u), ot.makeSpan(["mord", "vbox"], [w], u);
            },
            mathmlBuilder: (d, u) => {
              const f = new ft.MathNode("mpadded", [_e(d.body, u)]);
              if (d.alignment !== "rlap") {
                const b = d.alignment === "llap" ? "-1" : "-0.5";
                f.setAttribute("lspace", b + "width");
              }
              return f.setAttribute("width", "0px"), f;
            }
          }), Ct({
            type: "styling",
            names: ["\\(", "$"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(d, u) {
              let {
                funcName: f,
                parser: b
              } = d;
              const w = b.mode;
              b.switchMode("math");
              const T = f === "\\(" ? "\\)" : "$", E = b.parseExpression(false, T);
              return b.expect(T), b.switchMode(w), {
                type: "styling",
                mode: b.mode,
                style: "text",
                body: E
              };
            }
          }), Ct({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\)", "\\]"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(d, u) {
              throw new s("Mismatched " + d.funcName);
            }
          });
          const _y = (d, u) => {
            switch (u.style.size) {
              case et.DISPLAY.size:
                return d.display;
              case et.TEXT.size:
                return d.text;
              case et.SCRIPT.size:
                return d.script;
              case et.SCRIPTSCRIPT.size:
                return d.scriptscript;
              default:
                return d.text;
            }
          };
          Ct({
            type: "mathchoice",
            names: ["\\mathchoice"],
            props: {
              numArgs: 4,
              primitive: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              return {
                type: "mathchoice",
                mode: f.mode,
                display: Re(u[0]),
                text: Re(u[1]),
                script: Re(u[2]),
                scriptscript: Re(u[3])
              };
            },
            htmlBuilder: (d, u) => {
              const f = _y(d, u), b = Ge(f, u, false);
              return ot.makeFragment(b);
            },
            mathmlBuilder: (d, u) => {
              const f = _y(d, u);
              return ji(f, u);
            }
          });
          const Cy = (d, u, f, b, w, T, E) => {
            d = ot.makeSpan([], [d]);
            const D = f && k.isCharacterBox(f);
            let P, Q;
            if (u) {
              const lt = ce(u, b.havingStyle(w.sup()), b);
              Q = {
                elem: lt,
                kern: Math.max(b.fontMetrics().bigOpSpacing1, b.fontMetrics().bigOpSpacing3 - lt.depth)
              };
            }
            if (f) {
              const lt = ce(f, b.havingStyle(w.sub()), b);
              P = {
                elem: lt,
                kern: Math.max(b.fontMetrics().bigOpSpacing2, b.fontMetrics().bigOpSpacing4 - lt.height)
              };
            }
            let nt;
            if (Q && P) {
              const lt = b.fontMetrics().bigOpSpacing5 + P.elem.height + P.elem.depth + P.kern + d.depth + E;
              nt = ot.makeVList({
                positionType: "bottom",
                positionData: lt,
                children: [{
                  type: "kern",
                  size: b.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: P.elem,
                  marginLeft: bt(-T)
                }, {
                  type: "kern",
                  size: P.kern
                }, {
                  type: "elem",
                  elem: d
                }, {
                  type: "kern",
                  size: Q.kern
                }, {
                  type: "elem",
                  elem: Q.elem,
                  marginLeft: bt(T)
                }, {
                  type: "kern",
                  size: b.fontMetrics().bigOpSpacing5
                }]
              }, b);
            } else if (P) {
              const lt = d.height - E;
              nt = ot.makeVList({
                positionType: "top",
                positionData: lt,
                children: [{
                  type: "kern",
                  size: b.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: P.elem,
                  marginLeft: bt(-T)
                }, {
                  type: "kern",
                  size: P.kern
                }, {
                  type: "elem",
                  elem: d
                }]
              }, b);
            } else if (Q) {
              const lt = d.depth + E;
              nt = ot.makeVList({
                positionType: "bottom",
                positionData: lt,
                children: [{
                  type: "elem",
                  elem: d
                }, {
                  type: "kern",
                  size: Q.kern
                }, {
                  type: "elem",
                  elem: Q.elem,
                  marginLeft: bt(T)
                }, {
                  type: "kern",
                  size: b.fontMetrics().bigOpSpacing5
                }]
              }, b);
            } else
              return d;
            const it = [nt];
            if (P && T !== 0 && !D) {
              const lt = ot.makeSpan(["mspace"], [], b);
              lt.style.marginRight = bt(T), it.unshift(lt);
            }
            return ot.makeSpan(["mop", "op-limits"], it, b);
          }, Sy = ["\\smallint"], xo = (d, u) => {
            let f, b, w = false, T;
            d.type === "supsub" ? (f = d.sup, b = d.sub, T = Jt(d.base, "op"), w = true) : T = Jt(d, "op");
            const E = u.style;
            let D = false;
            E.size === et.DISPLAY.size && T.symbol && !k.contains(Sy, T.name) && (D = true);
            let P;
            if (T.symbol) {
              const it = D ? "Size2-Regular" : "Size1-Regular";
              let lt = "";
              if ((T.name === "\\oiint" || T.name === "\\oiiint") && (lt = T.name.slice(1), T.name = lt === "oiint" ? "\\iint" : "\\iiint"), P = ot.makeSymbol(T.name, it, "math", u, ["mop", "op-symbol", D ? "large-op" : "small-op"]), lt.length > 0) {
                const yt = P.italic, kt = ot.staticSvg(lt + "Size" + (D ? "2" : "1"), u);
                P = ot.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: P,
                    shift: 0
                  }, {
                    type: "elem",
                    elem: kt,
                    shift: D ? 0.08 : 0
                  }]
                }, u), T.name = "\\" + lt, P.classes.unshift("mop"), P.italic = yt;
              }
            } else if (T.body) {
              const it = Ge(T.body, u, true);
              it.length === 1 && it[0] instanceof Dr ? (P = it[0], P.classes[0] = "mop") : P = ot.makeSpan(["mop"], it, u);
            } else {
              const it = [];
              for (let lt = 1; lt < T.name.length; lt++)
                it.push(ot.mathsym(T.name[lt], T.mode, u));
              P = ot.makeSpan(["mop"], it, u);
            }
            let Q = 0, nt = 0;
            return (P instanceof Dr || T.name === "\\oiint" || T.name === "\\oiiint") && !T.suppressBaseShift && (Q = (P.height - P.depth) / 2 - u.fontMetrics().axisHeight, nt = P.italic), w ? Cy(P, f, b, u, E, nt, Q) : (Q && (P.style.position = "relative", P.style.top = bt(Q)), P);
          }, Da = (d, u) => {
            let f;
            if (d.symbol)
              f = new Xr("mo", [ln(d.name, d.mode)]), k.contains(Sy, d.name) && f.setAttribute("largeop", "false");
            else if (d.body)
              f = new Xr("mo", Ir(d.body, u));
            else {
              f = new Xr("mi", [new In(d.name.slice(1))]);
              const b = new Xr("mo", [ln("⁡", "text")]);
              d.parentIsSupSub ? f = new Xr("mrow", [f, b]) : f = jg([f, b]);
            }
            return f;
          }, uC = {
            "∏": "\\prod",
            "∐": "\\coprod",
            "∑": "\\sum",
            "⋀": "\\bigwedge",
            "⋁": "\\bigvee",
            "⋂": "\\bigcap",
            "⋃": "\\bigcup",
            "⨀": "\\bigodot",
            "⨁": "\\bigoplus",
            "⨂": "\\bigotimes",
            "⨄": "\\biguplus",
            "⨆": "\\bigsqcup"
          };
          Ct({
            type: "op",
            names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
            props: {
              numArgs: 0
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d, w = b;
              return w.length === 1 && (w = uC[w]), {
                type: "op",
                mode: f.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: true,
                name: w
              };
            },
            htmlBuilder: xo,
            mathmlBuilder: Da
          }), Ct({
            type: "op",
            names: ["\\mathop"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "op",
                mode: f.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                body: Re(b)
              };
            },
            htmlBuilder: xo,
            mathmlBuilder: Da
          });
          const dC = {
            "∫": "\\int",
            "∬": "\\iint",
            "∭": "\\iiint",
            "∮": "\\oint",
            "∯": "\\oiint",
            "∰": "\\oiiint"
          };
          Ct({
            type: "op",
            names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
            props: {
              numArgs: 0
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              return {
                type: "op",
                mode: u.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                name: f
              };
            },
            htmlBuilder: xo,
            mathmlBuilder: Da
          }), Ct({
            type: "op",
            names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
            props: {
              numArgs: 0
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              return {
                type: "op",
                mode: u.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: false,
                name: f
              };
            },
            htmlBuilder: xo,
            mathmlBuilder: Da
          }), Ct({
            type: "op",
            names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
            props: {
              numArgs: 0
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d, b = f;
              return b.length === 1 && (b = dC[b]), {
                type: "op",
                mode: u.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: true,
                name: b
              };
            },
            htmlBuilder: xo,
            mathmlBuilder: Da
          });
          const Ty = (d, u) => {
            let f, b, w = false, T;
            d.type === "supsub" ? (f = d.sup, b = d.sub, T = Jt(d.base, "operatorname"), w = true) : T = Jt(d, "operatorname");
            let E;
            if (T.body.length > 0) {
              const D = T.body.map((Q) => {
                const nt = Q.text;
                return typeof nt == "string" ? {
                  type: "textord",
                  mode: Q.mode,
                  text: nt
                } : Q;
              }), P = Ge(D, u.withFont("mathrm"), true);
              for (let Q = 0; Q < P.length; Q++) {
                const nt = P[Q];
                nt instanceof Dr && (nt.text = nt.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
              }
              E = ot.makeSpan(["mop"], P, u);
            } else
              E = ot.makeSpan(["mop"], [], u);
            return w ? Cy(E, f, b, u, u.style, 0, 0) : E;
          };
          Ct({
            type: "operatorname",
            names: ["\\operatorname@", "\\operatornamewithlimits"],
            props: {
              numArgs: 1
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "operatorname",
                mode: f.mode,
                body: Re(w),
                alwaysHandleSupSub: b === "\\operatornamewithlimits",
                limits: false,
                parentIsSupSub: false
              };
            },
            htmlBuilder: Ty,
            mathmlBuilder: (d, u) => {
              let f = Ir(d.body, u.withFont("mathrm")), b = true;
              for (let E = 0; E < f.length; E++) {
                const D = f[E];
                if (!(D instanceof ft.SpaceNode)) if (D instanceof ft.MathNode)
                  switch (D.type) {
                    case "mi":
                    case "mn":
                    case "ms":
                    case "mspace":
                    case "mtext":
                      break;
                    case "mo": {
                      const P = D.children[0];
                      D.children.length === 1 && P instanceof ft.TextNode ? P.text = P.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : b = false;
                      break;
                    }
                    default:
                      b = false;
                  }
                else
                  b = false;
              }
              if (b) {
                const E = f.map((D) => D.toText()).join("");
                f = [new ft.TextNode(E)];
              }
              const w = new ft.MathNode("mi", f);
              w.setAttribute("mathvariant", "normal");
              const T = new ft.MathNode("mo", [ln("⁡", "text")]);
              return d.parentIsSupSub ? new ft.MathNode("mrow", [w, T]) : ft.newDocumentFragment([w, T]);
            }
          }), N("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@"), Ts({
            type: "ordgroup",
            htmlBuilder(d, u) {
              return d.semisimple ? ot.makeFragment(Ge(d.body, u, false)) : ot.makeSpan(["mord"], Ge(d.body, u, true), u);
            },
            mathmlBuilder(d, u) {
              return ji(d.body, u, true);
            }
          }), Ct({
            type: "overline",
            names: ["\\overline"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "overline",
                mode: f.mode,
                body: b
              };
            },
            htmlBuilder(d, u) {
              const f = ce(d.body, u.havingCrampedStyle()), b = ot.makeLineSpan("overline-line", u), w = u.fontMetrics().defaultRuleThickness, T = ot.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: f
                }, {
                  type: "kern",
                  size: 3 * w
                }, {
                  type: "elem",
                  elem: b
                }, {
                  type: "kern",
                  size: w
                }]
              }, u);
              return ot.makeSpan(["mord", "overline"], [T], u);
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mo", [new ft.TextNode("‾")]);
              f.setAttribute("stretchy", "true");
              const b = new ft.MathNode("mover", [_e(d.body, u), f]);
              return b.setAttribute("accent", "true"), b;
            }
          }), Ct({
            type: "phantom",
            names: ["\\phantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "phantom",
                mode: f.mode,
                body: Re(b)
              };
            },
            htmlBuilder: (d, u) => {
              const f = Ge(d.body, u.withPhantom(), false);
              return ot.makeFragment(f);
            },
            mathmlBuilder: (d, u) => {
              const f = Ir(d.body, u);
              return new ft.MathNode("mphantom", f);
            }
          }), Ct({
            type: "hphantom",
            names: ["\\hphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "hphantom",
                mode: f.mode,
                body: b
              };
            },
            htmlBuilder: (d, u) => {
              let f = ot.makeSpan([], [ce(d.body, u.withPhantom())]);
              if (f.height = 0, f.depth = 0, f.children)
                for (let b = 0; b < f.children.length; b++)
                  f.children[b].height = 0, f.children[b].depth = 0;
              return f = ot.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: f
                }]
              }, u), ot.makeSpan(["mord"], [f], u);
            },
            mathmlBuilder: (d, u) => {
              const f = Ir(Re(d.body), u), b = new ft.MathNode("mphantom", f), w = new ft.MathNode("mpadded", [b]);
              return w.setAttribute("height", "0px"), w.setAttribute("depth", "0px"), w;
            }
          }), Ct({
            type: "vphantom",
            names: ["\\vphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "vphantom",
                mode: f.mode,
                body: b
              };
            },
            htmlBuilder: (d, u) => {
              const f = ot.makeSpan(["inner"], [ce(d.body, u.withPhantom())]), b = ot.makeSpan(["fix"], []);
              return ot.makeSpan(["mord", "rlap"], [f, b], u);
            },
            mathmlBuilder: (d, u) => {
              const f = Ir(Re(d.body), u), b = new ft.MathNode("mphantom", f), w = new ft.MathNode("mpadded", [b]);
              return w.setAttribute("width", "0px"), w;
            }
          }), Ct({
            type: "raisebox",
            names: ["\\raisebox"],
            props: {
              numArgs: 2,
              argTypes: ["size", "hbox"],
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = Jt(u[0], "size").value, w = u[1];
              return {
                type: "raisebox",
                mode: f.mode,
                dy: b,
                body: w
              };
            },
            htmlBuilder(d, u) {
              const f = ce(d.body, u), b = we(d.dy, u);
              return ot.makeVList({
                positionType: "shift",
                positionData: -b,
                children: [{
                  type: "elem",
                  elem: f
                }]
              }, u);
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mpadded", [_e(d.body, u)]), b = d.dy.number + d.dy.unit;
              return f.setAttribute("voffset", b), f;
            }
          }), Ct({
            type: "internal",
            names: ["\\relax"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInArgument: true
            },
            handler(d) {
              let {
                parser: u
              } = d;
              return {
                type: "internal",
                mode: u.mode
              };
            }
          }), Ct({
            type: "rule",
            names: ["\\rule"],
            props: {
              numArgs: 2,
              numOptionalArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              argTypes: ["size", "size", "size"]
            },
            handler(d, u, f) {
              let {
                parser: b
              } = d;
              const w = f[0], T = Jt(u[0], "size"), E = Jt(u[1], "size");
              return {
                type: "rule",
                mode: b.mode,
                shift: w && Jt(w, "size").value,
                width: T.value,
                height: E.value
              };
            },
            htmlBuilder(d, u) {
              const f = ot.makeSpan(["mord", "rule"], [], u), b = we(d.width, u), w = we(d.height, u), T = d.shift ? we(d.shift, u) : 0;
              return f.style.borderRightWidth = bt(b), f.style.borderTopWidth = bt(w), f.style.bottom = bt(T), f.width = b, f.height = w + T, f.depth = -T, f.maxFontSize = w * 1.125 * u.sizeMultiplier, f;
            },
            mathmlBuilder(d, u) {
              const f = we(d.width, u), b = we(d.height, u), w = d.shift ? we(d.shift, u) : 0, T = u.color && u.getColor() || "black", E = new ft.MathNode("mspace");
              E.setAttribute("mathbackground", T), E.setAttribute("width", bt(f)), E.setAttribute("height", bt(b));
              const D = new ft.MathNode("mpadded", [E]);
              return w >= 0 ? D.setAttribute("height", bt(w)) : (D.setAttribute("height", bt(w)), D.setAttribute("depth", bt(-w))), D.setAttribute("voffset", bt(w)), D;
            }
          });
          function Ay(d, u, f) {
            const b = Ge(d, u, false), w = u.sizeMultiplier / f.sizeMultiplier;
            for (let T = 0; T < b.length; T++) {
              const E = b[T].classes.indexOf("sizing");
              E < 0 ? Array.prototype.push.apply(b[T].classes, u.sizingClasses(f)) : b[T].classes[E + 1] === "reset-size" + u.size && (b[T].classes[E + 1] = "reset-size" + f.size), b[T].height *= w, b[T].depth *= w;
            }
            return ot.makeFragment(b);
          }
          const $y = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
          Ct({
            type: "sizing",
            names: $y,
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                breakOnTokenText: f,
                funcName: b,
                parser: w
              } = d;
              const T = w.parseExpression(false, f);
              return {
                type: "sizing",
                mode: w.mode,
                // Figure out what size to use based on the list of functions above
                size: $y.indexOf(b) + 1,
                body: T
              };
            },
            htmlBuilder: (d, u) => {
              const f = u.havingSize(d.size);
              return Ay(d.body, f, u);
            },
            mathmlBuilder: (d, u) => {
              const f = u.havingSize(d.size), b = Ir(d.body, f), w = new ft.MathNode("mstyle", b);
              return w.setAttribute("mathsize", bt(f.sizeMultiplier)), w;
            }
          }), Ct({
            type: "smash",
            names: ["\\smash"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              allowedInText: true
            },
            handler: (d, u, f) => {
              let {
                parser: b
              } = d, w = false, T = false;
              const E = f[0] && Jt(f[0], "ordgroup");
              if (E) {
                let P = "";
                for (let Q = 0; Q < E.body.length; ++Q)
                  if (P = E.body[Q].text, P === "t")
                    w = true;
                  else if (P === "b")
                    T = true;
                  else {
                    w = false, T = false;
                    break;
                  }
              } else
                w = true, T = true;
              const D = u[0];
              return {
                type: "smash",
                mode: b.mode,
                body: D,
                smashHeight: w,
                smashDepth: T
              };
            },
            htmlBuilder: (d, u) => {
              const f = ot.makeSpan([], [ce(d.body, u)]);
              if (!d.smashHeight && !d.smashDepth)
                return f;
              if (d.smashHeight && (f.height = 0, f.children))
                for (let w = 0; w < f.children.length; w++)
                  f.children[w].height = 0;
              if (d.smashDepth && (f.depth = 0, f.children))
                for (let w = 0; w < f.children.length; w++)
                  f.children[w].depth = 0;
              const b = ot.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: f
                }]
              }, u);
              return ot.makeSpan(["mord"], [b], u);
            },
            mathmlBuilder: (d, u) => {
              const f = new ft.MathNode("mpadded", [_e(d.body, u)]);
              return d.smashHeight && f.setAttribute("height", "0px"), d.smashDepth && f.setAttribute("depth", "0px"), f;
            }
          }), Ct({
            type: "sqrt",
            names: ["\\sqrt"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(d, u, f) {
              let {
                parser: b
              } = d;
              const w = f[0], T = u[0];
              return {
                type: "sqrt",
                mode: b.mode,
                body: T,
                index: w
              };
            },
            htmlBuilder(d, u) {
              let f = ce(d.body, u.havingCrampedStyle());
              f.height === 0 && (f.height = u.fontMetrics().xHeight), f = ot.wrapFragment(f, u);
              const b = u.fontMetrics().defaultRuleThickness;
              let w = b;
              u.style.id < et.TEXT.id && (w = u.fontMetrics().xHeight);
              let T = b + w / 4;
              const E = f.height + f.depth + T + b, {
                span: D,
                ruleWidth: P,
                advanceWidth: Q
              } = gi.sqrtImage(E, u), nt = D.height - P;
              nt > f.height + f.depth + T && (T = (T + nt - f.height - f.depth) / 2);
              const it = D.height - f.height - T - P;
              f.style.paddingLeft = bt(Q);
              const lt = ot.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: f,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: -(f.height + it)
                }, {
                  type: "elem",
                  elem: D
                }, {
                  type: "kern",
                  size: P
                }]
              }, u);
              if (d.index) {
                const yt = u.havingStyle(et.SCRIPTSCRIPT), kt = ce(d.index, yt, u), Kt = 0.6 * (lt.height - lt.depth), ie = ot.makeVList({
                  positionType: "shift",
                  positionData: -Kt,
                  children: [{
                    type: "elem",
                    elem: kt
                  }]
                }, u), ee = ot.makeSpan(["root"], [ie]);
                return ot.makeSpan(["mord", "sqrt"], [ee, lt], u);
              } else
                return ot.makeSpan(["mord", "sqrt"], [lt], u);
            },
            mathmlBuilder(d, u) {
              const {
                body: f,
                index: b
              } = d;
              return b ? new ft.MathNode("mroot", [_e(f, u), _e(b, u)]) : new ft.MathNode("msqrt", [_e(f, u)]);
            }
          });
          const Ey = {
            display: et.DISPLAY,
            text: et.TEXT,
            script: et.SCRIPT,
            scriptscript: et.SCRIPTSCRIPT
          };
          Ct({
            type: "styling",
            names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(d, u) {
              let {
                breakOnTokenText: f,
                funcName: b,
                parser: w
              } = d;
              const T = w.parseExpression(true, f), E = b.slice(1, b.length - 5);
              return {
                type: "styling",
                mode: w.mode,
                // Figure out what style to use by pulling out the style from
                // the function name
                style: E,
                body: T
              };
            },
            htmlBuilder(d, u) {
              const f = Ey[d.style], b = u.havingStyle(f).withFont("");
              return Ay(d.body, b, u);
            },
            mathmlBuilder(d, u) {
              const f = Ey[d.style], b = u.havingStyle(f), w = Ir(d.body, b), T = new ft.MathNode("mstyle", w), E = {
                display: ["0", "true"],
                text: ["0", "false"],
                script: ["1", "false"],
                scriptscript: ["2", "false"]
              }[d.style];
              return T.setAttribute("scriptlevel", E[0]), T.setAttribute("displaystyle", E[1]), T;
            }
          });
          const pC = function(d, u) {
            const f = d.base;
            return f ? f.type === "op" ? f.limits && (u.style.size === et.DISPLAY.size || f.alwaysHandleSupSub) ? xo : null : f.type === "operatorname" ? f.alwaysHandleSupSub && (u.style.size === et.DISPLAY.size || f.limits) ? Ty : null : f.type === "accent" ? k.isCharacterBox(f.base) ? ld : null : f.type === "horizBrace" && !d.sub === f.isOver ? vy : null : null;
          };
          Ts({
            type: "supsub",
            htmlBuilder(d, u) {
              const f = pC(d, u);
              if (f)
                return f(d, u);
              const {
                base: b,
                sup: w,
                sub: T
              } = d, E = ce(b, u);
              let D, P;
              const Q = u.fontMetrics();
              let nt = 0, it = 0;
              const lt = b && k.isCharacterBox(b);
              if (w) {
                const he = u.havingStyle(u.style.sup());
                D = ce(w, he, u), lt || (nt = E.height - he.fontMetrics().supDrop * he.sizeMultiplier / u.sizeMultiplier);
              }
              if (T) {
                const he = u.havingStyle(u.style.sub());
                P = ce(T, he, u), lt || (it = E.depth + he.fontMetrics().subDrop * he.sizeMultiplier / u.sizeMultiplier);
              }
              let yt;
              u.style === et.DISPLAY ? yt = Q.sup1 : u.style.cramped ? yt = Q.sup3 : yt = Q.sup2;
              const kt = u.sizeMultiplier, Kt = bt(0.5 / Q.ptPerEm / kt);
              let ie = null;
              if (P) {
                const he = d.base && d.base.type === "op" && d.base.name && (d.base.name === "\\oiint" || d.base.name === "\\oiiint");
                (E instanceof Dr || he) && (ie = bt(-E.italic));
              }
              let ee;
              if (D && P) {
                nt = Math.max(nt, yt, D.depth + 0.25 * Q.xHeight), it = Math.max(it, Q.sub2);
                const he = 4 * Q.defaultRuleThickness;
                if (nt - D.depth - (P.height - it) < he) {
                  it = he - (nt - D.depth) + P.height;
                  const cr = 0.8 * Q.xHeight - (nt - D.depth);
                  cr > 0 && (nt += cr, it -= cr);
                }
                const $e = [{
                  type: "elem",
                  elem: P,
                  shift: it,
                  marginRight: Kt,
                  marginLeft: ie
                }, {
                  type: "elem",
                  elem: D,
                  shift: -nt,
                  marginRight: Kt
                }];
                ee = ot.makeVList({
                  positionType: "individualShift",
                  children: $e
                }, u);
              } else if (P) {
                it = Math.max(it, Q.sub1, P.height - 0.8 * Q.xHeight);
                const he = [{
                  type: "elem",
                  elem: P,
                  marginLeft: ie,
                  marginRight: Kt
                }];
                ee = ot.makeVList({
                  positionType: "shift",
                  positionData: it,
                  children: he
                }, u);
              } else if (D)
                nt = Math.max(nt, yt, D.depth + 0.25 * Q.xHeight), ee = ot.makeVList({
                  positionType: "shift",
                  positionData: -nt,
                  children: [{
                    type: "elem",
                    elem: D,
                    marginRight: Kt
                  }]
                }, u);
              else
                throw new Error("supsub must have either sup or sub.");
              const de = rd(E, "right") || "mord";
              return ot.makeSpan([de], [E, ot.makeSpan(["msupsub"], [ee])], u);
            },
            mathmlBuilder(d, u) {
              let f = false, b, w;
              d.base && d.base.type === "horizBrace" && (w = !!d.sup, w === d.base.isOver && (f = true, b = d.base.isOver)), d.base && (d.base.type === "op" || d.base.type === "operatorname") && (d.base.parentIsSupSub = true);
              const T = [_e(d.base, u)];
              d.sub && T.push(_e(d.sub, u)), d.sup && T.push(_e(d.sup, u));
              let E;
              if (f)
                E = b ? "mover" : "munder";
              else if (d.sub)
                if (d.sup) {
                  const D = d.base;
                  D && D.type === "op" && D.limits && u.style === et.DISPLAY || D && D.type === "operatorname" && D.alwaysHandleSupSub && (u.style === et.DISPLAY || D.limits) ? E = "munderover" : E = "msubsup";
                } else {
                  const D = d.base;
                  D && D.type === "op" && D.limits && (u.style === et.DISPLAY || D.alwaysHandleSupSub) || D && D.type === "operatorname" && D.alwaysHandleSupSub && (D.limits || u.style === et.DISPLAY) ? E = "munder" : E = "msub";
                }
              else {
                const D = d.base;
                D && D.type === "op" && D.limits && (u.style === et.DISPLAY || D.alwaysHandleSupSub) || D && D.type === "operatorname" && D.alwaysHandleSupSub && (D.limits || u.style === et.DISPLAY) ? E = "mover" : E = "msup";
              }
              return new ft.MathNode(E, T);
            }
          }), Ts({
            type: "atom",
            htmlBuilder(d, u) {
              return ot.mathsym(d.text, d.mode, u, ["m" + d.family]);
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mo", [ln(d.text, d.mode)]);
              if (d.family === "bin") {
                const b = sd(d, u);
                b === "bold-italic" && f.setAttribute("mathvariant", b);
              } else d.family === "punct" ? f.setAttribute("separator", "true") : (d.family === "open" || d.family === "close") && f.setAttribute("stretchy", "false");
              return f;
            }
          });
          const My = {
            mi: "italic",
            mn: "normal",
            mtext: "normal"
          };
          Ts({
            type: "mathord",
            htmlBuilder(d, u) {
              return ot.makeOrd(d, u, "mathord");
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mi", [ln(d.text, d.mode, u)]), b = sd(d, u) || "italic";
              return b !== My[f.type] && f.setAttribute("mathvariant", b), f;
            }
          }), Ts({
            type: "textord",
            htmlBuilder(d, u) {
              return ot.makeOrd(d, u, "textord");
            },
            mathmlBuilder(d, u) {
              const f = ln(d.text, d.mode, u), b = sd(d, u) || "normal";
              let w;
              return d.mode === "text" ? w = new ft.MathNode("mtext", [f]) : /[0-9]/.test(d.text) ? w = new ft.MathNode("mn", [f]) : d.text === "\\prime" ? w = new ft.MathNode("mo", [f]) : w = new ft.MathNode("mi", [f]), b !== My[w.type] && w.setAttribute("mathvariant", b), w;
            }
          });
          const Cd = {
            "\\nobreak": "nobreak",
            "\\allowbreak": "allowbreak"
          }, Sd = {
            " ": {},
            "\\ ": {},
            "~": {
              className: "nobreak"
            },
            "\\space": {},
            "\\nobreakspace": {
              className: "nobreak"
            }
          };
          Ts({
            type: "spacing",
            htmlBuilder(d, u) {
              if (Sd.hasOwnProperty(d.text)) {
                const f = Sd[d.text].className || "";
                if (d.mode === "text") {
                  const b = ot.makeOrd(d, u, "textord");
                  return b.classes.push(f), b;
                } else
                  return ot.makeSpan(["mspace", f], [ot.mathsym(d.text, d.mode, u)], u);
              } else {
                if (Cd.hasOwnProperty(d.text))
                  return ot.makeSpan(["mspace", Cd[d.text]], [], u);
                throw new s('Unknown type of space "' + d.text + '"');
              }
            },
            mathmlBuilder(d, u) {
              let f;
              if (Sd.hasOwnProperty(d.text))
                f = new ft.MathNode("mtext", [new ft.TextNode(" ")]);
              else {
                if (Cd.hasOwnProperty(d.text))
                  return new ft.MathNode("mspace");
                throw new s('Unknown type of space "' + d.text + '"');
              }
              return f;
            }
          });
          const By = () => {
            const d = new ft.MathNode("mtd", []);
            return d.setAttribute("width", "50%"), d;
          };
          Ts({
            type: "tag",
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mtable", [new ft.MathNode("mtr", [By(), new ft.MathNode("mtd", [ji(d.body, u)]), By(), new ft.MathNode("mtd", [ji(d.tag, u)])])]);
              return f.setAttribute("width", "100%"), f;
            }
          });
          const Ly = {
            "\\text": void 0,
            "\\textrm": "textrm",
            "\\textsf": "textsf",
            "\\texttt": "texttt",
            "\\textnormal": "textrm"
          }, Dy = {
            "\\textbf": "textbf",
            "\\textmd": "textmd"
          }, fC = {
            "\\textit": "textit",
            "\\textup": "textup"
          }, Fy = (d, u) => {
            const f = d.font;
            if (f) {
              if (Ly[f])
                return u.withTextFontFamily(Ly[f]);
              if (Dy[f])
                return u.withTextFontWeight(Dy[f]);
              if (f === "\\emph")
                return u.fontShape === "textit" ? u.withTextFontShape("textup") : u.withTextFontShape("textit");
            } else return u;
            return u.withTextFontShape(fC[f]);
          };
          Ct({
            type: "text",
            names: [
              // Font families
              "\\text",
              "\\textrm",
              "\\textsf",
              "\\texttt",
              "\\textnormal",
              // Font weights
              "\\textbf",
              "\\textmd",
              // Font Shapes
              "\\textit",
              "\\textup",
              "\\emph"
            ],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInArgument: true,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "text",
                mode: f.mode,
                body: Re(w),
                font: b
              };
            },
            htmlBuilder(d, u) {
              const f = Fy(d, u), b = Ge(d.body, f, true);
              return ot.makeSpan(["mord", "text"], b, f);
            },
            mathmlBuilder(d, u) {
              const f = Fy(d, u);
              return ji(d.body, f);
            }
          }), Ct({
            type: "underline",
            names: ["\\underline"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "underline",
                mode: f.mode,
                body: u[0]
              };
            },
            htmlBuilder(d, u) {
              const f = ce(d.body, u), b = ot.makeLineSpan("underline-line", u), w = u.fontMetrics().defaultRuleThickness, T = ot.makeVList({
                positionType: "top",
                positionData: f.height,
                children: [{
                  type: "kern",
                  size: w
                }, {
                  type: "elem",
                  elem: b
                }, {
                  type: "kern",
                  size: 3 * w
                }, {
                  type: "elem",
                  elem: f
                }]
              }, u);
              return ot.makeSpan(["mord", "underline"], [T], u);
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mo", [new ft.TextNode("‾")]);
              f.setAttribute("stretchy", "true");
              const b = new ft.MathNode("munder", [_e(d.body, u), f]);
              return b.setAttribute("accentunder", "true"), b;
            }
          }), Ct({
            type: "vcenter",
            names: ["\\vcenter"],
            props: {
              numArgs: 1,
              argTypes: ["original"],
              // In LaTeX, \vcenter can act only on a box.
              allowedInText: false
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "vcenter",
                mode: f.mode,
                body: u[0]
              };
            },
            htmlBuilder(d, u) {
              const f = ce(d.body, u), b = u.fontMetrics().axisHeight, w = 0.5 * (f.height - b - (f.depth + b));
              return ot.makeVList({
                positionType: "shift",
                positionData: w,
                children: [{
                  type: "elem",
                  elem: f
                }]
              }, u);
            },
            mathmlBuilder(d, u) {
              return new ft.MathNode("mpadded", [_e(d.body, u)], ["vcenter"]);
            }
          }), Ct({
            type: "verb",
            names: ["\\verb"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(d, u, f) {
              throw new s("\\verb ended by end of line instead of matching delimiter");
            },
            htmlBuilder(d, u) {
              const f = Ny(d), b = [], w = u.havingStyle(u.style.text());
              for (let T = 0; T < f.length; T++) {
                let E = f[T];
                E === "~" && (E = "\\textasciitilde"), b.push(ot.makeSymbol(E, "Typewriter-Regular", d.mode, w, ["mord", "texttt"]));
              }
              return ot.makeSpan(["mord", "text"].concat(w.sizingClasses(u)), ot.tryCombineChars(b), w);
            },
            mathmlBuilder(d, u) {
              const f = new ft.TextNode(Ny(d)), b = new ft.MathNode("mtext", [f]);
              return b.setAttribute("mathvariant", "monospace"), b;
            }
          });
          const Ny = (d) => d.body.replace(/ /g, d.star ? "␣" : " ");
          var Hi = Rg;
          const Iy = `[ \r
	]`, mC = "\\\\[a-zA-Z@]+", gC = "\\\\[^\uD800-\uDFFF]", yC = "(" + mC + ")" + Iy + "*", bC = `\\\\(
|[ \r	]+
?)[ \r	]*`, Td = "[̀-ͯ]", xC = new RegExp(Td + "+$"), wC = "(" + Iy + "+)|" + // whitespace
          (bC + "|") + // \whitespace
          "([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
          (Td + "*") + // ...plus accents
          "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
          (Td + "*") + // ...plus accents
          "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
          ("|" + yC) + // \macroName + spaces
          ("|" + gC + ")");
          class Oy {
            // Category codes. The lexer only supports comment characters (14) for now.
            // MacroExpander additionally distinguishes active (13).
            constructor(u, f) {
              this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = u, this.settings = f, this.tokenRegex = new RegExp(wC, "g"), this.catcodes = {
                "%": 14,
                // comment character
                "~": 13
                // active character
              };
            }
            setCatcode(u, f) {
              this.catcodes[u] = f;
            }
            /**
             * This function lexes a single token.
             */
            lex() {
              const u = this.input, f = this.tokenRegex.lastIndex;
              if (f === u.length)
                return new cn("EOF", new Yr(this, f, f));
              const b = this.tokenRegex.exec(u);
              if (b === null || b.index !== f)
                throw new s("Unexpected character: '" + u[f] + "'", new cn(u[f], new Yr(this, f, f + 1)));
              const w = b[6] || b[3] || (b[2] ? "\\ " : " ");
              if (this.catcodes[w] === 14) {
                const T = u.indexOf(`
`, this.tokenRegex.lastIndex);
                return T === -1 ? (this.tokenRegex.lastIndex = u.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = T + 1, this.lex();
              }
              return new cn(w, new Yr(this, f, this.tokenRegex.lastIndex));
            }
          }
          class kC {
            /**
             * Both arguments are optional.  The first argument is an object of
             * built-in mappings which never change.  The second argument is an object
             * of initial (global-level) mappings, which will constantly change
             * according to any global/top-level `set`s done.
             */
            constructor(u, f) {
              u === void 0 && (u = {}), f === void 0 && (f = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = f, this.builtins = u, this.undefStack = [];
            }
            /**
             * Start a new nested group, affecting future local `set`s.
             */
            beginGroup() {
              this.undefStack.push({});
            }
            /**
             * End current nested group, restoring values before the group began.
             */
            endGroup() {
              if (this.undefStack.length === 0)
                throw new s("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
              const u = this.undefStack.pop();
              for (const f in u)
                u.hasOwnProperty(f) && (u[f] == null ? delete this.current[f] : this.current[f] = u[f]);
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              for (; this.undefStack.length > 0; )
                this.endGroup();
            }
            /**
             * Detect whether `name` has a definition.  Equivalent to
             * `get(name) != null`.
             */
            has(u) {
              return this.current.hasOwnProperty(u) || this.builtins.hasOwnProperty(u);
            }
            /**
             * Get the current value of a name, or `undefined` if there is no value.
             *
             * Note: Do not use `if (namespace.get(...))` to detect whether a macro
             * is defined, as the definition may be the empty string which evaluates
             * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
             * `if (namespace.has(...))`.
             */
            get(u) {
              return this.current.hasOwnProperty(u) ? this.current[u] : this.builtins[u];
            }
            /**
             * Set the current value of a name, and optionally set it globally too.
             * Local set() sets the current value and (when appropriate) adds an undo
             * operation to the undo stack.  Global set() may change the undo
             * operation at every level, so takes time linear in their number.
             * A value of undefined means to delete existing definitions.
             */
            set(u, f, b) {
              if (b === void 0 && (b = false), b) {
                for (let w = 0; w < this.undefStack.length; w++)
                  delete this.undefStack[w][u];
                this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][u] = f);
              } else {
                const w = this.undefStack[this.undefStack.length - 1];
                w && !w.hasOwnProperty(u) && (w[u] = this.current[u]);
              }
              f == null ? delete this.current[u] : this.current[u] = f;
            }
          }
          var vC = dy;
          N("\\noexpand", function(d) {
            const u = d.popToken();
            return d.isExpandable(u.text) && (u.noexpand = true, u.treatAsRelax = true), {
              tokens: [u],
              numArgs: 0
            };
          }), N("\\expandafter", function(d) {
            const u = d.popToken();
            return d.expandOnce(true), {
              tokens: [u],
              numArgs: 0
            };
          }), N("\\@firstoftwo", function(d) {
            return {
              tokens: d.consumeArgs(2)[0],
              numArgs: 0
            };
          }), N("\\@secondoftwo", function(d) {
            return {
              tokens: d.consumeArgs(2)[1],
              numArgs: 0
            };
          }), N("\\@ifnextchar", function(d) {
            const u = d.consumeArgs(3);
            d.consumeSpaces();
            const f = d.future();
            return u[0].length === 1 && u[0][0].text === f.text ? {
              tokens: u[1],
              numArgs: 0
            } : {
              tokens: u[2],
              numArgs: 0
            };
          }), N("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"), N("\\TextOrMath", function(d) {
            const u = d.consumeArgs(2);
            return d.mode === "text" ? {
              tokens: u[0],
              numArgs: 0
            } : {
              tokens: u[1],
              numArgs: 0
            };
          });
          const zy = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            a: 10,
            A: 10,
            b: 11,
            B: 11,
            c: 12,
            C: 12,
            d: 13,
            D: 13,
            e: 14,
            E: 14,
            f: 15,
            F: 15
          };
          N("\\char", function(d) {
            let u = d.popToken(), f, b = "";
            if (u.text === "'")
              f = 8, u = d.popToken();
            else if (u.text === '"')
              f = 16, u = d.popToken();
            else if (u.text === "`")
              if (u = d.popToken(), u.text[0] === "\\")
                b = u.text.charCodeAt(1);
              else {
                if (u.text === "EOF")
                  throw new s("\\char` missing argument");
                b = u.text.charCodeAt(0);
              }
            else
              f = 10;
            if (f) {
              if (b = zy[u.text], b == null || b >= f)
                throw new s("Invalid base-" + f + " digit " + u.text);
              let w;
              for (; (w = zy[d.future().text]) != null && w < f; )
                b *= f, b += w, d.popToken();
            }
            return "\\@char{" + b + "}";
          });
          const Ad = (d, u, f, b) => {
            let w = d.consumeArg().tokens;
            if (w.length !== 1)
              throw new s("\\newcommand's first argument must be a macro name");
            const T = w[0].text, E = d.isDefined(T);
            if (E && !u)
              throw new s("\\newcommand{" + T + "} attempting to redefine " + (T + "; use \\renewcommand"));
            if (!E && !f)
              throw new s("\\renewcommand{" + T + "} when command " + T + " does not yet exist; use \\newcommand");
            let D = 0;
            if (w = d.consumeArg().tokens, w.length === 1 && w[0].text === "[") {
              let P = "", Q = d.expandNextToken();
              for (; Q.text !== "]" && Q.text !== "EOF"; )
                P += Q.text, Q = d.expandNextToken();
              if (!P.match(/^\s*[0-9]+\s*$/))
                throw new s("Invalid number of arguments: " + P);
              D = parseInt(P), w = d.consumeArg().tokens;
            }
            return E && b || d.macros.set(T, {
              tokens: w,
              numArgs: D
            }), "";
          };
          N("\\newcommand", (d) => Ad(d, false, true, false)), N("\\renewcommand", (d) => Ad(d, true, false, false)), N("\\providecommand", (d) => Ad(d, true, true, true)), N("\\message", (d) => {
            const u = d.consumeArgs(1)[0];
            return console.log(u.reverse().map((f) => f.text).join("")), "";
          }), N("\\errmessage", (d) => {
            const u = d.consumeArgs(1)[0];
            return console.error(u.reverse().map((f) => f.text).join("")), "";
          }), N("\\show", (d) => {
            const u = d.popToken(), f = u.text;
            return console.log(u, d.macros.get(f), Hi[f], fe.math[f], fe.text[f]), "";
          }), N("\\bgroup", "{"), N("\\egroup", "}"), N("~", "\\nobreakspace"), N("\\lq", "`"), N("\\rq", "'"), N("\\aa", "\\r a"), N("\\AA", "\\r A"), N("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}"), N("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}"), N("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}"), N("ℬ", "\\mathscr{B}"), N("ℰ", "\\mathscr{E}"), N("ℱ", "\\mathscr{F}"), N("ℋ", "\\mathscr{H}"), N("ℐ", "\\mathscr{I}"), N("ℒ", "\\mathscr{L}"), N("ℳ", "\\mathscr{M}"), N("ℛ", "\\mathscr{R}"), N("ℭ", "\\mathfrak{C}"), N("ℌ", "\\mathfrak{H}"), N("ℨ", "\\mathfrak{Z}"), N("\\Bbbk", "\\Bbb{k}"), N("·", "\\cdotp"), N("\\llap", "\\mathllap{\\textrm{#1}}"), N("\\rlap", "\\mathrlap{\\textrm{#1}}"), N("\\clap", "\\mathclap{\\textrm{#1}}"), N("\\mathstrut", "\\vphantom{(}"), N("\\underbar", "\\underline{\\text{#1}}"), N("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'), N("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}"), N("\\ne", "\\neq"), N("≠", "\\neq"), N("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}"), N("∉", "\\notin"), N("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}"), N("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}"), N("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}"), N("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}"), N("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}"), N("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}"), N("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}"), N("⟂", "\\perp"), N("‼", "\\mathclose{!\\mkern-0.8mu!}"), N("∌", "\\notni"), N("⌜", "\\ulcorner"), N("⌝", "\\urcorner"), N("⌞", "\\llcorner"), N("⌟", "\\lrcorner"), N("©", "\\copyright"), N("®", "\\textregistered"), N("️", "\\textregistered"), N("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}'), N("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}'), N("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}'), N("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}'), N("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}"), N("⋮", "\\vdots"), N("\\varGamma", "\\mathit{\\Gamma}"), N("\\varDelta", "\\mathit{\\Delta}"), N("\\varTheta", "\\mathit{\\Theta}"), N("\\varLambda", "\\mathit{\\Lambda}"), N("\\varXi", "\\mathit{\\Xi}"), N("\\varPi", "\\mathit{\\Pi}"), N("\\varSigma", "\\mathit{\\Sigma}"), N("\\varUpsilon", "\\mathit{\\Upsilon}"), N("\\varPhi", "\\mathit{\\Phi}"), N("\\varPsi", "\\mathit{\\Psi}"), N("\\varOmega", "\\mathit{\\Omega}"), N("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"), N("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"), N("\\boxed", "\\fbox{$\\displaystyle{#1}$}"), N("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;"), N("\\implies", "\\DOTSB\\;\\Longrightarrow\\;"), N("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"), N("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}"), N("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
          const qy = {
            ",": "\\dotsc",
            "\\not": "\\dotsb",
            // \keybin@ checks for the following:
            "+": "\\dotsb",
            "=": "\\dotsb",
            "<": "\\dotsb",
            ">": "\\dotsb",
            "-": "\\dotsb",
            "*": "\\dotsb",
            ":": "\\dotsb",
            // Symbols whose definition starts with \DOTSB:
            "\\DOTSB": "\\dotsb",
            "\\coprod": "\\dotsb",
            "\\bigvee": "\\dotsb",
            "\\bigwedge": "\\dotsb",
            "\\biguplus": "\\dotsb",
            "\\bigcap": "\\dotsb",
            "\\bigcup": "\\dotsb",
            "\\prod": "\\dotsb",
            "\\sum": "\\dotsb",
            "\\bigotimes": "\\dotsb",
            "\\bigoplus": "\\dotsb",
            "\\bigodot": "\\dotsb",
            "\\bigsqcup": "\\dotsb",
            "\\And": "\\dotsb",
            "\\longrightarrow": "\\dotsb",
            "\\Longrightarrow": "\\dotsb",
            "\\longleftarrow": "\\dotsb",
            "\\Longleftarrow": "\\dotsb",
            "\\longleftrightarrow": "\\dotsb",
            "\\Longleftrightarrow": "\\dotsb",
            "\\mapsto": "\\dotsb",
            "\\longmapsto": "\\dotsb",
            "\\hookrightarrow": "\\dotsb",
            "\\doteq": "\\dotsb",
            // Symbols whose definition starts with \mathbin:
            "\\mathbin": "\\dotsb",
            // Symbols whose definition starts with \mathrel:
            "\\mathrel": "\\dotsb",
            "\\relbar": "\\dotsb",
            "\\Relbar": "\\dotsb",
            "\\xrightarrow": "\\dotsb",
            "\\xleftarrow": "\\dotsb",
            // Symbols whose definition starts with \DOTSI:
            "\\DOTSI": "\\dotsi",
            "\\int": "\\dotsi",
            "\\oint": "\\dotsi",
            "\\iint": "\\dotsi",
            "\\iiint": "\\dotsi",
            "\\iiiint": "\\dotsi",
            "\\idotsint": "\\dotsi",
            // Symbols whose definition starts with \DOTSX:
            "\\DOTSX": "\\dotsx"
          };
          N("\\dots", function(d) {
            let u = "\\dotso";
            const f = d.expandAfterFuture().text;
            return f in qy ? u = qy[f] : (f.slice(0, 4) === "\\not" || f in fe.math && k.contains(["bin", "rel"], fe.math[f].group)) && (u = "\\dotsb"), u;
          });
          const $d = {
            // \rightdelim@ checks for the following:
            ")": true,
            "]": true,
            "\\rbrack": true,
            "\\}": true,
            "\\rbrace": true,
            "\\rangle": true,
            "\\rceil": true,
            "\\rfloor": true,
            "\\rgroup": true,
            "\\rmoustache": true,
            "\\right": true,
            "\\bigr": true,
            "\\biggr": true,
            "\\Bigr": true,
            "\\Biggr": true,
            // \extra@ also tests for the following:
            $: true,
            // \extrap@ checks for the following:
            ";": true,
            ".": true,
            ",": true
          };
          N("\\dotso", function(d) {
            return d.future().text in $d ? "\\ldots\\," : "\\ldots";
          }), N("\\dotsc", function(d) {
            const u = d.future().text;
            return u in $d && u !== "," ? "\\ldots\\," : "\\ldots";
          }), N("\\cdots", function(d) {
            return d.future().text in $d ? "\\@cdots\\," : "\\@cdots";
          }), N("\\dotsb", "\\cdots"), N("\\dotsm", "\\cdots"), N("\\dotsi", "\\!\\cdots"), N("\\dotsx", "\\ldots\\,"), N("\\DOTSI", "\\relax"), N("\\DOTSB", "\\relax"), N("\\DOTSX", "\\relax"), N("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"), N("\\,", "\\tmspace+{3mu}{.1667em}"), N("\\thinspace", "\\,"), N("\\>", "\\mskip{4mu}"), N("\\:", "\\tmspace+{4mu}{.2222em}"), N("\\medspace", "\\:"), N("\\;", "\\tmspace+{5mu}{.2777em}"), N("\\thickspace", "\\;"), N("\\!", "\\tmspace-{3mu}{.1667em}"), N("\\negthinspace", "\\!"), N("\\negmedspace", "\\tmspace-{4mu}{.2222em}"), N("\\negthickspace", "\\tmspace-{5mu}{.277em}"), N("\\enspace", "\\kern.5em "), N("\\enskip", "\\hskip.5em\\relax"), N("\\quad", "\\hskip1em\\relax"), N("\\qquad", "\\hskip2em\\relax"), N("\\tag", "\\@ifstar\\tag@literal\\tag@paren"), N("\\tag@paren", "\\tag@literal{({#1})}"), N("\\tag@literal", (d) => {
            if (d.macros.get("\\df@tag"))
              throw new s("Multiple \\tag");
            return "\\gdef\\df@tag{\\text{#1}}";
          }), N("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"), N("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"), N("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}"), N("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"), N("\\newline", "\\\\\\relax"), N("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
          const Ry = bt(wr["Main-Regular"][84][1] - 0.7 * wr["Main-Regular"][65][1]);
          N("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + Ry + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"), N("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + Ry + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"), N("\\hspace", "\\@ifstar\\@hspacer\\@hspace"), N("\\@hspace", "\\hskip #1\\relax"), N("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"), N("\\ordinarycolon", ":"), N("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"), N("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}'), N("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}'), N("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}'), N("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}'), N("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}'), N("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}'), N("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}'), N("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}'), N("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}'), N("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}'), N("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}'), N("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}'), N("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}'), N("∷", "\\dblcolon"), N("∹", "\\eqcolon"), N("≔", "\\coloneqq"), N("≕", "\\eqqcolon"), N("⩴", "\\Coloneqq"), N("\\ratio", "\\vcentcolon"), N("\\coloncolon", "\\dblcolon"), N("\\colonequals", "\\coloneqq"), N("\\coloncolonequals", "\\Coloneqq"), N("\\equalscolon", "\\eqqcolon"), N("\\equalscoloncolon", "\\Eqqcolon"), N("\\colonminus", "\\coloneq"), N("\\coloncolonminus", "\\Coloneq"), N("\\minuscolon", "\\eqcolon"), N("\\minuscoloncolon", "\\Eqcolon"), N("\\coloncolonapprox", "\\Colonapprox"), N("\\coloncolonsim", "\\Colonsim"), N("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), N("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}"), N("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), N("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"), N("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}"), N("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}"), N("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"), N("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}"), N("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}"), N("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}"), N("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}"), N("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}"), N("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"), N("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}"), N("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}"), N("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}"), N("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}"), N("\\nleqq", "\\html@mathml{\\@nleqq}{≰}"), N("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}"), N("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}"), N("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}"), N("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}"), N("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}"), N("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}"), N("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}"), N("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}"), N("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}"), N("\\imath", "\\html@mathml{\\@imath}{ı}"), N("\\jmath", "\\html@mathml{\\@jmath}{ȷ}"), N("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}"), N("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}"), N("⟦", "\\llbracket"), N("⟧", "\\rrbracket"), N("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}"), N("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}"), N("⦃", "\\lBrace"), N("⦄", "\\rBrace"), N("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}"), N("⦵", "\\minuso"), N("\\darr", "\\downarrow"), N("\\dArr", "\\Downarrow"), N("\\Darr", "\\Downarrow"), N("\\lang", "\\langle"), N("\\rang", "\\rangle"), N("\\uarr", "\\uparrow"), N("\\uArr", "\\Uparrow"), N("\\Uarr", "\\Uparrow"), N("\\N", "\\mathbb{N}"), N("\\R", "\\mathbb{R}"), N("\\Z", "\\mathbb{Z}"), N("\\alef", "\\aleph"), N("\\alefsym", "\\aleph"), N("\\Alpha", "\\mathrm{A}"), N("\\Beta", "\\mathrm{B}"), N("\\bull", "\\bullet"), N("\\Chi", "\\mathrm{X}"), N("\\clubs", "\\clubsuit"), N("\\cnums", "\\mathbb{C}"), N("\\Complex", "\\mathbb{C}"), N("\\Dagger", "\\ddagger"), N("\\diamonds", "\\diamondsuit"), N("\\empty", "\\emptyset"), N("\\Epsilon", "\\mathrm{E}"), N("\\Eta", "\\mathrm{H}"), N("\\exist", "\\exists"), N("\\harr", "\\leftrightarrow"), N("\\hArr", "\\Leftrightarrow"), N("\\Harr", "\\Leftrightarrow"), N("\\hearts", "\\heartsuit"), N("\\image", "\\Im"), N("\\infin", "\\infty"), N("\\Iota", "\\mathrm{I}"), N("\\isin", "\\in"), N("\\Kappa", "\\mathrm{K}"), N("\\larr", "\\leftarrow"), N("\\lArr", "\\Leftarrow"), N("\\Larr", "\\Leftarrow"), N("\\lrarr", "\\leftrightarrow"), N("\\lrArr", "\\Leftrightarrow"), N("\\Lrarr", "\\Leftrightarrow"), N("\\Mu", "\\mathrm{M}"), N("\\natnums", "\\mathbb{N}"), N("\\Nu", "\\mathrm{N}"), N("\\Omicron", "\\mathrm{O}"), N("\\plusmn", "\\pm"), N("\\rarr", "\\rightarrow"), N("\\rArr", "\\Rightarrow"), N("\\Rarr", "\\Rightarrow"), N("\\real", "\\Re"), N("\\reals", "\\mathbb{R}"), N("\\Reals", "\\mathbb{R}"), N("\\Rho", "\\mathrm{P}"), N("\\sdot", "\\cdot"), N("\\sect", "\\S"), N("\\spades", "\\spadesuit"), N("\\sub", "\\subset"), N("\\sube", "\\subseteq"), N("\\supe", "\\supseteq"), N("\\Tau", "\\mathrm{T}"), N("\\thetasym", "\\vartheta"), N("\\weierp", "\\wp"), N("\\Zeta", "\\mathrm{Z}"), N("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}"), N("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}"), N("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"), N("\\bra", "\\mathinner{\\langle{#1}|}"), N("\\ket", "\\mathinner{|{#1}\\rangle}"), N("\\braket", "\\mathinner{\\langle{#1}\\rangle}"), N("\\Bra", "\\left\\langle#1\\right|"), N("\\Ket", "\\left|#1\\right\\rangle");
          const Py = (d) => (u) => {
            const f = u.consumeArg().tokens, b = u.consumeArg().tokens, w = u.consumeArg().tokens, T = u.consumeArg().tokens, E = u.macros.get("|"), D = u.macros.get("\\|");
            u.macros.beginGroup();
            const P = (it) => (lt) => {
              d && (lt.macros.set("|", E), w.length && lt.macros.set("\\|", D));
              let yt = it;
              return !it && w.length && lt.future().text === "|" && (lt.popToken(), yt = true), {
                tokens: yt ? w : b,
                numArgs: 0
              };
            };
            u.macros.set("|", P(false)), w.length && u.macros.set("\\|", P(true));
            const Q = u.consumeArg().tokens, nt = u.expandTokens([
              ...T,
              ...Q,
              ...f
              // reversed
            ]);
            return u.macros.endGroup(), {
              tokens: nt.reverse(),
              numArgs: 0
            };
          };
          N("\\bra@ket", Py(false)), N("\\bra@set", Py(true)), N("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}"), N("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}"), N("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"), N("\\angln", "{\\angl n}"), N("\\blue", "\\textcolor{##6495ed}{#1}"), N("\\orange", "\\textcolor{##ffa500}{#1}"), N("\\pink", "\\textcolor{##ff00af}{#1}"), N("\\red", "\\textcolor{##df0030}{#1}"), N("\\green", "\\textcolor{##28ae7b}{#1}"), N("\\gray", "\\textcolor{gray}{#1}"), N("\\purple", "\\textcolor{##9d38bd}{#1}"), N("\\blueA", "\\textcolor{##ccfaff}{#1}"), N("\\blueB", "\\textcolor{##80f6ff}{#1}"), N("\\blueC", "\\textcolor{##63d9ea}{#1}"), N("\\blueD", "\\textcolor{##11accd}{#1}"), N("\\blueE", "\\textcolor{##0c7f99}{#1}"), N("\\tealA", "\\textcolor{##94fff5}{#1}"), N("\\tealB", "\\textcolor{##26edd5}{#1}"), N("\\tealC", "\\textcolor{##01d1c1}{#1}"), N("\\tealD", "\\textcolor{##01a995}{#1}"), N("\\tealE", "\\textcolor{##208170}{#1}"), N("\\greenA", "\\textcolor{##b6ffb0}{#1}"), N("\\greenB", "\\textcolor{##8af281}{#1}"), N("\\greenC", "\\textcolor{##74cf70}{#1}"), N("\\greenD", "\\textcolor{##1fab54}{#1}"), N("\\greenE", "\\textcolor{##0d923f}{#1}"), N("\\goldA", "\\textcolor{##ffd0a9}{#1}"), N("\\goldB", "\\textcolor{##ffbb71}{#1}"), N("\\goldC", "\\textcolor{##ff9c39}{#1}"), N("\\goldD", "\\textcolor{##e07d10}{#1}"), N("\\goldE", "\\textcolor{##a75a05}{#1}"), N("\\redA", "\\textcolor{##fca9a9}{#1}"), N("\\redB", "\\textcolor{##ff8482}{#1}"), N("\\redC", "\\textcolor{##f9685d}{#1}"), N("\\redD", "\\textcolor{##e84d39}{#1}"), N("\\redE", "\\textcolor{##bc2612}{#1}"), N("\\maroonA", "\\textcolor{##ffbde0}{#1}"), N("\\maroonB", "\\textcolor{##ff92c6}{#1}"), N("\\maroonC", "\\textcolor{##ed5fa6}{#1}"), N("\\maroonD", "\\textcolor{##ca337c}{#1}"), N("\\maroonE", "\\textcolor{##9e034e}{#1}"), N("\\purpleA", "\\textcolor{##ddd7ff}{#1}"), N("\\purpleB", "\\textcolor{##c6b9fc}{#1}"), N("\\purpleC", "\\textcolor{##aa87ff}{#1}"), N("\\purpleD", "\\textcolor{##7854ab}{#1}"), N("\\purpleE", "\\textcolor{##543b78}{#1}"), N("\\mintA", "\\textcolor{##f5f9e8}{#1}"), N("\\mintB", "\\textcolor{##edf2df}{#1}"), N("\\mintC", "\\textcolor{##e0e5cc}{#1}"), N("\\grayA", "\\textcolor{##f6f7f7}{#1}"), N("\\grayB", "\\textcolor{##f0f1f2}{#1}"), N("\\grayC", "\\textcolor{##e3e5e6}{#1}"), N("\\grayD", "\\textcolor{##d6d8da}{#1}"), N("\\grayE", "\\textcolor{##babec2}{#1}"), N("\\grayF", "\\textcolor{##888d93}{#1}"), N("\\grayG", "\\textcolor{##626569}{#1}"), N("\\grayH", "\\textcolor{##3b3e40}{#1}"), N("\\grayI", "\\textcolor{##21242c}{#1}"), N("\\kaBlue", "\\textcolor{##314453}{#1}"), N("\\kaGreen", "\\textcolor{##71B307}{#1}");
          const jy = {
            "^": true,
            // Parser.js
            _: true,
            // Parser.js
            "\\limits": true,
            // Parser.js
            "\\nolimits": true
            // Parser.js
          };
          class _C {
            constructor(u, f, b) {
              this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = f, this.expansionCount = 0, this.feed(u), this.macros = new kC(vC, f.macros), this.mode = b, this.stack = [];
            }
            /**
             * Feed a new input string to the same MacroExpander
             * (with existing macros etc.).
             */
            feed(u) {
              this.lexer = new Oy(u, this.settings);
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(u) {
              this.mode = u;
            }
            /**
             * Start a new group nesting within all namespaces.
             */
            beginGroup() {
              this.macros.beginGroup();
            }
            /**
             * End current group nesting within all namespaces.
             */
            endGroup() {
              this.macros.endGroup();
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              this.macros.endGroups();
            }
            /**
             * Returns the topmost token on the stack, without expanding it.
             * Similar in behavior to TeX's `\futurelet`.
             */
            future() {
              return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
            }
            /**
             * Remove and return the next unexpanded token.
             */
            popToken() {
              return this.future(), this.stack.pop();
            }
            /**
             * Add a given token to the token stack.  In particular, this get be used
             * to put back a token returned from one of the other methods.
             */
            pushToken(u) {
              this.stack.push(u);
            }
            /**
             * Append an array of tokens to the token stack.
             */
            pushTokens(u) {
              this.stack.push(...u);
            }
            /**
             * Find an macro argument without expanding tokens and append the array of
             * tokens to the token stack. Uses Token as a container for the result.
             */
            scanArgument(u) {
              let f, b, w;
              if (u) {
                if (this.consumeSpaces(), this.future().text !== "[")
                  return null;
                f = this.popToken(), {
                  tokens: w,
                  end: b
                } = this.consumeArg(["]"]);
              } else
                ({
                  tokens: w,
                  start: f,
                  end: b
                } = this.consumeArg());
              return this.pushToken(new cn("EOF", b.loc)), this.pushTokens(w), f.range(b, "");
            }
            /**
             * Consume all following space tokens, without expansion.
             */
            consumeSpaces() {
              for (; this.future().text === " "; )
                this.stack.pop();
            }
            /**
             * Consume an argument from the token stream, and return the resulting array
             * of tokens and start/end token.
             */
            consumeArg(u) {
              const f = [], b = u && u.length > 0;
              b || this.consumeSpaces();
              const w = this.future();
              let T, E = 0, D = 0;
              do {
                if (T = this.popToken(), f.push(T), T.text === "{")
                  ++E;
                else if (T.text === "}") {
                  if (--E, E === -1)
                    throw new s("Extra }", T);
                } else if (T.text === "EOF")
                  throw new s("Unexpected end of input in a macro argument, expected '" + (u && b ? u[D] : "}") + "'", T);
                if (u && b)
                  if ((E === 0 || E === 1 && u[D] === "{") && T.text === u[D]) {
                    if (++D, D === u.length) {
                      f.splice(-D, D);
                      break;
                    }
                  } else
                    D = 0;
              } while (E !== 0 || b);
              return w.text === "{" && f[f.length - 1].text === "}" && (f.pop(), f.shift()), f.reverse(), {
                tokens: f,
                start: w,
                end: T
              };
            }
            /**
             * Consume the specified number of (delimited) arguments from the token
             * stream and return the resulting array of arguments.
             */
            consumeArgs(u, f) {
              if (f) {
                if (f.length !== u + 1)
                  throw new s("The length of delimiters doesn't match the number of args!");
                const w = f[0];
                for (let T = 0; T < w.length; T++) {
                  const E = this.popToken();
                  if (w[T] !== E.text)
                    throw new s("Use of the macro doesn't match its definition", E);
                }
              }
              const b = [];
              for (let w = 0; w < u; w++)
                b.push(this.consumeArg(f && f[w + 1]).tokens);
              return b;
            }
            /**
             * Increment `expansionCount` by the specified amount.
             * Throw an error if it exceeds `maxExpand`.
             */
            countExpansion(u) {
              if (this.expansionCount += u, this.expansionCount > this.settings.maxExpand)
                throw new s("Too many expansions: infinite loop or need to increase maxExpand setting");
            }
            /**
             * Expand the next token only once if possible.
             *
             * If the token is expanded, the resulting tokens will be pushed onto
             * the stack in reverse order, and the number of such tokens will be
             * returned.  This number might be zero or positive.
             *
             * If not, the return value is `false`, and the next token remains at the
             * top of the stack.
             *
             * In either case, the next token will be on the top of the stack,
             * or the stack will be empty (in case of empty expansion
             * and no other tokens).
             *
             * Used to implement `expandAfterFuture` and `expandNextToken`.
             *
             * If expandableOnly, only expandable tokens are expanded and
             * an undefined control sequence results in an error.
             */
            expandOnce(u) {
              const f = this.popToken(), b = f.text, w = f.noexpand ? null : this._getExpansion(b);
              if (w == null || u && w.unexpandable) {
                if (u && w == null && b[0] === "\\" && !this.isDefined(b))
                  throw new s("Undefined control sequence: " + b);
                return this.pushToken(f), false;
              }
              this.countExpansion(1);
              let T = w.tokens;
              const E = this.consumeArgs(w.numArgs, w.delimiters);
              if (w.numArgs) {
                T = T.slice();
                for (let D = T.length - 1; D >= 0; --D) {
                  let P = T[D];
                  if (P.text === "#") {
                    if (D === 0)
                      throw new s("Incomplete placeholder at end of macro body", P);
                    if (P = T[--D], P.text === "#")
                      T.splice(D + 1, 1);
                    else if (/^[1-9]$/.test(P.text))
                      T.splice(D, 2, ...E[+P.text - 1]);
                    else
                      throw new s("Not a valid argument number", P);
                  }
                }
              }
              return this.pushTokens(T), T.length;
            }
            /**
             * Expand the next token only once (if possible), and return the resulting
             * top token on the stack (without removing anything from the stack).
             * Similar in behavior to TeX's `\expandafter\futurelet`.
             * Equivalent to expandOnce() followed by future().
             */
            expandAfterFuture() {
              return this.expandOnce(), this.future();
            }
            /**
             * Recursively expand first token, then return first non-expandable token.
             */
            expandNextToken() {
              for (; ; )
                if (this.expandOnce() === false) {
                  const u = this.stack.pop();
                  return u.treatAsRelax && (u.text = "\\relax"), u;
                }
              throw new Error();
            }
            /**
             * Fully expand the given macro name and return the resulting list of
             * tokens, or return `undefined` if no such macro is defined.
             */
            expandMacro(u) {
              return this.macros.has(u) ? this.expandTokens([new cn(u)]) : void 0;
            }
            /**
             * Fully expand the given token stream and return the resulting list of
             * tokens.  Note that the input tokens are in reverse order, but the
             * output tokens are in forward order.
             */
            expandTokens(u) {
              const f = [], b = this.stack.length;
              for (this.pushTokens(u); this.stack.length > b; )
                if (this.expandOnce(true) === false) {
                  const w = this.stack.pop();
                  w.treatAsRelax && (w.noexpand = false, w.treatAsRelax = false), f.push(w);
                }
              return this.countExpansion(f.length), f;
            }
            /**
             * Fully expand the given macro name and return the result as a string,
             * or return `undefined` if no such macro is defined.
             */
            expandMacroAsText(u) {
              const f = this.expandMacro(u);
              return f && f.map((b) => b.text).join("");
            }
            /**
             * Returns the expanded macro as a reversed array of tokens and a macro
             * argument count.  Or returns `null` if no such macro.
             */
            _getExpansion(u) {
              const f = this.macros.get(u);
              if (f == null)
                return f;
              if (u.length === 1) {
                const w = this.lexer.catcodes[u];
                if (w != null && w !== 13)
                  return;
              }
              const b = typeof f == "function" ? f(this) : f;
              if (typeof b == "string") {
                let w = 0;
                if (b.indexOf("#") !== -1) {
                  const P = b.replace(/##/g, "");
                  for (; P.indexOf("#" + (w + 1)) !== -1; )
                    ++w;
                }
                const T = new Oy(b, this.settings), E = [];
                let D = T.lex();
                for (; D.text !== "EOF"; )
                  E.push(D), D = T.lex();
                return E.reverse(), {
                  tokens: E,
                  numArgs: w
                };
              }
              return b;
            }
            /**
             * Determine whether a command is currently "defined" (has some
             * functionality), meaning that it's a macro (in the current group),
             * a function, a symbol, or one of the special commands listed in
             * `implicitCommands`.
             */
            isDefined(u) {
              return this.macros.has(u) || Hi.hasOwnProperty(u) || fe.math.hasOwnProperty(u) || fe.text.hasOwnProperty(u) || jy.hasOwnProperty(u);
            }
            /**
             * Determine whether a command is expandable.
             */
            isExpandable(u) {
              const f = this.macros.get(u);
              return f != null ? typeof f == "string" || typeof f == "function" || !f.unexpandable : Hi.hasOwnProperty(u) && !Hi[u].primitive;
            }
          }
          const Wy = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, Pc = Object.freeze({
            "₊": "+",
            "₋": "-",
            "₌": "=",
            "₍": "(",
            "₎": ")",
            "₀": "0",
            "₁": "1",
            "₂": "2",
            "₃": "3",
            "₄": "4",
            "₅": "5",
            "₆": "6",
            "₇": "7",
            "₈": "8",
            "₉": "9",
            "ₐ": "a",
            "ₑ": "e",
            "ₕ": "h",
            "ᵢ": "i",
            "ⱼ": "j",
            "ₖ": "k",
            "ₗ": "l",
            "ₘ": "m",
            "ₙ": "n",
            "ₒ": "o",
            "ₚ": "p",
            "ᵣ": "r",
            "ₛ": "s",
            "ₜ": "t",
            "ᵤ": "u",
            "ᵥ": "v",
            "ₓ": "x",
            "ᵦ": "β",
            "ᵧ": "γ",
            "ᵨ": "ρ",
            "ᵩ": "ϕ",
            "ᵪ": "χ",
            "⁺": "+",
            "⁻": "-",
            "⁼": "=",
            "⁽": "(",
            "⁾": ")",
            "⁰": "0",
            "¹": "1",
            "²": "2",
            "³": "3",
            "⁴": "4",
            "⁵": "5",
            "⁶": "6",
            "⁷": "7",
            "⁸": "8",
            "⁹": "9",
            "ᴬ": "A",
            "ᴮ": "B",
            "ᴰ": "D",
            "ᴱ": "E",
            "ᴳ": "G",
            "ᴴ": "H",
            "ᴵ": "I",
            "ᴶ": "J",
            "ᴷ": "K",
            "ᴸ": "L",
            "ᴹ": "M",
            "ᴺ": "N",
            "ᴼ": "O",
            "ᴾ": "P",
            "ᴿ": "R",
            "ᵀ": "T",
            "ᵁ": "U",
            "ⱽ": "V",
            "ᵂ": "W",
            "ᵃ": "a",
            "ᵇ": "b",
            "ᶜ": "c",
            "ᵈ": "d",
            "ᵉ": "e",
            "ᶠ": "f",
            "ᵍ": "g",
            ʰ: "h",
            "ⁱ": "i",
            ʲ: "j",
            "ᵏ": "k",
            ˡ: "l",
            "ᵐ": "m",
            ⁿ: "n",
            "ᵒ": "o",
            "ᵖ": "p",
            ʳ: "r",
            ˢ: "s",
            "ᵗ": "t",
            "ᵘ": "u",
            "ᵛ": "v",
            ʷ: "w",
            ˣ: "x",
            ʸ: "y",
            "ᶻ": "z",
            "ᵝ": "β",
            "ᵞ": "γ",
            "ᵟ": "δ",
            "ᵠ": "ϕ",
            "ᵡ": "χ",
            "ᶿ": "θ"
          }), Ed = {
            "́": {
              text: "\\'",
              math: "\\acute"
            },
            "̀": {
              text: "\\`",
              math: "\\grave"
            },
            "̈": {
              text: '\\"',
              math: "\\ddot"
            },
            "̃": {
              text: "\\~",
              math: "\\tilde"
            },
            "̄": {
              text: "\\=",
              math: "\\bar"
            },
            "̆": {
              text: "\\u",
              math: "\\breve"
            },
            "̌": {
              text: "\\v",
              math: "\\check"
            },
            "̂": {
              text: "\\^",
              math: "\\hat"
            },
            "̇": {
              text: "\\.",
              math: "\\dot"
            },
            "̊": {
              text: "\\r",
              math: "\\mathring"
            },
            "̋": {
              text: "\\H"
            },
            "̧": {
              text: "\\c"
            }
          }, Hy = {
            á: "á",
            à: "à",
            ä: "ä",
            ǟ: "ǟ",
            ã: "ã",
            ā: "ā",
            ă: "ă",
            ắ: "ắ",
            ằ: "ằ",
            ẵ: "ẵ",
            ǎ: "ǎ",
            â: "â",
            ấ: "ấ",
            ầ: "ầ",
            ẫ: "ẫ",
            ȧ: "ȧ",
            ǡ: "ǡ",
            å: "å",
            ǻ: "ǻ",
            ḃ: "ḃ",
            ć: "ć",
            ḉ: "ḉ",
            č: "č",
            ĉ: "ĉ",
            ċ: "ċ",
            ç: "ç",
            ď: "ď",
            ḋ: "ḋ",
            ḑ: "ḑ",
            é: "é",
            è: "è",
            ë: "ë",
            ẽ: "ẽ",
            ē: "ē",
            ḗ: "ḗ",
            ḕ: "ḕ",
            ĕ: "ĕ",
            ḝ: "ḝ",
            ě: "ě",
            ê: "ê",
            ế: "ế",
            ề: "ề",
            ễ: "ễ",
            ė: "ė",
            ȩ: "ȩ",
            ḟ: "ḟ",
            ǵ: "ǵ",
            ḡ: "ḡ",
            ğ: "ğ",
            ǧ: "ǧ",
            ĝ: "ĝ",
            ġ: "ġ",
            ģ: "ģ",
            ḧ: "ḧ",
            ȟ: "ȟ",
            ĥ: "ĥ",
            ḣ: "ḣ",
            ḩ: "ḩ",
            í: "í",
            ì: "ì",
            ï: "ï",
            ḯ: "ḯ",
            ĩ: "ĩ",
            ī: "ī",
            ĭ: "ĭ",
            ǐ: "ǐ",
            î: "î",
            ǰ: "ǰ",
            ĵ: "ĵ",
            ḱ: "ḱ",
            ǩ: "ǩ",
            ķ: "ķ",
            ĺ: "ĺ",
            ľ: "ľ",
            ļ: "ļ",
            ḿ: "ḿ",
            ṁ: "ṁ",
            ń: "ń",
            ǹ: "ǹ",
            ñ: "ñ",
            ň: "ň",
            ṅ: "ṅ",
            ņ: "ņ",
            ó: "ó",
            ò: "ò",
            ö: "ö",
            ȫ: "ȫ",
            õ: "õ",
            ṍ: "ṍ",
            ṏ: "ṏ",
            ȭ: "ȭ",
            ō: "ō",
            ṓ: "ṓ",
            ṑ: "ṑ",
            ŏ: "ŏ",
            ǒ: "ǒ",
            ô: "ô",
            ố: "ố",
            ồ: "ồ",
            ỗ: "ỗ",
            ȯ: "ȯ",
            ȱ: "ȱ",
            ő: "ő",
            ṕ: "ṕ",
            ṗ: "ṗ",
            ŕ: "ŕ",
            ř: "ř",
            ṙ: "ṙ",
            ŗ: "ŗ",
            ś: "ś",
            ṥ: "ṥ",
            š: "š",
            ṧ: "ṧ",
            ŝ: "ŝ",
            ṡ: "ṡ",
            ş: "ş",
            ẗ: "ẗ",
            ť: "ť",
            ṫ: "ṫ",
            ţ: "ţ",
            ú: "ú",
            ù: "ù",
            ü: "ü",
            ǘ: "ǘ",
            ǜ: "ǜ",
            ǖ: "ǖ",
            ǚ: "ǚ",
            ũ: "ũ",
            ṹ: "ṹ",
            ū: "ū",
            ṻ: "ṻ",
            ŭ: "ŭ",
            ǔ: "ǔ",
            û: "û",
            ů: "ů",
            ű: "ű",
            ṽ: "ṽ",
            ẃ: "ẃ",
            ẁ: "ẁ",
            ẅ: "ẅ",
            ŵ: "ŵ",
            ẇ: "ẇ",
            ẘ: "ẘ",
            ẍ: "ẍ",
            ẋ: "ẋ",
            ý: "ý",
            ỳ: "ỳ",
            ÿ: "ÿ",
            ỹ: "ỹ",
            ȳ: "ȳ",
            ŷ: "ŷ",
            ẏ: "ẏ",
            ẙ: "ẙ",
            ź: "ź",
            ž: "ž",
            ẑ: "ẑ",
            ż: "ż",
            Á: "Á",
            À: "À",
            Ä: "Ä",
            Ǟ: "Ǟ",
            Ã: "Ã",
            Ā: "Ā",
            Ă: "Ă",
            Ắ: "Ắ",
            Ằ: "Ằ",
            Ẵ: "Ẵ",
            Ǎ: "Ǎ",
            Â: "Â",
            Ấ: "Ấ",
            Ầ: "Ầ",
            Ẫ: "Ẫ",
            Ȧ: "Ȧ",
            Ǡ: "Ǡ",
            Å: "Å",
            Ǻ: "Ǻ",
            Ḃ: "Ḃ",
            Ć: "Ć",
            Ḉ: "Ḉ",
            Č: "Č",
            Ĉ: "Ĉ",
            Ċ: "Ċ",
            Ç: "Ç",
            Ď: "Ď",
            Ḋ: "Ḋ",
            Ḑ: "Ḑ",
            É: "É",
            È: "È",
            Ë: "Ë",
            Ẽ: "Ẽ",
            Ē: "Ē",
            Ḗ: "Ḗ",
            Ḕ: "Ḕ",
            Ĕ: "Ĕ",
            Ḝ: "Ḝ",
            Ě: "Ě",
            Ê: "Ê",
            Ế: "Ế",
            Ề: "Ề",
            Ễ: "Ễ",
            Ė: "Ė",
            Ȩ: "Ȩ",
            Ḟ: "Ḟ",
            Ǵ: "Ǵ",
            Ḡ: "Ḡ",
            Ğ: "Ğ",
            Ǧ: "Ǧ",
            Ĝ: "Ĝ",
            Ġ: "Ġ",
            Ģ: "Ģ",
            Ḧ: "Ḧ",
            Ȟ: "Ȟ",
            Ĥ: "Ĥ",
            Ḣ: "Ḣ",
            Ḩ: "Ḩ",
            Í: "Í",
            Ì: "Ì",
            Ï: "Ï",
            Ḯ: "Ḯ",
            Ĩ: "Ĩ",
            Ī: "Ī",
            Ĭ: "Ĭ",
            Ǐ: "Ǐ",
            Î: "Î",
            İ: "İ",
            Ĵ: "Ĵ",
            Ḱ: "Ḱ",
            Ǩ: "Ǩ",
            Ķ: "Ķ",
            Ĺ: "Ĺ",
            Ľ: "Ľ",
            Ļ: "Ļ",
            Ḿ: "Ḿ",
            Ṁ: "Ṁ",
            Ń: "Ń",
            Ǹ: "Ǹ",
            Ñ: "Ñ",
            Ň: "Ň",
            Ṅ: "Ṅ",
            Ņ: "Ņ",
            Ó: "Ó",
            Ò: "Ò",
            Ö: "Ö",
            Ȫ: "Ȫ",
            Õ: "Õ",
            Ṍ: "Ṍ",
            Ṏ: "Ṏ",
            Ȭ: "Ȭ",
            Ō: "Ō",
            Ṓ: "Ṓ",
            Ṑ: "Ṑ",
            Ŏ: "Ŏ",
            Ǒ: "Ǒ",
            Ô: "Ô",
            Ố: "Ố",
            Ồ: "Ồ",
            Ỗ: "Ỗ",
            Ȯ: "Ȯ",
            Ȱ: "Ȱ",
            Ő: "Ő",
            Ṕ: "Ṕ",
            Ṗ: "Ṗ",
            Ŕ: "Ŕ",
            Ř: "Ř",
            Ṙ: "Ṙ",
            Ŗ: "Ŗ",
            Ś: "Ś",
            Ṥ: "Ṥ",
            Š: "Š",
            Ṧ: "Ṧ",
            Ŝ: "Ŝ",
            Ṡ: "Ṡ",
            Ş: "Ş",
            Ť: "Ť",
            Ṫ: "Ṫ",
            Ţ: "Ţ",
            Ú: "Ú",
            Ù: "Ù",
            Ü: "Ü",
            Ǘ: "Ǘ",
            Ǜ: "Ǜ",
            Ǖ: "Ǖ",
            Ǚ: "Ǚ",
            Ũ: "Ũ",
            Ṹ: "Ṹ",
            Ū: "Ū",
            Ṻ: "Ṻ",
            Ŭ: "Ŭ",
            Ǔ: "Ǔ",
            Û: "Û",
            Ů: "Ů",
            Ű: "Ű",
            Ṽ: "Ṽ",
            Ẃ: "Ẃ",
            Ẁ: "Ẁ",
            Ẅ: "Ẅ",
            Ŵ: "Ŵ",
            Ẇ: "Ẇ",
            Ẍ: "Ẍ",
            Ẋ: "Ẋ",
            Ý: "Ý",
            Ỳ: "Ỳ",
            Ÿ: "Ÿ",
            Ỹ: "Ỹ",
            Ȳ: "Ȳ",
            Ŷ: "Ŷ",
            Ẏ: "Ẏ",
            Ź: "Ź",
            Ž: "Ž",
            Ẑ: "Ẑ",
            Ż: "Ż",
            ά: "ά",
            ὰ: "ὰ",
            ᾱ: "ᾱ",
            ᾰ: "ᾰ",
            έ: "έ",
            ὲ: "ὲ",
            ή: "ή",
            ὴ: "ὴ",
            ί: "ί",
            ὶ: "ὶ",
            ϊ: "ϊ",
            ΐ: "ΐ",
            ῒ: "ῒ",
            ῑ: "ῑ",
            ῐ: "ῐ",
            ό: "ό",
            ὸ: "ὸ",
            ύ: "ύ",
            ὺ: "ὺ",
            ϋ: "ϋ",
            ΰ: "ΰ",
            ῢ: "ῢ",
            ῡ: "ῡ",
            ῠ: "ῠ",
            ώ: "ώ",
            ὼ: "ὼ",
            Ύ: "Ύ",
            Ὺ: "Ὺ",
            Ϋ: "Ϋ",
            Ῡ: "Ῡ",
            Ῠ: "Ῠ",
            Ώ: "Ώ",
            Ὼ: "Ὼ"
          };
          class jc {
            constructor(u, f) {
              this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new _C(u, f, this.mode), this.settings = f, this.leftrightDepth = 0;
            }
            /**
             * Checks a result to make sure it has the right type, and throws an
             * appropriate error otherwise.
             */
            expect(u, f) {
              if (f === void 0 && (f = true), this.fetch().text !== u)
                throw new s("Expected '" + u + "', got '" + this.fetch().text + "'", this.fetch());
              f && this.consume();
            }
            /**
             * Discards the current lookahead token, considering it consumed.
             */
            consume() {
              this.nextToken = null;
            }
            /**
             * Return the current lookahead token, or if there isn't one (at the
             * beginning, or if the previous lookahead token was consume()d),
             * fetch the next token as the new lookahead token and return it.
             */
            fetch() {
              return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(u) {
              this.mode = u, this.gullet.switchMode(u);
            }
            /**
             * Main parsing function, which parses an entire input.
             */
            parse() {
              this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
              try {
                const u = this.parseExpression(false);
                return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), u;
              } finally {
                this.gullet.endGroups();
              }
            }
            /**
             * Fully parse a separate sequence of tokens as a separate job.
             * Tokens should be specified in reverse order, as in a MacroDefinition.
             */
            subparse(u) {
              const f = this.nextToken;
              this.consume(), this.gullet.pushToken(new cn("}")), this.gullet.pushTokens(u);
              const b = this.parseExpression(false);
              return this.expect("}"), this.nextToken = f, b;
            }
            /**
             * Parses an "expression", which is a list of atoms.
             *
             * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
             *                 happens when functions have higher precedence han infix
             *                 nodes in implicit parses.
             *
             * `breakOnTokenText`: The text of the token that the expression should end
             *                     with, or `null` if something else should end the
             *                     expression.
             */
            parseExpression(u, f) {
              const b = [];
              for (; ; ) {
                this.mode === "math" && this.consumeSpaces();
                const w = this.fetch();
                if (jc.endOfExpression.indexOf(w.text) !== -1 || f && w.text === f || u && Hi[w.text] && Hi[w.text].infix)
                  break;
                const T = this.parseAtom(f);
                if (T) {
                  if (T.type === "internal")
                    continue;
                } else break;
                b.push(T);
              }
              return this.mode === "text" && this.formLigatures(b), this.handleInfixNodes(b);
            }
            /**
             * Rewrites infix operators such as \over with corresponding commands such
             * as \frac.
             *
             * There can only be one infix operator per group.  If there's more than one
             * then the expression is ambiguous.  This can be resolved by adding {}.
             */
            handleInfixNodes(u) {
              let f = -1, b;
              for (let w = 0; w < u.length; w++)
                if (u[w].type === "infix") {
                  if (f !== -1)
                    throw new s("only one infix operator per group", u[w].token);
                  f = w, b = u[w].replaceWith;
                }
              if (f !== -1 && b) {
                let w, T;
                const E = u.slice(0, f), D = u.slice(f + 1);
                E.length === 1 && E[0].type === "ordgroup" ? w = E[0] : w = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: E
                }, D.length === 1 && D[0].type === "ordgroup" ? T = D[0] : T = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: D
                };
                let P;
                return b === "\\\\abovefrac" ? P = this.callFunction(b, [w, u[f], T], []) : P = this.callFunction(b, [w, T], []), [P];
              } else
                return u;
            }
            /**
             * Handle a subscript or superscript with nice errors.
             */
            handleSupSubscript(u) {
              const f = this.fetch(), b = f.text;
              this.consume(), this.consumeSpaces();
              let w;
              do {
                var T;
                w = this.parseGroup(u);
              } while (((T = w) == null ? void 0 : T.type) === "internal");
              if (!w)
                throw new s("Expected group after '" + b + "'", f);
              return w;
            }
            /**
             * Converts the textual input of an unsupported command into a text node
             * contained within a color node whose color is determined by errorColor
             */
            formatUnsupportedCmd(u) {
              const f = [];
              for (let w = 0; w < u.length; w++)
                f.push({
                  type: "textord",
                  mode: "text",
                  text: u[w]
                });
              const b = {
                type: "text",
                mode: this.mode,
                body: f
              };
              return {
                type: "color",
                mode: this.mode,
                color: this.settings.errorColor,
                body: [b]
              };
            }
            /**
             * Parses a group with optional super/subscripts.
             */
            parseAtom(u) {
              const f = this.parseGroup("atom", u);
              if ((f == null ? void 0 : f.type) === "internal" || this.mode === "text")
                return f;
              let b, w;
              for (; ; ) {
                this.consumeSpaces();
                const T = this.fetch();
                if (T.text === "\\limits" || T.text === "\\nolimits") {
                  if (f && f.type === "op") {
                    const E = T.text === "\\limits";
                    f.limits = E, f.alwaysHandleSupSub = true;
                  } else if (f && f.type === "operatorname")
                    f.alwaysHandleSupSub && (f.limits = T.text === "\\limits");
                  else
                    throw new s("Limit controls must follow a math operator", T);
                  this.consume();
                } else if (T.text === "^") {
                  if (b)
                    throw new s("Double superscript", T);
                  b = this.handleSupSubscript("superscript");
                } else if (T.text === "_") {
                  if (w)
                    throw new s("Double subscript", T);
                  w = this.handleSupSubscript("subscript");
                } else if (T.text === "'") {
                  if (b)
                    throw new s("Double superscript", T);
                  const E = {
                    type: "textord",
                    mode: this.mode,
                    text: "\\prime"
                  }, D = [E];
                  for (this.consume(); this.fetch().text === "'"; )
                    D.push(E), this.consume();
                  this.fetch().text === "^" && D.push(this.handleSupSubscript("superscript")), b = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: D
                  };
                } else if (Pc[T.text]) {
                  const E = Wy.test(T.text), D = [];
                  for (D.push(new cn(Pc[T.text])), this.consume(); ; ) {
                    const Q = this.fetch().text;
                    if (!Pc[Q] || Wy.test(Q) !== E)
                      break;
                    D.unshift(new cn(Pc[Q])), this.consume();
                  }
                  const P = this.subparse(D);
                  E ? w = {
                    type: "ordgroup",
                    mode: "math",
                    body: P
                  } : b = {
                    type: "ordgroup",
                    mode: "math",
                    body: P
                  };
                } else
                  break;
              }
              return b || w ? {
                type: "supsub",
                mode: this.mode,
                base: f,
                sup: b,
                sub: w
              } : f;
            }
            /**
             * Parses an entire function, including its base and all of its arguments.
             */
            parseFunction(u, f) {
              const b = this.fetch(), w = b.text, T = Hi[w];
              if (!T)
                return null;
              if (this.consume(), f && f !== "atom" && !T.allowedInArgument)
                throw new s("Got function '" + w + "' with no arguments" + (f ? " as " + f : ""), b);
              if (this.mode === "text" && !T.allowedInText)
                throw new s("Can't use function '" + w + "' in text mode", b);
              if (this.mode === "math" && T.allowedInMath === false)
                throw new s("Can't use function '" + w + "' in math mode", b);
              const {
                args: E,
                optArgs: D
              } = this.parseArguments(w, T);
              return this.callFunction(w, E, D, b, u);
            }
            /**
             * Call a function handler with a suitable context and arguments.
             */
            callFunction(u, f, b, w, T) {
              const E = {
                funcName: u,
                parser: this,
                token: w,
                breakOnTokenText: T
              }, D = Hi[u];
              if (D && D.handler)
                return D.handler(E, f, b);
              throw new s("No function handler for " + u);
            }
            /**
             * Parses the arguments of a function or environment
             */
            parseArguments(u, f) {
              const b = f.numArgs + f.numOptionalArgs;
              if (b === 0)
                return {
                  args: [],
                  optArgs: []
                };
              const w = [], T = [];
              for (let E = 0; E < b; E++) {
                let D = f.argTypes && f.argTypes[E];
                const P = E < f.numOptionalArgs;
                (f.primitive && D == null || // \sqrt expands into primitive if optional argument doesn't exist
                f.type === "sqrt" && E === 1 && T[0] == null) && (D = "primitive");
                const Q = this.parseGroupOfType("argument to '" + u + "'", D, P);
                if (P)
                  T.push(Q);
                else if (Q != null)
                  w.push(Q);
                else
                  throw new s("Null argument, please report this as a bug");
              }
              return {
                args: w,
                optArgs: T
              };
            }
            /**
             * Parses a group when the mode is changing.
             */
            parseGroupOfType(u, f, b) {
              switch (f) {
                case "color":
                  return this.parseColorGroup(b);
                case "size":
                  return this.parseSizeGroup(b);
                case "url":
                  return this.parseUrlGroup(b);
                case "math":
                case "text":
                  return this.parseArgumentGroup(b, f);
                case "hbox": {
                  const w = this.parseArgumentGroup(b, "text");
                  return w != null ? {
                    type: "styling",
                    mode: w.mode,
                    body: [w],
                    style: "text"
                    // simulate \textstyle
                  } : null;
                }
                case "raw": {
                  const w = this.parseStringGroup("raw", b);
                  return w != null ? {
                    type: "raw",
                    mode: "text",
                    string: w.text
                  } : null;
                }
                case "primitive": {
                  if (b)
                    throw new s("A primitive argument cannot be optional");
                  const w = this.parseGroup(u);
                  if (w == null)
                    throw new s("Expected group as " + u, this.fetch());
                  return w;
                }
                case "original":
                case null:
                case void 0:
                  return this.parseArgumentGroup(b);
                default:
                  throw new s("Unknown group type as " + u, this.fetch());
              }
            }
            /**
             * Discard any space tokens, fetching the next non-space token.
             */
            consumeSpaces() {
              for (; this.fetch().text === " "; )
                this.consume();
            }
            /**
             * Parses a group, essentially returning the string formed by the
             * brace-enclosed tokens plus some position information.
             */
            parseStringGroup(u, f) {
              const b = this.gullet.scanArgument(f);
              if (b == null)
                return null;
              let w = "", T;
              for (; (T = this.fetch()).text !== "EOF"; )
                w += T.text, this.consume();
              return this.consume(), b.text = w, b;
            }
            /**
             * Parses a regex-delimited group: the largest sequence of tokens
             * whose concatenated strings match `regex`. Returns the string
             * formed by the tokens plus some position information.
             */
            parseRegexGroup(u, f) {
              const b = this.fetch();
              let w = b, T = "", E;
              for (; (E = this.fetch()).text !== "EOF" && u.test(T + E.text); )
                w = E, T += w.text, this.consume();
              if (T === "")
                throw new s("Invalid " + f + ": '" + b.text + "'", b);
              return b.range(w, T);
            }
            /**
             * Parses a color description.
             */
            parseColorGroup(u) {
              const f = this.parseStringGroup("color", u);
              if (f == null)
                return null;
              const b = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(f.text);
              if (!b)
                throw new s("Invalid color: '" + f.text + "'", f);
              let w = b[0];
              return /^[0-9a-f]{6}$/i.test(w) && (w = "#" + w), {
                type: "color-token",
                mode: this.mode,
                color: w
              };
            }
            /**
             * Parses a size specification, consisting of magnitude and unit.
             */
            parseSizeGroup(u) {
              let f, b = false;
              if (this.gullet.consumeSpaces(), !u && this.gullet.future().text !== "{" ? f = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : f = this.parseStringGroup("size", u), !f)
                return null;
              !u && f.text.length === 0 && (f.text = "0pt", b = true);
              const w = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(f.text);
              if (!w)
                throw new s("Invalid size: '" + f.text + "'", f);
              const T = {
                number: +(w[1] + w[2]),
                // sign + magnitude, cast to number
                unit: w[3]
              };
              if (!ks(T))
                throw new s("Invalid unit: '" + T.unit + "'", f);
              return {
                type: "size",
                mode: this.mode,
                value: T,
                isBlank: b
              };
            }
            /**
             * Parses an URL, checking escaped letters and allowed protocols,
             * and setting the catcode of % as an active character (as in \hyperref).
             */
            parseUrlGroup(u) {
              this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
              const f = this.parseStringGroup("url", u);
              if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), f == null)
                return null;
              const b = f.text.replace(/\\([#$%&~_^{}])/g, "$1");
              return {
                type: "url",
                mode: this.mode,
                url: b
              };
            }
            /**
             * Parses an argument with the mode specified.
             */
            parseArgumentGroup(u, f) {
              const b = this.gullet.scanArgument(u);
              if (b == null)
                return null;
              const w = this.mode;
              f && this.switchMode(f), this.gullet.beginGroup();
              const T = this.parseExpression(false, "EOF");
              this.expect("EOF"), this.gullet.endGroup();
              const E = {
                type: "ordgroup",
                mode: this.mode,
                loc: b.loc,
                body: T
              };
              return f && this.switchMode(w), E;
            }
            /**
             * Parses an ordinary group, which is either a single nucleus (like "x")
             * or an expression in braces (like "{x+y}") or an implicit group, a group
             * that starts at the current position, and ends right before a higher explicit
             * group ends, or at EOF.
             */
            parseGroup(u, f) {
              const b = this.fetch(), w = b.text;
              let T;
              if (w === "{" || w === "\\begingroup") {
                this.consume();
                const E = w === "{" ? "}" : "\\endgroup";
                this.gullet.beginGroup();
                const D = this.parseExpression(false, E), P = this.fetch();
                this.expect(E), this.gullet.endGroup(), T = {
                  type: "ordgroup",
                  mode: this.mode,
                  loc: Yr.range(b, P),
                  body: D,
                  // A group formed by \begingroup...\endgroup is a semi-simple group
                  // which doesn't affect spacing in math mode, i.e., is transparent.
                  // https://tex.stackexchange.com/questions/1930/when-should-one-
                  // use-begingroup-instead-of-bgroup
                  semisimple: w === "\\begingroup" || void 0
                };
              } else if (T = this.parseFunction(f, u) || this.parseSymbol(), T == null && w[0] === "\\" && !jy.hasOwnProperty(w)) {
                if (this.settings.throwOnError)
                  throw new s("Undefined control sequence: " + w, b);
                T = this.formatUnsupportedCmd(w), this.consume();
              }
              return T;
            }
            /**
             * Form ligature-like combinations of characters for text mode.
             * This includes inputs like "--", "---", "``" and "''".
             * The result will simply replace multiple textord nodes with a single
             * character in each value by a single textord node having multiple
             * characters in its value.  The representation is still ASCII source.
             * The group will be modified in place.
             */
            formLigatures(u) {
              let f = u.length - 1;
              for (let b = 0; b < f; ++b) {
                const w = u[b], T = w.text;
                T === "-" && u[b + 1].text === "-" && (b + 1 < f && u[b + 2].text === "-" ? (u.splice(b, 3, {
                  type: "textord",
                  mode: "text",
                  loc: Yr.range(w, u[b + 2]),
                  text: "---"
                }), f -= 2) : (u.splice(b, 2, {
                  type: "textord",
                  mode: "text",
                  loc: Yr.range(w, u[b + 1]),
                  text: "--"
                }), f -= 1)), (T === "'" || T === "`") && u[b + 1].text === T && (u.splice(b, 2, {
                  type: "textord",
                  mode: "text",
                  loc: Yr.range(w, u[b + 1]),
                  text: T + T
                }), f -= 1);
              }
            }
            /**
             * Parse a single symbol out of the string. Here, we handle single character
             * symbols and special functions like \verb.
             */
            parseSymbol() {
              const u = this.fetch();
              let f = u.text;
              if (/^\\verb[^a-zA-Z]/.test(f)) {
                this.consume();
                let T = f.slice(5);
                const E = T.charAt(0) === "*";
                if (E && (T = T.slice(1)), T.length < 2 || T.charAt(0) !== T.slice(-1))
                  throw new s(`\\verb assertion failed --
                    please report what input caused this bug`);
                return T = T.slice(1, -1), {
                  type: "verb",
                  mode: "text",
                  body: T,
                  star: E
                };
              }
              Hy.hasOwnProperty(f[0]) && !fe[this.mode][f[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + f[0] + '" used in math mode', u), f = Hy[f[0]] + f.slice(1));
              const b = xC.exec(f);
              b && (f = f.substring(0, b.index), f === "i" ? f = "ı" : f === "j" && (f = "ȷ"));
              let w;
              if (fe[this.mode][f]) {
                this.settings.strict && this.mode === "math" && Ue.indexOf(f) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + f[0] + '" used in math mode', u);
                const T = fe[this.mode][f].group, E = Yr.range(u);
                let D;
                if (Tc.hasOwnProperty(T)) {
                  const P = T;
                  D = {
                    type: "atom",
                    mode: this.mode,
                    family: P,
                    loc: E,
                    text: f
                  };
                } else
                  D = {
                    type: T,
                    mode: this.mode,
                    loc: E,
                    text: f
                  };
                w = D;
              } else if (f.charCodeAt(0) >= 128)
                this.settings.strict && (gt(f.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + f[0] + '" used in math mode', u) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + f[0] + '"' + (" (" + f.charCodeAt(0) + ")"), u)), w = {
                  type: "textord",
                  mode: "text",
                  loc: Yr.range(u),
                  text: f
                };
              else
                return null;
              if (this.consume(), b)
                for (let T = 0; T < b[0].length; T++) {
                  const E = b[0][T];
                  if (!Ed[E])
                    throw new s("Unknown accent ' " + E + "'", u);
                  const D = Ed[E][this.mode] || Ed[E].text;
                  if (!D)
                    throw new s("Accent " + E + " unsupported in " + this.mode + " mode", u);
                  w = {
                    type: "accent",
                    mode: this.mode,
                    loc: Yr.range(u),
                    label: D,
                    isStretchy: false,
                    isShifty: true,
                    // $FlowFixMe
                    base: w
                  };
                }
              return w;
            }
          }
          jc.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
          var Md = function(d, u) {
            if (!(typeof d == "string" || d instanceof String))
              throw new TypeError("KaTeX can only parse string typed expression");
            const f = new jc(d, u);
            delete f.gullet.macros.current["\\df@tag"];
            let b = f.parse();
            if (delete f.gullet.macros.current["\\current@color"], delete f.gullet.macros.current["\\color"], f.gullet.macros.get("\\df@tag")) {
              if (!u.displayMode)
                throw new s("\\tag works only in display equations");
              b = [{
                type: "tag",
                mode: "text",
                body: b,
                tag: f.subparse([new cn("\\df@tag")])
              }];
            }
            return b;
          };
          let Uy = function(d, u, f) {
            u.textContent = "";
            const b = Bd(d, f).toNode();
            u.appendChild(b);
          };
          typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), Uy = function() {
            throw new s("KaTeX doesn't work in quirks mode.");
          });
          const CC = function(d, u) {
            return Bd(d, u).toMarkup();
          }, SC = function(d, u) {
            const f = new $(u);
            return Md(d, f);
          }, Vy = function(d, u, f) {
            if (f.throwOnError || !(d instanceof s))
              throw d;
            const b = ot.makeSpan(["katex-error"], [new Dr(u)]);
            return b.setAttribute("title", d.toString()), b.setAttribute("style", "color:" + f.errorColor), b;
          }, Bd = function(d, u) {
            const f = new $(u);
            try {
              const b = Md(d, f);
              return R_(b, d, f);
            } catch (b) {
              return Vy(b, d, f);
            }
          };
          var TC = {
            /**
             * Current KaTeX version
             */
            version: "0.16.22",
            /**
             * Renders the given LaTeX into an HTML+MathML combination, and adds
             * it as a child to the specified DOM node.
             */
            render: Uy,
            /**
             * Renders the given LaTeX into an HTML+MathML combination string,
             * for sending to the client.
             */
            renderToString: CC,
            /**
             * KaTeX error, usually during parsing.
             */
            ParseError: s,
            /**
             * The schema of Settings
             */
            SETTINGS_SCHEMA: C,
            /**
             * Parses the given LaTeX into KaTeX's internal parse tree structure,
             * without rendering to HTML or MathML.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __parse: SC,
            /**
             * Renders the given LaTeX into an HTML+MathML internal DOM tree
             * representation, without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToDomTree: Bd,
            /**
             * Renders the given LaTeX into an HTML internal DOM tree representation,
             * without MathML and without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToHTMLTree: function(d, u) {
              const f = new $(u);
              try {
                const b = Md(d, f);
                return P_(b, d, f);
              } catch (b) {
                return Vy(b, d, f);
              }
            },
            /**
             * extends internal font metrics object with a new object
             * each key in the new object represents a font name
            */
            __setFontMetrics: _c,
            /**
             * adds a new symbol to builtin symbols table
             */
            __defineSymbol: v,
            /**
             * adds a new function to builtin function list,
             * which directly produce parse tree elements
             * and have their own html/mathml builders
             */
            __defineFunction: Ct,
            /**
             * adds a new macro to builtin macro list
             */
            __defineMacro: N,
            /**
             * Expose the dom tree node types, which can be useful for type checking nodes.
             *
             * NOTE: These methods are not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __domTree: {
              Span: Nn,
              Anchor: Ta,
              SymbolNode: Dr,
              SvgNode: ke,
              PathNode: vr,
              LineNode: Aa
            }
          }, AC = TC;
          return n = n.default, n;
        }()
      );
    });
  }(mf)), mf.exports;
}
var Z2;
function YL() {
  if (Z2) return So;
  Z2 = 1;
  var t15 = So && So.__importDefault || function(y) {
    return y && y.__esModule ? y : { default: y };
  };
  Object.defineProperty(So, "__esModule", { value: true });
  const e = t15(XL());
  function r(y, x) {
    const k = y.src[x - 1], C = y.src[x], _ = y.src[x + 1];
    if (C !== "$")
      return { can_open: false, can_close: false };
    let $ = false, L = false;
    return k !== "$" && k !== "\\" && (k === void 0 || n(k) || !i(k)) && ($ = true), _ !== "$" && (_ == null || n(_) || !i(_)) && (L = true), { can_open: $, can_close: L };
  }
  function n(y) {
    return /^\s$/u.test(y);
  }
  function i(y) {
    return /^[\w\d]$/u.test(y);
  }
  function s(y, x) {
    const k = y.src[x - 1], C = y.src[x], _ = y.src[x + 1], $ = y.src[x + 2];
    return C === "$" && k !== "$" && k !== "\\" && _ === "$" && $ !== "$" ? { can_open: true, can_close: true } : { can_open: false, can_close: false };
  }
  function o(y, x) {
    if (y.src[y.pos] !== "$")
      return false;
    const k = y.tokens.at(-1);
    if ((k == null ? void 0 : k.type) === "html_inline" && /^<\w+.+[^/]>$/.test(k.content))
      return false;
    let C = r(y, y.pos);
    if (!C.can_open)
      return x || (y.pending += "$"), y.pos += 1, true;
    let _ = y.pos + 1, $ = _, L;
    for (; ($ = y.src.indexOf("$", $)) !== -1; ) {
      for (L = $ - 1; y.src[L] === "\\"; )
        L -= 1;
      if (($ - L) % 2 == 1)
        break;
      $ += 1;
    }
    if ($ === -1)
      return x || (y.pending += "$"), y.pos = _, true;
    if ($ - _ === 0)
      return x || (y.pending += "$$"), y.pos = _ + 1, true;
    if (C = r(y, $), !C.can_close)
      return x || (y.pending += "$"), y.pos = _, true;
    if (!x) {
      const B = y.push("math_inline", "math", 0);
      B.markup = "$", B.content = y.src.slice(_, $);
    }
    return y.pos = $ + 1, true;
  }
  function a(y, x, k, C) {
    let _ = false, $ = y.bMarks[x] + y.tShift[x], L = y.eMarks[x];
    if ($ + 2 > L || y.src.slice($, $ + 2) !== "$$")
      return false;
    $ += 2;
    let B = y.src.slice($, L);
    const q = [...B.matchAll(/\$\$/g)];
    if (q.length === 1 && q[0].index === B.length - 2)
      B = B.trim().slice(0, -2), _ = true;
    else if (q.length > 1)
      return false;
    if (C)
      return true;
    let H, G, F;
    for (G = x; !_ && (G++, !(G >= k || ($ = y.bMarks[G] + y.tShift[G], L = y.eMarks[G], $ < L && y.tShift[G] < y.blkIndent))); )
      y.src.slice($, L).trim().slice(-2) === "$$" ? (F = y.src.slice(0, L).lastIndexOf("$$"), H = y.src.slice($, F), _ = true) : y.src.slice($, L).trim().includes("$$") && (F = y.src.slice(0, L).trim().indexOf("$$"), H = y.src.slice($, F), _ = true);
    y.line = G + 1;
    const W = y.push("math_block", "math", 0);
    return W.block = true, W.content = (B && B.trim() ? B + `
` : "") + y.getLines(x + 1, G, y.tShift[x], true) + (H && H.trim() ? H : ""), W.map = [x, y.line], W.markup = "$$", true;
  }
  function l(y, x, k, C) {
    const _ = y.bMarks[x] + y.tShift[x], $ = y.eMarks[x];
    if (!y.src.slice(_, $).match(/^\s*\\begin\s*\{([^{}]+)\}/))
      return false;
    if (x > 0) {
      const F = y.bMarks[x - 1] + y.tShift[x - 1], W = y.eMarks[x - 1], R = y.src.slice(F, W);
      if (!/^\s*$/.test(R))
        return false;
    }
    if (C)
      return true;
    const L = [];
    let B = x, q, H = false;
    t: for (; !H && !(B >= k); B++) {
      const F = y.bMarks[B] + y.tShift[B], W = y.eMarks[B];
      if (F < W && y.tShift[B] < y.blkIndent)
        break;
      const R = y.src.slice(F, W);
      for (const J of R.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
        if (J[1] === "\\begin")
          L.push(J[2].trim());
        else if (J[1] === "\\end" && (L.pop(), !L.length)) {
          q = y.src.slice(F, W), H = true;
          break t;
        }
    }
    y.line = B + 1;
    const G = y.push("math_block", "math", 0);
    return G.block = true, G.content = (y.getLines(x, B, y.tShift[x], true) + (q ?? "")).trim(), G.map = [x, y.line], G.markup = "$$", true;
  }
  function c(y, x) {
    var k, C, _, $, L;
    if (y.src.slice(y.pos, y.pos + 2) !== "$$")
      return false;
    if ($ = s(y, y.pos), !$.can_open)
      return x || (y.pending += "$$"), y.pos += 2, true;
    for (k = y.pos + 2, C = k; (C = y.src.indexOf("$$", C)) !== -1; ) {
      for (L = C - 1; y.src[L] === "\\"; )
        L -= 1;
      if ((C - L) % 2 == 1)
        break;
      C += 2;
    }
    return C === -1 ? (x || (y.pending += "$$"), y.pos = k, true) : C - k === 0 ? (x || (y.pending += "$$$$"), y.pos = k + 2, true) : ($ = s(y, C), $.can_close ? (x || (_ = y.push("math_block", "math", 0), _.block = true, _.markup = "$$", _.content = y.src.slice(k, C)), y.pos = C + 2, true) : (x || (y.pending += "$$"), y.pos = k, true));
  }
  function h10(y, x) {
    const k = y.src.slice(y.pos);
    if (!/^\n\\begin/.test(k))
      return false;
    if (y.pos += 1, x)
      return true;
    const C = k.split(/\n/g).slice(1);
    let _;
    const $ = [];
    t: for (var L = 0; L < C.length; ++L) {
      const H = C[L];
      for (const G of H.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
        if (G[1] === "\\begin")
          $.push(G[2].trim());
        else if (G[1] === "\\end" && ($.pop(), !$.length)) {
          _ = L;
          break t;
        }
    }
    if (typeof _ > "u")
      return false;
    const B = C.slice(0, _ + 1).reduce((H, G) => H + G.length, 0) + _ + 1, q = y.push("math_inline_bare_block", "math", 0);
    return q.block = true, q.markup = "$$", q.content = k.slice(1, B), y.pos = y.pos + B, true;
  }
  function p(y, x, k, C) {
    const _ = y.tokens;
    for (let $ = _.length - 1; $ >= 0; $--) {
      const L = _[$], B = [];
      if (L.type !== "html_block")
        continue;
      const q = L.content;
      for (const H of q.matchAll(C)) {
        if (!H.groups)
          continue;
        const G = H.groups.html_before_math, F = H.groups.math, W = H.groups.html_after_math;
        G && B.push({ ...L, type: "html_block", map: null, content: G }), F && B.push({
          ...L,
          type: x,
          map: null,
          content: F,
          markup: k,
          block: true,
          tag: "math"
        }), W && B.push({ ...L, type: "html_block", map: null, content: W });
      }
      B.length > 0 && _.splice($, 1, ...B);
    }
    return true;
  }
  function m(y) {
    return y.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  function g(y, x) {
    const k = (x == null ? void 0 : x.katex) ?? e.default, C = x == null ? void 0 : x.enableBareBlocks, _ = x == null ? void 0 : x.enableMathBlockInHtml, $ = x == null ? void 0 : x.enableMathInlineInHtml, L = x == null ? void 0 : x.enableFencedBlocks;
    y.inline.ruler.after("escape", "math_inline", o), y.inline.ruler.after("escape", "math_inline_block", c), C && y.inline.ruler.before("text", "math_inline_bare_block", h10), y.block.ruler.after("blockquote", "math_block", (R, J, rt, I) => C && l(R, J, rt, I) ? true : a(R, J, rt, I), {
      alt: ["paragraph", "reference", "blockquote", "list"]
    });
    const B = /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm, q = /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
    _ && y.core.ruler.push("math_block_in_html_block", (R) => p(R, "math_block", "$$", B)), $ && y.core.ruler.push("math_inline_in_html_block", (R) => p(R, "math_inline", "$", q));
    const H = (R) => {
      const J = /\\begin\{(align|equation|gather|cd|alignat)\}/ig.test(R);
      try {
        return k.renderToString(R, { ...x, displayMode: J });
      } catch (rt) {
        return (x == null ? void 0 : x.throwOnError) && console.log(rt), `<span class="katex-error" title="${m(R)}">${m(rt + "")}</span>`;
      }
    }, G = (R, J) => {
      const rt = R[J].content, I = rt.length > 2 && rt[0] === "`" && rt[rt.length - 1] === "`" ? rt.slice(1, -1) : rt;
      return H(I);
    }, F = (R) => {
      try {
        return `<p class="katex-block">${k.renderToString(R, { ...x, displayMode: true })}</p>`;
      } catch (J) {
        return (x == null ? void 0 : x.throwOnError) && console.log(J), `<p class="katex-block katex-error" title="${m(R)}">${m(J + "")}</p>`;
      }
    }, W = (R, J) => F(R[J].content) + `
`;
    if (y.renderer.rules.math_inline = G, y.renderer.rules.math_inline_block = W, y.renderer.rules.math_inline_bare_block = W, y.renderer.rules.math_block = W, L) {
      const R = "math", J = y.renderer.rules.fence;
      y.renderer.rules.fence = function(rt, I, j, z, K) {
        const Y = rt[I];
        return Y.info.trim().toLowerCase() === R && L ? F(Y.content) + `
` : (J == null ? void 0 : J.call(this, rt, I, j, z, K)) || "";
      };
    }
  }
  return So.default = g, So;
}
var KL = YL();
var ZL = VL(KL);
function QL() {
  const t15 = yn({
    html: true,
    breaks: true
  });
  return t15.use(AB).use($B).use(BB).use(FB), t15;
}
function JL(t15) {
  return {
    transformer: t15,
    parser: new Ja(),
    beforeParse: new Ja(),
    afterParse: new Ja(),
    retransform: new Ja()
  };
}
var tD = `<svg width="16" height="16" viewBox="0 -3 24 24"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"/></svg>
`;
var eD = `<svg width="16" height="16" viewBox="0 -3 24 24"><path fill-rule="evenodd" d="M6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1zM3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-5z" clip-rule="evenodd"/></svg>
`;
var rD = "checkbox";
var Q2 = {
  " ": eD.trim(),
  x: tD.trim()
};
var nD = {
  name: rD,
  transform(t15) {
    return t15.parser.tap((e) => {
      e.core.ruler.before("inline", "checkbox", (r) => {
        for (let n = 2; n < r.tokens.length; n += 1) {
          const i = r.tokens[n];
          if (i.type === "inline" && i.content) {
            const s = r.tokens[n - 1].type, o = r.tokens[n - 2].type;
            (s === "heading_open" || s === "paragraph_open" && o === "list_item_open") && (i.content = i.content.replace(
              /^\[(.)\] /,
              (a, l) => Q2[l] ? `${Q2[l]} ` : a
            ));
          }
        }
        return false;
      });
    }), {};
  }
};
var iD = "frontmatter";
var sD = {
  name: iD,
  transform(t15) {
    return t15.beforeParse.tap((e, r) => {
      var n;
      const { content: i } = r;
      if (!/^---\r?\n/.test(i)) return;
      const s = /\n---\r?\n/.exec(i);
      if (!s) return;
      const o = i.slice(4, s.index).trimEnd();
      let a;
      try {
        a = UL(o.replace(/\r?\n|\r/g, `
`)), (a == null ? void 0 : a.markmap) && (a.markmap = oD(
          a.markmap
        ));
      } catch {
        return;
      }
      r.frontmatter = a, r.parserOptions = {
        ...r.parserOptions,
        ...(n = a == null ? void 0 : a.markmap) == null ? void 0 : n.htmlParser
      }, r.frontmatterInfo = {
        lines: i.slice(0, s.index).split(`
`).length + 1,
        offset: s.index + s[0].length
      };
    }), {};
  }
};
function oD(t15) {
  if (t15)
    return ["color", "extraJs", "extraCss"].forEach((e) => {
      t15[e] != null && (t15[e] = aD(t15[e]));
    }), ["duration", "maxWidth", "initialExpandLevel"].forEach((e) => {
      t15[e] != null && (t15[e] = lD(t15[e]));
    }), t15;
}
function aD(t15) {
  let e;
  return typeof t15 == "string" ? e = [t15] : Array.isArray(t15) && (e = t15.filter((r) => r && typeof r == "string")), (e == null ? void 0 : e.length) ? e : void 0;
}
function lD(t15) {
  if (!isNaN(+t15))
    return +t15;
}
function bm(t15, e) {
  return e.type === "script" && e.data.src ? {
    ...e,
    data: {
      ...e.data,
      src: t15.getFullUrl(e.data.src)
    }
  } : e;
}
function cD(t15, e) {
  return e.type === "stylesheet" && e.data.href ? {
    ...e,
    data: {
      ...e.data,
      href: t15.getFullUrl(e.data.href)
    }
  } : e;
}
var J2 = "hljs";
var hD = [
  "@highlightjs/cdn-assets@11.11.1/highlight.min.js"
].map((t15) => F1(t15));
var uD = [
  "@highlightjs/cdn-assets@11.11.1/styles/default.min.css"
].map((t15) => O5(t15));
var dD = {
  versions: {
    hljs: "11.11.1"
  },
  preloadScripts: hD,
  styles: uD
};
var gf = {
  name: J2,
  config: dD,
  transform(t15) {
    var e, r, n;
    let i;
    const s = ((r = (e = gf.config) == null ? void 0 : e.preloadScripts) == null ? void 0 : r.map(
      (l) => bm(t15.transformer.urlBuilder, l)
    )) || [], o = () => (i || (i = I5(s)), i);
    let a = Bo;
    return t15.parser.tap((l) => {
      l.set({
        highlight: (c, h10) => {
          a();
          const { hljs: p } = window;
          return p ? p.highlightAuto(c, h10 ? [h10] : void 0).value : (o().then(() => {
            t15.retransform.call();
          }), c);
        }
      });
    }), t15.beforeParse.tap((l, c) => {
      a = () => {
        c.features[J2] = true;
      };
    }), {
      styles: (n = gf.config) == null ? void 0 : n.styles
    };
  }
};
function pD(t15, e, r) {
  return t15.map((n) => {
    if (typeof n == "string" && !n.includes("://")) {
      n.startsWith("npm:") || (n = `npm:${n}`);
      const i = 4 + e.length;
      n.startsWith(`npm:${e}/`) && (n = `${n.slice(0, i)}@${r}${n.slice(
        i
      )}`);
    }
    return n;
  });
}
var fD = ["katex@0.16.18/dist/fonts/KaTeX_AMS-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Script-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size1-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size2-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size3-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size4-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Typewriter-Regular.woff2"];
var tp = "katex";
var mD = [
  "katex@0.16.18/dist/katex.min.js"
].map((t15) => F1(t15));
var W3 = F1(
  "webfontloader@1.6.28/webfontloader.js"
);
W3.data.defer = true;
var gD = ["katex@0.16.18/dist/katex.min.css"].map(
  (t15) => O5(t15)
);
var yD = {
  versions: {
    katex: "0.16.18",
    webfontloader: "1.6.28"
  },
  preloadScripts: mD,
  scripts: [
    {
      type: "iife",
      data: {
        fn: (t15) => {
          window.WebFontConfig = {
            custom: {
              families: [
                "KaTeX_AMS",
                "KaTeX_Caligraphic:n4,n7",
                "KaTeX_Fraktur:n4,n7",
                "KaTeX_Main:n4,n7,i4,i7",
                "KaTeX_Math:i4,i7",
                "KaTeX_Script",
                "KaTeX_SansSerif:n4,n7,i4",
                "KaTeX_Size1",
                "KaTeX_Size2",
                "KaTeX_Size3",
                "KaTeX_Size4",
                "KaTeX_Typewriter"
              ]
            },
            active: () => {
              t15().refreshHook.call();
            }
          };
        },
        getParams({ getMarkmap: t15 }) {
          return [t15];
        }
      }
    },
    W3
  ],
  styles: gD,
  resources: fD
};
function bD(t15) {
  return t15.default || t15;
}
var xD = bD(ZL);
var nl = {
  name: tp,
  config: yD,
  transform(t15) {
    var e, r, n, i;
    let s;
    const o = ((r = (e = nl.config) == null ? void 0 : e.preloadScripts) == null ? void 0 : r.map(
      (h10) => bm(t15.transformer.urlBuilder, h10)
    )) || [], a = () => (s || (s = I5(o)), s), l = (h10, p) => {
      const { katex: m } = window;
      return m ? m.renderToString(h10, {
        displayMode: p,
        throwOnError: false
      }) : (a().then(() => {
        t15.retransform.call();
      }), h10);
    };
    let c = Bo;
    return t15.parser.tap((h10) => {
      h10.use(xD), ["math_block", "math_inline"].forEach((p) => {
        const m = (g, y) => (c(), l(g[y].content, !!g[y].block));
        h10.renderer.rules[p] = m;
      });
    }), t15.beforeParse.tap((h10, p) => {
      c = () => {
        p.features[tp] = true;
      };
    }), t15.afterParse.tap((h10, p) => {
      var m;
      const g = (m = p.frontmatter) == null ? void 0 : m.markmap;
      g && ["extraJs", "extraCss"].forEach((y) => {
        var x, k;
        const C = g[y];
        C && (g[y] = pD(
          C,
          tp,
          ((k = (x = nl.config) == null ? void 0 : x.versions) == null ? void 0 : k.katex) || ""
        ));
      });
    }), {
      styles: (n = nl.config) == null ? void 0 : n.styles,
      scripts: (i = nl.config) == null ? void 0 : i.scripts
    };
  }
};
var wD = "npmUrl";
var kD = {
  name: wD,
  transform(t15) {
    return t15.afterParse.tap((e, r) => {
      const { frontmatter: n } = r, i = n == null ? void 0 : n.markmap;
      i && ["extraJs", "extraCss"].forEach((s) => {
        const o = i[s];
        o && (i[s] = o.map((a) => a.startsWith("npm:") ? t15.transformer.urlBuilder.getFullUrl(
          a.slice(4)
        ) : a));
      });
    }), {};
  }
};
var vD = "sourceLines";
var _D = {
  name: vD,
  transform(t15) {
    let e = 0;
    return t15.beforeParse.tap((r, n) => {
      var i;
      e = ((i = n.frontmatterInfo) == null ? void 0 : i.lines) || 0;
    }), t15.parser.tap((r) => {
      r.renderer.renderAttrs = Ky(
        r.renderer.renderAttrs,
        (n, i) => {
          if (i.block && i.map) {
            const s = i.map.map((o) => o + e);
            i.attrSet("data-lines", s.join(","));
          }
          return n(i);
        }
      ), r.renderer.rules.fence && (r.renderer.rules.fence = Ky(
        r.renderer.rules.fence,
        (n, i, s, ...o) => {
          let a = n(i, s, ...o);
          const l = i[s];
          if (a.startsWith("<pre>") && l.map) {
            const c = l.map.map(
              (h10) => h10 + e
            );
            a = a.slice(0, 4) + ` data-lines="${c.join(",")}"` + a.slice(4);
          }
          return a;
        }
      ));
    }), {};
  }
};
var CD = [
  sD,
  nl,
  gf,
  kD,
  nD,
  _D
];
var SD = CD;
function H3(t15) {
  for (; !t15.content && t15.children.length === 1; )
    t15 = t15.children[0];
  for (; t15.children.length === 1 && !t15.children[0].content; )
    t15 = {
      ...t15,
      children: t15.children[0].children
    };
  return {
    ...t15,
    children: t15.children.map(H3)
  };
}
var TD = class {
  constructor(e = SD) {
    this.assetsMap = {}, this.urlBuilder = new DC(), this.hooks = JL(this), this.plugins = e.map(
      (i) => typeof i == "function" ? i() : i
    );
    const r = {};
    for (const { name: i, transform: s } of this.plugins)
      r[i] = s(this.hooks);
    this.assetsMap = r;
    const n = QL();
    this.md = n, this.hooks.parser.call(n);
  }
  transform(e, r) {
    var n;
    const i = {
      content: e,
      features: {},
      parserOptions: r
    };
    this.hooks.beforeParse.call(this.md, i);
    let { content: s } = i;
    i.frontmatterInfo && (s = s.slice(i.frontmatterInfo.offset));
    const o = this.md.render(s, {});
    this.hooks.afterParse.call(this.md, i);
    const a = H3(P$(o, i.parserOptions));
    return a.content || (a.content = `${((n = i.frontmatter) == null ? void 0 : n.title) || ""}`), { ...i, root: a };
  }
  resolveJS(e) {
    return bm(this.urlBuilder, e);
  }
  resolveCSS(e) {
    return cD(this.urlBuilder, e);
  }
  /**
   * Get all assets from enabled plugins or filter them by plugin names as keys.
   */
  getAssets(e) {
    const r = [], n = [];
    e ?? (e = this.plugins.map((i) => i.name));
    for (const i of e.map((s) => this.assetsMap[s]))
      i && (i.styles && r.push(...i.styles), i.scripts && n.push(...i.scripts));
    return {
      styles: r.map((i) => this.resolveCSS(i)),
      scripts: n.map((i) => this.resolveJS(i))
    };
  }
  /**
   * Get used assets by features object returned by `transform`.
   */
  getUsedAssets(e) {
    const r = this.plugins.map((n) => n.name).filter((n) => e[n]);
    return this.getAssets(r);
  }
};
var tb = class extends Map {
  constructor(e, r = ED) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), e != null) for (const [n, i] of e) this.set(n, i);
  }
  get(e) {
    return super.get(eb(this, e));
  }
  has(e) {
    return super.has(eb(this, e));
  }
  set(e, r) {
    return super.set(AD(this, e), r);
  }
  delete(e) {
    return super.delete($D(this, e));
  }
};
function eb({ _intern: t15, _key: e }, r) {
  const n = e(r);
  return t15.has(n) ? t15.get(n) : r;
}
function AD({ _intern: t15, _key: e }, r) {
  const n = e(r);
  return t15.has(n) ? t15.get(n) : (t15.set(n, r), r);
}
function $D({ _intern: t15, _key: e }, r) {
  const n = e(r);
  return t15.has(n) && (r = t15.get(n), t15.delete(n)), r;
}
function ED(t15) {
  return t15 !== null && typeof t15 == "object" ? t15.valueOf() : t15;
}
function rb(t15, e) {
  let r;
  if (e === void 0)
    for (const n of t15)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t15)
      (i = e(i, ++n, t15)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function nb(t15, e) {
  let r;
  if (e === void 0)
    for (const n of t15)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t15)
      (i = e(i, ++n, t15)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function MD(t15, e) {
  let r, n = -1, i = -1;
  if (e === void 0)
    for (const s of t15)
      ++i, s != null && (r > s || r === void 0 && s >= s) && (r = s, n = i);
  else
    for (let s of t15)
      (s = e(s, ++i, t15)) != null && (r > s || r === void 0 && s >= s) && (r = s, n = i);
  return n;
}
var BD = { value: () => {
} };
function xm() {
  for (var t15 = 0, e = arguments.length, r = {}, n; t15 < e; ++t15) {
    if (!(n = arguments[t15] + "") || n in r || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new Sh(r);
}
function Sh(t15) {
  this._ = t15;
}
function LD(t15, e) {
  return t15.trim().split(/^|\s+/).map(function(r) {
    var n = "", i = r.indexOf(".");
    if (i >= 0 && (n = r.slice(i + 1), r = r.slice(0, i)), r && !e.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
Sh.prototype = xm.prototype = {
  constructor: Sh,
  on: function(t15, e) {
    var r = this._, n = LD(t15 + "", r), i, s = -1, o = n.length;
    if (arguments.length < 2) {
      for (; ++s < o; ) if ((i = (t15 = n[s]).type) && (i = DD(r[i], t15.name))) return i;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++s < o; )
      if (i = (t15 = n[s]).type) r[i] = ib(r[i], t15.name, e);
      else if (e == null) for (i in r) r[i] = ib(r[i], t15.name, null);
    return this;
  },
  copy: function() {
    var t15 = {}, e = this._;
    for (var r in e) t15[r] = e[r].slice();
    return new Sh(t15);
  },
  call: function(t15, e) {
    if ((i = arguments.length - 2) > 0) for (var r = new Array(i), n = 0, i, s; n < i; ++n) r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(t15)) throw new Error("unknown type: " + t15);
    for (s = this._[t15], n = 0, i = s.length; n < i; ++n) s[n].value.apply(e, r);
  },
  apply: function(t15, e, r) {
    if (!this._.hasOwnProperty(t15)) throw new Error("unknown type: " + t15);
    for (var n = this._[t15], i = 0, s = n.length; i < s; ++i) n[i].value.apply(e, r);
  }
};
function DD(t15, e) {
  for (var r = 0, n = t15.length, i; r < n; ++r)
    if ((i = t15[r]).name === e)
      return i.value;
}
function ib(t15, e, r) {
  for (var n = 0, i = t15.length; n < i; ++n)
    if (t15[n].name === e) {
      t15[n] = BD, t15 = t15.slice(0, n).concat(t15.slice(n + 1));
      break;
    }
  return r != null && t15.push({ name: e, value: r }), t15;
}
var yf = "http://www.w3.org/1999/xhtml";
var sb = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: yf,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function y0(t15) {
  var e = t15 += "", r = e.indexOf(":");
  return r >= 0 && (e = t15.slice(0, r)) !== "xmlns" && (t15 = t15.slice(r + 1)), sb.hasOwnProperty(e) ? { space: sb[e], local: t15 } : t15;
}
function FD(t15) {
  return function() {
    var e = this.ownerDocument, r = this.namespaceURI;
    return r === yf && e.documentElement.namespaceURI === yf ? e.createElement(t15) : e.createElementNS(r, t15);
  };
}
function ND(t15) {
  return function() {
    return this.ownerDocument.createElementNS(t15.space, t15.local);
  };
}
function U3(t15) {
  var e = y0(t15);
  return (e.local ? ND : FD)(e);
}
function ID() {
}
function wm(t15) {
  return t15 == null ? ID : function() {
    return this.querySelector(t15);
  };
}
function OD(t15) {
  typeof t15 != "function" && (t15 = wm(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], o = s.length, a = n[i] = new Array(o), l, c, h10 = 0; h10 < o; ++h10)
      (l = s[h10]) && (c = t15.call(l, l.__data__, h10, s)) && ("__data__" in l && (c.__data__ = l.__data__), a[h10] = c);
  return new rn(n, this._parents);
}
function zD(t15) {
  return t15 == null ? [] : Array.isArray(t15) ? t15 : Array.from(t15);
}
function qD() {
  return [];
}
function V3(t15) {
  return t15 == null ? qD : function() {
    return this.querySelectorAll(t15);
  };
}
function RD(t15) {
  return function() {
    return zD(t15.apply(this, arguments));
  };
}
function PD(t15) {
  typeof t15 == "function" ? t15 = RD(t15) : t15 = V3(t15);
  for (var e = this._groups, r = e.length, n = [], i = [], s = 0; s < r; ++s)
    for (var o = e[s], a = o.length, l, c = 0; c < a; ++c)
      (l = o[c]) && (n.push(t15.call(l, l.__data__, c, o)), i.push(l));
  return new rn(n, i);
}
function G3(t15) {
  return function() {
    return this.matches(t15);
  };
}
function X3(t15) {
  return function(e) {
    return e.matches(t15);
  };
}
var jD = Array.prototype.find;
function WD(t15) {
  return function() {
    return jD.call(this.children, t15);
  };
}
function HD() {
  return this.firstElementChild;
}
function UD(t15) {
  return this.select(t15 == null ? HD : WD(typeof t15 == "function" ? t15 : X3(t15)));
}
var VD = Array.prototype.filter;
function GD() {
  return Array.from(this.children);
}
function XD(t15) {
  return function() {
    return VD.call(this.children, t15);
  };
}
function YD(t15) {
  return this.selectAll(t15 == null ? GD : XD(typeof t15 == "function" ? t15 : X3(t15)));
}
function KD(t15) {
  typeof t15 != "function" && (t15 = G3(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], o = s.length, a = n[i] = [], l, c = 0; c < o; ++c)
      (l = s[c]) && t15.call(l, l.__data__, c, s) && a.push(l);
  return new rn(n, this._parents);
}
function Y3(t15) {
  return new Array(t15.length);
}
function ZD() {
  return new rn(this._enter || this._groups.map(Y3), this._parents);
}
function lu(t15, e) {
  this.ownerDocument = t15.ownerDocument, this.namespaceURI = t15.namespaceURI, this._next = null, this._parent = t15, this.__data__ = e;
}
lu.prototype = {
  constructor: lu,
  appendChild: function(t15) {
    return this._parent.insertBefore(t15, this._next);
  },
  insertBefore: function(t15, e) {
    return this._parent.insertBefore(t15, e);
  },
  querySelector: function(t15) {
    return this._parent.querySelector(t15);
  },
  querySelectorAll: function(t15) {
    return this._parent.querySelectorAll(t15);
  }
};
function QD(t15) {
  return function() {
    return t15;
  };
}
function JD(t15, e, r, n, i, s) {
  for (var o = 0, a, l = e.length, c = s.length; o < c; ++o)
    (a = e[o]) ? (a.__data__ = s[o], n[o] = a) : r[o] = new lu(t15, s[o]);
  for (; o < l; ++o)
    (a = e[o]) && (i[o] = a);
}
function tF(t15, e, r, n, i, s, o) {
  var a, l, c = /* @__PURE__ */ new Map(), h10 = e.length, p = s.length, m = new Array(h10), g;
  for (a = 0; a < h10; ++a)
    (l = e[a]) && (m[a] = g = o.call(l, l.__data__, a, e) + "", c.has(g) ? i[a] = l : c.set(g, l));
  for (a = 0; a < p; ++a)
    g = o.call(t15, s[a], a, s) + "", (l = c.get(g)) ? (n[a] = l, l.__data__ = s[a], c.delete(g)) : r[a] = new lu(t15, s[a]);
  for (a = 0; a < h10; ++a)
    (l = e[a]) && c.get(m[a]) === l && (i[a] = l);
}
function eF(t15) {
  return t15.__data__;
}
function rF(t15, e) {
  if (!arguments.length) return Array.from(this, eF);
  var r = e ? tF : JD, n = this._parents, i = this._groups;
  typeof t15 != "function" && (t15 = QD(t15));
  for (var s = i.length, o = new Array(s), a = new Array(s), l = new Array(s), c = 0; c < s; ++c) {
    var h10 = n[c], p = i[c], m = p.length, g = nF(t15.call(h10, h10 && h10.__data__, c, n)), y = g.length, x = a[c] = new Array(y), k = o[c] = new Array(y), C = l[c] = new Array(m);
    r(h10, p, x, k, C, g, e);
    for (var _ = 0, $ = 0, L, B; _ < y; ++_)
      if (L = x[_]) {
        for (_ >= $ && ($ = _ + 1); !(B = k[$]) && ++$ < y; ) ;
        L._next = B || null;
      }
  }
  return o = new rn(o, n), o._enter = a, o._exit = l, o;
}
function nF(t15) {
  return typeof t15 == "object" && "length" in t15 ? t15 : Array.from(t15);
}
function iF() {
  return new rn(this._exit || this._groups.map(Y3), this._parents);
}
function sF(t15, e, r) {
  var n = this.enter(), i = this, s = this.exit();
  return typeof t15 == "function" ? (n = t15(n), n && (n = n.selection())) : n = n.append(t15 + ""), e != null && (i = e(i), i && (i = i.selection())), r == null ? s.remove() : r(s), n && i ? n.merge(i).order() : i;
}
function oF(t15) {
  for (var e = t15.selection ? t15.selection() : t15, r = this._groups, n = e._groups, i = r.length, s = n.length, o = Math.min(i, s), a = new Array(i), l = 0; l < o; ++l)
    for (var c = r[l], h10 = n[l], p = c.length, m = a[l] = new Array(p), g, y = 0; y < p; ++y)
      (g = c[y] || h10[y]) && (m[y] = g);
  for (; l < i; ++l)
    a[l] = r[l];
  return new rn(a, this._parents);
}
function aF() {
  for (var t15 = this._groups, e = -1, r = t15.length; ++e < r; )
    for (var n = t15[e], i = n.length - 1, s = n[i], o; --i >= 0; )
      (o = n[i]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function lF(t15) {
  t15 || (t15 = cF);
  function e(p, m) {
    return p && m ? t15(p.__data__, m.__data__) : !p - !m;
  }
  for (var r = this._groups, n = r.length, i = new Array(n), s = 0; s < n; ++s) {
    for (var o = r[s], a = o.length, l = i[s] = new Array(a), c, h10 = 0; h10 < a; ++h10)
      (c = o[h10]) && (l[h10] = c);
    l.sort(e);
  }
  return new rn(i, this._parents).order();
}
function cF(t15, e) {
  return t15 < e ? -1 : t15 > e ? 1 : t15 >= e ? 0 : NaN;
}
function hF() {
  var t15 = arguments[0];
  return arguments[0] = this, t15.apply(null, arguments), this;
}
function uF() {
  return Array.from(this);
}
function dF() {
  for (var t15 = this._groups, e = 0, r = t15.length; e < r; ++e)
    for (var n = t15[e], i = 0, s = n.length; i < s; ++i) {
      var o = n[i];
      if (o) return o;
    }
  return null;
}
function pF() {
  let t15 = 0;
  for (const e of this) ++t15;
  return t15;
}
function fF() {
  return !this.node();
}
function mF(t15) {
  for (var e = this._groups, r = 0, n = e.length; r < n; ++r)
    for (var i = e[r], s = 0, o = i.length, a; s < o; ++s)
      (a = i[s]) && t15.call(a, a.__data__, s, i);
  return this;
}
function gF(t15) {
  return function() {
    this.removeAttribute(t15);
  };
}
function yF(t15) {
  return function() {
    this.removeAttributeNS(t15.space, t15.local);
  };
}
function bF(t15, e) {
  return function() {
    this.setAttribute(t15, e);
  };
}
function xF(t15, e) {
  return function() {
    this.setAttributeNS(t15.space, t15.local, e);
  };
}
function wF(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttribute(t15) : this.setAttribute(t15, r);
  };
}
function kF(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttributeNS(t15.space, t15.local) : this.setAttributeNS(t15.space, t15.local, r);
  };
}
function vF(t15, e) {
  var r = y0(t15);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((e == null ? r.local ? yF : gF : typeof e == "function" ? r.local ? kF : wF : r.local ? xF : bF)(r, e));
}
function K3(t15) {
  return t15.ownerDocument && t15.ownerDocument.defaultView || t15.document && t15 || t15.defaultView;
}
function _F(t15) {
  return function() {
    this.style.removeProperty(t15);
  };
}
function CF(t15, e, r) {
  return function() {
    this.style.setProperty(t15, e, r);
  };
}
function SF(t15, e, r) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(t15) : this.style.setProperty(t15, n, r);
  };
}
function TF(t15, e, r) {
  return arguments.length > 1 ? this.each((e == null ? _F : typeof e == "function" ? SF : CF)(t15, e, r ?? "")) : Yo(this.node(), t15);
}
function Yo(t15, e) {
  return t15.style.getPropertyValue(e) || K3(t15).getComputedStyle(t15, null).getPropertyValue(e);
}
function AF(t15) {
  return function() {
    delete this[t15];
  };
}
function $F(t15, e) {
  return function() {
    this[t15] = e;
  };
}
function EF(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? delete this[t15] : this[t15] = r;
  };
}
function MF(t15, e) {
  return arguments.length > 1 ? this.each((e == null ? AF : typeof e == "function" ? EF : $F)(t15, e)) : this.node()[t15];
}
function Z3(t15) {
  return t15.trim().split(/^|\s+/);
}
function km(t15) {
  return t15.classList || new Q3(t15);
}
function Q3(t15) {
  this._node = t15, this._names = Z3(t15.getAttribute("class") || "");
}
Q3.prototype = {
  add: function(t15) {
    var e = this._names.indexOf(t15);
    e < 0 && (this._names.push(t15), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t15) {
    var e = this._names.indexOf(t15);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t15) {
    return this._names.indexOf(t15) >= 0;
  }
};
function J3(t15, e) {
  for (var r = km(t15), n = -1, i = e.length; ++n < i; ) r.add(e[n]);
}
function t6(t15, e) {
  for (var r = km(t15), n = -1, i = e.length; ++n < i; ) r.remove(e[n]);
}
function BF(t15) {
  return function() {
    J3(this, t15);
  };
}
function LF(t15) {
  return function() {
    t6(this, t15);
  };
}
function DF(t15, e) {
  return function() {
    (e.apply(this, arguments) ? J3 : t6)(this, t15);
  };
}
function FF(t15, e) {
  var r = Z3(t15 + "");
  if (arguments.length < 2) {
    for (var n = km(this.node()), i = -1, s = r.length; ++i < s; ) if (!n.contains(r[i])) return false;
    return true;
  }
  return this.each((typeof e == "function" ? DF : e ? BF : LF)(r, e));
}
function NF() {
  this.textContent = "";
}
function IF(t15) {
  return function() {
    this.textContent = t15;
  };
}
function OF(t15) {
  return function() {
    var e = t15.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function zF(t15) {
  return arguments.length ? this.each(t15 == null ? NF : (typeof t15 == "function" ? OF : IF)(t15)) : this.node().textContent;
}
function qF() {
  this.innerHTML = "";
}
function RF(t15) {
  return function() {
    this.innerHTML = t15;
  };
}
function PF(t15) {
  return function() {
    var e = t15.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function jF(t15) {
  return arguments.length ? this.each(t15 == null ? qF : (typeof t15 == "function" ? PF : RF)(t15)) : this.node().innerHTML;
}
function WF() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function HF() {
  return this.each(WF);
}
function UF() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function VF() {
  return this.each(UF);
}
function GF(t15) {
  var e = typeof t15 == "function" ? t15 : U3(t15);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function XF() {
  return null;
}
function YF(t15, e) {
  var r = typeof t15 == "function" ? t15 : U3(t15), n = e == null ? XF : typeof e == "function" ? e : wm(e);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function KF() {
  var t15 = this.parentNode;
  t15 && t15.removeChild(this);
}
function ZF() {
  return this.each(KF);
}
function QF() {
  var t15 = this.cloneNode(false), e = this.parentNode;
  return e ? e.insertBefore(t15, this.nextSibling) : t15;
}
function JF() {
  var t15 = this.cloneNode(true), e = this.parentNode;
  return e ? e.insertBefore(t15, this.nextSibling) : t15;
}
function tN(t15) {
  return this.select(t15 ? JF : QF);
}
function eN(t15) {
  return arguments.length ? this.property("__data__", t15) : this.node().__data__;
}
function rN(t15) {
  return function(e) {
    t15.call(this, e, this.__data__);
  };
}
function nN(t15) {
  return t15.trim().split(/^|\s+/).map(function(e) {
    var r = "", n = e.indexOf(".");
    return n >= 0 && (r = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: r };
  });
}
function iN(t15) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var r = 0, n = -1, i = e.length, s; r < i; ++r)
        s = e[r], (!t15.type || s.type === t15.type) && s.name === t15.name ? this.removeEventListener(s.type, s.listener, s.options) : e[++n] = s;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function sN(t15, e, r) {
  return function() {
    var n = this.__on, i, s = rN(e);
    if (n) {
      for (var o = 0, a = n.length; o < a; ++o)
        if ((i = n[o]).type === t15.type && i.name === t15.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = r), i.value = e;
          return;
        }
    }
    this.addEventListener(t15.type, s, r), i = { type: t15.type, name: t15.name, value: e, listener: s, options: r }, n ? n.push(i) : this.__on = [i];
  };
}
function oN(t15, e, r) {
  var n = nN(t15 + ""), i, s = n.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, c = a.length, h10; l < c; ++l)
        for (i = 0, h10 = a[l]; i < s; ++i)
          if ((o = n[i]).type === h10.type && o.name === h10.name)
            return h10.value;
    }
    return;
  }
  for (a = e ? sN : iN, i = 0; i < s; ++i) this.each(a(n[i], e, r));
  return this;
}
function e6(t15, e, r) {
  var n = K3(t15), i = n.CustomEvent;
  typeof i == "function" ? i = new i(e, r) : (i = n.document.createEvent("Event"), r ? (i.initEvent(e, r.bubbles, r.cancelable), i.detail = r.detail) : i.initEvent(e, false, false)), t15.dispatchEvent(i);
}
function aN(t15, e) {
  return function() {
    return e6(this, t15, e);
  };
}
function lN(t15, e) {
  return function() {
    return e6(this, t15, e.apply(this, arguments));
  };
}
function cN(t15, e) {
  return this.each((typeof e == "function" ? lN : aN)(t15, e));
}
function* hN() {
  for (var t15 = this._groups, e = 0, r = t15.length; e < r; ++e)
    for (var n = t15[e], i = 0, s = n.length, o; i < s; ++i)
      (o = n[i]) && (yield o);
}
var r6 = [null];
function rn(t15, e) {
  this._groups = t15, this._parents = e;
}
function ac() {
  return new rn([[document.documentElement]], r6);
}
function uN() {
  return this;
}
rn.prototype = ac.prototype = {
  constructor: rn,
  select: OD,
  selectAll: PD,
  selectChild: UD,
  selectChildren: YD,
  filter: KD,
  data: rF,
  enter: ZD,
  exit: iF,
  join: sF,
  merge: oF,
  selection: uN,
  order: aF,
  sort: lF,
  call: hF,
  nodes: uF,
  node: dF,
  size: pF,
  empty: fF,
  each: mF,
  attr: vF,
  style: TF,
  property: MF,
  classed: FF,
  text: zF,
  html: jF,
  raise: HF,
  lower: VF,
  append: GF,
  insert: YF,
  remove: ZF,
  clone: tN,
  datum: eN,
  on: oN,
  dispatch: cN,
  [Symbol.iterator]: hN
};
function es(t15) {
  return typeof t15 == "string" ? new rn([[document.querySelector(t15)]], [document.documentElement]) : new rn([[t15]], r6);
}
function dN(t15) {
  let e;
  for (; e = t15.sourceEvent; ) t15 = e;
  return t15;
}
function $s(t15, e) {
  if (t15 = dN(t15), e === void 0 && (e = t15.currentTarget), e) {
    var r = e.ownerSVGElement || e;
    if (r.createSVGPoint) {
      var n = r.createSVGPoint();
      return n.x = t15.clientX, n.y = t15.clientY, n = n.matrixTransform(e.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (e.getBoundingClientRect) {
      var i = e.getBoundingClientRect();
      return [t15.clientX - i.left - e.clientLeft, t15.clientY - i.top - e.clientTop];
    }
  }
  return [t15.pageX, t15.pageY];
}
var bf = { capture: true, passive: false };
function xf(t15) {
  t15.preventDefault(), t15.stopImmediatePropagation();
}
function pN(t15) {
  var e = t15.document.documentElement, r = es(t15).on("dragstart.drag", xf, bf);
  "onselectstart" in e ? r.on("selectstart.drag", xf, bf) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function fN(t15, e) {
  var r = t15.document.documentElement, n = es(t15).on("dragstart.drag", null);
  e && (n.on("click.drag", xf, bf), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in r ? n.on("selectstart.drag", null) : (r.style.MozUserSelect = r.__noselect, delete r.__noselect);
}
function vm(t15, e, r) {
  t15.prototype = e.prototype = r, r.constructor = t15;
}
function n6(t15, e) {
  var r = Object.create(t15.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function lc() {
}
var Nl = 0.7;
var cu = 1 / Nl;
var zo = "\\s*([+-]?\\d+)\\s*";
var Il = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var Qn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var mN = /^#([0-9a-f]{3,8})$/;
var gN = new RegExp(`^rgb\\(${zo},${zo},${zo}\\)$`);
var yN = new RegExp(`^rgb\\(${Qn},${Qn},${Qn}\\)$`);
var bN = new RegExp(`^rgba\\(${zo},${zo},${zo},${Il}\\)$`);
var xN = new RegExp(`^rgba\\(${Qn},${Qn},${Qn},${Il}\\)$`);
var wN = new RegExp(`^hsl\\(${Il},${Qn},${Qn}\\)$`);
var kN = new RegExp(`^hsla\\(${Il},${Qn},${Qn},${Il}\\)$`);
var ob = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
vm(lc, Ol, {
  copy(t15) {
    return Object.assign(new this.constructor(), this, t15);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: ab,
  // Deprecated! Use color.formatHex.
  formatHex: ab,
  formatHex8: vN,
  formatHsl: _N,
  formatRgb: lb,
  toString: lb
});
function ab() {
  return this.rgb().formatHex();
}
function vN() {
  return this.rgb().formatHex8();
}
function _N() {
  return i6(this).formatHsl();
}
function lb() {
  return this.rgb().formatRgb();
}
function Ol(t15) {
  var e, r;
  return t15 = (t15 + "").trim().toLowerCase(), (e = mN.exec(t15)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? cb(e) : r === 3 ? new Hr(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? th(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? th(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = gN.exec(t15)) ? new Hr(e[1], e[2], e[3], 1) : (e = yN.exec(t15)) ? new Hr(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = bN.exec(t15)) ? th(e[1], e[2], e[3], e[4]) : (e = xN.exec(t15)) ? th(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = wN.exec(t15)) ? db(e[1], e[2] / 100, e[3] / 100, 1) : (e = kN.exec(t15)) ? db(e[1], e[2] / 100, e[3] / 100, e[4]) : ob.hasOwnProperty(t15) ? cb(ob[t15]) : t15 === "transparent" ? new Hr(NaN, NaN, NaN, 0) : null;
}
function cb(t15) {
  return new Hr(t15 >> 16 & 255, t15 >> 8 & 255, t15 & 255, 1);
}
function th(t15, e, r, n) {
  return n <= 0 && (t15 = e = r = NaN), new Hr(t15, e, r, n);
}
function CN(t15) {
  return t15 instanceof lc || (t15 = Ol(t15)), t15 ? (t15 = t15.rgb(), new Hr(t15.r, t15.g, t15.b, t15.opacity)) : new Hr();
}
function wf(t15, e, r, n) {
  return arguments.length === 1 ? CN(t15) : new Hr(t15, e, r, n ?? 1);
}
function Hr(t15, e, r, n) {
  this.r = +t15, this.g = +e, this.b = +r, this.opacity = +n;
}
vm(Hr, wf, n6(lc, {
  brighter(t15) {
    return t15 = t15 == null ? cu : Math.pow(cu, t15), new Hr(this.r * t15, this.g * t15, this.b * t15, this.opacity);
  },
  darker(t15) {
    return t15 = t15 == null ? Nl : Math.pow(Nl, t15), new Hr(this.r * t15, this.g * t15, this.b * t15, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Hr(Vs(this.r), Vs(this.g), Vs(this.b), hu(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: hb,
  // Deprecated! Use color.formatHex.
  formatHex: hb,
  formatHex8: SN,
  formatRgb: ub,
  toString: ub
}));
function hb() {
  return `#${Rs(this.r)}${Rs(this.g)}${Rs(this.b)}`;
}
function SN() {
  return `#${Rs(this.r)}${Rs(this.g)}${Rs(this.b)}${Rs((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function ub() {
  const t15 = hu(this.opacity);
  return `${t15 === 1 ? "rgb(" : "rgba("}${Vs(this.r)}, ${Vs(this.g)}, ${Vs(this.b)}${t15 === 1 ? ")" : `, ${t15})`}`;
}
function hu(t15) {
  return isNaN(t15) ? 1 : Math.max(0, Math.min(1, t15));
}
function Vs(t15) {
  return Math.max(0, Math.min(255, Math.round(t15) || 0));
}
function Rs(t15) {
  return t15 = Vs(t15), (t15 < 16 ? "0" : "") + t15.toString(16);
}
function db(t15, e, r, n) {
  return n <= 0 ? t15 = e = r = NaN : r <= 0 || r >= 1 ? t15 = e = NaN : e <= 0 && (t15 = NaN), new Sn(t15, e, r, n);
}
function i6(t15) {
  if (t15 instanceof Sn) return new Sn(t15.h, t15.s, t15.l, t15.opacity);
  if (t15 instanceof lc || (t15 = Ol(t15)), !t15) return new Sn();
  if (t15 instanceof Sn) return t15;
  t15 = t15.rgb();
  var e = t15.r / 255, r = t15.g / 255, n = t15.b / 255, i = Math.min(e, r, n), s = Math.max(e, r, n), o = NaN, a = s - i, l = (s + i) / 2;
  return a ? (e === s ? o = (r - n) / a + (r < n) * 6 : r === s ? o = (n - e) / a + 2 : o = (e - r) / a + 4, a /= l < 0.5 ? s + i : 2 - s - i, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new Sn(o, a, l, t15.opacity);
}
function TN(t15, e, r, n) {
  return arguments.length === 1 ? i6(t15) : new Sn(t15, e, r, n ?? 1);
}
function Sn(t15, e, r, n) {
  this.h = +t15, this.s = +e, this.l = +r, this.opacity = +n;
}
vm(Sn, TN, n6(lc, {
  brighter(t15) {
    return t15 = t15 == null ? cu : Math.pow(cu, t15), new Sn(this.h, this.s, this.l * t15, this.opacity);
  },
  darker(t15) {
    return t15 = t15 == null ? Nl : Math.pow(Nl, t15), new Sn(this.h, this.s, this.l * t15, this.opacity);
  },
  rgb() {
    var t15 = this.h % 360 + (this.h < 0) * 360, e = isNaN(t15) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new Hr(
      ep(t15 >= 240 ? t15 - 240 : t15 + 120, i, n),
      ep(t15, i, n),
      ep(t15 < 120 ? t15 + 240 : t15 - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new Sn(pb(this.h), eh(this.s), eh(this.l), hu(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t15 = hu(this.opacity);
    return `${t15 === 1 ? "hsl(" : "hsla("}${pb(this.h)}, ${eh(this.s) * 100}%, ${eh(this.l) * 100}%${t15 === 1 ? ")" : `, ${t15})`}`;
  }
}));
function pb(t15) {
  return t15 = (t15 || 0) % 360, t15 < 0 ? t15 + 360 : t15;
}
function eh(t15) {
  return Math.max(0, Math.min(1, t15 || 0));
}
function ep(t15, e, r) {
  return (t15 < 60 ? e + (r - e) * t15 / 60 : t15 < 180 ? r : t15 < 240 ? e + (r - e) * (240 - t15) / 60 : e) * 255;
}
var s6 = (t15) => () => t15;
function AN(t15, e) {
  return function(r) {
    return t15 + r * e;
  };
}
function $N(t15, e, r) {
  return t15 = Math.pow(t15, r), e = Math.pow(e, r) - t15, r = 1 / r, function(n) {
    return Math.pow(t15 + n * e, r);
  };
}
function EN(t15) {
  return (t15 = +t15) == 1 ? o6 : function(e, r) {
    return r - e ? $N(e, r, t15) : s6(isNaN(e) ? r : e);
  };
}
function o6(t15, e) {
  var r = e - t15;
  return r ? AN(t15, r) : s6(isNaN(t15) ? e : t15);
}
var fb = function t(e) {
  var r = EN(e);
  function n(i, s) {
    var o = r((i = wf(i)).r, (s = wf(s)).r), a = r(i.g, s.g), l = r(i.b, s.b), c = o6(i.opacity, s.opacity);
    return function(h10) {
      return i.r = o(h10), i.g = a(h10), i.b = l(h10), i.opacity = c(h10), i + "";
    };
  }
  return n.gamma = t, n;
}(1);
function Qi(t15, e) {
  return t15 = +t15, e = +e, function(r) {
    return t15 * (1 - r) + e * r;
  };
}
var kf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var rp = new RegExp(kf.source, "g");
function MN(t15) {
  return function() {
    return t15;
  };
}
function BN(t15) {
  return function(e) {
    return t15(e) + "";
  };
}
function LN(t15, e) {
  var r = kf.lastIndex = rp.lastIndex = 0, n, i, s, o = -1, a = [], l = [];
  for (t15 = t15 + "", e = e + ""; (n = kf.exec(t15)) && (i = rp.exec(e)); )
    (s = i.index) > r && (s = e.slice(r, s), a[o] ? a[o] += s : a[++o] = s), (n = n[0]) === (i = i[0]) ? a[o] ? a[o] += i : a[++o] = i : (a[++o] = null, l.push({ i: o, x: Qi(n, i) })), r = rp.lastIndex;
  return r < e.length && (s = e.slice(r), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? BN(l[0].x) : MN(e) : (e = l.length, function(c) {
    for (var h10 = 0, p; h10 < e; ++h10) a[(p = l[h10]).i] = p.x(c);
    return a.join("");
  });
}
var mb = 180 / Math.PI;
var a6 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function l6(t15, e, r, n, i, s) {
  var o, a, l;
  return (o = Math.sqrt(t15 * t15 + e * e)) && (t15 /= o, e /= o), (l = t15 * r + e * n) && (r -= t15 * l, n -= e * l), (a = Math.sqrt(r * r + n * n)) && (r /= a, n /= a, l /= a), t15 * n < e * r && (t15 = -t15, e = -e, l = -l, o = -o), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(e, t15) * mb,
    skewX: Math.atan(l) * mb,
    scaleX: o,
    scaleY: a
  };
}
var rh;
function DN(t15) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t15 + "");
  return e.isIdentity ? a6 : l6(e.a, e.b, e.c, e.d, e.e, e.f);
}
function FN(t15) {
  return t15 == null || (rh || (rh = document.createElementNS("http://www.w3.org/2000/svg", "g")), rh.setAttribute("transform", t15), !(t15 = rh.transform.baseVal.consolidate())) ? a6 : (t15 = t15.matrix, l6(t15.a, t15.b, t15.c, t15.d, t15.e, t15.f));
}
function c6(t15, e, r, n) {
  function i(c) {
    return c.length ? c.pop() + " " : "";
  }
  function s(c, h10, p, m, g, y) {
    if (c !== p || h10 !== m) {
      var x = g.push("translate(", null, e, null, r);
      y.push({ i: x - 4, x: Qi(c, p) }, { i: x - 2, x: Qi(h10, m) });
    } else (p || m) && g.push("translate(" + p + e + m + r);
  }
  function o(c, h10, p, m) {
    c !== h10 ? (c - h10 > 180 ? h10 += 360 : h10 - c > 180 && (c += 360), m.push({ i: p.push(i(p) + "rotate(", null, n) - 2, x: Qi(c, h10) })) : h10 && p.push(i(p) + "rotate(" + h10 + n);
  }
  function a(c, h10, p, m) {
    c !== h10 ? m.push({ i: p.push(i(p) + "skewX(", null, n) - 2, x: Qi(c, h10) }) : h10 && p.push(i(p) + "skewX(" + h10 + n);
  }
  function l(c, h10, p, m, g, y) {
    if (c !== p || h10 !== m) {
      var x = g.push(i(g) + "scale(", null, ",", null, ")");
      y.push({ i: x - 4, x: Qi(c, p) }, { i: x - 2, x: Qi(h10, m) });
    } else (p !== 1 || m !== 1) && g.push(i(g) + "scale(" + p + "," + m + ")");
  }
  return function(c, h10) {
    var p = [], m = [];
    return c = t15(c), h10 = t15(h10), s(c.translateX, c.translateY, h10.translateX, h10.translateY, p, m), o(c.rotate, h10.rotate, p, m), a(c.skewX, h10.skewX, p, m), l(c.scaleX, c.scaleY, h10.scaleX, h10.scaleY, p, m), c = h10 = null, function(g) {
      for (var y = -1, x = m.length, k; ++y < x; ) p[(k = m[y]).i] = k.x(g);
      return p.join("");
    };
  };
}
var NN = c6(DN, "px, ", "px)", "deg)");
var IN = c6(FN, ", ", ")", ")");
var ON = 1e-12;
function gb(t15) {
  return ((t15 = Math.exp(t15)) + 1 / t15) / 2;
}
function zN(t15) {
  return ((t15 = Math.exp(t15)) - 1 / t15) / 2;
}
function qN(t15) {
  return ((t15 = Math.exp(2 * t15)) - 1) / (t15 + 1);
}
var RN = function t4(e, r, n) {
  function i(s, o) {
    var a = s[0], l = s[1], c = s[2], h10 = o[0], p = o[1], m = o[2], g = h10 - a, y = p - l, x = g * g + y * y, k, C;
    if (x < ON)
      C = Math.log(m / c) / e, k = function(H) {
        return [
          a + H * g,
          l + H * y,
          c * Math.exp(e * H * C)
        ];
      };
    else {
      var _ = Math.sqrt(x), $ = (m * m - c * c + n * x) / (2 * c * r * _), L = (m * m - c * c - n * x) / (2 * m * r * _), B = Math.log(Math.sqrt($ * $ + 1) - $), q = Math.log(Math.sqrt(L * L + 1) - L);
      C = (q - B) / e, k = function(H) {
        var G = H * C, F = gb(B), W = c / (r * _) * (F * qN(e * G + B) - zN(B));
        return [
          a + W * g,
          l + W * y,
          c * F / gb(e * G + B)
        ];
      };
    }
    return k.duration = C * 1e3 * e / Math.SQRT2, k;
  }
  return i.rho = function(s) {
    var o = Math.max(1e-3, +s), a = o * o, l = a * a;
    return t4(o, a, l);
  }, i;
}(Math.SQRT2, 2, 4);
var Ko = 0;
var il = 0;
var Ia = 0;
var h6 = 1e3;
var uu;
var sl;
var du = 0;
var Qs = 0;
var b0 = 0;
var zl = typeof performance == "object" && performance.now ? performance : Date;
var u6 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t15) {
  setTimeout(t15, 17);
};
function _m() {
  return Qs || (u6(PN), Qs = zl.now() + b0);
}
function PN() {
  Qs = 0;
}
function pu() {
  this._call = this._time = this._next = null;
}
pu.prototype = d6.prototype = {
  constructor: pu,
  restart: function(t15, e, r) {
    if (typeof t15 != "function") throw new TypeError("callback is not a function");
    r = (r == null ? _m() : +r) + (e == null ? 0 : +e), !this._next && sl !== this && (sl ? sl._next = this : uu = this, sl = this), this._call = t15, this._time = r, vf();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, vf());
  }
};
function d6(t15, e, r) {
  var n = new pu();
  return n.restart(t15, e, r), n;
}
function jN() {
  _m(), ++Ko;
  for (var t15 = uu, e; t15; )
    (e = Qs - t15._time) >= 0 && t15._call.call(void 0, e), t15 = t15._next;
  --Ko;
}
function yb() {
  Qs = (du = zl.now()) + b0, Ko = il = 0;
  try {
    jN();
  } finally {
    Ko = 0, HN(), Qs = 0;
  }
}
function WN() {
  var t15 = zl.now(), e = t15 - du;
  e > h6 && (b0 -= e, du = t15);
}
function HN() {
  for (var t15, e = uu, r, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), t15 = e, e = e._next) : (r = e._next, e._next = null, e = t15 ? t15._next = r : uu = r);
  sl = t15, vf(n);
}
function vf(t15) {
  if (!Ko) {
    il && (il = clearTimeout(il));
    var e = t15 - Qs;
    e > 24 ? (t15 < 1 / 0 && (il = setTimeout(yb, t15 - zl.now() - b0)), Ia && (Ia = clearInterval(Ia))) : (Ia || (du = zl.now(), Ia = setInterval(WN, h6)), Ko = 1, u6(yb));
  }
}
function bb(t15, e, r) {
  var n = new pu();
  return e = e == null ? 0 : +e, n.restart((i) => {
    n.stop(), t15(i + e);
  }, e, r), n;
}
var UN = xm("start", "end", "cancel", "interrupt");
var VN = [];
var p6 = 0;
var xb = 1;
var _f = 2;
var Th = 3;
var wb = 4;
var Cf = 5;
var Ah = 6;
function x0(t15, e, r, n, i, s) {
  var o = t15.__transition;
  if (!o) t15.__transition = {};
  else if (r in o) return;
  GN(t15, r, {
    name: e,
    index: n,
    // For context during callback.
    group: i,
    // For context during callback.
    on: UN,
    tween: VN,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: p6
  });
}
function Cm(t15, e) {
  var r = Dn(t15, e);
  if (r.state > p6) throw new Error("too late; already scheduled");
  return r;
}
function oi(t15, e) {
  var r = Dn(t15, e);
  if (r.state > Th) throw new Error("too late; already running");
  return r;
}
function Dn(t15, e) {
  var r = t15.__transition;
  if (!r || !(r = r[e])) throw new Error("transition not found");
  return r;
}
function GN(t15, e, r) {
  var n = t15.__transition, i;
  n[e] = r, r.timer = d6(s, 0, r.time);
  function s(c) {
    r.state = xb, r.timer.restart(o, r.delay, r.time), r.delay <= c && o(c - r.delay);
  }
  function o(c) {
    var h10, p, m, g;
    if (r.state !== xb) return l();
    for (h10 in n)
      if (g = n[h10], g.name === r.name) {
        if (g.state === Th) return bb(o);
        g.state === wb ? (g.state = Ah, g.timer.stop(), g.on.call("interrupt", t15, t15.__data__, g.index, g.group), delete n[h10]) : +h10 < e && (g.state = Ah, g.timer.stop(), g.on.call("cancel", t15, t15.__data__, g.index, g.group), delete n[h10]);
      }
    if (bb(function() {
      r.state === Th && (r.state = wb, r.timer.restart(a, r.delay, r.time), a(c));
    }), r.state = _f, r.on.call("start", t15, t15.__data__, r.index, r.group), r.state === _f) {
      for (r.state = Th, i = new Array(m = r.tween.length), h10 = 0, p = -1; h10 < m; ++h10)
        (g = r.tween[h10].value.call(t15, t15.__data__, r.index, r.group)) && (i[++p] = g);
      i.length = p + 1;
    }
  }
  function a(c) {
    for (var h10 = c < r.duration ? r.ease.call(null, c / r.duration) : (r.timer.restart(l), r.state = Cf, 1), p = -1, m = i.length; ++p < m; )
      i[p].call(t15, h10);
    r.state === Cf && (r.on.call("end", t15, t15.__data__, r.index, r.group), l());
  }
  function l() {
    r.state = Ah, r.timer.stop(), delete n[e];
    for (var c in n) return;
    delete t15.__transition;
  }
}
function $h(t15, e) {
  var r = t15.__transition, n, i, s = true, o;
  if (r) {
    e = e == null ? null : e + "";
    for (o in r) {
      if ((n = r[o]).name !== e) {
        s = false;
        continue;
      }
      i = n.state > _f && n.state < Cf, n.state = Ah, n.timer.stop(), n.on.call(i ? "interrupt" : "cancel", t15, t15.__data__, n.index, n.group), delete r[o];
    }
    s && delete t15.__transition;
  }
}
function XN(t15) {
  return this.each(function() {
    $h(this, t15);
  });
}
function YN(t15, e) {
  var r, n;
  return function() {
    var i = oi(this, t15), s = i.tween;
    if (s !== r) {
      n = r = s;
      for (var o = 0, a = n.length; o < a; ++o)
        if (n[o].name === e) {
          n = n.slice(), n.splice(o, 1);
          break;
        }
    }
    i.tween = n;
  };
}
function KN(t15, e, r) {
  var n, i;
  if (typeof r != "function") throw new Error();
  return function() {
    var s = oi(this, t15), o = s.tween;
    if (o !== n) {
      i = (n = o).slice();
      for (var a = { name: e, value: r }, l = 0, c = i.length; l < c; ++l)
        if (i[l].name === e) {
          i[l] = a;
          break;
        }
      l === c && i.push(a);
    }
    s.tween = i;
  };
}
function ZN(t15, e) {
  var r = this._id;
  if (t15 += "", arguments.length < 2) {
    for (var n = Dn(this.node(), r).tween, i = 0, s = n.length, o; i < s; ++i)
      if ((o = n[i]).name === t15)
        return o.value;
    return null;
  }
  return this.each((e == null ? YN : KN)(r, t15, e));
}
function Sm(t15, e, r) {
  var n = t15._id;
  return t15.each(function() {
    var i = oi(this, n);
    (i.value || (i.value = {}))[e] = r.apply(this, arguments);
  }), function(i) {
    return Dn(i, n).value[e];
  };
}
function f6(t15, e) {
  var r;
  return (typeof e == "number" ? Qi : e instanceof Ol ? fb : (r = Ol(e)) ? (e = r, fb) : LN)(t15, e);
}
function QN(t15) {
  return function() {
    this.removeAttribute(t15);
  };
}
function JN(t15) {
  return function() {
    this.removeAttributeNS(t15.space, t15.local);
  };
}
function tI(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var o = this.getAttribute(t15);
    return o === i ? null : o === n ? s : s = e(n = o, r);
  };
}
function eI(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var o = this.getAttributeNS(t15.space, t15.local);
    return o === i ? null : o === n ? s : s = e(n = o, r);
  };
}
function rI(t15, e, r) {
  var n, i, s;
  return function() {
    var o, a = r(this), l;
    return a == null ? void this.removeAttribute(t15) : (o = this.getAttribute(t15), l = a + "", o === l ? null : o === n && l === i ? s : (i = l, s = e(n = o, a)));
  };
}
function nI(t15, e, r) {
  var n, i, s;
  return function() {
    var o, a = r(this), l;
    return a == null ? void this.removeAttributeNS(t15.space, t15.local) : (o = this.getAttributeNS(t15.space, t15.local), l = a + "", o === l ? null : o === n && l === i ? s : (i = l, s = e(n = o, a)));
  };
}
function iI(t15, e) {
  var r = y0(t15), n = r === "transform" ? IN : f6;
  return this.attrTween(t15, typeof e == "function" ? (r.local ? nI : rI)(r, n, Sm(this, "attr." + t15, e)) : e == null ? (r.local ? JN : QN)(r) : (r.local ? eI : tI)(r, n, e));
}
function sI(t15, e) {
  return function(r) {
    this.setAttribute(t15, e.call(this, r));
  };
}
function oI(t15, e) {
  return function(r) {
    this.setAttributeNS(t15.space, t15.local, e.call(this, r));
  };
}
function aI(t15, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && oI(t15, s)), r;
  }
  return i._value = e, i;
}
function lI(t15, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && sI(t15, s)), r;
  }
  return i._value = e, i;
}
function cI(t15, e) {
  var r = "attr." + t15;
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (e == null) return this.tween(r, null);
  if (typeof e != "function") throw new Error();
  var n = y0(t15);
  return this.tween(r, (n.local ? aI : lI)(n, e));
}
function hI(t15, e) {
  return function() {
    Cm(this, t15).delay = +e.apply(this, arguments);
  };
}
function uI(t15, e) {
  return e = +e, function() {
    Cm(this, t15).delay = e;
  };
}
function dI(t15) {
  var e = this._id;
  return arguments.length ? this.each((typeof t15 == "function" ? hI : uI)(e, t15)) : Dn(this.node(), e).delay;
}
function pI(t15, e) {
  return function() {
    oi(this, t15).duration = +e.apply(this, arguments);
  };
}
function fI(t15, e) {
  return e = +e, function() {
    oi(this, t15).duration = e;
  };
}
function mI(t15) {
  var e = this._id;
  return arguments.length ? this.each((typeof t15 == "function" ? pI : fI)(e, t15)) : Dn(this.node(), e).duration;
}
function gI(t15, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    oi(this, t15).ease = e;
  };
}
function yI(t15) {
  var e = this._id;
  return arguments.length ? this.each(gI(e, t15)) : Dn(this.node(), e).ease;
}
function bI(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    if (typeof r != "function") throw new Error();
    oi(this, t15).ease = r;
  };
}
function xI(t15) {
  if (typeof t15 != "function") throw new Error();
  return this.each(bI(this._id, t15));
}
function wI(t15) {
  typeof t15 != "function" && (t15 = G3(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], o = s.length, a = n[i] = [], l, c = 0; c < o; ++c)
      (l = s[c]) && t15.call(l, l.__data__, c, s) && a.push(l);
  return new Fi(n, this._parents, this._name, this._id);
}
function kI(t15) {
  if (t15._id !== this._id) throw new Error();
  for (var e = this._groups, r = t15._groups, n = e.length, i = r.length, s = Math.min(n, i), o = new Array(n), a = 0; a < s; ++a)
    for (var l = e[a], c = r[a], h10 = l.length, p = o[a] = new Array(h10), m, g = 0; g < h10; ++g)
      (m = l[g] || c[g]) && (p[g] = m);
  for (; a < n; ++a)
    o[a] = e[a];
  return new Fi(o, this._parents, this._name, this._id);
}
function vI(t15) {
  return (t15 + "").trim().split(/^|\s+/).every(function(e) {
    var r = e.indexOf(".");
    return r >= 0 && (e = e.slice(0, r)), !e || e === "start";
  });
}
function _I(t15, e, r) {
  var n, i, s = vI(e) ? Cm : oi;
  return function() {
    var o = s(this, t15), a = o.on;
    a !== n && (i = (n = a).copy()).on(e, r), o.on = i;
  };
}
function CI(t15, e) {
  var r = this._id;
  return arguments.length < 2 ? Dn(this.node(), r).on.on(t15) : this.each(_I(r, t15, e));
}
function SI(t15) {
  return function() {
    var e = this.parentNode;
    for (var r in this.__transition) if (+r !== t15) return;
    e && e.removeChild(this);
  };
}
function TI() {
  return this.on("end.remove", SI(this._id));
}
function AI(t15) {
  var e = this._name, r = this._id;
  typeof t15 != "function" && (t15 = wm(t15));
  for (var n = this._groups, i = n.length, s = new Array(i), o = 0; o < i; ++o)
    for (var a = n[o], l = a.length, c = s[o] = new Array(l), h10, p, m = 0; m < l; ++m)
      (h10 = a[m]) && (p = t15.call(h10, h10.__data__, m, a)) && ("__data__" in h10 && (p.__data__ = h10.__data__), c[m] = p, x0(c[m], e, r, m, c, Dn(h10, r)));
  return new Fi(s, this._parents, e, r);
}
function $I(t15) {
  var e = this._name, r = this._id;
  typeof t15 != "function" && (t15 = V3(t15));
  for (var n = this._groups, i = n.length, s = [], o = [], a = 0; a < i; ++a)
    for (var l = n[a], c = l.length, h10, p = 0; p < c; ++p)
      if (h10 = l[p]) {
        for (var m = t15.call(h10, h10.__data__, p, l), g, y = Dn(h10, r), x = 0, k = m.length; x < k; ++x)
          (g = m[x]) && x0(g, e, r, x, m, y);
        s.push(m), o.push(h10);
      }
  return new Fi(s, o, e, r);
}
var EI = ac.prototype.constructor;
function MI() {
  return new EI(this._groups, this._parents);
}
function BI(t15, e) {
  var r, n, i;
  return function() {
    var s = Yo(this, t15), o = (this.style.removeProperty(t15), Yo(this, t15));
    return s === o ? null : s === r && o === n ? i : i = e(r = s, n = o);
  };
}
function m6(t15) {
  return function() {
    this.style.removeProperty(t15);
  };
}
function LI(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var o = Yo(this, t15);
    return o === i ? null : o === n ? s : s = e(n = o, r);
  };
}
function DI(t15, e, r) {
  var n, i, s;
  return function() {
    var o = Yo(this, t15), a = r(this), l = a + "";
    return a == null && (l = a = (this.style.removeProperty(t15), Yo(this, t15))), o === l ? null : o === n && l === i ? s : (i = l, s = e(n = o, a));
  };
}
function FI(t15, e) {
  var r, n, i, s = "style." + e, o = "end." + s, a;
  return function() {
    var l = oi(this, t15), c = l.on, h10 = l.value[s] == null ? a || (a = m6(e)) : void 0;
    (c !== r || i !== h10) && (n = (r = c).copy()).on(o, i = h10), l.on = n;
  };
}
function NI(t15, e, r) {
  var n = (t15 += "") == "transform" ? NN : f6;
  return e == null ? this.styleTween(t15, BI(t15, n)).on("end.style." + t15, m6(t15)) : typeof e == "function" ? this.styleTween(t15, DI(t15, n, Sm(this, "style." + t15, e))).each(FI(this._id, t15)) : this.styleTween(t15, LI(t15, n, e), r).on("end.style." + t15, null);
}
function II(t15, e, r) {
  return function(n) {
    this.style.setProperty(t15, e.call(this, n), r);
  };
}
function OI(t15, e, r) {
  var n, i;
  function s() {
    var o = e.apply(this, arguments);
    return o !== i && (n = (i = o) && II(t15, o, r)), n;
  }
  return s._value = e, s;
}
function zI(t15, e, r) {
  var n = "style." + (t15 += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, OI(t15, e, r ?? ""));
}
function qI(t15) {
  return function() {
    this.textContent = t15;
  };
}
function RI(t15) {
  return function() {
    var e = t15(this);
    this.textContent = e ?? "";
  };
}
function PI(t15) {
  return this.tween("text", typeof t15 == "function" ? RI(Sm(this, "text", t15)) : qI(t15 == null ? "" : t15 + ""));
}
function jI(t15) {
  return function(e) {
    this.textContent = t15.call(this, e);
  };
}
function WI(t15) {
  var e, r;
  function n() {
    var i = t15.apply(this, arguments);
    return i !== r && (e = (r = i) && jI(i)), e;
  }
  return n._value = t15, n;
}
function HI(t15) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t15 == null) return this.tween(e, null);
  if (typeof t15 != "function") throw new Error();
  return this.tween(e, WI(t15));
}
function UI() {
  for (var t15 = this._name, e = this._id, r = g6(), n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var o = n[s], a = o.length, l, c = 0; c < a; ++c)
      if (l = o[c]) {
        var h10 = Dn(l, e);
        x0(l, t15, r, c, o, {
          time: h10.time + h10.delay + h10.duration,
          delay: 0,
          duration: h10.duration,
          ease: h10.ease
        });
      }
  return new Fi(n, this._parents, t15, r);
}
function VI() {
  var t15, e, r = this, n = r._id, i = r.size();
  return new Promise(function(s, o) {
    var a = { value: o }, l = { value: function() {
      --i === 0 && s();
    } };
    r.each(function() {
      var c = oi(this, n), h10 = c.on;
      h10 !== t15 && (e = (t15 = h10).copy(), e._.cancel.push(a), e._.interrupt.push(a), e._.end.push(l)), c.on = e;
    }), i === 0 && s();
  });
}
var GI = 0;
function Fi(t15, e, r, n) {
  this._groups = t15, this._parents = e, this._name = r, this._id = n;
}
function g6() {
  return ++GI;
}
var yi = ac.prototype;
Fi.prototype = {
  constructor: Fi,
  select: AI,
  selectAll: $I,
  selectChild: yi.selectChild,
  selectChildren: yi.selectChildren,
  filter: wI,
  merge: kI,
  selection: MI,
  transition: UI,
  call: yi.call,
  nodes: yi.nodes,
  node: yi.node,
  size: yi.size,
  empty: yi.empty,
  each: yi.each,
  on: CI,
  attr: iI,
  attrTween: cI,
  style: NI,
  styleTween: zI,
  text: PI,
  textTween: HI,
  remove: TI,
  tween: ZN,
  delay: dI,
  duration: mI,
  ease: yI,
  easeVarying: xI,
  end: VI,
  [Symbol.iterator]: yi[Symbol.iterator]
};
function XI(t15) {
  return ((t15 *= 2) <= 1 ? t15 * t15 * t15 : (t15 -= 2) * t15 * t15 + 2) / 2;
}
var YI = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: XI
};
function KI(t15, e) {
  for (var r; !(r = t15.__transition) || !(r = r[e]); )
    if (!(t15 = t15.parentNode))
      throw new Error(`transition ${e} not found`);
  return r;
}
function ZI(t15) {
  var e, r;
  t15 instanceof Fi ? (e = t15._id, t15 = t15._name) : (e = g6(), (r = YI).time = _m(), t15 = t15 == null ? null : t15 + "");
  for (var n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var o = n[s], a = o.length, l, c = 0; c < a; ++c)
      (l = o[c]) && x0(l, t15, e, c, o, r || KI(l, e));
  return new Fi(n, this._parents, t15, e);
}
ac.prototype.interrupt = XN;
ac.prototype.transition = ZI;
var Sf = Math.PI;
var Tf = 2 * Sf;
var Ds = 1e-6;
var QI = Tf - Ds;
function y6(t15) {
  this._ += t15[0];
  for (let e = 1, r = t15.length; e < r; ++e)
    this._ += arguments[e] + t15[e];
}
function JI(t15) {
  let e = Math.floor(t15);
  if (!(e >= 0)) throw new Error(`invalid digits: ${t15}`);
  if (e > 15) return y6;
  const r = 10 ** e;
  return function(n) {
    this._ += n[0];
    for (let i = 1, s = n.length; i < s; ++i)
      this._ += Math.round(arguments[i] * r) / r + n[i];
  };
}
var tO = class {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? y6 : JI(e);
  }
  moveTo(e, r) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, r) {
    this._append`L${this._x1 = +e},${this._y1 = +r}`;
  }
  quadraticCurveTo(e, r, n, i) {
    this._append`Q${+e},${+r},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(e, r, n, i, s, o) {
    this._append`C${+e},${+r},${+n},${+i},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(e, r, n, i, s) {
    if (e = +e, r = +r, n = +n, i = +i, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, l = n - e, c = i - r, h10 = o - e, p = a - r, m = h10 * h10 + p * p;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = r}`;
    else if (m > Ds) if (!(Math.abs(p * l - c * h10) > Ds) || !s)
      this._append`L${this._x1 = e},${this._y1 = r}`;
    else {
      let g = n - o, y = i - a, x = l * l + c * c, k = g * g + y * y, C = Math.sqrt(x), _ = Math.sqrt(m), $ = s * Math.tan((Sf - Math.acos((x + m - k) / (2 * C * _))) / 2), L = $ / _, B = $ / C;
      Math.abs(L - 1) > Ds && this._append`L${e + L * h10},${r + L * p}`, this._append`A${s},${s},0,0,${+(p * g > h10 * y)},${this._x1 = e + B * l},${this._y1 = r + B * c}`;
    }
  }
  arc(e, r, n, i, s, o) {
    if (e = +e, r = +r, n = +n, o = !!o, n < 0) throw new Error(`negative radius: ${n}`);
    let a = n * Math.cos(i), l = n * Math.sin(i), c = e + a, h10 = r + l, p = 1 ^ o, m = o ? i - s : s - i;
    this._x1 === null ? this._append`M${c},${h10}` : (Math.abs(this._x1 - c) > Ds || Math.abs(this._y1 - h10) > Ds) && this._append`L${c},${h10}`, n && (m < 0 && (m = m % Tf + Tf), m > QI ? this._append`A${n},${n},0,1,${p},${e - a},${r - l}A${n},${n},0,1,${p},${this._x1 = c},${this._y1 = h10}` : m > Ds && this._append`A${n},${n},0,${+(m >= Sf)},${p},${this._x1 = e + n * Math.cos(s)},${this._y1 = r + n * Math.sin(s)}`);
  }
  rect(e, r, n, i) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function eO(t15, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t15);
      break;
    default:
      this.range(e).domain(t15);
      break;
  }
  return this;
}
var kb = Symbol("implicit");
function b6() {
  var t15 = new tb(), e = [], r = [], n = kb;
  function i(s) {
    let o = t15.get(s);
    if (o === void 0) {
      if (n !== kb) return n;
      t15.set(s, o = e.push(s) - 1);
    }
    return r[o % r.length];
  }
  return i.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [], t15 = new tb();
    for (const o of s)
      t15.has(o) || t15.set(o, e.push(o) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (r = Array.from(s), i) : r.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (n = s, i) : n;
  }, i.copy = function() {
    return b6(e, r).unknown(n);
  }, eO.apply(i, arguments), i;
}
function rO(t15) {
  for (var e = t15.length / 6 | 0, r = new Array(e), n = 0; n < e; ) r[n] = "#" + t15.slice(n * 6, ++n * 6);
  return r;
}
var nO = rO("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
function vb(t15) {
  return function() {
    return t15;
  };
}
function iO(t15) {
  let e = 3;
  return t15.digits = function(r) {
    if (!arguments.length) return e;
    if (r == null)
      e = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
      e = n;
    }
    return t15;
  }, () => new tO(e);
}
var sO = Array.prototype.slice;
function oO(t15) {
  return t15[0];
}
function aO(t15) {
  return t15[1];
}
var lO = class {
  constructor(e, r) {
    this._context = e, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, r) {
    switch (e = +e, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, r, e, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, e, this._y0, e, r);
        break;
      }
    }
    this._x0 = e, this._y0 = r;
  }
};
function cO(t15) {
  return new lO(t15, true);
}
function hO(t15) {
  return t15.source;
}
function uO(t15) {
  return t15.target;
}
function dO(t15) {
  let e = hO, r = uO, n = oO, i = aO, s = null, o = null, a = iO(l);
  function l() {
    let c;
    const h10 = sO.call(arguments), p = e.apply(this, h10), m = r.apply(this, h10);
    if (s == null && (o = t15(c = a())), o.lineStart(), h10[0] = p, o.point(+n.apply(this, h10), +i.apply(this, h10)), h10[0] = m, o.point(+n.apply(this, h10), +i.apply(this, h10)), o.lineEnd(), c) return o = null, c + "" || null;
  }
  return l.source = function(c) {
    return arguments.length ? (e = c, l) : e;
  }, l.target = function(c) {
    return arguments.length ? (r = c, l) : r;
  }, l.x = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : vb(+c), l) : n;
  }, l.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : vb(+c), l) : i;
  }, l.context = function(c) {
    return arguments.length ? (c == null ? s = o = null : o = t15(s = c), l) : s;
  }, l;
}
function pO() {
  return dO(cO);
}
var nh = (t15) => () => t15;
function fO(t15, {
  sourceEvent: e,
  target: r,
  transform: n,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: t15, enumerable: true, configurable: true },
    sourceEvent: { value: e, enumerable: true, configurable: true },
    target: { value: r, enumerable: true, configurable: true },
    transform: { value: n, enumerable: true, configurable: true },
    _: { value: i }
  });
}
function Ai(t15, e, r) {
  this.k = t15, this.x = e, this.y = r;
}
Ai.prototype = {
  constructor: Ai,
  scale: function(t15) {
    return t15 === 1 ? this : new Ai(this.k * t15, this.x, this.y);
  },
  translate: function(t15, e) {
    return t15 === 0 & e === 0 ? this : new Ai(this.k, this.x + this.k * t15, this.y + this.k * e);
  },
  apply: function(t15) {
    return [t15[0] * this.k + this.x, t15[1] * this.k + this.y];
  },
  applyX: function(t15) {
    return t15 * this.k + this.x;
  },
  applyY: function(t15) {
    return t15 * this.k + this.y;
  },
  invert: function(t15) {
    return [(t15[0] - this.x) / this.k, (t15[1] - this.y) / this.k];
  },
  invertX: function(t15) {
    return (t15 - this.x) / this.k;
  },
  invertY: function(t15) {
    return (t15 - this.y) / this.k;
  },
  rescaleX: function(t15) {
    return t15.copy().domain(t15.range().map(this.invertX, this).map(t15.invert, t15));
  },
  rescaleY: function(t15) {
    return t15.copy().domain(t15.range().map(this.invertY, this).map(t15.invert, t15));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var w0 = new Ai(1, 0, 0);
$o.prototype = Ai.prototype;
function $o(t15) {
  for (; !t15.__zoom; ) if (!(t15 = t15.parentNode)) return w0;
  return t15.__zoom;
}
function np(t15) {
  t15.stopImmediatePropagation();
}
function Oa(t15) {
  t15.preventDefault(), t15.stopImmediatePropagation();
}
function mO(t15) {
  return (!t15.ctrlKey || t15.type === "wheel") && !t15.button;
}
function gO() {
  var t15 = this;
  return t15 instanceof SVGElement ? (t15 = t15.ownerSVGElement || t15, t15.hasAttribute("viewBox") ? (t15 = t15.viewBox.baseVal, [[t15.x, t15.y], [t15.x + t15.width, t15.y + t15.height]]) : [[0, 0], [t15.width.baseVal.value, t15.height.baseVal.value]]) : [[0, 0], [t15.clientWidth, t15.clientHeight]];
}
function _b() {
  return this.__zoom || w0;
}
function yO(t15) {
  return -t15.deltaY * (t15.deltaMode === 1 ? 0.05 : t15.deltaMode ? 1 : 2e-3) * (t15.ctrlKey ? 10 : 1);
}
function bO() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function xO(t15, e, r) {
  var n = t15.invertX(e[0][0]) - r[0][0], i = t15.invertX(e[1][0]) - r[1][0], s = t15.invertY(e[0][1]) - r[0][1], o = t15.invertY(e[1][1]) - r[1][1];
  return t15.translate(
    i > n ? (n + i) / 2 : Math.min(0, n) || Math.max(0, i),
    o > s ? (s + o) / 2 : Math.min(0, s) || Math.max(0, o)
  );
}
function wO() {
  var t15 = mO, e = gO, r = xO, n = yO, i = bO, s = [0, 1 / 0], o = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], a = 250, l = RN, c = xm("start", "zoom", "end"), h10, p, m, g = 500, y = 150, x = 0, k = 10;
  function C(I) {
    I.property("__zoom", _b).on("wheel.zoom", G, { passive: false }).on("mousedown.zoom", F).on("dblclick.zoom", W).filter(i).on("touchstart.zoom", R).on("touchmove.zoom", J).on("touchend.zoom touchcancel.zoom", rt).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  C.transform = function(I, j, z, K) {
    var Y = I.selection ? I.selection() : I;
    Y.property("__zoom", _b), I !== Y ? B(I, j, z, K) : Y.interrupt().each(function() {
      q(this, arguments).event(K).start().zoom(null, typeof j == "function" ? j.apply(this, arguments) : j).end();
    });
  }, C.scaleBy = function(I, j, z, K) {
    C.scaleTo(I, function() {
      var Y = this.__zoom.k, at = typeof j == "function" ? j.apply(this, arguments) : j;
      return Y * at;
    }, z, K);
  }, C.scaleTo = function(I, j, z, K) {
    C.transform(I, function() {
      var Y = e.apply(this, arguments), at = this.__zoom, et = z == null ? L(Y) : typeof z == "function" ? z.apply(this, arguments) : z, ht = at.invert(et), X = typeof j == "function" ? j.apply(this, arguments) : j;
      return r($(_(at, X), et, ht), Y, o);
    }, z, K);
  }, C.translateBy = function(I, j, z, K) {
    C.transform(I, function() {
      return r(this.__zoom.translate(
        typeof j == "function" ? j.apply(this, arguments) : j,
        typeof z == "function" ? z.apply(this, arguments) : z
      ), e.apply(this, arguments), o);
    }, null, K);
  }, C.translateTo = function(I, j, z, K, Y) {
    C.transform(I, function() {
      var at = e.apply(this, arguments), et = this.__zoom, ht = K == null ? L(at) : typeof K == "function" ? K.apply(this, arguments) : K;
      return r(w0.translate(ht[0], ht[1]).scale(et.k).translate(
        typeof j == "function" ? -j.apply(this, arguments) : -j,
        typeof z == "function" ? -z.apply(this, arguments) : -z
      ), at, o);
    }, K, Y);
  };
  function _(I, j) {
    return j = Math.max(s[0], Math.min(s[1], j)), j === I.k ? I : new Ai(j, I.x, I.y);
  }
  function $(I, j, z) {
    var K = j[0] - z[0] * I.k, Y = j[1] - z[1] * I.k;
    return K === I.x && Y === I.y ? I : new Ai(I.k, K, Y);
  }
  function L(I) {
    return [(+I[0][0] + +I[1][0]) / 2, (+I[0][1] + +I[1][1]) / 2];
  }
  function B(I, j, z, K) {
    I.on("start.zoom", function() {
      q(this, arguments).event(K).start();
    }).on("interrupt.zoom end.zoom", function() {
      q(this, arguments).event(K).end();
    }).tween("zoom", function() {
      var Y = this, at = arguments, et = q(Y, at).event(K), ht = e.apply(Y, at), X = z == null ? L(ht) : typeof z == "function" ? z.apply(Y, at) : z, ct = Math.max(ht[1][0] - ht[0][0], ht[1][1] - ht[0][1]), gt = Y.__zoom, xt = typeof j == "function" ? j.apply(Y, at) : j, Yt = l(gt.invert(X).concat(ct / gt.k), xt.invert(X).concat(ct / xt.k));
      return function(U) {
        if (U === 1) U = xt;
        else {
          var mt = Yt(U), wt = ct / mt[2];
          U = new Ai(wt, X[0] - mt[0] * wt, X[1] - mt[1] * wt);
        }
        et.zoom(null, U);
      };
    });
  }
  function q(I, j, z) {
    return !z && I.__zooming || new H(I, j);
  }
  function H(I, j) {
    this.that = I, this.args = j, this.active = 0, this.sourceEvent = null, this.extent = e.apply(I, j), this.taps = 0;
  }
  H.prototype = {
    event: function(I) {
      return I && (this.sourceEvent = I), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(I, j) {
      return this.mouse && I !== "mouse" && (this.mouse[1] = j.invert(this.mouse[0])), this.touch0 && I !== "touch" && (this.touch0[1] = j.invert(this.touch0[0])), this.touch1 && I !== "touch" && (this.touch1[1] = j.invert(this.touch1[0])), this.that.__zoom = j, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(I) {
      var j = es(this.that).datum();
      c.call(
        I,
        this.that,
        new fO(I, {
          sourceEvent: this.sourceEvent,
          target: C,
          transform: this.that.__zoom,
          dispatch: c
        }),
        j
      );
    }
  };
  function G(I, ...j) {
    if (!t15.apply(this, arguments)) return;
    var z = q(this, j).event(I), K = this.__zoom, Y = Math.max(s[0], Math.min(s[1], K.k * Math.pow(2, n.apply(this, arguments)))), at = $s(I);
    if (z.wheel)
      (z.mouse[0][0] !== at[0] || z.mouse[0][1] !== at[1]) && (z.mouse[1] = K.invert(z.mouse[0] = at)), clearTimeout(z.wheel);
    else {
      if (K.k === Y) return;
      z.mouse = [at, K.invert(at)], $h(this), z.start();
    }
    Oa(I), z.wheel = setTimeout(et, y), z.zoom("mouse", r($(_(K, Y), z.mouse[0], z.mouse[1]), z.extent, o));
    function et() {
      z.wheel = null, z.end();
    }
  }
  function F(I, ...j) {
    if (m || !t15.apply(this, arguments)) return;
    var z = I.currentTarget, K = q(this, j, true).event(I), Y = es(I.view).on("mousemove.zoom", X, true).on("mouseup.zoom", ct, true), at = $s(I, z), et = I.clientX, ht = I.clientY;
    pN(I.view), np(I), K.mouse = [at, this.__zoom.invert(at)], $h(this), K.start();
    function X(gt) {
      if (Oa(gt), !K.moved) {
        var xt = gt.clientX - et, Yt = gt.clientY - ht;
        K.moved = xt * xt + Yt * Yt > x;
      }
      K.event(gt).zoom("mouse", r($(K.that.__zoom, K.mouse[0] = $s(gt, z), K.mouse[1]), K.extent, o));
    }
    function ct(gt) {
      Y.on("mousemove.zoom mouseup.zoom", null), fN(gt.view, K.moved), Oa(gt), K.event(gt).end();
    }
  }
  function W(I, ...j) {
    if (t15.apply(this, arguments)) {
      var z = this.__zoom, K = $s(I.changedTouches ? I.changedTouches[0] : I, this), Y = z.invert(K), at = z.k * (I.shiftKey ? 0.5 : 2), et = r($(_(z, at), K, Y), e.apply(this, j), o);
      Oa(I), a > 0 ? es(this).transition().duration(a).call(B, et, K, I) : es(this).call(C.transform, et, K, I);
    }
  }
  function R(I, ...j) {
    if (t15.apply(this, arguments)) {
      var z = I.touches, K = z.length, Y = q(this, j, I.changedTouches.length === K).event(I), at, et, ht, X;
      for (np(I), et = 0; et < K; ++et)
        ht = z[et], X = $s(ht, this), X = [X, this.__zoom.invert(X), ht.identifier], Y.touch0 ? !Y.touch1 && Y.touch0[2] !== X[2] && (Y.touch1 = X, Y.taps = 0) : (Y.touch0 = X, at = true, Y.taps = 1 + !!h10);
      h10 && (h10 = clearTimeout(h10)), at && (Y.taps < 2 && (p = X[0], h10 = setTimeout(function() {
        h10 = null;
      }, g)), $h(this), Y.start());
    }
  }
  function J(I, ...j) {
    if (this.__zooming) {
      var z = q(this, j).event(I), K = I.changedTouches, Y = K.length, at, et, ht, X;
      for (Oa(I), at = 0; at < Y; ++at)
        et = K[at], ht = $s(et, this), z.touch0 && z.touch0[2] === et.identifier ? z.touch0[0] = ht : z.touch1 && z.touch1[2] === et.identifier && (z.touch1[0] = ht);
      if (et = z.that.__zoom, z.touch1) {
        var ct = z.touch0[0], gt = z.touch0[1], xt = z.touch1[0], Yt = z.touch1[1], U = (U = xt[0] - ct[0]) * U + (U = xt[1] - ct[1]) * U, mt = (mt = Yt[0] - gt[0]) * mt + (mt = Yt[1] - gt[1]) * mt;
        et = _(et, Math.sqrt(U / mt)), ht = [(ct[0] + xt[0]) / 2, (ct[1] + xt[1]) / 2], X = [(gt[0] + Yt[0]) / 2, (gt[1] + Yt[1]) / 2];
      } else if (z.touch0) ht = z.touch0[0], X = z.touch0[1];
      else return;
      z.zoom("touch", r($(et, ht, X), z.extent, o));
    }
  }
  function rt(I, ...j) {
    if (this.__zooming) {
      var z = q(this, j).event(I), K = I.changedTouches, Y = K.length, at, et;
      for (np(I), m && clearTimeout(m), m = setTimeout(function() {
        m = null;
      }, g), at = 0; at < Y; ++at)
        et = K[at], z.touch0 && z.touch0[2] === et.identifier ? delete z.touch0 : z.touch1 && z.touch1[2] === et.identifier && delete z.touch1;
      if (z.touch1 && !z.touch0 && (z.touch0 = z.touch1, delete z.touch1), z.touch0) z.touch0[1] = this.__zoom.invert(z.touch0[0]);
      else if (z.end(), z.taps === 2 && (et = $s(et, this), Math.hypot(p[0] - et[0], p[1] - et[1]) < k)) {
        var ht = es(this).on("dblclick.zoom");
        ht && ht.apply(this, arguments);
      }
    }
  }
  return C.wheelDelta = function(I) {
    return arguments.length ? (n = typeof I == "function" ? I : nh(+I), C) : n;
  }, C.filter = function(I) {
    return arguments.length ? (t15 = typeof I == "function" ? I : nh(!!I), C) : t15;
  }, C.touchable = function(I) {
    return arguments.length ? (i = typeof I == "function" ? I : nh(!!I), C) : i;
  }, C.extent = function(I) {
    return arguments.length ? (e = typeof I == "function" ? I : nh([[+I[0][0], +I[0][1]], [+I[1][0], +I[1][1]]]), C) : e;
  }, C.scaleExtent = function(I) {
    return arguments.length ? (s[0] = +I[0], s[1] = +I[1], C) : [s[0], s[1]];
  }, C.translateExtent = function(I) {
    return arguments.length ? (o[0][0] = +I[0][0], o[1][0] = +I[1][0], o[0][1] = +I[0][1], o[1][1] = +I[1][1], C) : [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
  }, C.constrain = function(I) {
    return arguments.length ? (r = I, C) : r;
  }, C.duration = function(I) {
    return arguments.length ? (a = +I, C) : a;
  }, C.interpolate = function(I) {
    return arguments.length ? (l = I, C) : l;
  }, C.on = function() {
    var I = c.on.apply(c, arguments);
    return I === c ? C : I;
  }, C.clickDistance = function(I) {
    return arguments.length ? (x = (I = +I) * I, C) : Math.sqrt(x);
  }, C.tapDistance = function(I) {
    return arguments.length ? (k = +I, C) : k;
  }, C;
}
var x6 = typeof navigator < "u" && navigator.userAgent.includes("Macintosh");
var kO = b6(nO);
var vO = (t15 = 1, e = 3, r = 2) => (n) => t15 + e / r ** n.state.depth;
var _O = {
  autoFit: false,
  duration: 500,
  embedGlobalCSS: true,
  fitRatio: 0.95,
  maxInitialScale: 2,
  scrollForPan: x6,
  initialExpandLevel: -1,
  zoom: true,
  pan: true,
  toggleRecursively: false,
  color: (t15) => {
    var e;
    return kO(`${((e = t15.state) == null ? void 0 : e.path) || ""}`);
  },
  lineWidth: vO(),
  maxWidth: 0,
  nodeMinHeight: 16,
  paddingX: 8,
  spacingHorizontal: 80,
  spacingVertical: 5
};
function CO(t15) {
  let e = 0;
  for (let r = 0; r < t15.length; r++)
    e = (e << 5) - e + t15.charCodeAt(r) | 0;
  return (e >>> 0).toString(36);
}
function Kr(t15) {
  if (typeof t15 == "string") {
    const r = t15;
    t15 = (n) => n.matches(r);
  }
  const e = t15;
  return function() {
    let r = Array.from(this.childNodes);
    return e && (r = r.filter((n) => e(n))), r;
  };
}
function SO(t15) {
  var e = 0, r = t15.children, n = r && r.length;
  if (!n) e = 1;
  else for (; --n >= 0; ) e += r[n].value;
  t15.value = e;
}
function TO() {
  return this.eachAfter(SO);
}
function AO(t15) {
  var e = this, r, n = [e], i, s, o;
  do
    for (r = n.reverse(), n = []; e = r.pop(); )
      if (t15(e), i = e.children, i) for (s = 0, o = i.length; s < o; ++s)
        n.push(i[s]);
  while (n.length);
  return this;
}
function $O(t15) {
  for (var e = this, r = [e], n, i; e = r.pop(); )
    if (t15(e), n = e.children, n) for (i = n.length - 1; i >= 0; --i)
      r.push(n[i]);
  return this;
}
function EO(t15) {
  for (var e = this, r = [e], n = [], i, s, o; e = r.pop(); )
    if (n.push(e), i = e.children, i) for (s = 0, o = i.length; s < o; ++s)
      r.push(i[s]);
  for (; e = n.pop(); )
    t15(e);
  return this;
}
function MO(t15) {
  return this.eachAfter(function(e) {
    for (var r = +t15(e.data) || 0, n = e.children, i = n && n.length; --i >= 0; ) r += n[i].value;
    e.value = r;
  });
}
function BO(t15) {
  return this.eachBefore(function(e) {
    e.children && e.children.sort(t15);
  });
}
function LO(t15) {
  for (var e = this, r = DO(e, t15), n = [e]; e !== r; )
    e = e.parent, n.push(e);
  for (var i = n.length; t15 !== r; )
    n.splice(i, 0, t15), t15 = t15.parent;
  return n;
}
function DO(t15, e) {
  if (t15 === e) return t15;
  var r = t15.ancestors(), n = e.ancestors(), i = null;
  for (t15 = r.pop(), e = n.pop(); t15 === e; )
    i = t15, t15 = r.pop(), e = n.pop();
  return i;
}
function FO() {
  for (var t15 = this, e = [t15]; t15 = t15.parent; )
    e.push(t15);
  return e;
}
function NO() {
  var t15 = [];
  return this.each(function(e) {
    t15.push(e);
  }), t15;
}
function IO() {
  var t15 = [];
  return this.eachBefore(function(e) {
    e.children || t15.push(e);
  }), t15;
}
function OO() {
  var t15 = this, e = [];
  return t15.each(function(r) {
    r !== t15 && e.push({ source: r.parent, target: r });
  }), e;
}
function Tm(t15, e) {
  var r = new fu(t15), n = +t15.value && (r.value = t15.value), i, s = [r], o, a, l, c;
  for (e == null && (e = qO); i = s.pop(); )
    if (n && (i.value = +i.data.value), (a = e(i.data)) && (c = a.length))
      for (i.children = new Array(c), l = c - 1; l >= 0; --l)
        s.push(o = i.children[l] = new fu(a[l])), o.parent = i, o.depth = i.depth + 1;
  return r.eachBefore(PO);
}
function zO() {
  return Tm(this).eachBefore(RO);
}
function qO(t15) {
  return t15.children;
}
function RO(t15) {
  t15.data = t15.data.data;
}
function PO(t15) {
  var e = 0;
  do
    t15.height = e;
  while ((t15 = t15.parent) && t15.height < ++e);
}
function fu(t15) {
  this.data = t15, this.depth = this.height = 0, this.parent = null;
}
fu.prototype = Tm.prototype = {
  constructor: fu,
  count: TO,
  each: AO,
  eachAfter: EO,
  eachBefore: $O,
  sum: MO,
  sort: BO,
  path: LO,
  ancestors: FO,
  descendants: NO,
  leaves: IO,
  links: OO,
  copy: zO
};
var jO = "2.1.2";
var WO = {
  version: jO
};
var { version: HO } = WO;
var UO = Object.freeze({
  children: (t15) => t15.children,
  nodeSize: (t15) => t15.data.size,
  spacing: 0
});
function k6(t15) {
  const e = Object.assign({}, UO, t15);
  function r(a) {
    const l = e[a];
    return typeof l == "function" ? l : () => l;
  }
  function n(a) {
    const l = o(s(), a, (c) => c.children);
    return l.update(), l.data;
  }
  function i() {
    const a = r("nodeSize"), l = r("spacing");
    return class w6 extends Tm.prototype.constructor {
      constructor(h10) {
        super(h10);
      }
      copy() {
        const h10 = o(this.constructor, this, (p) => p.children);
        return h10.each((p) => p.data = p.data.data), h10;
      }
      get size() {
        return a(this);
      }
      spacing(h10) {
        return l(this, h10);
      }
      get nodes() {
        return this.descendants();
      }
      get xSize() {
        return this.size[0];
      }
      get ySize() {
        return this.size[1];
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.ySize;
      }
      get left() {
        return this.x - this.xSize / 2;
      }
      get right() {
        return this.x + this.xSize / 2;
      }
      get root() {
        const h10 = this.ancestors();
        return h10[h10.length - 1];
      }
      get numChildren() {
        return this.hasChildren ? this.children.length : 0;
      }
      get hasChildren() {
        return !this.noChildren;
      }
      get noChildren() {
        return this.children === null;
      }
      get firstChild() {
        return this.hasChildren ? this.children[0] : null;
      }
      get lastChild() {
        return this.hasChildren ? this.children[this.numChildren - 1] : null;
      }
      get extents() {
        return (this.children || []).reduce(
          (h10, p) => w6.maxExtents(h10, p.extents),
          this.nodeExtents
        );
      }
      get nodeExtents() {
        return {
          top: this.top,
          bottom: this.bottom,
          left: this.left,
          right: this.right
        };
      }
      static maxExtents(h10, p) {
        return {
          top: Math.min(h10.top, p.top),
          bottom: Math.max(h10.bottom, p.bottom),
          left: Math.min(h10.left, p.left),
          right: Math.max(h10.right, p.right)
        };
      }
    };
  }
  function s() {
    const a = i(), l = r("nodeSize"), c = r("spacing");
    return class extends a {
      constructor(h10) {
        super(h10), Object.assign(this, {
          x: 0,
          y: 0,
          relX: 0,
          prelim: 0,
          shift: 0,
          change: 0,
          lExt: this,
          lExtRelX: 0,
          lThr: null,
          rExt: this,
          rExtRelX: 0,
          rThr: null
        });
      }
      get size() {
        return l(this.data);
      }
      spacing(h10) {
        return c(this.data, h10.data);
      }
      get x() {
        return this.data.x;
      }
      set x(h10) {
        this.data.x = h10;
      }
      get y() {
        return this.data.y;
      }
      set y(h10) {
        this.data.y = h10;
      }
      update() {
        return v6(this), _6(this), this;
      }
    };
  }
  function o(a, l, c) {
    const h10 = (p, m) => {
      const g = new a(p);
      Object.assign(g, {
        parent: m,
        depth: m === null ? 0 : m.depth + 1,
        height: 0,
        length: 1
      });
      const y = c(p) || [];
      return g.children = y.length === 0 ? null : y.map((x) => h10(x, g)), g.children && Object.assign(g, g.children.reduce(
        (x, k) => ({
          height: Math.max(x.height, k.height + 1),
          length: x.length + k.length
        }),
        g
      )), g;
    };
    return h10(l, null);
  }
  return Object.assign(n, {
    nodeSize(a) {
      return arguments.length ? (e.nodeSize = a, n) : e.nodeSize;
    },
    spacing(a) {
      return arguments.length ? (e.spacing = a, n) : e.spacing;
    },
    children(a) {
      return arguments.length ? (e.children = a, n) : e.children;
    },
    hierarchy(a, l) {
      const c = typeof l > "u" ? e.children : l;
      return o(i(), a, c);
    },
    dump(a) {
      const l = r("nodeSize"), c = (h10) => (p) => {
        const m = h10 + "  ", g = h10 + "    ", { x: y, y: x } = p, k = l(p), C = p.children || [], _ = C.length === 0 ? " " : `,${m}children: [${g}${C.map(c(g)).join(g)}${m}],${h10}`;
        return `{ size: [${k.join(", ")}],${m}x: ${y}, y: ${x}${_}},`;
      };
      return c(`
`)(a);
    }
  }), n;
}
k6.version = HO;
var v6 = (t15, e = 0) => (t15.y = e, (t15.children || []).reduce((r, n) => {
  const [i, s] = r;
  v6(n, t15.y + t15.ySize);
  const o = (i === 0 ? n.lExt : n.rExt).bottom;
  i !== 0 && GO(t15, i, s);
  const a = ez(o, i, s);
  return [i + 1, a];
}, [0, null]), VO(t15), tz(t15), t15);
var _6 = (t15, e, r) => {
  typeof e > "u" && (e = -t15.relX - t15.prelim, r = 0);
  const n = e + t15.relX;
  return t15.relX = n + t15.prelim - r, t15.prelim = 0, t15.x = r + t15.relX, (t15.children || []).forEach((i) => _6(i, n, t15.x)), t15;
};
var VO = (t15) => {
  (t15.children || []).reduce((e, r) => {
    const [n, i] = e, s = n + r.shift, o = i + s + r.change;
    return r.relX += o, [s, o];
  }, [0, 0]);
};
var GO = (t15, e, r) => {
  const n = t15.children[e - 1], i = t15.children[e];
  let s = n, o = n.relX, a = i, l = i.relX, c = true;
  for (; s && a; ) {
    s.bottom > r.lowY && (r = r.next);
    const h10 = o + s.prelim - (l + a.prelim) + s.xSize / 2 + a.xSize / 2 + s.spacing(a);
    (h10 > 0 || h10 < 0 && c) && (l += h10, XO(i, h10), YO(t15, e, r.index, h10)), c = false;
    const p = s.bottom, m = a.bottom;
    p <= m && (s = ZO(s), s && (o += s.relX)), p >= m && (a = KO(a), a && (l += a.relX));
  }
  !s && a ? QO(t15, e, a, l) : s && !a && JO(t15, e, s, o);
};
var XO = (t15, e) => {
  t15.relX += e, t15.lExtRelX += e, t15.rExtRelX += e;
};
var YO = (t15, e, r, n) => {
  const i = t15.children[e], s = e - r;
  if (s > 1) {
    const o = n / s;
    t15.children[r + 1].shift += o, i.shift -= o, i.change -= n - o;
  }
};
var KO = (t15) => t15.hasChildren ? t15.firstChild : t15.lThr;
var ZO = (t15) => t15.hasChildren ? t15.lastChild : t15.rThr;
var QO = (t15, e, r, n) => {
  const i = t15.firstChild, s = i.lExt, o = t15.children[e];
  s.lThr = r;
  const a = n - r.relX - i.lExtRelX;
  s.relX += a, s.prelim -= a, i.lExt = o.lExt, i.lExtRelX = o.lExtRelX;
};
var JO = (t15, e, r, n) => {
  const i = t15.children[e], s = i.rExt, o = t15.children[e - 1];
  s.rThr = r;
  const a = n - r.relX - i.rExtRelX;
  s.relX += a, s.prelim -= a, i.rExt = o.rExt, i.rExtRelX = o.rExtRelX;
};
var tz = (t15) => {
  if (t15.hasChildren) {
    const e = t15.firstChild, r = t15.lastChild, n = (e.prelim + e.relX - e.xSize / 2 + r.relX + r.prelim + r.xSize / 2) / 2;
    Object.assign(t15, {
      prelim: n,
      lExt: e.lExt,
      lExtRelX: e.lExtRelX,
      rExt: r.rExt,
      rExtRelX: r.rExtRelX
    });
  }
};
var ez = (t15, e, r) => {
  for (; r !== null && t15 >= r.lowY; )
    r = r.next;
  return {
    lowY: t15,
    index: e,
    next: r
  };
};
var rz = ".markmap{--markmap-max-width: 9999px;--markmap-a-color: #0097e6;--markmap-a-hover-color: #00a8ff;--markmap-code-bg: #f0f0f0;--markmap-code-color: #555;--markmap-highlight-bg: #ffeaa7;--markmap-table-border: 1px solid currentColor;--markmap-font: 300 16px/20px sans-serif;--markmap-circle-open-bg: #fff;--markmap-text-color: #333;--markmap-highlight-node-bg: #ff02;font:var(--markmap-font);color:var(--markmap-text-color)}.markmap-link{fill:none}.markmap-node>circle{cursor:pointer}.markmap-foreign{display:inline-block}.markmap-foreign p{margin:0}.markmap-foreign a{color:var(--markmap-a-color)}.markmap-foreign a:hover{color:var(--markmap-a-hover-color)}.markmap-foreign code{padding:.25em;font-size:calc(1em - 2px);color:var(--markmap-code-color);background-color:var(--markmap-code-bg);border-radius:2px}.markmap-foreign pre{margin:0}.markmap-foreign pre>code{display:block}.markmap-foreign del{text-decoration:line-through}.markmap-foreign em{font-style:italic}.markmap-foreign strong{font-weight:700}.markmap-foreign mark{background:var(--markmap-highlight-bg)}.markmap-foreign table,.markmap-foreign th,.markmap-foreign td{border-collapse:collapse;border:var(--markmap-table-border)}.markmap-foreign img{display:inline-block}.markmap-foreign svg{fill:currentColor}.markmap-foreign>div{width:var(--markmap-max-width);text-align:left}.markmap-foreign>div>div{display:inline-block}.markmap-highlight rect{fill:var(--markmap-highlight-node-bg)}.markmap-dark .markmap{--markmap-code-bg: #1a1b26;--markmap-code-color: #ddd;--markmap-circle-open-bg: #444;--markmap-text-color: #eee}";
var ip = "g.markmap-node";
var nz = "path.markmap-link";
var iz = "g.markmap-highlight";
var sp = pO();
function Cb(t15, e) {
  const r = MD(t15, e);
  return t15[r];
}
function op(t15) {
  t15.stopPropagation();
}
var sz = new Ja();
var oz = class C6 {
  constructor(e, r) {
    this.options = { ..._O }, this._disposeList = [], this.handleZoom = (n) => {
      const { transform: i } = n;
      this.g.attr("transform", i);
    }, this.handlePan = (n) => {
      n.preventDefault();
      const i = $o(this.svg.node()), s = i.translate(
        -n.deltaX / i.k,
        -n.deltaY / i.k
      );
      this.svg.call(this.zoom.transform, s);
    }, this.handleClick = (n, i) => {
      let s = this.options.toggleRecursively;
      (x6 ? n.metaKey : n.ctrlKey) && (s = !s), this.toggleNode(i, s);
    }, this.ensureView = this.ensureVisible, this.svg = e.datum ? e : es(e), this.styleNode = this.svg.append("style"), this.zoom = wO().filter((n) => this.options.scrollForPan && n.type === "wheel" ? n.ctrlKey && !n.button : (!n.ctrlKey || n.type === "wheel") && !n.button).on("zoom", this.handleZoom), this.setOptions(r), this.state = {
      id: this.options.id || this.svg.attr("id") || NC(),
      rect: { x1: 0, y1: 0, x2: 0, y2: 0 }
    }, this.g = this.svg.append("g"), this.g.append("g").attr("class", "markmap-highlight"), this._observer = new ResizeObserver(
      qC(() => {
        this.renderData();
      }, 100)
    ), this._disposeList.push(
      sz.tap(() => {
        this.setData();
      }),
      () => this._observer.disconnect()
    );
  }
  getStyleContent() {
    const { style: e } = this.options, { id: r } = this.state, n = typeof e == "function" ? e(r) : "";
    return [this.options.embedGlobalCSS && rz, n].filter(Boolean).join(`
`);
  }
  updateStyle() {
    this.svg.attr(
      "class",
      IC(this.svg.attr("class"), "markmap", this.state.id)
    );
    const e = this.getStyleContent();
    this.styleNode.text(e);
  }
  async toggleNode(e, r = false) {
    var n, i;
    const s = (n = e.payload) != null && n.fold ? 0 : 1;
    r ? tl(e, (o, a) => {
      o.payload = {
        ...o.payload,
        fold: s
      }, a();
    }) : e.payload = {
      ...e.payload,
      fold: (i = e.payload) != null && i.fold ? 0 : 1
    }, await this.renderData(e);
  }
  _initializeData(e) {
    let r = 0;
    const { color: n, initialExpandLevel: i } = this.options;
    let s = 0, o = 0;
    return tl(e, (a, l, c) => {
      var h10, p, m, g;
      o += 1, a.children = (h10 = a.children) == null ? void 0 : h10.map((x) => ({ ...x })), r += 1, a.state = {
        ...a.state,
        depth: o,
        id: r,
        rect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        size: [0, 0]
      }, a.state.key = [(p = c == null ? void 0 : c.state) == null ? void 0 : p.id, a.state.id].filter(Boolean).join(".") + CO(a.content), a.state.path = [(m = c == null ? void 0 : c.state) == null ? void 0 : m.path, a.state.id].filter(Boolean).join("."), n(a);
      const y = ((g = a.payload) == null ? void 0 : g.fold) === 2;
      y ? s += 1 : (s || i >= 0 && a.state.depth >= i) && (a.payload = { ...a.payload, fold: 1 }), l(), y && (s -= 1), o -= 1;
    }), e;
  }
  _relayout() {
    if (!this.state.data) return;
    this.g.selectAll(Kr(ip)).selectAll(
      Kr("foreignObject")
    ).each(function(l) {
      var c;
      const h10 = (c = this.firstChild) == null ? void 0 : c.firstChild, p = [h10.scrollWidth, h10.scrollHeight];
      l.state.size = p;
    });
    const { lineWidth: e, paddingX: r, spacingHorizontal: n, spacingVertical: i } = this.options, s = k6({}).children((l) => {
      var c;
      if (!((c = l.payload) != null && c.fold)) return l.children;
    }).nodeSize((l) => {
      const [c, h10] = l.data.state.size;
      return [h10, c + (c ? r * 2 : 0) + n];
    }).spacing((l, c) => (l.parent === c.parent ? i : i * 2) + e(l.data)), o = s.hierarchy(this.state.data);
    s(o);
    const a = o.descendants();
    a.forEach((l) => {
      const c = l.data;
      c.state.rect = {
        x: l.y,
        y: l.x - l.xSize / 2,
        width: l.ySize - n,
        height: l.xSize
      };
    }), this.state.rect = {
      x1: nb(a, (l) => l.data.state.rect.x) || 0,
      y1: nb(a, (l) => l.data.state.rect.y) || 0,
      x2: rb(
        a,
        (l) => l.data.state.rect.x + l.data.state.rect.width
      ) || 0,
      y2: rb(
        a,
        (l) => l.data.state.rect.y + l.data.state.rect.height
      ) || 0
    };
  }
  setOptions(e) {
    this.options = {
      ...this.options,
      ...e
    }, this.options.zoom ? this.svg.call(this.zoom) : this.svg.on(".zoom", null), this.options.pan ? this.svg.on("wheel", this.handlePan) : this.svg.on("wheel", null);
  }
  async setData(e, r) {
    r && this.setOptions(r), e && (this.state.data = this._initializeData(e)), this.state.data && (this.updateStyle(), await this.renderData());
  }
  async setHighlight(e) {
    this.state.highlight = e || void 0, await this.renderData();
  }
  _getHighlightRect(e) {
    const r = this.svg.node(), n = 4 / $o(r).k, i = {
      ...e.state.rect
    };
    return i.x -= n, i.y -= n, i.width += 2 * n, i.height += 2 * n, i;
  }
  async renderData(e) {
    const { paddingX: r, autoFit: n, color: i, maxWidth: s, lineWidth: o } = this.options, a = this.state.data;
    if (!a) return;
    const l = {}, c = {}, h10 = [];
    tl(a, (X, ct, gt) => {
      var xt;
      (xt = X.payload) != null && xt.fold || ct(), l[X.state.id] = X, gt && (c[X.state.id] = gt.state.id), h10.push(X);
    });
    const p = {}, m = {}, g = (X) => {
      !X || p[X.state.id] || tl(X, (ct, gt) => {
        p[ct.state.id] = X.state.id, gt();
      });
    }, y = (X) => m[p[X.state.id]] || a.state.rect, x = (X) => (l[p[X.state.id]] || a).state.rect;
    m[a.state.id] = a.state.rect, e && g(e);
    let { highlight: k } = this.state;
    k && !l[k.state.id] && (k = void 0);
    let C = this.g.selectAll(Kr(iz)).selectAll(Kr("rect")).data(k ? [this._getHighlightRect(k)] : []).join("rect").attr("x", (X) => X.x).attr("y", (X) => X.y).attr("width", (X) => X.width).attr("height", (X) => X.height);
    const _ = this.g.selectAll(Kr(ip)).each((X) => {
      m[X.state.id] = X.state.rect;
    }).data(h10, (X) => X.state.key), $ = _.enter().append("g").attr("data-depth", (X) => X.state.depth).attr("data-path", (X) => X.state.path).each((X) => {
      g(l[c[X.state.id]]);
    }), L = _.exit().each((X) => {
      g(l[c[X.state.id]]);
    }), B = _.merge($).attr(
      "class",
      (X) => {
        var ct;
        return ["markmap-node", ((ct = X.payload) == null ? void 0 : ct.fold) && "markmap-fold"].filter(Boolean).join(" ");
      }
    ), q = B.selectAll(Kr("line")).data(
      (X) => [X],
      (X) => X.state.key
    ), H = q.enter().append("line").attr("stroke", (X) => i(X)).attr("stroke-width", 0), G = q.merge(H), F = B.selectAll(Kr("circle")).data(
      (X) => {
        var ct;
        return (ct = X.children) != null && ct.length ? [X] : [];
      },
      (X) => X.state.key
    ), W = F.enter().append("circle").attr("stroke-width", 0).attr("r", 0).on("click", (X, ct) => this.handleClick(X, ct)).on("mousedown", op).merge(F).attr("stroke", (X) => i(X)).attr(
      "fill",
      (X) => {
        var ct;
        return (ct = X.payload) != null && ct.fold && X.children ? i(X) : "var(--markmap-circle-open-bg)";
      }
    ), R = this._observer, J = B.selectAll(Kr("foreignObject")).data(
      (X) => [X],
      (X) => X.state.key
    ), rt = J.enter().append("foreignObject").attr("class", "markmap-foreign").attr("x", r).attr("y", 0).style("opacity", 0).on("mousedown", op).on("dblclick", op);
    rt.append("xhtml:div").append("xhtml:div").html((X) => X.content).attr("xmlns", "http://www.w3.org/1999/xhtml"), rt.each(function() {
      var X;
      const ct = (X = this.firstChild) == null ? void 0 : X.firstChild;
      R.observe(ct);
    });
    const I = L.selectAll(
      Kr("foreignObject")
    );
    I.each(function() {
      var X;
      const ct = (X = this.firstChild) == null ? void 0 : X.firstChild;
      R.unobserve(ct);
    });
    const j = rt.merge(J), z = h10.flatMap(
      (X) => {
        var ct;
        return (ct = X.payload) != null && ct.fold ? [] : X.children.map((gt) => ({ source: X, target: gt }));
      }
    ), K = this.g.selectAll(Kr(nz)).data(z, (X) => X.target.state.key), Y = K.exit(), at = K.enter().insert("path", "g").attr("class", "markmap-link").attr("data-depth", (X) => X.target.state.depth).attr("data-path", (X) => X.target.state.path).attr("d", (X) => {
      const ct = y(X.target), gt = [
        ct.x + ct.width,
        ct.y + ct.height
      ];
      return sp({ source: gt, target: gt });
    }).attr("stroke-width", 0).merge(K);
    this.svg.style(
      "--markmap-max-width",
      s ? `${s}px` : null
    ), await new Promise(requestAnimationFrame), this._relayout(), C = C.data(k ? [this._getHighlightRect(k)] : []).join("rect"), this.transition(C).attr("x", (X) => X.x).attr("y", (X) => X.y).attr("width", (X) => X.width).attr("height", (X) => X.height), $.attr("transform", (X) => {
      const ct = y(X);
      return `translate(${ct.x + ct.width - X.state.rect.width},${ct.y + ct.height - X.state.rect.height})`;
    }), this.transition(L).attr("transform", (X) => {
      const ct = x(X), gt = ct.x + ct.width - X.state.rect.width, xt = ct.y + ct.height - X.state.rect.height;
      return `translate(${gt},${xt})`;
    }).remove(), this.transition(B).attr(
      "transform",
      (X) => `translate(${X.state.rect.x},${X.state.rect.y})`
    );
    const et = L.selectAll(
      Kr("line")
    );
    this.transition(et).attr("x1", (X) => X.state.rect.width).attr("stroke-width", 0), H.attr("x1", (X) => X.state.rect.width).attr("x2", (X) => X.state.rect.width), G.attr("y1", (X) => X.state.rect.height + o(X) / 2).attr("y2", (X) => X.state.rect.height + o(X) / 2), this.transition(G).attr("x1", -1).attr("x2", (X) => X.state.rect.width + 2).attr("stroke", (X) => i(X)).attr("stroke-width", o);
    const ht = L.selectAll(
      Kr("circle")
    );
    this.transition(ht).attr("r", 0).attr("stroke-width", 0), W.attr("cx", (X) => X.state.rect.width).attr("cy", (X) => X.state.rect.height + o(X) / 2), this.transition(W).attr("r", 6).attr("stroke-width", "1.5"), this.transition(I).style("opacity", 0), j.attr("width", (X) => Math.max(0, X.state.rect.width - r * 2)).attr("height", (X) => X.state.rect.height), this.transition(j).style("opacity", 1), this.transition(Y).attr("d", (X) => {
      const ct = x(X.target), gt = [
        ct.x + ct.width,
        ct.y + ct.height + o(X.target) / 2
      ];
      return sp({ source: gt, target: gt });
    }).attr("stroke-width", 0).remove(), this.transition(at).attr("stroke", (X) => i(X.target)).attr("stroke-width", (X) => o(X.target)).attr("d", (X) => {
      const ct = X.source, gt = X.target, xt = [
        ct.state.rect.x + ct.state.rect.width,
        ct.state.rect.y + ct.state.rect.height + o(ct) / 2
      ], Yt = [
        gt.state.rect.x,
        gt.state.rect.y + gt.state.rect.height + o(gt) / 2
      ];
      return sp({ source: xt, target: Yt });
    }), n && this.fit();
  }
  transition(e) {
    const { duration: r } = this.options;
    return e.transition().duration(r);
  }
  /**
   * Fit the content to the viewport.
   */
  async fit(e = this.options.maxInitialScale) {
    const r = this.svg.node(), { width: n, height: i } = r.getBoundingClientRect(), { fitRatio: s } = this.options, { x1: o, y1: a, x2: l, y2: c } = this.state.rect, h10 = l - o, p = c - a, m = Math.min(
      n / h10 * s,
      i / p * s,
      e
    ), g = w0.translate(
      (n - h10 * m) / 2 - o * m,
      (i - p * m) / 2 - a * m
    ).scale(m);
    return this.transition(this.svg).call(this.zoom.transform, g).end().catch(Bo);
  }
  findElement(e) {
    let r;
    return this.g.selectAll(Kr(ip)).each(function(n) {
      n === e && (r = {
        data: n,
        g: this
      });
    }), r;
  }
  /**
   * Pan the content to make the provided node visible in the viewport.
   */
  async ensureVisible(e, r) {
    var n;
    const i = (n = this.findElement(e)) == null ? void 0 : n.data;
    if (!i) return;
    const s = this.svg.node(), o = s.getBoundingClientRect(), a = $o(s), [l, c] = [
      i.state.rect.x,
      i.state.rect.x + i.state.rect.width + 2
    ].map((C) => C * a.k + a.x), [h10, p] = [
      i.state.rect.y,
      i.state.rect.y + i.state.rect.height
    ].map((C) => C * a.k + a.y), m = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      ...r
    }, g = [m.left - l, o.width - m.right - c], y = [m.top - h10, o.height - m.bottom - p], x = g[0] * g[1] > 0 ? Cb(g, Math.abs) / a.k : 0, k = y[0] * y[1] > 0 ? Cb(y, Math.abs) / a.k : 0;
    if (x || k) {
      const C = a.translate(x, k);
      return this.transition(this.svg).call(this.zoom.transform, C).end().catch(Bo);
    }
  }
  async centerNode(e, r) {
    var n;
    const i = (n = this.findElement(e)) == null ? void 0 : n.data;
    if (!i) return;
    const s = this.svg.node(), o = s.getBoundingClientRect(), a = $o(s), l = (i.state.rect.x + i.state.rect.width / 2) * a.k + a.x, c = (i.state.rect.y + i.state.rect.height / 2) * a.k + a.y, h10 = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      ...r
    }, p = (h10.left + o.width - h10.right) / 2, m = (h10.top + o.height - h10.bottom) / 2, g = (p - l) / a.k, y = (m - c) / a.k;
    if (g || y) {
      const x = a.translate(g, y);
      return this.transition(this.svg).call(this.zoom.transform, x).end().catch(Bo);
    }
  }
  /**
   * Scale content with it pinned at the center of the viewport.
   */
  async rescale(e) {
    const r = this.svg.node(), { width: n, height: i } = r.getBoundingClientRect(), s = n / 2, o = i / 2, a = $o(r), l = a.translate(
      (s - a.x) * (1 - e) / a.k,
      (o - a.y) * (1 - e) / a.k
    ).scale(e);
    return this.transition(this.svg).call(this.zoom.transform, l).end().catch(Bo);
  }
  destroy() {
    this.svg.on(".zoom", null), this.svg.html(null), this._disposeList.forEach((e) => {
      e();
    });
  }
  static create(e, r, n = null) {
    const i = new C6(e, r);
    return n && i.setData(n).then(() => {
      i.fit();
    }), i;
  }
};
var Es = /* @__PURE__ */ new Map();
var ap = /* @__PURE__ */ new Map();
var Zr = /* @__PURE__ */ new Map();
var ol = /* @__PURE__ */ new Map();
var lp = /* @__PURE__ */ new Map();
var Sb = /* @__PURE__ */ new WeakMap();
var bi = /* @__PURE__ */ new Set();
function az(t15) {
  if (ol.has(t15))
    return ol.get(t15);
  if ((/* @__PURE__ */ new Set(["script", "style", "meta", "link", "noscript", "template"])).has(t15)) {
    const s = {};
    return ol.set(t15, s), s;
  }
  let e = document.getElementById("snapdom-sandbox");
  e || (e = document.createElement("div"), e.id = "snapdom-sandbox", e.style.position = "absolute", e.style.left = "-9999px", e.style.top = "-9999px", e.style.width = "0", e.style.height = "0", e.style.overflow = "hidden", document.body.appendChild(e));
  const r = document.createElement(t15);
  r.style.all = "initial", e.appendChild(r);
  const n = getComputedStyle(r), i = {};
  for (let s of n)
    i[s] = n.getPropertyValue(s);
  return e.removeChild(r), ol.set(t15, i), i;
}
function Af(t15, e, r = false) {
  const n = [], i = az(e);
  for (let [s, o] of Object.entries(t15))
    if (!r)
      o && n.push(`${s}:${o}`);
    else {
      const a = i[s];
      o && o !== a && n.push(`${s}:${o}`);
    }
  return n.sort().join(";");
}
function lz(t15) {
  const e = /* @__PURE__ */ new Set();
  return t15.nodeType !== Node.ELEMENT_NODE && t15.nodeType !== Node.DOCUMENT_FRAGMENT_NODE ? [] : (t15.tagName && e.add(t15.tagName.toLowerCase()), typeof t15.querySelectorAll == "function" && t15.querySelectorAll("*").forEach((r) => e.add(r.tagName.toLowerCase())), Array.from(e));
}
function cz(t15) {
  const e = /* @__PURE__ */ new Map();
  for (let n of t15) {
    const i = ol.get(n);
    if (!i) continue;
    const s = Object.entries(i).map(([o, a]) => `${o}:${a};`).sort().join("");
    e.has(s) || e.set(s, []), e.get(s).push(n);
  }
  let r = "";
  for (let [n, i] of e.entries())
    r += `${i.join(",")} { ${n} }
`;
  return r;
}
function hz(t15) {
  const e = new Set(t15.values()), r = /* @__PURE__ */ new Map();
  let n = 1;
  for (const i of e)
    r.set(i, `c${n++}`);
  return r;
}
async function S6(t15, e = {}) {
  var _a2;
  const r = (_a2 = t15.match(/url\(["']?(.*?)["']?\)/)) == null ? void 0 : _a2[1];
  if (r) {
    const n = Em(r);
    if (ap.has(n))
      return e.skipInline ? void 0 : `url(${ap.get(n)})`;
    {
      const i = await $m(n, { useProxy: e.useProxy });
      return ap.set(n, i), e.skipInline ? void 0 : `url("${i}")`;
    }
  }
  return t15;
}
function za(t15, { fast: e = false } = {}) {
  if (e) return t15();
  "requestIdleCallback" in window ? requestIdleCallback(t15, { timeout: 50 }) : setTimeout(t15, 1);
}
function Am(t15, e = null) {
  if (!(t15 instanceof Element))
    return window.getComputedStyle(t15, e);
  let r = Sb.get(t15);
  if (r || (r = /* @__PURE__ */ new Map(), Sb.set(t15, r)), !r.has(e)) {
    const n = window.getComputedStyle(t15, e);
    r.set(e, n);
  }
  return r.get(e);
}
function uz(t15) {
  let e = t15.replace(/^['"]|['"]$/g, "");
  if (e.startsWith("\\"))
    try {
      return String.fromCharCode(parseInt(e.replace("\\", ""), 16));
    } catch {
      return e;
    }
  return e;
}
function T6(t15) {
  const e = t15.indexOf("url(");
  if (e === -1) return null;
  let r = t15.slice(e + 4).trim();
  return r.endsWith(")") && (r = r.slice(0, -1).trim()), (r.startsWith('"') && r.endsWith('"') || r.startsWith("'") && r.endsWith("'")) && (r = r.slice(1, -1)), r;
}
function $m(t15, { timeout: e = 3e3, useProxy: r = "" } = {}) {
  function n(o) {
    try {
      return new URL(o, window.location.href).origin === window.location.origin ? "use-credentials" : "anonymous";
    } catch {
      return "anonymous";
    }
  }
  async function i(o) {
    const a = (l) => fetch(l, {
      mode: "cors",
      credentials: n(l) === "use-credentials" ? "include" : "omit"
    }).then((c) => c.blob()).then((c) => new Promise((h10, p) => {
      const m = new FileReader();
      m.onloadend = () => {
        const g = m.result;
        if (typeof g != "string" || !g.startsWith("data:image/")) {
          p(new Error("Invalid image data URL"));
          return;
        }
        h10(g);
      }, m.onerror = () => p(new Error("FileReader error")), m.readAsDataURL(c);
    }));
    try {
      return await a(o);
    } catch {
      if (r && typeof r == "string") {
        const l = r.replace(/\/$/, "") + Em(o);
        try {
          return await a(l);
        } catch {
          throw console.error(`[SnapDOM - fetchImage] Proxy fallback failed for: ${o}`), new Error("CORS restrictions prevented image capture (even via proxy)");
        }
      } else
        throw console.error(`[SnapDOM - fetchImage] No valid proxy URL provided for fallback: ${o}`), new Error("Fetch fallback failed and no proxy provided");
    }
  }
  const s = n(t15);
  return console.log(`[SnapDOM - fetchImage] Start loading image: ${t15} with crossOrigin=${s}`), Es.has(t15) ? (console.log(`[SnapDOM - fetchImage] Cache hit for: ${t15}`), Promise.resolve(Es.get(t15))) : t15.startsWith("data:image/") ? (Es.set(t15, t15), Promise.resolve(t15)) : /\.svg(\?.*)?$/i.test(t15) ? (async () => {
    try {
      const o = await (await fetch(t15, {
        mode: "cors",
        credentials: s === "use-credentials" ? "include" : "omit"
      })).text(), a = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(o)}`;
      return Es.set(t15, a), a;
    } catch {
      return i(t15);
    }
  })() : new Promise((o, a) => {
    const l = setTimeout(() => {
      console.log(`[SnapDOM - fetchImage] Timeout after ${e}ms for image: ${t15}`), a(new Error("Image load timed out"));
    }, e), c = new Image();
    c.crossOrigin = s, c.onload = async () => {
      clearTimeout(l);
      try {
        await c.decode();
        const h10 = document.createElement("canvas");
        h10.width = c.width, h10.height = c.height, h10.getContext("2d").drawImage(c, 0, 0, h10.width, h10.height);
        const p = h10.toDataURL("image/png");
        Es.set(t15, p), o(p);
      } catch {
        try {
          const h10 = await i(t15);
          Es.set(t15, h10), o(h10);
        } catch (h10) {
          a(h10);
        }
      }
    }, c.onerror = async () => {
      clearTimeout(l), console.error(`[SnapDOM - fetchImage] Image failed to load: ${t15}`);
      try {
        const h10 = await i(t15);
        Es.set(t15, h10), o(h10);
      } catch (h10) {
        a(h10);
      }
    }, c.src = t15;
  });
}
function Tb(t15) {
  const e = {};
  for (let r of t15)
    e[r] = t15.getPropertyValue(r);
  return e;
}
function A6() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function dz(t15) {
  if (!t15 || t15 === "none") return "";
  let e = t15.replace(/translate[XY]?\([^)]*\)/g, "");
  return e = e.replace(/matrix\(([^)]+)\)/g, (r, n) => {
    const i = n.split(",").map((s) => s.trim());
    return i.length !== 6 ? `matrix(${n})` : (i[4] = "0", i[5] = "0", `matrix(${i.join(", ")})`);
  }), e = e.replace(/matrix3d\(([^)]+)\)/g, (r, n) => {
    const i = n.split(",").map((s) => s.trim());
    return i.length !== 16 ? `matrix3d(${n})` : (i[12] = "0", i[13] = "0", `matrix3d(${i.join(", ")})`);
  }), e.trim().replace(/\s{2,}/g, " ");
}
function Em(t15) {
  if (/%[0-9A-Fa-f]{2}/.test(t15)) return t15;
  try {
    return encodeURI(t15);
  } catch {
    return t15;
  }
}
function $6(t15) {
  const e = [];
  let r = 0, n = 0;
  for (let i = 0; i < t15.length; i++) {
    const s = t15[i];
    s === "(" && r++, s === ")" && r--, s === "," && r === 0 && (e.push(t15.slice(n, i).trim()), n = i + 1);
  }
  return e.push(t15.slice(n).trim()), e;
}
var cp = /* @__PURE__ */ new WeakMap();
var hp = /* @__PURE__ */ new Map();
function pz(t15) {
  const e = {};
  for (let r = 0; r < t15.length; r++) {
    const n = t15[r];
    let i = t15.getPropertyValue(n);
    (n === "background-image" || n === "content") && i.includes("url(") && !i.includes("data:") && (i = "none"), e[n] = i;
  }
  return e;
}
function Ab(t15, e, r, n, i) {
  var _a2;
  if (t15.tagName === "STYLE") return;
  n.has(t15) || n.set(t15, Am(t15));
  const s = n.get(t15);
  if (!cp.has(t15)) {
    const h10 = pz(s);
    cp.set(t15, h10);
  }
  const o = cp.get(t15), a = Object.entries(o).sort(([h10], [p]) => h10.localeCompare(p)).map(([h10, p]) => `${h10}:${p}`).join(";");
  if (hp.has(a)) {
    r.set(e, hp.get(a));
    return;
  }
  const l = ((_a2 = t15.tagName) == null ? void 0 : _a2.toLowerCase()) || "div", c = Af(o, l, i);
  hp.set(a, c), r.set(e, c);
}
function fz(t15) {
  return t15.nodeType === Node.ELEMENT_NODE && t15.tagName === "SLOT";
}
function Eh(t15, e, r, n, i, s = {}, o) {
  var _a2, _b2;
  if (t15.nodeType === Node.TEXT_NODE || t15.nodeType !== Node.ELEMENT_NODE) return t15.cloneNode(true);
  if (t15.getAttribute("data-capture") === "exclude") {
    const l = document.createElement("div"), c = t15.getBoundingClientRect();
    return l.style.cssText = `display: inline-block; width: ${c.width}px; height: ${c.height}px; visibility: hidden;`, l;
  }
  if (s.exclude && Array.isArray(s.exclude))
    for (const l of s.exclude)
      try {
        if ((_a2 = t15.matches) == null ? void 0 : _a2.call(t15, l)) {
          const c = document.createElement("div"), h10 = t15.getBoundingClientRect();
          return c.style.cssText = `display: inline-block; width: ${h10.width}px; height: ${h10.height}px; visibility: hidden;`, c;
        }
      } catch (c) {
        console.warn(`Invalid selector in exclude option: ${l}`, c);
      }
  if (typeof s.filter == "function")
    try {
      if (!s.filter(t15, o || t15)) {
        const l = document.createElement("div"), c = t15.getBoundingClientRect();
        return l.style.cssText = `display: inline-block; width: ${c.width}px; height: ${c.height}px; visibility: hidden;`, l;
      }
    } catch (l) {
      console.warn("Error in filter function:", l);
    }
  if (t15.tagName === "IFRAME") {
    const l = document.createElement("div");
    return l.textContent = "", l.style.cssText = `width: ${t15.offsetWidth}px; height: ${t15.offsetHeight}px; background-image: repeating-linear-gradient(45deg, #ddd, #ddd 5px, #f9f9f9 5px, #f9f9f9 10px);display: flex;align-items: center;justify-content: center;font-size: 12px;color: #555; border: 1px solid #aaa;`, l;
  }
  if (t15.getAttribute("data-capture") === "placeholder") {
    const l = t15.cloneNode(false);
    n.set(l, t15), Ab(t15, l, e, r, i);
    const c = document.createElement("div");
    return c.textContent = t15.getAttribute("data-placeholder-text") || "", c.style.cssText = "color: #666;font-size: 12px;text-align: center;line-height: 1.4;padding: 0.5em;box-sizing: border-box;", l.appendChild(c), l;
  }
  if (t15.tagName === "CANVAS") {
    const l = t15.toDataURL(), c = document.createElement("img");
    return c.src = l, c.width = t15.width, c.height = t15.height, c.style.display = "inline-block", c.style.width = t15.style.width || `${t15.width}px`, c.style.height = t15.style.height || `${t15.height}px`, c;
  }
  const a = t15.cloneNode(false);
  if (n.set(a, t15), t15 instanceof HTMLInputElement)
    a.value = t15.value, a.setAttribute("value", t15.value), t15.checked !== void 0 && (a.checked = t15.checked, t15.checked && a.setAttribute("checked", ""));
  else if (t15 instanceof HTMLTextAreaElement) {
    const l = t15.getBoundingClientRect();
    a.textContent = t15.value, a.style.width = `${l.width}px`, a.style.height = `${l.height}px`;
  } else t15 instanceof HTMLSelectElement && (a.value = t15.value, Array.from(a.options).forEach((l) => {
    l.value === t15.value ? l.setAttribute("selected", "") : l.removeAttribute("selected");
  }));
  if (Ab(t15, a, e, r, i), fz(t15)) {
    const l = ((_b2 = t15.assignedNodes) == null ? void 0 : _b2.call(t15, { flatten: true })) || [], c = l.length > 0 ? l : Array.from(t15.childNodes), h10 = document.createDocumentFragment();
    for (const p of c) {
      const m = Eh(p, e, r, n, i, s, o || t15);
      m && h10.appendChild(m);
    }
    return h10;
  } else if (!(t15 instanceof HTMLTextAreaElement)) {
    const l = t15.shadowRoot ? t15.shadowRoot.childNodes : t15.childNodes;
    for (const c of l) {
      const h10 = Eh(c, e, r, n, i, s, o || t15);
      h10 && a.appendChild(h10);
    }
    if (t15.shadowRoot && t15.childNodes.length > 0 && !t15.shadowRoot.querySelector("slot")) {
      const c = document.createDocumentFragment();
      for (const h10 of t15.childNodes) {
        const p = Eh(h10, e, r, n, i, s, o || t15);
        p && c.appendChild(p);
      }
      a.appendChild(c);
    }
  }
  return a;
}
var mz = [
  // /uicons/i,
  /font\s*awesome/i,
  /material\s*icons/i,
  /ionicons/i,
  /glyphicons/i,
  /feather/i,
  /bootstrap\s*icons/i,
  /remix\s*icons/i,
  /heroicons/i,
  /layui/i,
  /lucide/i
];
var $f = [];
function gz(t15) {
  const e = Array.isArray(t15) ? t15 : [t15];
  for (const r of e)
    r instanceof RegExp ? $f.push(r) : typeof r == "string" ? $f.push(new RegExp(r, "i")) : console.warn("[snapdom] Ignored invalid iconFont value:", r);
}
function Gi(t15) {
  const e = typeof t15 == "string" ? t15 : "", r = [...mz, ...$f];
  for (const n of r)
    if (n instanceof RegExp && n.test(e)) return true;
  return !!(/icon/i.test(e) || /glyph/i.test(e) || /symbols/i.test(e) || /feather/i.test(e) || /fontawesome/i.test(e));
}
async function yz(t15, e, r, n = 32, i = "#000") {
  e = e.replace(/^['"]+|['"]+$/g, "");
  const s = window.devicePixelRatio || 1, o = document.createElement("canvas").getContext("2d");
  o.font = r ? `${r} ${n}px "${e}"` : `${n}px "${e}"`;
  const a = o.measureText(t15), l = a.actualBoundingBoxAscent || n * 0.8, c = a.actualBoundingBoxDescent || n * 0.2, h10 = l + c, p = a.width, m = document.createElement("canvas");
  m.width = Math.ceil(p * s), m.height = Math.ceil(h10 * s);
  const g = m.getContext("2d");
  return g.scale(s, s), g.font = o.font, g.textAlign = "left", g.textBaseline = "alphabetic", g.fillStyle = i, g.fillText(t15, 0, l), m.toDataURL();
}
function E6(t15) {
  return Array.from(document.styleSheets).some((e) => e.href === t15);
}
function bz(t15) {
  return new Promise((e) => {
    if (E6(t15)) return e(null);
    const r = document.createElement("link");
    r.rel = "stylesheet", r.href = t15, r.setAttribute("data-snapdom", "injected-import"), r.onload = () => e(r), r.onerror = () => e(null), document.head.appendChild(r);
  });
}
async function xz({ preCached: t15 = false } = {}) {
  if (Zr.has("fonts-embed-css")) {
    if (t15) {
      const s = document.createElement("style");
      s.setAttribute("data-snapdom", "embedFonts"), s.textContent = Zr.get("fonts-embed-css"), document.head.appendChild(s);
    }
    return Zr.get("fonts-embed-css");
  }
  const e = /@import\s+url\(["']?([^"')]+)["']?\)/g, r = [];
  for (const s of document.querySelectorAll("style")) {
    const o = s.textContent || "", a = Array.from(o.matchAll(e));
    for (const l of a) {
      const c = l[1];
      Gi(c) || E6(c) || r.push(c);
    }
  }
  await Promise.all(r.map(bz));
  const n = Array.from(document.querySelectorAll('link[rel="stylesheet"]')).filter((s) => s.href);
  let i = "";
  for (const s of n)
    try {
      const o = await (await fetch(s.href)).text();
      if (Gi(s.href) || Gi(o)) continue;
      const a = /url\((["']?)([^"')]+)\1\)/g, l = await Promise.all(
        Array.from(o.matchAll(a)).map(async (h10) => {
          let p = T6(h10[0]);
          if (!p) return null;
          let m = p;
          if (!m.startsWith("http") && !m.startsWith("data:") && (m = new URL(m, s.href).href), Gi(m)) return null;
          if (Zr.has(m))
            return bi.add(m), { original: h10[0], inlined: `url(${Zr.get(m)})` };
          if (bi.has(m)) return null;
          try {
            const g = await (await fetch(m)).blob(), y = await new Promise((x) => {
              const k = new FileReader();
              k.onload = () => x(k.result), k.readAsDataURL(g);
            });
            return Zr.set(m, y), bi.add(m), { original: h10[0], inlined: `url(${y})` };
          } catch {
            return console.warn("[snapdom] Failed to fetch font resource:", m), null;
          }
        })
      );
      let c = o;
      for (const h10 of l)
        h10 && (c = c.replace(h10.original, h10.inlined));
      i += c + `
`;
    } catch {
      console.warn("[snapdom] Failed to fetch CSS:", s.href);
    }
  for (const s of document.styleSheets)
    try {
      if (!s.href || n.every((o) => o.href !== s.href)) {
        for (const o of s.cssRules)
          if (o.type === CSSRule.FONT_FACE_RULE) {
            const a = o.style.getPropertyValue("src"), l = o.style.getPropertyValue("font-family");
            if (!a || Gi(l)) continue;
            const c = /url\((["']?)([^"')]+)\1\)/g;
            let h10 = a;
            const p = Array.from(a.matchAll(c));
            for (const m of p) {
              let g = m[2].trim();
              if (!g) continue;
              let y = g;
              if (!y.startsWith("http") && !y.startsWith("data:") && (y = new URL(y, s.href || location.href).href), !Gi(y)) {
                if (Zr.has(y)) {
                  bi.add(y), h10 = h10.replace(m[0], `url(${Zr.get(y)})`);
                  continue;
                }
                if (!bi.has(y))
                  try {
                    const x = await (await fetch(y)).blob(), k = await new Promise((C) => {
                      const _ = new FileReader();
                      _.onload = () => C(_.result), _.readAsDataURL(x);
                    });
                    Zr.set(y, k), bi.add(y), h10 = h10.replace(m[0], `url(${k})`);
                  } catch {
                    console.warn("[snapdom] Failed to fetch font URL:", y);
                  }
              }
            }
            i += `@font-face {
  font-family: ${l};
  src: ${h10};
  font-style: ${o.style.getPropertyValue("font-style") || "normal"};
  font-weight: ${o.style.getPropertyValue("font-weight") || "normal"};
}
`;
          }
      }
    } catch (o) {
      console.warn("[snapdom] Cannot access stylesheet", s.href, o);
    }
  for (const s of document.fonts)
    if (s.family && s.status === "loaded" && s._snapdomSrc) {
      if (Gi(s.family)) continue;
      let o = s._snapdomSrc;
      if (!o.startsWith("data:")) {
        if (Zr.has(s._snapdomSrc))
          o = Zr.get(s._snapdomSrc), bi.add(s._snapdomSrc);
        else if (!bi.has(s._snapdomSrc))
          try {
            const a = await (await fetch(s._snapdomSrc)).blob();
            o = await new Promise((l) => {
              const c = new FileReader();
              c.onload = () => l(c.result), c.readAsDataURL(a);
            }), Zr.set(s._snapdomSrc, o), bi.add(s._snapdomSrc);
          } catch {
            console.warn("[snapdom] Failed to fetch dynamic font src:", s._snapdomSrc);
            continue;
          }
      }
      i += `@font-face {
  font-family: '${s.family}';
  src: url(${o});
  font-style: ${s.style || "normal"};
  font-weight: ${s.weight || "normal"};
}
`;
    }
  if (i && (Zr.set("fonts-embed-css", i), t15)) {
    const s = document.createElement("style");
    s.setAttribute("data-snapdom", "embedFonts"), s.textContent = i, document.head.appendChild(s);
  }
  return i;
}
async function M6(t15, e, r, n, i, s = false, o) {
  var _a2;
  if (!(t15 instanceof Element) || !(e instanceof Element)) return;
  for (const c of ["::before", "::after", "::first-letter"])
    try {
      const h10 = Am(t15, c);
      if (!h10 || typeof h10[Symbol.iterator] != "function") continue;
      if (c === "::first-letter") {
        const C = getComputedStyle(t15);
        if (!(h10.color !== C.color || h10.fontSize !== C.fontSize || h10.fontWeight !== C.fontWeight)) continue;
        const _ = Array.from(e.childNodes).find(
          (W) => W.nodeType === Node.TEXT_NODE && W.textContent && W.textContent.trim().length > 0
        );
        if (!_) continue;
        const $ = _.textContent, L = (_a2 = $.match(/^([^\p{L}\p{N}\s]*[\p{L}\p{N}](?:['’])?)/u)) == null ? void 0 : _a2[0], B = $.slice((L == null ? void 0 : L.length) || 0);
        if (!L || /[\uD800-\uDFFF]/.test(L)) continue;
        const q = document.createElement("span");
        q.textContent = L, q.dataset.snapdomPseudo = "::first-letter";
        const H = Tb(h10), G = Af(H, "span", i);
        r.set(q, G);
        const F = document.createTextNode(B);
        e.replaceChild(F, _), e.insertBefore(q, F);
        continue;
      }
      const p = h10.getPropertyValue("content"), m = h10.getPropertyValue("background-image"), g = h10.getPropertyValue("background-color"), y = p !== "none", x = m && m !== "none", k = g && g !== "transparent" && g !== "rgba(0, 0, 0, 0)";
      if (y || x || k) {
        const C = h10.getPropertyValue("font-family"), _ = parseInt(h10.getPropertyValue("font-size")) || 32, $ = parseInt(h10.getPropertyValue("font-weight")) || false, L = h10.getPropertyValue("color") || "#000", B = document.createElement("span");
        B.dataset.snapdomPseudo = c;
        const q = Tb(h10), H = Af(q, "span", i);
        r.set(B, H);
        const G = Gi(C), F = uz(p);
        if (G && F.length === 1) {
          const W = document.createElement("img");
          W.src = await yz(F, C, $, _, L), W.style = `width:${_}px;height:auto;object-fit:contain;`, B.appendChild(W);
        } else if (F.startsWith("url(")) {
          const W = T6(F);
          if (W && W.trim() !== "")
            try {
              const R = document.createElement("img"), J = await $m(Em(W, { useProxy: o }));
              R.src = J, R.style = `width:${_}px;height:auto;object-fit:contain;`, B.appendChild(R);
            } catch (R) {
              console.error(`[snapdom] Error in pseudo ${c} for`, t15, R);
            }
        } else !G && F && F !== "none" && (B.textContent = F);
        if (x)
          try {
            const W = $6(m), R = await Promise.all(
              W.map((J) => S6(J))
            );
            B.style.backgroundImage = R.join(", ");
          } catch (W) {
            console.warn(`[snapdom] Failed to inline background-image for ${c}`, W);
          }
        if (k && (B.style.backgroundColor = g), !(B.childNodes.length > 0 || B.textContent && B.textContent.trim() !== "" || x || k)) continue;
        c === "::before" ? e.insertBefore(B, e.firstChild) : e.appendChild(B);
      }
    } catch (h10) {
      console.warn(`[snapdom] Failed to capture ${c} for`, t15, h10);
    }
  const a = Array.from(t15.children), l = Array.from(e.children).filter((c) => !c.dataset.snapdomPseudo);
  for (let c = 0; c < Math.min(a.length, l.length); c++)
    await M6(
      a[c],
      l[c],
      r,
      n,
      i,
      s,
      o
    );
}
function wz(t15) {
  if (!t15) return;
  const e = document.querySelectorAll("svg > defs");
  e.length && t15.querySelectorAll("svg").forEach((r) => {
    const n = r.querySelectorAll("use");
    if (!n.length) return;
    const i = /* @__PURE__ */ new Set();
    if (n.forEach((o) => {
      const a = o.getAttribute("xlink:href") || o.getAttribute("href");
      a && a.startsWith("#") && i.add(a.slice(1));
    }), !i.size) return;
    const s = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    for (const o of i)
      for (const a of e) {
        const l = a.querySelector(`#${CSS.escape(o)}`);
        if (l) {
          s.appendChild(l.cloneNode(true));
          break;
        }
      }
    s.childNodes.length && r.insertBefore(s, r.firstChild);
  });
}
async function kz(t15, e = false, r = false, n = {}) {
  var _a2;
  const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new Map();
  let a;
  try {
    a = Eh(t15, i, s, o, e, n, t15);
  } catch (c) {
    throw console.warn("deepClone failed:", c), c;
  }
  try {
    await M6(t15, a, i, s, e, r, n.useProxy);
  } catch (c) {
    console.warn("inlinePseudoElements failed:", c);
  }
  try {
    wz(a);
  } catch (c) {
    console.warn("inlineExternalDef failed:", c);
  }
  let l = "";
  if (e) {
    const c = hz(i);
    l = Array.from(c.entries()).map(([h10, p]) => `.${p}{${h10}}`).join("");
    for (const [h10, p] of i.entries()) {
      if (h10.tagName === "STYLE") continue;
      const m = c.get(p);
      m && h10.classList.add(m);
      const g = (_a2 = h10.style) == null ? void 0 : _a2.backgroundImage;
      h10.removeAttribute("style"), g && g !== "none" && (h10.style.backgroundImage = g);
    }
  } else
    for (const [c, h10] of i.entries())
      c.tagName !== "STYLE" && c.setAttribute("style", h10.replace(/;/g, "; "));
  for (const [c, h10] of o.entries()) {
    const p = h10.scrollLeft, m = h10.scrollTop;
    if ((p || m) && c instanceof HTMLElement) {
      c.style.overflow = "hidden", c.style.scrollbarWidth = "none", c.style.msOverflowStyle = "none";
      const g = document.createElement("div");
      for (g.style.transform = `translate(${-p}px, ${-m}px)`, g.style.willChange = "transform", g.style.display = "inline-block", g.style.width = "100%"; c.firstChild; )
        g.appendChild(c.firstChild);
      c.appendChild(g);
    }
  }
  if (t15 === o.get(a)) {
    const c = s.get(t15) || window.getComputedStyle(t15);
    s.set(t15, c);
    const h10 = dz(c.transform);
    a.style.margin = "0", a.style.position = "static", a.style.top = "auto", a.style.left = "auto", a.style.right = "auto", a.style.bottom = "auto", a.style.zIndex = "auto", a.style.float = "none", a.style.clear = "none", a.style.transform = h10 || "";
  }
  for (const [c, h10] of o.entries())
    h10.tagName === "PRE" && (c.style.marginTop = "0", c.style.marginBlockStart = "0");
  return { clone: a, classCSS: l, styleCache: s };
}
async function vz(t15, e = {}) {
  const r = Array.from(t15.querySelectorAll("img")), n = async (i) => {
    const s = i.src;
    try {
      const o = await $m(s, { useProxy: e.useProxy });
      i.src = o, i.width || (i.width = i.naturalWidth || 100), i.height || (i.height = i.naturalHeight || 100);
    } catch {
      const o = document.createElement("div");
      o.style = `width: ${i.width || 100}px; height: ${i.height || 100}px; background: #ccc; display: inline-block; text-align: center; line-height: ${i.height || 100}px; color: #666; font-size: 12px;`, o.innerText = "img", i.replaceWith(o);
    }
  };
  for (let i = 0; i < r.length; i += 4) {
    const s = r.slice(i, i + 4).map(n);
    await Promise.allSettled(s);
  }
}
async function _z(t15, e, r, n = {}) {
  const i = [[t15, e]], s = [
    "background-image",
    "mask",
    "mask-image",
    "-webkit-mask-image",
    "mask-source",
    "mask-box-image-source",
    "mask-border-source",
    "-webkit-mask-box-image-source"
  ];
  for (; i.length; ) {
    const [o, a] = i.shift(), l = r.get(o) || Am(o);
    r.has(o) || r.set(o, l);
    for (const m of s) {
      const g = l.getPropertyValue(m);
      if (!g || g === "none") continue;
      const y = $6(g), x = await Promise.all(
        y.map((k) => S6(k, n))
      );
      x.some((k) => k && k !== "none" && !/^url\(undefined/.test(k)) && a.style.setProperty(m, x.join(", "));
    }
    const c = l.getPropertyValue("background-color");
    c && c !== "transparent" && c !== "rgba(0, 0, 0, 0)" && (a.style.backgroundColor = c);
    const h10 = Array.from(o.children), p = Array.from(a.children);
    for (let m = 0; m < Math.min(h10.length, p.length); m++)
      i.push([h10[m], p[m]]);
  }
}
async function Cz(t15, e = {}) {
  if (!t15) throw new Error("Element cannot be null or undefined");
  const { compress: r = true, embedFonts: n = false, fast: i = true, scale: s = 1, useProxy: o = "" } = e;
  let a, l, c, h10 = "", p = "", m, g;
  if ({ clone: a, classCSS: l, styleCache: c } = await kz(t15, r, n, e), await new Promise((x) => {
    za(async () => {
      await vz(a, e), x();
    }, { fast: i });
  }), await new Promise((x) => {
    za(async () => {
      await _z(t15, a, c, e), x();
    }, { fast: i });
  }), n && await new Promise((x) => {
    za(async () => {
      h10 = await xz(), x();
    }, { fast: i });
  }), r) {
    const x = lz(a).sort(), k = x.join(",");
    lp.has(k) ? p = lp.get(k) : await new Promise((C) => {
      za(() => {
        p = cz(x), lp.set(k, p), C();
      }, { fast: i });
    });
  }
  await new Promise((x) => {
    za(() => {
      const k = t15.getBoundingClientRect();
      let C = k.width, _ = k.height;
      const $ = Number.isFinite(e.width), L = Number.isFinite(e.height), B = typeof s == "number" && s !== 1;
      if (!B) {
        const W = k.width / k.height;
        $ && L ? (C = e.width, _ = e.height) : $ ? (C = e.width, _ = C / W) : L && (_ = e.height, C = _ * W);
      }
      if (C = Math.ceil(C), _ = Math.ceil(_), a.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), a.style.transformOrigin = "top left", !B && ($ || L)) {
        const W = k.width, R = k.height, J = C / W, rt = _ / R, I = a.style.transform || "", j = `scale(${J}, ${rt})`;
        a.style.transform = `${j} ${I}`.trim();
      } else B && A6() && (a.style.scale = `${s}`);
      const q = "http://www.w3.org/2000/svg", H = document.createElementNS(q, "foreignObject");
      H.setAttribute("width", "100%"), H.setAttribute("height", "100%");
      const G = document.createElement("style");
      G.textContent = p + h10 + "svg{overflow:visible;}" + l, H.appendChild(G), H.appendChild(a);
      const F = new XMLSerializer().serializeToString(H);
      g = `<svg xmlns="${q}" width="${C}" height="${_}" viewBox="0 0 ${C} ${_}">` + F + "</svg>", m = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(g)}`, x();
    }, { fast: i });
  });
  const y = document.getElementById("snapdom-sandbox");
  return y && y.style.position === "absolute" && y.remove(), m;
}
async function Sz(t15, { dpr: e = 1, scale: r = 1 }) {
  const n = new Image();
  return n.src = t15, await n.decode(), A6 ? (n.width = n.width * r, n.height = n.height * r) : (n.width = n.width / r, n.height = n.height / r), n;
}
async function B6(t15, { dpr: e = 1, scale: r = 1 } = {}) {
  const n = new Image();
  n.src = t15, await n.decode();
  const i = document.createElement("canvas"), s = n.width * r, o = n.height * r;
  i.width = Math.ceil(s * e), i.height = Math.ceil(o * e);
  const a = i.getContext("2d");
  return a.scale(e, e), a.drawImage(n, 0, 0, s, o), i.style.width = `${s}px`, i.style.height = `${o}px`, i;
}
async function L6(t15, {
  type: e = "svg",
  scale: r = 1,
  backgroundColor: n = "#fff",
  quality: i
} = {}) {
  const s = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[e] || "image/png";
  if (e === "svg") {
    const a = decodeURIComponent(t15.split(",")[1]);
    return new Blob([a], { type: "image/svg+xml" });
  }
  const o = await Mm(t15, { dpr: 1, scale: r }, n);
  return new Promise((a) => {
    o.toBlob((l) => a(l), `${s}`, i);
  });
}
async function Mm(t15, { dpr: e = 1, scale: r = 1 }, n) {
  const i = await B6(t15, { dpr: e, scale: r });
  if (!n) return i;
  const s = document.createElement("canvas");
  s.width = i.width, s.height = i.height;
  const o = s.getContext("2d");
  return o.fillStyle = n, o.fillRect(0, 0, s.width, s.height), o.drawImage(i, 0, 0), s;
}
async function up(t15, { dpr: e = 1, scale: r = 1, backgroundColor: n = "#fff", quality: i }, s = "png") {
  const o = await Mm(t15, { dpr: e, scale: r }, n), a = new Image();
  return a.src = o.toDataURL(`image/${s}`, i), await a.decode(), a.style.width = `${o.width / e}px`, a.style.height = `${o.height / e}px`, a;
}
async function Tz(t15, { dpr: e = 1, scale: r = 1, backgroundColor: n = "#fff", format: i = "png", filename: s = "capture" } = {}) {
  if (i === "svg") {
    const p = await L6(t15), m = URL.createObjectURL(p), g = document.createElement("a");
    g.href = m, g.download = `${s}.svg`, g.click(), URL.revokeObjectURL(m);
    return;
  }
  const o = ["jpg", "jpeg", "webp"].includes(i) ? "#fff" : void 0, a = await Mm(t15, { dpr: e, scale: r }, n ?? o), l = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[i] || "image/png", c = a.toDataURL(l), h10 = document.createElement("a");
  h10.href = c, h10.download = `${s}.${i}`, h10.click();
}
async function Ze(t15, e = {}) {
  if (e = { scale: 1, ...e }, !t15) throw new Error("Element cannot be null or undefined");
  return e.iconFonts && gz(e.iconFonts), await Ze.capture(t15, e);
}
Ze.capture = async (t15, e = {}) => {
  const r = await Cz(t15, e), n = window.devicePixelRatio || 1, i = e.scale || 1;
  return {
    url: r,
    options: e,
    toRaw: () => r,
    toImg: () => Sz(r, { dpr: n, scale: i }),
    toCanvas: () => B6(r, { dpr: n, scale: i }),
    toBlob: (s) => L6(r, { scale: i, ...s }),
    toPng: (s) => up(r, { dpr: n, scale: i, ...s }, "png"),
    toJpg: (s) => up(r, { dpr: n, scale: i, ...s }, "jpeg"),
    toWebp: (s) => up(r, { dpr: n, scale: i, ...s }, "webp"),
    download: ({ format: s = "png", filename: o = "capture", backgroundColor: a } = {}) => Tz(r, { dpr: n, scale: i, backgroundColor: a, format: s, filename: o })
  };
};
Ze.toRaw = async (t15, e) => (await Ze.capture(t15, e)).toRaw();
Ze.toImg = async (t15, e) => (await Ze.capture(t15, e)).toImg();
Ze.toCanvas = async (t15, e) => (await Ze.capture(t15, e)).toCanvas();
Ze.toBlob = async (t15, e) => (await Ze.capture(t15, e)).toBlob(e);
Ze.toPng = async (t15, e) => (await Ze.capture(t15, e)).toPng(e);
Ze.toJpg = async (t15, e) => (await Ze.capture(t15, e)).toJpg(e);
Ze.toWebp = async (t15, e) => (await Ze.capture(t15, e)).toWebp(e);
Ze.download = async (t15, e = {}) => {
  const {
    format: r = "png",
    filename: n = "capture",
    backgroundColor: i,
    ...s
  } = e;
  return await (await Ze.capture(t15, s)).download({ format: r, filename: n, backgroundColor: i });
};
var Ef = { exports: {} };
var Az = Ef.exports;
var $b;
function $z() {
  return $b || ($b = 1, function(t15, e) {
    (function(r, n) {
      t15.exports = n();
    })(Az, function() {
      var r = 1e3, n = 6e4, i = 36e5, s = "millisecond", o = "second", a = "minute", l = "hour", c = "day", h10 = "week", p = "month", m = "quarter", g = "year", y = "date", x = "Invalid Date", k = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, C = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, _ = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(I) {
        var j = ["th", "st", "nd", "rd"], z = I % 100;
        return "[" + I + (j[(z - 20) % 10] || j[z] || j[0]) + "]";
      } }, $ = function(I, j, z) {
        var K = String(I);
        return !K || K.length >= j ? I : "" + Array(j + 1 - K.length).join(z) + I;
      }, L = { s: $, z: function(I) {
        var j = -I.utcOffset(), z = Math.abs(j), K = Math.floor(z / 60), Y = z % 60;
        return (j <= 0 ? "+" : "-") + $(K, 2, "0") + ":" + $(Y, 2, "0");
      }, m: function I(j, z) {
        if (j.date() < z.date()) return -I(z, j);
        var K = 12 * (z.year() - j.year()) + (z.month() - j.month()), Y = j.clone().add(K, p), at = z - Y < 0, et = j.clone().add(K + (at ? -1 : 1), p);
        return +(-(K + (z - Y) / (at ? Y - et : et - Y)) || 0);
      }, a: function(I) {
        return I < 0 ? Math.ceil(I) || 0 : Math.floor(I);
      }, p: function(I) {
        return { M: p, y: g, w: h10, d: c, D: y, h: l, m: a, s: o, ms: s, Q: m }[I] || String(I || "").toLowerCase().replace(/s$/, "");
      }, u: function(I) {
        return I === void 0;
      } }, B = "en", q = {};
      q[B] = _;
      var H = "$isDayjsObject", G = function(I) {
        return I instanceof J || !(!I || !I[H]);
      }, F = function I(j, z, K) {
        var Y;
        if (!j) return B;
        if (typeof j == "string") {
          var at = j.toLowerCase();
          q[at] && (Y = at), z && (q[at] = z, Y = at);
          var et = j.split("-");
          if (!Y && et.length > 1) return I(et[0]);
        } else {
          var ht = j.name;
          q[ht] = j, Y = ht;
        }
        return !K && Y && (B = Y), Y || !K && B;
      }, W = function(I, j) {
        if (G(I)) return I.clone();
        var z = typeof j == "object" ? j : {};
        return z.date = I, z.args = arguments, new J(z);
      }, R = L;
      R.l = F, R.i = G, R.w = function(I, j) {
        return W(I, { locale: j.$L, utc: j.$u, x: j.$x, $offset: j.$offset });
      };
      var J = function() {
        function I(z) {
          this.$L = F(z.locale, null, true), this.parse(z), this.$x = this.$x || z.x || {}, this[H] = true;
        }
        var j = I.prototype;
        return j.parse = function(z) {
          this.$d = function(K) {
            var Y = K.date, at = K.utc;
            if (Y === null) return /* @__PURE__ */ new Date(NaN);
            if (R.u(Y)) return /* @__PURE__ */ new Date();
            if (Y instanceof Date) return new Date(Y);
            if (typeof Y == "string" && !/Z$/i.test(Y)) {
              var et = Y.match(k);
              if (et) {
                var ht = et[2] - 1 || 0, X = (et[7] || "0").substring(0, 3);
                return at ? new Date(Date.UTC(et[1], ht, et[3] || 1, et[4] || 0, et[5] || 0, et[6] || 0, X)) : new Date(et[1], ht, et[3] || 1, et[4] || 0, et[5] || 0, et[6] || 0, X);
              }
            }
            return new Date(Y);
          }(z), this.init();
        }, j.init = function() {
          var z = this.$d;
          this.$y = z.getFullYear(), this.$M = z.getMonth(), this.$D = z.getDate(), this.$W = z.getDay(), this.$H = z.getHours(), this.$m = z.getMinutes(), this.$s = z.getSeconds(), this.$ms = z.getMilliseconds();
        }, j.$utils = function() {
          return R;
        }, j.isValid = function() {
          return this.$d.toString() !== x;
        }, j.isSame = function(z, K) {
          var Y = W(z);
          return this.startOf(K) <= Y && Y <= this.endOf(K);
        }, j.isAfter = function(z, K) {
          return W(z) < this.startOf(K);
        }, j.isBefore = function(z, K) {
          return this.endOf(K) < W(z);
        }, j.$g = function(z, K, Y) {
          return R.u(z) ? this[K] : this.set(Y, z);
        }, j.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, j.valueOf = function() {
          return this.$d.getTime();
        }, j.startOf = function(z, K) {
          var Y = this, at = !!R.u(K) || K, et = R.p(z), ht = function(wt, Tt) {
            var Ut = R.w(Y.$u ? Date.UTC(Y.$y, Tt, wt) : new Date(Y.$y, Tt, wt), Y);
            return at ? Ut : Ut.endOf(c);
          }, X = function(wt, Tt) {
            return R.w(Y.toDate()[wt].apply(Y.toDate("s"), (at ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Tt)), Y);
          }, ct = this.$W, gt = this.$M, xt = this.$D, Yt = "set" + (this.$u ? "UTC" : "");
          switch (et) {
            case g:
              return at ? ht(1, 0) : ht(31, 11);
            case p:
              return at ? ht(1, gt) : ht(0, gt + 1);
            case h10:
              var U = this.$locale().weekStart || 0, mt = (ct < U ? ct + 7 : ct) - U;
              return ht(at ? xt - mt : xt + (6 - mt), gt);
            case c:
            case y:
              return X(Yt + "Hours", 0);
            case l:
              return X(Yt + "Minutes", 1);
            case a:
              return X(Yt + "Seconds", 2);
            case o:
              return X(Yt + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, j.endOf = function(z) {
          return this.startOf(z, false);
        }, j.$set = function(z, K) {
          var Y, at = R.p(z), et = "set" + (this.$u ? "UTC" : ""), ht = (Y = {}, Y[c] = et + "Date", Y[y] = et + "Date", Y[p] = et + "Month", Y[g] = et + "FullYear", Y[l] = et + "Hours", Y[a] = et + "Minutes", Y[o] = et + "Seconds", Y[s] = et + "Milliseconds", Y)[at], X = at === c ? this.$D + (K - this.$W) : K;
          if (at === p || at === g) {
            var ct = this.clone().set(y, 1);
            ct.$d[ht](X), ct.init(), this.$d = ct.set(y, Math.min(this.$D, ct.daysInMonth())).$d;
          } else ht && this.$d[ht](X);
          return this.init(), this;
        }, j.set = function(z, K) {
          return this.clone().$set(z, K);
        }, j.get = function(z) {
          return this[R.p(z)]();
        }, j.add = function(z, K) {
          var Y, at = this;
          z = Number(z);
          var et = R.p(K), ht = function(gt) {
            var xt = W(at);
            return R.w(xt.date(xt.date() + Math.round(gt * z)), at);
          };
          if (et === p) return this.set(p, this.$M + z);
          if (et === g) return this.set(g, this.$y + z);
          if (et === c) return ht(1);
          if (et === h10) return ht(7);
          var X = (Y = {}, Y[a] = n, Y[l] = i, Y[o] = r, Y)[et] || 1, ct = this.$d.getTime() + z * X;
          return R.w(ct, this);
        }, j.subtract = function(z, K) {
          return this.add(-1 * z, K);
        }, j.format = function(z) {
          var K = this, Y = this.$locale();
          if (!this.isValid()) return Y.invalidDate || x;
          var at = z || "YYYY-MM-DDTHH:mm:ssZ", et = R.z(this), ht = this.$H, X = this.$m, ct = this.$M, gt = Y.weekdays, xt = Y.months, Yt = Y.meridiem, U = function(Tt, Ut, Ce, ue) {
            return Tt && (Tt[Ut] || Tt(K, at)) || Ce[Ut].slice(0, ue);
          }, mt = function(Tt) {
            return R.s(ht % 12 || 12, Tt, "0");
          }, wt = Yt || function(Tt, Ut, Ce) {
            var ue = Tt < 12 ? "AM" : "PM";
            return Ce ? ue.toLowerCase() : ue;
          };
          return at.replace(C, function(Tt, Ut) {
            return Ut || function(Ce) {
              switch (Ce) {
                case "YY":
                  return String(K.$y).slice(-2);
                case "YYYY":
                  return R.s(K.$y, 4, "0");
                case "M":
                  return ct + 1;
                case "MM":
                  return R.s(ct + 1, 2, "0");
                case "MMM":
                  return U(Y.monthsShort, ct, xt, 3);
                case "MMMM":
                  return U(xt, ct);
                case "D":
                  return K.$D;
                case "DD":
                  return R.s(K.$D, 2, "0");
                case "d":
                  return String(K.$W);
                case "dd":
                  return U(Y.weekdaysMin, K.$W, gt, 2);
                case "ddd":
                  return U(Y.weekdaysShort, K.$W, gt, 3);
                case "dddd":
                  return gt[K.$W];
                case "H":
                  return String(ht);
                case "HH":
                  return R.s(ht, 2, "0");
                case "h":
                  return mt(1);
                case "hh":
                  return mt(2);
                case "a":
                  return wt(ht, X, true);
                case "A":
                  return wt(ht, X, false);
                case "m":
                  return String(X);
                case "mm":
                  return R.s(X, 2, "0");
                case "s":
                  return String(K.$s);
                case "ss":
                  return R.s(K.$s, 2, "0");
                case "SSS":
                  return R.s(K.$ms, 3, "0");
                case "Z":
                  return et;
              }
              return null;
            }(Tt) || et.replace(":", "");
          });
        }, j.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, j.diff = function(z, K, Y) {
          var at, et = this, ht = R.p(K), X = W(z), ct = (X.utcOffset() - this.utcOffset()) * n, gt = this - X, xt = function() {
            return R.m(et, X);
          };
          switch (ht) {
            case g:
              at = xt() / 12;
              break;
            case p:
              at = xt();
              break;
            case m:
              at = xt() / 3;
              break;
            case h10:
              at = (gt - ct) / 6048e5;
              break;
            case c:
              at = (gt - ct) / 864e5;
              break;
            case l:
              at = gt / i;
              break;
            case a:
              at = gt / n;
              break;
            case o:
              at = gt / r;
              break;
            default:
              at = gt;
          }
          return Y ? at : R.a(at);
        }, j.daysInMonth = function() {
          return this.endOf(p).$D;
        }, j.$locale = function() {
          return q[this.$L];
        }, j.locale = function(z, K) {
          if (!z) return this.$L;
          var Y = this.clone(), at = F(z, K, true);
          return at && (Y.$L = at), Y;
        }, j.clone = function() {
          return R.w(this.$d, this);
        }, j.toDate = function() {
          return new Date(this.valueOf());
        }, j.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, j.toISOString = function() {
          return this.$d.toISOString();
        }, j.toString = function() {
          return this.$d.toUTCString();
        }, I;
      }(), rt = J.prototype;
      return W.prototype = rt, [["$ms", s], ["$s", o], ["$m", a], ["$H", l], ["$W", c], ["$M", p], ["$y", g], ["$D", y]].forEach(function(I) {
        rt[I[1]] = function(j) {
          return this.$g(j, I[0], I[1]);
        };
      }), W.extend = function(I, j) {
        return I.$i || (I(j, J, W), I.$i = true), W;
      }, W.locale = F, W.isDayjs = G, W.unix = function(I) {
        return W(1e3 * I);
      }, W.en = q[B], W.Ls = q, W.p = {}, W;
    });
  }(Ef)), Ef.exports;
}
$z();
function Ez(t15) {
  navigator.clipboard.writeText(t15);
}
var Mf = 1;
var Mz = class {
  constructor() {
    __publicField(this, "subscribers");
    __publicField(this, "toasts");
    __publicField(this, "dismissedToasts");
    __publicField(this, "subscribe", (e) => (this.subscribers.push(e), () => {
      const r = this.subscribers.indexOf(e);
      this.subscribers.splice(r, 1);
    }));
    __publicField(this, "publish", (e) => {
      this.subscribers.forEach((r) => r(e));
    });
    __publicField(this, "addToast", (e) => {
      this.publish(e), this.toasts = [...this.toasts, e];
    });
    __publicField(this, "create", (e) => {
      var _a2;
      const { message: r, ...n } = e, i = typeof e.id == "number" || e.id && ((_a2 = e.id) == null ? void 0 : _a2.length) > 0 ? e.id : Mf++, s = this.toasts.find((a) => a.id === i), o = e.dismissible === void 0 ? true : e.dismissible;
      return this.dismissedToasts.has(i) && this.dismissedToasts.delete(i), s ? this.toasts = this.toasts.map((a) => a.id === i ? (this.publish({
        ...a,
        ...e,
        id: i,
        title: r
      }), {
        ...a,
        ...e,
        id: i,
        dismissible: o,
        title: r
      }) : a) : this.addToast({
        title: r,
        ...n,
        dismissible: o,
        id: i
      }), i;
    });
    __publicField(this, "dismiss", (e) => (e ? (this.dismissedToasts.add(e), requestAnimationFrame(() => this.subscribers.forEach((r) => r({
      id: e,
      dismiss: true
    })))) : this.toasts.forEach((r) => {
      this.subscribers.forEach((n) => n({
        id: r.id,
        dismiss: true
      }));
    }), e));
    __publicField(this, "message", (e, r) => this.create({
      ...r,
      message: e,
      type: "default"
    }));
    __publicField(this, "error", (e, r) => this.create({
      ...r,
      type: "error",
      message: e
    }));
    __publicField(this, "success", (e, r) => this.create({
      ...r,
      type: "success",
      message: e
    }));
    __publicField(this, "info", (e, r) => this.create({
      ...r,
      type: "info",
      message: e
    }));
    __publicField(this, "warning", (e, r) => this.create({
      ...r,
      type: "warning",
      message: e
    }));
    __publicField(this, "loading", (e, r) => this.create({
      ...r,
      type: "loading",
      message: e
    }));
    __publicField(this, "promise", (e, r) => {
      if (!r) return;
      let n;
      r.loading !== void 0 && (n = this.create({
        ...r,
        promise: e,
        type: "loading",
        message: r.loading,
        description: typeof r.description != "function" ? r.description : void 0
      }));
      const i = Promise.resolve(e instanceof Function ? e() : e);
      let s = n !== void 0, o;
      const a = i.then(async (c) => {
        if (o = ["resolve", c], isVNode(c))
          s = false, this.create({
            id: n,
            type: "default",
            message: c
          });
        else if (Lz(c) && !c.ok) {
          s = false;
          const h10 = typeof r.error == "function" ? await r.error(`HTTP error! status: ${c.status}`) : r.error, p = typeof r.description == "function" ? await r.description(`HTTP error! status: ${c.status}`) : r.description, m = typeof h10 == "object" && !isVNode(h10) ? h10 : {
            message: h10 || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: p,
            ...m
          });
        } else if (c instanceof Error) {
          s = false;
          const h10 = typeof r.error == "function" ? await r.error(c) : r.error, p = typeof r.description == "function" ? await r.description(c) : r.description, m = typeof h10 == "object" && !isVNode(h10) ? h10 : {
            message: h10 || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: p,
            ...m
          });
        } else if (r.success !== void 0) {
          s = false;
          const h10 = typeof r.success == "function" ? await r.success(c) : r.success, p = typeof r.description == "function" ? await r.description(c) : r.description, m = typeof h10 == "object" && !isVNode(h10) ? h10 : {
            message: h10 || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "success",
            description: p,
            ...m
          });
        }
      }).catch(async (c) => {
        if (o = ["reject", c], r.error !== void 0) {
          s = false;
          const h10 = typeof r.error == "function" ? await r.error(c) : r.error, p = typeof r.description == "function" ? await r.description(c) : r.description, m = typeof h10 == "object" && !isVNode(h10) ? h10 : {
            message: h10 || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: p,
            ...m
          });
        }
      }).finally(() => {
        var _a2;
        s && (this.dismiss(n), n = void 0), (_a2 = r.finally) == null ? void 0 : _a2.call(r);
      }), l = () => new Promise((c, h10) => a.then(() => o[0] === "reject" ? h10(o[1]) : c(o[1])).catch(h10));
      return typeof n != "string" && typeof n != "number" ? { unwrap: l } : Object.assign(n, { unwrap: l });
    });
    __publicField(this, "custom", (e, r) => {
      const n = (r == null ? void 0 : r.id) || Mf++;
      return this.publish({
        component: e,
        id: n,
        ...r
      }), n;
    });
    __publicField(this, "getActiveToasts", () => this.toasts.filter((e) => !this.dismissedToasts.has(e.id)));
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
};
var zr = new Mz();
function Bz(t15, e) {
  const r = (e == null ? void 0 : e.id) || Mf++;
  return zr.create({
    message: t15,
    id: r,
    type: "default",
    ...e
  }), r;
}
var Lz = (t15) => t15 && typeof t15 == "object" && "ok" in t15 && typeof t15.ok == "boolean" && "status" in t15 && typeof t15.status == "number";
var Dz = Bz;
var Fz = () => zr.toasts;
var Nz = () => zr.getActiveToasts();
var Eb = Object.assign(Dz, {
  success: zr.success,
  info: zr.info,
  warning: zr.warning,
  error: zr.error,
  custom: zr.custom,
  message: zr.message,
  promise: zr.promise,
  dismiss: zr.dismiss,
  loading: zr.loading
}, {
  getHistory: Fz,
  getToasts: Nz
});
function ih(t15) {
  return t15.label !== void 0;
}
var Iz = 3;
var D6 = "24px";
var F6 = "16px";
var Mb = 4e3;
var Oz = 356;
var zz = 14;
var qz = 45;
var N6 = 200;
function Rz() {
  const t15 = ref(false);
  return watchEffect(() => {
    const e = () => {
      t15.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", e), () => window.removeEventListener("visibilitychange", e);
  }), { isDocumentHidden: t15 };
}
function Ui(...t15) {
  return t15.filter(Boolean).join(" ");
}
function Pz(t15) {
  const [e, r] = t15.split("-"), n = [];
  return e && n.push(e), r && n.push(r), n;
}
function jz(t15, e) {
  const r = {};
  return [t15, e].forEach((n, i) => {
    const s = i === 1, o = s ? "--mobile-offset" : "--offset", a = s ? F6 : D6;
    function l(c) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((h10) => {
        r[`${o}-${h10}`] = typeof c == "number" ? `${c}px` : c;
      });
    }
    typeof n == "number" || typeof n == "string" ? l(n) : typeof n == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((c) => {
      n[c] === void 0 ? r[`${o}-${c}`] = a : r[`${o}-${c}`] = typeof n[c] == "number" ? `${n[c]}px` : n[c];
    }) : l(a);
  }), r;
}
var Wz = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded"
];
var Hz = ["aria-label", "data-disabled"];
var Uz = defineComponent({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(t15, { emit: e }) {
    const r = t15, n = e, i = ref(null), s = ref(null), o = ref(false), a = ref(false), l = ref(false), c = ref(false), h10 = ref(false), p = ref(0), m = ref(0), g = ref(r.toast.duration || r.duration || Mb), y = ref(null), x = ref(null), k = computed(() => r.index === 0), C = computed(() => r.index + 1 <= r.visibleToasts), _ = computed(() => r.toast.type), $ = computed(() => r.toast.dismissible !== false), L = computed(() => r.toast.class || ""), B = computed(() => r.descriptionClass || ""), q = computed(() => {
      const U = r.toast.position || r.position, mt = r.heights.filter((wt) => wt.position === U).findIndex((wt) => wt.toastId === r.toast.id);
      return mt >= 0 ? mt : 0;
    }), H = computed(() => {
      const U = r.toast.position || r.position;
      return r.heights.filter((mt) => mt.position === U).reduce((mt, wt, Tt) => Tt >= q.value ? mt : mt + wt.height, 0);
    }), G = computed(() => q.value * r.gap + H.value || 0), F = computed(() => r.toast.closeButton ?? r.closeButton), W = computed(() => r.toast.duration || r.duration || Mb), R = ref(0), J = ref(0), rt = ref(null), I = computed(() => r.position.split("-")), j = computed(() => I.value[0]), z = computed(() => I.value[1]), K = computed(() => typeof r.toast.title != "string"), Y = computed(() => typeof r.toast.description != "string"), { isDocumentHidden: at } = Rz(), et = computed(() => _.value && _.value === "loading");
    onMounted(() => {
      o.value = true, g.value = W.value;
    }), watchEffect(async () => {
      if (!o.value || !x.value) return;
      await nextTick();
      const U = x.value, mt = U.style.height;
      U.style.height = "auto";
      const wt = U.getBoundingClientRect().height;
      U.style.height = mt, m.value = wt, n("update:height", {
        toastId: r.toast.id,
        height: wt,
        position: r.toast.position || r.position
      });
    });
    function ht() {
      a.value = true, p.value = G.value, setTimeout(() => {
        n("removeToast", r.toast);
      }, N6);
    }
    function X() {
      var _a2, _b2;
      if (et.value || !$.value) return {};
      ht(), (_b2 = (_a2 = r.toast).onDismiss) == null ? void 0 : _b2.call(_a2, r.toast);
    }
    function ct(U) {
      et.value || !$.value || (y.value = /* @__PURE__ */ new Date(), p.value = G.value, U.target.setPointerCapture(U.pointerId), U.target.tagName !== "BUTTON" && (l.value = true, rt.value = {
        x: U.clientX,
        y: U.clientY
      }));
    }
    function gt() {
      var _a2, _b2, _c, _d, _e, _f2, _g2;
      if (c.value || !$.value) return;
      rt.value = null;
      const U = Number(((_a2 = x.value) == null ? void 0 : _a2.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), mt = Number(((_b2 = x.value) == null ? void 0 : _b2.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), wt = (/* @__PURE__ */ new Date()).getTime() - (((_c = y.value) == null ? void 0 : _c.getTime()) || 0), Tt = i.value === "x" ? U : mt, Ut = Math.abs(Tt) / wt;
      if (Math.abs(Tt) >= qz || Ut > 0.11) {
        p.value = G.value, (_e = (_d = r.toast).onDismiss) == null ? void 0 : _e.call(_d, r.toast), i.value === "x" ? s.value = U > 0 ? "right" : "left" : s.value = mt > 0 ? "down" : "up", ht(), c.value = true;
        return;
      } else
        (_f2 = x.value) == null ? void 0 : _f2.style.setProperty("--swipe-amount-x", "0px"), (_g2 = x.value) == null ? void 0 : _g2.style.setProperty("--swipe-amount-y", "0px");
      h10.value = false, l.value = false, i.value = null;
    }
    function xt(U) {
      var _a2, _b2, _c, _d;
      if (!rt.value || !$.value || (((_b2 = (_a2 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a2.toString()) == null ? void 0 : _b2.length) ?? false)) return;
      const mt = U.clientY - rt.value.y, wt = U.clientX - rt.value.x, Tt = r.swipeDirections ?? Pz(r.position);
      !i.value && (Math.abs(wt) > 1 || Math.abs(mt) > 1) && (i.value = Math.abs(wt) > Math.abs(mt) ? "x" : "y");
      let Ut = {
        x: 0,
        y: 0
      };
      const Ce = (ue) => 1 / (1.5 + Math.abs(ue) / 20);
      if (i.value === "y") {
        if (Tt.includes("top") || Tt.includes("bottom")) if (Tt.includes("top") && mt < 0 || Tt.includes("bottom") && mt > 0) Ut.y = mt;
        else {
          const ue = mt * Ce(mt);
          Ut.y = Math.abs(ue) < Math.abs(mt) ? ue : mt;
        }
      } else if (i.value === "x" && (Tt.includes("left") || Tt.includes("right")))
        if (Tt.includes("left") && wt < 0 || Tt.includes("right") && wt > 0) Ut.x = wt;
        else {
          const ue = wt * Ce(wt);
          Ut.x = Math.abs(ue) < Math.abs(wt) ? ue : wt;
        }
      (Math.abs(Ut.x) > 0 || Math.abs(Ut.y) > 0) && (h10.value = true), (_c = x.value) == null ? void 0 : _c.style.setProperty("--swipe-amount-x", `${Ut.x}px`), (_d = x.value) == null ? void 0 : _d.style.setProperty("--swipe-amount-y", `${Ut.y}px`);
    }
    onMounted(() => {
      if (o.value = true, !x.value) return;
      const U = x.value.getBoundingClientRect().height;
      m.value = U;
      const mt = [{
        toastId: r.toast.id,
        height: U,
        position: r.toast.position
      }, ...r.heights];
      n("update:heights", mt);
    }), onBeforeUnmount(() => {
      x.value && n("removeToast", r.toast);
    }), watchEffect((U) => {
      if (r.toast.promise && _.value === "loading" || r.toast.duration === 1 / 0 || r.toast.type === "loading") return;
      let mt;
      const wt = () => {
        if (J.value < R.value) {
          const Ut = (/* @__PURE__ */ new Date()).getTime() - R.value;
          g.value = g.value - Ut;
        }
        J.value = (/* @__PURE__ */ new Date()).getTime();
      }, Tt = () => {
        g.value !== 1 / 0 && (R.value = (/* @__PURE__ */ new Date()).getTime(), mt = setTimeout(() => {
          var _a2, _b2;
          (_b2 = (_a2 = r.toast).onAutoClose) == null ? void 0 : _b2.call(_a2, r.toast), ht();
        }, g.value));
      };
      r.expanded || r.interacting || at.value ? wt() : Tt(), U(() => {
        clearTimeout(mt);
      });
    }), watch(() => r.toast.delete, (U) => {
      U !== void 0 && U && ht();
    }, { deep: true });
    function Yt() {
      l.value = false, i.value = null, rt.value = null;
    }
    return (U, mt) => {
      var _a2, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r, _s, _t, _u2, _v2, _w2, _x2, _y, _z2, _A2;
      return openBlock(), createElementBlock("li", {
        tabindex: "0",
        ref_key: "toastRef",
        ref: x,
        class: normalizeClass(unref(Ui)(r.class, L.value, (_a2 = U.classes) == null ? void 0 : _a2.toast, (_b2 = U.toast.classes) == null ? void 0 : _b2.toast, (_c = U.classes) == null ? void 0 : _c[_.value], (_e = (_d = U.toast) == null ? void 0 : _d.classes) == null ? void 0 : _e[_.value])),
        "data-sonner-toast": "",
        "data-rich-colors": U.toast.richColors ?? U.defaultRichColors,
        "data-styled": !(U.toast.component || ((_f2 = U.toast) == null ? void 0 : _f2.unstyled) || U.unstyled),
        "data-mounted": o.value,
        "data-promise": !!U.toast.promise,
        "data-swiped": h10.value,
        "data-removed": a.value,
        "data-visible": C.value,
        "data-y-position": j.value,
        "data-x-position": z.value,
        "data-index": U.index,
        "data-front": k.value,
        "data-swiping": l.value,
        "data-dismissible": $.value,
        "data-type": _.value,
        "data-invert": U.toast.invert || U.invert,
        "data-swipe-out": c.value,
        "data-swipe-direction": s.value,
        "data-expanded": !!(U.expanded || U.expandByDefault && o.value),
        style: normalizeStyle({
          "--index": U.index,
          "--toasts-before": U.index,
          "--z-index": U.toasts.length - U.index,
          "--offset": `${a.value ? p.value : G.value}px`,
          "--initial-height": U.expandByDefault ? "auto" : `${m.value}px`,
          ...U.style,
          ...r.toast.style
        }),
        onDragend: Yt,
        onPointerdown: ct,
        onPointerup: gt,
        onPointermove: xt
      }, [F.value && !U.toast.component && _.value !== "loading" ? (openBlock(), createElementBlock("button", {
        key: 0,
        "aria-label": U.closeButtonAriaLabel || "Close toast",
        "data-disabled": et.value,
        "data-close-button": "true",
        class: normalizeClass(unref(Ui)((_g2 = U.classes) == null ? void 0 : _g2.closeButton, (_i2 = (_h2 = U.toast) == null ? void 0 : _h2.classes) == null ? void 0 : _i2.closeButton)),
        onClick: X
      }, [((_j2 = U.icons) == null ? void 0 : _j2.close) ? (openBlock(), createBlock(resolveDynamicComponent((_k2 = U.icons) == null ? void 0 : _k2.close), { key: 0 })) : renderSlot(U.$slots, "close-icon", { key: 1 })], 10, Hz)) : createCommentVNode("v-if", true), U.toast.component ? (openBlock(), createBlock(resolveDynamicComponent(U.toast.component), mergeProps({ key: 1 }, U.toast.componentProps, { onCloseToast: X }), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        _.value !== "default" || U.toast.icon || U.toast.promise ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-icon": "",
          class: normalizeClass(unref(Ui)((_l2 = U.classes) == null ? void 0 : _l2.icon, (_n2 = (_m2 = U.toast) == null ? void 0 : _m2.classes) == null ? void 0 : _n2.icon))
        }, [U.toast.icon ? (openBlock(), createBlock(resolveDynamicComponent(U.toast.icon), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [_.value === "loading" ? renderSlot(U.$slots, "loading-icon", { key: 0 }) : _.value === "success" ? renderSlot(U.$slots, "success-icon", { key: 1 }) : _.value === "error" ? renderSlot(U.$slots, "error-icon", { key: 2 }) : _.value === "warning" ? renderSlot(U.$slots, "warning-icon", { key: 3 }) : _.value === "info" ? renderSlot(U.$slots, "info-icon", { key: 4 }) : createCommentVNode("v-if", true)], 64))], 2)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          "data-content": "",
          class: normalizeClass(unref(Ui)((_o2 = U.classes) == null ? void 0 : _o2.content, (_q2 = (_p2 = U.toast) == null ? void 0 : _p2.classes) == null ? void 0 : _q2.content))
        }, [createBaseVNode("div", {
          "data-title": "",
          class: normalizeClass(unref(Ui)((_r = U.classes) == null ? void 0 : _r.title, (_s = U.toast.classes) == null ? void 0 : _s.title))
        }, [K.value ? (openBlock(), createBlock(resolveDynamicComponent(U.toast.title), normalizeProps(mergeProps({ key: 0 }, U.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(U.toast.title), 1)], 64))], 2), U.toast.description ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-description": "",
          class: normalizeClass(unref(Ui)(U.descriptionClass, B.value, (_t = U.classes) == null ? void 0 : _t.description, (_u2 = U.toast.classes) == null ? void 0 : _u2.description))
        }, [Y.value ? (openBlock(), createBlock(resolveDynamicComponent(U.toast.description), normalizeProps(mergeProps({ key: 0 }, U.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(U.toast.description), 1)], 64))], 2)) : createCommentVNode("v-if", true)], 2),
        U.toast.cancel ? (openBlock(), createElementBlock("button", {
          key: 1,
          style: normalizeStyle(U.toast.cancelButtonStyle || U.cancelButtonStyle),
          class: normalizeClass(unref(Ui)((_v2 = U.classes) == null ? void 0 : _v2.cancelButton, (_w2 = U.toast.classes) == null ? void 0 : _w2.cancelButton)),
          "data-button": "",
          "data-cancel": "",
          onClick: mt[0] || (mt[0] = (wt) => {
            var _a3, _b3;
            unref(ih)(U.toast.cancel) && $.value && ((_b3 = (_a3 = U.toast.cancel).onClick) == null ? void 0 : _b3.call(_a3, wt), ht());
          })
        }, toDisplayString(unref(ih)(U.toast.cancel) ? (_x2 = U.toast.cancel) == null ? void 0 : _x2.label : U.toast.cancel), 7)) : createCommentVNode("v-if", true),
        U.toast.action ? (openBlock(), createElementBlock("button", {
          key: 2,
          style: normalizeStyle(U.toast.actionButtonStyle || U.actionButtonStyle),
          class: normalizeClass(unref(Ui)((_y = U.classes) == null ? void 0 : _y.actionButton, (_z2 = U.toast.classes) == null ? void 0 : _z2.actionButton)),
          "data-button": "",
          "data-action": "",
          onClick: mt[1] || (mt[1] = (wt) => {
            var _a3, _b3;
            unref(ih)(U.toast.action) && ((_b3 = (_a3 = U.toast.action).onClick) == null ? void 0 : _b3.call(_a3, wt), !wt.defaultPrevented && ht());
          })
        }, toDisplayString(unref(ih)(U.toast.action) ? (_A2 = U.toast.action) == null ? void 0 : _A2.label : U.toast.action), 7)) : createCommentVNode("v-if", true)
      ], 64))], 46, Wz);
    };
  }
});
var Vz = Uz;
var cc = (t15, e) => {
  const r = t15.__vccOpts || t15;
  for (const [n, i] of e) r[n] = i;
  return r;
};
var Gz = {};
var Xz = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Yz(t15, e) {
  return openBlock(), createElementBlock("svg", Xz, e[0] || (e[0] = [createBaseVNode("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), createBaseVNode("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var Kz = cc(Gz, [["render", Yz]]);
var Zz = ["data-visible"];
var Qz = { class: "sonner-spinner" };
var Jz = defineComponent({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(t15) {
    const e = Array(12).fill(0);
    return (r, n) => (openBlock(), createElementBlock("div", {
      class: "sonner-loading-wrapper",
      "data-visible": r.visible
    }, [createBaseVNode("div", Qz, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(e), (i) => (openBlock(), createElementBlock("div", {
      key: `spinner-bar-${i}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, Zz));
  }
});
var tq = Jz;
var eq = {};
var rq = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function nq(t15, e) {
  return openBlock(), createElementBlock("svg", rq, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var iq = cc(eq, [["render", nq]]);
var sq = {};
var oq = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function aq(t15, e) {
  return openBlock(), createElementBlock("svg", oq, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var lq = cc(sq, [["render", aq]]);
var cq = {};
var hq = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function uq(t15, e) {
  return openBlock(), createElementBlock("svg", hq, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var dq = cc(cq, [["render", uq]]);
var pq = {};
var fq = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function mq(t15, e) {
  return openBlock(), createElementBlock("svg", fq, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var gq = cc(pq, [["render", mq]]);
var yq = ["aria-label"];
var bq = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position",
  "data-lifted"
];
var xq = typeof window < "u" && typeof document < "u";
function wq() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const t15 = document.documentElement.getAttribute("dir");
  return t15 === "auto" || !t15 ? window.getComputedStyle(document.documentElement).direction : t15;
}
var kq = defineComponent({
  name: "Toaster",
  inheritAttrs: false,
  __name: "Toaster",
  props: {
    invert: {
      type: Boolean,
      default: false
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: false
    },
    expand: {
      type: Boolean,
      default: false
    },
    duration: {},
    gap: { default: zz },
    visibleToasts: { default: Iz },
    closeButton: {
      type: Boolean,
      default: false
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: D6 },
    mobileOffset: { default: F6 },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(t15) {
    const e = t15, r = useAttrs(), n = ref([]);
    function i(F, W) {
      return n.value.filter((R) => !R.position && W === 0 || R.position === F);
    }
    const s = computed(() => {
      const F = n.value.filter((W) => W.position).map((W) => W.position);
      return F.length > 0 ? Array.from(new Set([e.position].concat(F))) : [e.position];
    }), o = computed(() => {
      const F = {};
      return s.value.forEach((W) => {
        F[W] = n.value.filter((R) => R.position === W);
      }), F;
    }), a = ref([]), l = ref(false), c = ref(false), h10 = ref(e.theme !== "system" ? e.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = ref(null), m = ref(null), g = ref(false), y = e.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function x(F) {
      var _a2;
      ((_a2 = n.value.find((W) => W.id === F.id)) == null ? void 0 : _a2.delete) || zr.dismiss(F.id), n.value = n.value.filter(({ id: W }) => W !== F.id), setTimeout(() => {
        n.value.find((W) => W.id === F.id) || (a.value = a.value.filter((W) => W.toastId !== F.id));
      }, N6 + 50);
    }
    function k(F) {
      var _a2, _b2;
      g.value && !((_b2 = (_a2 = F.currentTarget) == null ? void 0 : _a2.contains) == null ? void 0 : _b2.call(_a2, F.relatedTarget)) && (g.value = false, m.value && (m.value.focus({ preventScroll: true }), m.value = null));
    }
    function C(F) {
      F.target instanceof HTMLElement && F.target.dataset.dismissible === "false" || g.value || (g.value = true, m.value = F.relatedTarget);
    }
    function _(F) {
      F.target && F.target instanceof HTMLElement && F.target.dataset.dismissible === "false" || (c.value = true);
    }
    watchEffect((F) => {
      const W = zr.subscribe((R) => {
        if (R.dismiss) {
          requestAnimationFrame(() => {
            n.value = n.value.map((J) => J.id === R.id ? {
              ...J,
              delete: true
            } : J);
          });
          return;
        }
        nextTick(() => {
          const J = n.value.findIndex((rt) => rt.id === R.id);
          J !== -1 ? n.value = [
            ...n.value.slice(0, J),
            {
              ...n.value[J],
              ...R
            },
            ...n.value.slice(J + 1)
          ] : n.value = [R, ...n.value];
        });
      });
      F(W);
    }), watchEffect((F) => {
      if (typeof window > "u") return;
      if (e.theme !== "system") {
        h10.value = e.theme;
        return;
      }
      const W = window.matchMedia("(prefers-color-scheme: dark)"), R = (rt) => {
        h10.value = rt ? "dark" : "light";
      };
      R(W.matches);
      const J = (rt) => {
        R(rt.matches);
      };
      try {
        W.addEventListener("change", J);
      } catch {
        W.addListener(J);
      }
      F(() => {
        try {
          W.removeEventListener("change", J);
        } catch {
          W.removeListener(J);
        }
      });
    }), watchEffect(() => {
      p.value && m.value && (m.value.focus({ preventScroll: true }), m.value = null, g.value = false);
    }), watchEffect(() => {
      n.value.length <= 1 && (l.value = false);
    }), watchEffect((F) => {
      function W(R) {
        const J = e.hotkey.every((j) => R[j] || R.code === j), rt = Array.isArray(p.value) ? p.value[0] : p.value;
        J && (l.value = true, rt == null ? void 0 : rt.focus());
        const I = document.activeElement === p.value || (rt == null ? void 0 : rt.contains(document.activeElement));
        R.code === "Escape" && I && (l.value = false);
      }
      xq && (document.addEventListener("keydown", W), F(() => {
        document.removeEventListener("keydown", W);
      }));
    });
    function $() {
      l.value = true;
    }
    function L() {
      c.value || (l.value = false);
    }
    function B() {
      l.value = false;
    }
    function q() {
      c.value = false;
    }
    function H(F) {
      a.value = F;
    }
    function G(F) {
      const W = a.value.findIndex((R) => R.toastId === F.toastId);
      if (W !== -1) a.value[W] = F;
      else {
        const R = a.value.findIndex((J) => J.position === F.position);
        R !== -1 ? a.value.splice(R, 0, F) : a.value.unshift(F);
      }
    }
    return (F, W) => (openBlock(), createElementBlock(Fragment, null, [createCommentVNode(" Remove item from normal navigation flow, only available via hotkey "), createBaseVNode("section", {
      "aria-label": `${F.containerAriaLabel} ${unref(y)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (R, J) => {
      var _a2;
      return openBlock(), createElementBlock("ol", mergeProps({
        key: R,
        ref_for: true,
        ref_key: "listRef",
        ref: p,
        "data-sonner-toaster": "",
        "data-sonner-theme": h10.value,
        class: e.class,
        dir: F.dir === "auto" ? wq() : F.dir,
        tabIndex: -1,
        "data-theme": F.theme,
        "data-rich-colors": F.richColors,
        "data-y-position": R.split("-")[0],
        "data-x-position": R.split("-")[1],
        "data-lifted": l.value && n.value.length > 1 && !F.expand,
        style: {
          "--front-toast-height": `${((_a2 = a.value[0]) == null ? void 0 : _a2.height) || 0}px`,
          "--width": `${unref(Oz)}px`,
          "--gap": `${F.gap}px`,
          ...F.style,
          ...unref(r).style,
          ...unref(jz)(F.offset, F.mobileOffset)
        }
      }, F.$attrs, {
        onBlur: k,
        onFocus: C,
        onMouseenter: $,
        onMousemove: $,
        onMouseleave: L,
        onDragend: B,
        onPointerdown: _,
        onPointerup: q
      }), [(openBlock(true), createElementBlock(Fragment, null, renderList(i(R, J), (rt, I) => {
        var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2;
        return openBlock(), createBlock(Vz, {
          key: rt.id,
          heights: a.value,
          icons: F.icons,
          index: I,
          toast: rt,
          defaultRichColors: F.richColors,
          duration: ((_a3 = F.toastOptions) == null ? void 0 : _a3.duration) ?? F.duration,
          class: normalizeClass(((_b2 = F.toastOptions) == null ? void 0 : _b2.class) ?? ""),
          descriptionClass: (_c = F.toastOptions) == null ? void 0 : _c.descriptionClass,
          invert: F.invert,
          visibleToasts: F.visibleToasts,
          closeButton: ((_d = F.toastOptions) == null ? void 0 : _d.closeButton) ?? F.closeButton,
          interacting: c.value,
          position: R,
          style: normalizeStyle((_e = F.toastOptions) == null ? void 0 : _e.style),
          unstyled: (_f2 = F.toastOptions) == null ? void 0 : _f2.unstyled,
          classes: (_g2 = F.toastOptions) == null ? void 0 : _g2.classes,
          cancelButtonStyle: (_h2 = F.toastOptions) == null ? void 0 : _h2.cancelButtonStyle,
          actionButtonStyle: (_i2 = F.toastOptions) == null ? void 0 : _i2.actionButtonStyle,
          "close-button-aria-label": (_j2 = F.toastOptions) == null ? void 0 : _j2.closeButtonAriaLabel,
          toasts: o.value[R],
          expandByDefault: F.expand,
          gap: F.gap,
          expanded: l.value,
          swipeDirections: e.swipeDirections,
          "onUpdate:heights": H,
          "onUpdate:height": G,
          onRemoveToast: x
        }, {
          "close-icon": withCtx(() => [renderSlot(F.$slots, "close-icon", {}, () => [createVNode(Kz)])]),
          "loading-icon": withCtx(() => [renderSlot(F.$slots, "loading-icon", {}, () => [createVNode(tq, { visible: rt.type === "loading" }, null, 8, ["visible"])])]),
          "success-icon": withCtx(() => [renderSlot(F.$slots, "success-icon", {}, () => [createVNode(iq)])]),
          "error-icon": withCtx(() => [renderSlot(F.$slots, "error-icon", {}, () => [createVNode(gq)])]),
          "warning-icon": withCtx(() => [renderSlot(F.$slots, "warning-icon", {}, () => [createVNode(dq)])]),
          "info-icon": withCtx(() => [renderSlot(F.$slots, "info-icon", {}, () => [createVNode(lq)])]),
          _: 2
        }, 1032, [
          "heights",
          "icons",
          "index",
          "toast",
          "defaultRichColors",
          "duration",
          "class",
          "descriptionClass",
          "invert",
          "visibleToasts",
          "closeButton",
          "interacting",
          "position",
          "style",
          "unstyled",
          "classes",
          "cancelButtonStyle",
          "actionButtonStyle",
          "close-button-aria-label",
          "toasts",
          "expandByDefault",
          "gap",
          "expanded",
          "swipeDirections"
        ]);
      }), 128))], 16, bq);
    }), 128))], 8, yq)], 2112));
  }
});
var vq = kq;
function k0(t15) {
  return getCurrentScope() ? (onScopeDispose(t15), true) : false;
}
var v0 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var _q = Object.prototype.toString;
var I6 = (t15) => _q.call(t15) === "[object Object]";
var Cq = () => {
};
var Bb = Sq();
function Sq() {
  var t15, e;
  return v0 && ((t15 = window == null ? void 0 : window.navigator) == null ? void 0 : t15.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function Tq(...t15) {
  if (t15.length !== 1)
    return toRef(...t15);
  const e = t15[0];
  return typeof e == "function" ? readonly(customRef(() => ({ get: e, set: Cq }))) : ref(e);
}
function qo(t15) {
  return Array.isArray(t15) ? t15 : [t15];
}
function Aq(t15) {
  return getCurrentInstance();
}
function $q(t15, e = true, r) {
  Aq() ? onMounted(t15, r) : e ? t15() : nextTick(t15);
}
function O6(t15, e, r) {
  return watch(
    t15,
    e,
    {
      ...r,
      immediate: true
    }
  );
}
var Eq = v0 ? window : void 0;
var Mq = v0 ? window.document : void 0;
function Bf(t15) {
  var e;
  const r = toValue(t15);
  return (e = r == null ? void 0 : r.$el) != null ? e : r;
}
function Lb(...t15) {
  const e = [], r = () => {
    e.forEach((a) => a()), e.length = 0;
  }, n = (a, l, c, h10) => (a.addEventListener(l, c, h10), () => a.removeEventListener(l, c, h10)), i = computed(() => {
    const a = qo(toValue(t15[0])).filter((l) => l != null);
    return a.every((l) => typeof l != "string") ? a : void 0;
  }), s = O6(
    () => {
      var a, l;
      return [
        (l = (a = i.value) == null ? void 0 : a.map((c) => Bf(c))) != null ? l : [Eq].filter((c) => c != null),
        qo(toValue(i.value ? t15[1] : t15[0])),
        qo(unref(i.value ? t15[2] : t15[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(i.value ? t15[3] : t15[2])
      ];
    },
    ([a, l, c, h10]) => {
      if (r(), !(a == null ? void 0 : a.length) || !(l == null ? void 0 : l.length) || !(c == null ? void 0 : c.length))
        return;
      const p = I6(h10) ? { ...h10 } : h10;
      e.push(
        ...a.flatMap(
          (m) => l.flatMap(
            (g) => c.map((y) => n(m, g, y, p))
          )
        )
      );
    },
    { flush: "post" }
  ), o = () => {
    s(), r();
  };
  return k0(r), o;
}
function Bq() {
  const t15 = shallowRef(false), e = getCurrentInstance();
  return e && onMounted(() => {
    t15.value = true;
  }, e), t15;
}
function Lq(t15) {
  const e = Bq();
  return computed(() => (e.value, !!t15()));
}
var Db = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function Dq(t15, e = {}) {
  const {
    document: r = Mq,
    autoExit: n = false
  } = e, i = computed(() => {
    var _;
    return (_ = Bf(t15)) != null ? _ : r == null ? void 0 : r.documentElement;
  }), s = shallowRef(false), o = computed(() => [
    "requestFullscreen",
    "webkitRequestFullscreen",
    "webkitEnterFullscreen",
    "webkitEnterFullScreen",
    "webkitRequestFullScreen",
    "mozRequestFullScreen",
    "msRequestFullscreen"
  ].find((_) => r && _ in r || i.value && _ in i.value)), a = computed(() => [
    "exitFullscreen",
    "webkitExitFullscreen",
    "webkitExitFullScreen",
    "webkitCancelFullScreen",
    "mozCancelFullScreen",
    "msExitFullscreen"
  ].find((_) => r && _ in r || i.value && _ in i.value)), l = computed(() => [
    "fullScreen",
    "webkitIsFullScreen",
    "webkitDisplayingFullscreen",
    "mozFullScreen",
    "msFullscreenElement"
  ].find((_) => r && _ in r || i.value && _ in i.value)), c = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((_) => r && _ in r), h10 = Lq(() => i.value && r && o.value !== void 0 && a.value !== void 0 && l.value !== void 0), p = () => c ? (r == null ? void 0 : r[c]) === i.value : false, m = () => {
    if (l.value) {
      if (r && r[l.value] != null)
        return r[l.value];
      {
        const _ = i.value;
        if ((_ == null ? void 0 : _[l.value]) != null)
          return !!_[l.value];
      }
    }
    return false;
  };
  async function g() {
    if (!(!h10.value || !s.value)) {
      if (a.value)
        if ((r == null ? void 0 : r[a.value]) != null)
          await r[a.value]();
        else {
          const _ = i.value;
          (_ == null ? void 0 : _[a.value]) != null && await _[a.value]();
        }
      s.value = false;
    }
  }
  async function y() {
    if (!h10.value || s.value)
      return;
    m() && await g();
    const _ = i.value;
    o.value && (_ == null ? void 0 : _[o.value]) != null && (await _[o.value](), s.value = true);
  }
  async function x() {
    await (s.value ? g() : y());
  }
  const k = () => {
    const _ = m();
    (!_ || _ && p()) && (s.value = _);
  }, C = { capture: false, passive: true };
  return Lb(r, Db, k, C), Lb(() => Bf(i), Db, k, C), $q(k, false), n && k0(g), {
    isSupported: h10,
    isFullscreen: s,
    enter: y,
    exit: g,
    toggle: x
  };
}
var Fq = v0 ? window : void 0;
function Nq(t15) {
  var e;
  const r = toValue(t15);
  return (e = r == null ? void 0 : r.$el) != null ? e : r;
}
function Iq(...t15) {
  const e = [], r = () => {
    e.forEach((a) => a()), e.length = 0;
  }, n = (a, l, c, h10) => (a.addEventListener(l, c, h10), () => a.removeEventListener(l, c, h10)), i = computed(() => {
    const a = qo(toValue(t15[0])).filter((l) => l != null);
    return a.every((l) => typeof l != "string") ? a : void 0;
  }), s = O6(
    () => {
      var a, l;
      return [
        (l = (a = i.value) == null ? void 0 : a.map((c) => Nq(c))) != null ? l : [Fq].filter((c) => c != null),
        qo(toValue(i.value ? t15[1] : t15[0])),
        qo(unref(i.value ? t15[2] : t15[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(i.value ? t15[3] : t15[2])
      ];
    },
    ([a, l, c, h10]) => {
      if (r(), !(a == null ? void 0 : a.length) || !(l == null ? void 0 : l.length) || !(c == null ? void 0 : c.length))
        return;
      const p = I6(h10) ? { ...h10 } : h10;
      e.push(
        ...a.flatMap(
          (m) => l.flatMap(
            (g) => c.map((y) => n(m, g, y, p))
          )
        )
      );
    },
    { flush: "post" }
  ), o = () => {
    s(), r();
  };
  return k0(r), o;
}
var Oq = defineComponent({
  name: "UseFullscreen",
  props: ["as"],
  setup(t15, { slots: e }) {
    const r = shallowRef(), n = reactive(Dq(r));
    return () => {
      if (e.default)
        return h(t15.as || "div", { ref: r }, e.default(n));
    };
  }
});
function dp(t15) {
  return typeof Window < "u" && t15 instanceof Window ? t15.document.documentElement : typeof Document < "u" && t15 instanceof Document ? t15.documentElement : t15;
}
function z6(t15) {
  const e = window.getComputedStyle(t15);
  if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t15.clientWidth < t15.scrollWidth || e.overflowY === "auto" && t15.clientHeight < t15.scrollHeight)
    return true;
  {
    const r = t15.parentNode;
    return !r || r.tagName === "BODY" ? false : z6(r);
  }
}
function zq(t15) {
  const e = t15 || window.event, r = e.target;
  return z6(r) ? false : e.touches.length > 1 ? true : (e.preventDefault && e.preventDefault(), false);
}
var pp = /* @__PURE__ */ new WeakMap();
function qq(t15, e = false) {
  const r = shallowRef(e);
  let n = null, i = "";
  watch(Tq(t15), (a) => {
    const l = dp(toValue(a));
    if (l) {
      const c = l;
      if (pp.get(c) || pp.set(c, c.style.overflow), c.style.overflow !== "hidden" && (i = c.style.overflow), c.style.overflow === "hidden")
        return r.value = true;
      if (r.value)
        return c.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const s = () => {
    const a = dp(toValue(t15));
    !a || r.value || (Bb && (n = Iq(
      a,
      "touchmove",
      (l) => {
        zq(l);
      },
      { passive: false }
    )), a.style.overflow = "hidden", r.value = true);
  }, o = () => {
    const a = dp(toValue(t15));
    !a || !r.value || (Bb && (n == null ? void 0 : n()), a.style.overflow = i, pp.delete(a), r.value = false);
  };
  return k0(o), computed({
    get() {
      return r.value;
    },
    set(a) {
      a ? s() : o();
    }
  });
}
function Rq() {
  let t15 = false;
  const e = shallowRef(false);
  return (r, n) => {
    if (e.value = n.value, t15)
      return;
    t15 = true;
    const i = qq(r, n.value);
    watch(e, (s) => i.value = s);
  };
}
Rq();
var Pq = ["id"];
var jq = ["onClick"];
var Wq = defineComponent({
  __name: "MindMapRoot",
  props: {
    markdown: {},
    type: { default: "view" },
    showToolbar: { default: "0" }
  },
  setup(t15) {
    const e = t15, r = computed(() => typeof document > "u" ? false : !!(document.documentElement.classList.contains("dark") || window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches)), n = ref(), i = ref(), s = shallowRef(), o = ref(), a = ref(
      `mindmap-${Math.random().toString(36).substring(2, 15)}`
    ), l = computed(() => ({
      // autoFit: true,
      // fitRatio: 1,
      // initialExpandLevel: 3,
      // maxInitialScale: 1,
      // pan: false,
      // scrollForPan: false,
      // toggleRecursively: true,
      // zoom: true,
      // paddingX: 2,
      // spacingHorizontal: 5,
      // spacingVertical: 5,
      // duration: 200,
      // maxWidth: 600,
      color: (B) => r.value ? c(B.depth, true) : c(B.depth, false)
    }));
    function c(B, q) {
      const H = q ? [
        "#2ecc71",
        // 亮绿色
        "#3498db",
        // 亮蓝色
        "#9b59b6",
        // 亮紫色
        "#f39c12",
        // 亮橙色
        "#e74c3c"
        // 亮红色
      ] : [
        "#2ecc71",
        // 绿色
        "#3498db",
        // 蓝色
        "#9b59b6",
        // 紫色
        "#e67e22",
        // 橙色
        "#e74c3c"
        // 红色
      ];
      return H[B % H.length];
    }
    function h10() {
      if (!i.value || !e.markdown) return;
      const B = new TD(), { root: q } = B.transform(decodeURIComponent(e.markdown));
      s.value ? (s.value.setOptions(l.value), s.value.setData(q), s.value.fit()) : s.value = oz.create(i.value, l.value, q);
    }
    async function p() {
      if (!s.value || !i.value || !n.value) return;
      const B = n.value.querySelector(
        `#toolbar-${a.value}`
      );
      try {
        B && (B.style.display = "none"), s.value.fit(), await (await Ze(n.value, {
          scale: 2,
          quality: 1,
          backgroundColor: getComputedStyle(
            document.documentElement
          ).getPropertyValue("--vp-c-bg-soft")
        })).download({ format: "png", filename: "mindmap" });
      } catch (q) {
        console.error("下载图片失败:", q), alert("下载图片失败，请检查浏览器安全设置或尝试其他浏览器");
      } finally {
        B && (B.style.display = "flex");
      }
    }
    function m() {
      s.value && s.value.rescale(1.25);
    }
    function g() {
      s.value && s.value.rescale(0.8);
    }
    function y() {
      s.value && s.value.fit();
    }
    async function x() {
      if (e.markdown)
        try {
          const B = decodeURIComponent(e.markdown);
          Ez(B), Eb.success("复制成功！");
        } catch (B) {
          console.error("复制失败:", B), Eb.error("复制失败，请重试");
        }
    }
    function k() {
      s.value && setTimeout(() => {
        var _a2;
        (_a2 = s.value) == null ? void 0 : _a2.fit();
      }, 100);
    }
    watch(
      () => e.markdown,
      () => {
        h10();
      }
    ), watch(
      () => r.value,
      () => {
        s.value && (s.value.setOptions(l.value), s.value.renderData());
      }
    );
    const C = ref(null);
    function _() {
      s.value && (s.value.setOptions(l.value), s.value.renderData());
    }
    onMounted(() => {
      h10(), window.ResizeObserver && (o.value = new ResizeObserver(k), i.value.parentElement && o.value.observe(i.value.parentElement)), window.addEventListener("resize", k), typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", _), typeof window < "u" && window.MutationObserver && (C.value = new MutationObserver((B) => {
        for (const q of B)
          if (q.attributeName === "class" && q.target === document.documentElement) {
            s.value && (s.value.setOptions(l.value), s.value.renderData());
            break;
          }
      }), C.value.observe(document.documentElement, {
        attributes: true
      }));
    }), onBeforeUnmount(() => {
      if (o.value && o.value.disconnect(), window.removeEventListener("resize", k), typeof window < "u" && window.matchMedia) {
        const B = window.matchMedia(
          "(prefers-color-scheme: dark)"
        );
        B.removeEventListener("change", _), B.removeListener(() => {
        });
      }
      C.value && C.value.disconnect();
    });
    const $ = () => {
      const B = window.document.querySelector(
        `#toolbar-${a.value}`
      );
      B.style.opacity = "1";
    }, L = () => {
      const B = window.document.querySelector(
        `#toolbar-${a.value}`
      );
      B.style.opacity = "0";
    };
    return (B, q) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(Oq), null, {
        default: withCtx(({ toggle: H, isFullscreen: G }) => [
          createBaseVNode("div", {
            ref_key: "mindmapContainerRef",
            ref: n,
            class: "mindmap-container",
            onMouseenter: $,
            onMouseleave: L
          }, [
            (openBlock(), createElementBlock("svg", {
              ref_key: "svgRef",
              ref: i,
              style: { "min-height": "400px" }
            }, null, 512)),
            withDirectives(createBaseVNode("div", {
              id: `toolbar-${a.value}`,
              class: "toolbar"
            }, [
              createBaseVNode("button", {
                class: "btn",
                title: "放大",
                onClick: m
              }, "🔍"),
              createBaseVNode("button", {
                class: "btn",
                title: "缩小",
                onClick: g
              }, "🔎"),
              createBaseVNode("button", {
                class: "btn",
                title: "适应屏幕",
                onClick: y
              }, "🔁"),
              createBaseVNode("button", {
                class: "btn",
                title: "复制Markdown内容",
                onClick: x
              }, " 📋 "),
              createBaseVNode("button", {
                class: "btn",
                title: "下载为PNG图片",
                onClick: p
              }, " ⬇️ "),
              createBaseVNode("button", {
                class: "btn",
                title: "全屏",
                onClick: H
              }, toDisplayString(G ? "🔲" : "🔳"), 9, jq)
            ], 8, Pq), [
              [vShow, Number(e.showToolbar) === 1]
            ])
          ], 544)
        ]),
        _: 1
      }),
      createVNode(unref(vq), {
        position: "top-right",
        "rich-colors": ""
      })
    ], 64));
  }
});
var q6 = (t15, e) => {
  const r = t15.__vccOpts || t15;
  for (const [n, i] of e)
    r[n] = i;
  return r;
};
var R6 = q6(Wq, [["__scopeId", "data-v-8a4f3a01"]]);
var Hq = { class: "vitepress-markmap-preview" };
var Uq = defineComponent({
  __name: "PreviewMarkmapPath",
  props: {
    path: {}
  },
  setup(t15) {
    const e = ref("");
    return (r, n) => {
      const i = resolveComponent("ClientOnly");
      return openBlock(), createElementBlock("div", Hq, [
        createVNode(i, null, {
          default: withCtx(() => [
            e.value ? (openBlock(), createBlock(R6, {
              key: 0,
              type: "view",
              markdown: e.value
            }, null, 8, ["markdown"])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});
var Vq = q6(Uq, [["__scopeId", "data-v-cc0e544b"]]);
function Gq(t15) {
  t15.component("MindMapRoot", R6), t15.component("PreviewMarkmapPath", Vq);
}
function Xq(t15) {
  return t15 && t15.__esModule && Object.prototype.hasOwnProperty.call(t15, "default") ? t15.default : t15;
}
var Lf = { exports: {} };
var Yq = Lf.exports;
var Fb;
function Kq() {
  return Fb || (Fb = 1, function(t15, e) {
    (function(r, n) {
      t15.exports = n();
    })(Yq, function() {
      var r = 1e3, n = 6e4, i = 36e5, s = "millisecond", o = "second", a = "minute", l = "hour", c = "day", h10 = "week", p = "month", m = "quarter", g = "year", y = "date", x = "Invalid Date", k = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, C = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, _ = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(I) {
        var j = ["th", "st", "nd", "rd"], z = I % 100;
        return "[" + I + (j[(z - 20) % 10] || j[z] || j[0]) + "]";
      } }, $ = function(I, j, z) {
        var K = String(I);
        return !K || K.length >= j ? I : "" + Array(j + 1 - K.length).join(z) + I;
      }, L = { s: $, z: function(I) {
        var j = -I.utcOffset(), z = Math.abs(j), K = Math.floor(z / 60), Y = z % 60;
        return (j <= 0 ? "+" : "-") + $(K, 2, "0") + ":" + $(Y, 2, "0");
      }, m: function I(j, z) {
        if (j.date() < z.date()) return -I(z, j);
        var K = 12 * (z.year() - j.year()) + (z.month() - j.month()), Y = j.clone().add(K, p), at = z - Y < 0, et = j.clone().add(K + (at ? -1 : 1), p);
        return +(-(K + (z - Y) / (at ? Y - et : et - Y)) || 0);
      }, a: function(I) {
        return I < 0 ? Math.ceil(I) || 0 : Math.floor(I);
      }, p: function(I) {
        return { M: p, y: g, w: h10, d: c, D: y, h: l, m: a, s: o, ms: s, Q: m }[I] || String(I || "").toLowerCase().replace(/s$/, "");
      }, u: function(I) {
        return I === void 0;
      } }, B = "en", q = {};
      q[B] = _;
      var H = "$isDayjsObject", G = function(I) {
        return I instanceof J || !(!I || !I[H]);
      }, F = function I(j, z, K) {
        var Y;
        if (!j) return B;
        if (typeof j == "string") {
          var at = j.toLowerCase();
          q[at] && (Y = at), z && (q[at] = z, Y = at);
          var et = j.split("-");
          if (!Y && et.length > 1) return I(et[0]);
        } else {
          var ht = j.name;
          q[ht] = j, Y = ht;
        }
        return !K && Y && (B = Y), Y || !K && B;
      }, W = function(I, j) {
        if (G(I)) return I.clone();
        var z = typeof j == "object" ? j : {};
        return z.date = I, z.args = arguments, new J(z);
      }, R = L;
      R.l = F, R.i = G, R.w = function(I, j) {
        return W(I, { locale: j.$L, utc: j.$u, x: j.$x, $offset: j.$offset });
      };
      var J = function() {
        function I(z) {
          this.$L = F(z.locale, null, true), this.parse(z), this.$x = this.$x || z.x || {}, this[H] = true;
        }
        var j = I.prototype;
        return j.parse = function(z) {
          this.$d = function(K) {
            var Y = K.date, at = K.utc;
            if (Y === null) return /* @__PURE__ */ new Date(NaN);
            if (R.u(Y)) return /* @__PURE__ */ new Date();
            if (Y instanceof Date) return new Date(Y);
            if (typeof Y == "string" && !/Z$/i.test(Y)) {
              var et = Y.match(k);
              if (et) {
                var ht = et[2] - 1 || 0, X = (et[7] || "0").substring(0, 3);
                return at ? new Date(Date.UTC(et[1], ht, et[3] || 1, et[4] || 0, et[5] || 0, et[6] || 0, X)) : new Date(et[1], ht, et[3] || 1, et[4] || 0, et[5] || 0, et[6] || 0, X);
              }
            }
            return new Date(Y);
          }(z), this.init();
        }, j.init = function() {
          var z = this.$d;
          this.$y = z.getFullYear(), this.$M = z.getMonth(), this.$D = z.getDate(), this.$W = z.getDay(), this.$H = z.getHours(), this.$m = z.getMinutes(), this.$s = z.getSeconds(), this.$ms = z.getMilliseconds();
        }, j.$utils = function() {
          return R;
        }, j.isValid = function() {
          return this.$d.toString() !== x;
        }, j.isSame = function(z, K) {
          var Y = W(z);
          return this.startOf(K) <= Y && Y <= this.endOf(K);
        }, j.isAfter = function(z, K) {
          return W(z) < this.startOf(K);
        }, j.isBefore = function(z, K) {
          return this.endOf(K) < W(z);
        }, j.$g = function(z, K, Y) {
          return R.u(z) ? this[K] : this.set(Y, z);
        }, j.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, j.valueOf = function() {
          return this.$d.getTime();
        }, j.startOf = function(z, K) {
          var Y = this, at = !!R.u(K) || K, et = R.p(z), ht = function(wt, Tt) {
            var Ut = R.w(Y.$u ? Date.UTC(Y.$y, Tt, wt) : new Date(Y.$y, Tt, wt), Y);
            return at ? Ut : Ut.endOf(c);
          }, X = function(wt, Tt) {
            return R.w(Y.toDate()[wt].apply(Y.toDate("s"), (at ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Tt)), Y);
          }, ct = this.$W, gt = this.$M, xt = this.$D, Yt = "set" + (this.$u ? "UTC" : "");
          switch (et) {
            case g:
              return at ? ht(1, 0) : ht(31, 11);
            case p:
              return at ? ht(1, gt) : ht(0, gt + 1);
            case h10:
              var U = this.$locale().weekStart || 0, mt = (ct < U ? ct + 7 : ct) - U;
              return ht(at ? xt - mt : xt + (6 - mt), gt);
            case c:
            case y:
              return X(Yt + "Hours", 0);
            case l:
              return X(Yt + "Minutes", 1);
            case a:
              return X(Yt + "Seconds", 2);
            case o:
              return X(Yt + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, j.endOf = function(z) {
          return this.startOf(z, false);
        }, j.$set = function(z, K) {
          var Y, at = R.p(z), et = "set" + (this.$u ? "UTC" : ""), ht = (Y = {}, Y[c] = et + "Date", Y[y] = et + "Date", Y[p] = et + "Month", Y[g] = et + "FullYear", Y[l] = et + "Hours", Y[a] = et + "Minutes", Y[o] = et + "Seconds", Y[s] = et + "Milliseconds", Y)[at], X = at === c ? this.$D + (K - this.$W) : K;
          if (at === p || at === g) {
            var ct = this.clone().set(y, 1);
            ct.$d[ht](X), ct.init(), this.$d = ct.set(y, Math.min(this.$D, ct.daysInMonth())).$d;
          } else ht && this.$d[ht](X);
          return this.init(), this;
        }, j.set = function(z, K) {
          return this.clone().$set(z, K);
        }, j.get = function(z) {
          return this[R.p(z)]();
        }, j.add = function(z, K) {
          var Y, at = this;
          z = Number(z);
          var et = R.p(K), ht = function(gt) {
            var xt = W(at);
            return R.w(xt.date(xt.date() + Math.round(gt * z)), at);
          };
          if (et === p) return this.set(p, this.$M + z);
          if (et === g) return this.set(g, this.$y + z);
          if (et === c) return ht(1);
          if (et === h10) return ht(7);
          var X = (Y = {}, Y[a] = n, Y[l] = i, Y[o] = r, Y)[et] || 1, ct = this.$d.getTime() + z * X;
          return R.w(ct, this);
        }, j.subtract = function(z, K) {
          return this.add(-1 * z, K);
        }, j.format = function(z) {
          var K = this, Y = this.$locale();
          if (!this.isValid()) return Y.invalidDate || x;
          var at = z || "YYYY-MM-DDTHH:mm:ssZ", et = R.z(this), ht = this.$H, X = this.$m, ct = this.$M, gt = Y.weekdays, xt = Y.months, Yt = Y.meridiem, U = function(Tt, Ut, Ce, ue) {
            return Tt && (Tt[Ut] || Tt(K, at)) || Ce[Ut].slice(0, ue);
          }, mt = function(Tt) {
            return R.s(ht % 12 || 12, Tt, "0");
          }, wt = Yt || function(Tt, Ut, Ce) {
            var ue = Tt < 12 ? "AM" : "PM";
            return Ce ? ue.toLowerCase() : ue;
          };
          return at.replace(C, function(Tt, Ut) {
            return Ut || function(Ce) {
              switch (Ce) {
                case "YY":
                  return String(K.$y).slice(-2);
                case "YYYY":
                  return R.s(K.$y, 4, "0");
                case "M":
                  return ct + 1;
                case "MM":
                  return R.s(ct + 1, 2, "0");
                case "MMM":
                  return U(Y.monthsShort, ct, xt, 3);
                case "MMMM":
                  return U(xt, ct);
                case "D":
                  return K.$D;
                case "DD":
                  return R.s(K.$D, 2, "0");
                case "d":
                  return String(K.$W);
                case "dd":
                  return U(Y.weekdaysMin, K.$W, gt, 2);
                case "ddd":
                  return U(Y.weekdaysShort, K.$W, gt, 3);
                case "dddd":
                  return gt[K.$W];
                case "H":
                  return String(ht);
                case "HH":
                  return R.s(ht, 2, "0");
                case "h":
                  return mt(1);
                case "hh":
                  return mt(2);
                case "a":
                  return wt(ht, X, true);
                case "A":
                  return wt(ht, X, false);
                case "m":
                  return String(X);
                case "mm":
                  return R.s(X, 2, "0");
                case "s":
                  return String(K.$s);
                case "ss":
                  return R.s(K.$s, 2, "0");
                case "SSS":
                  return R.s(K.$ms, 3, "0");
                case "Z":
                  return et;
              }
              return null;
            }(Tt) || et.replace(":", "");
          });
        }, j.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, j.diff = function(z, K, Y) {
          var at, et = this, ht = R.p(K), X = W(z), ct = (X.utcOffset() - this.utcOffset()) * n, gt = this - X, xt = function() {
            return R.m(et, X);
          };
          switch (ht) {
            case g:
              at = xt() / 12;
              break;
            case p:
              at = xt();
              break;
            case m:
              at = xt() / 3;
              break;
            case h10:
              at = (gt - ct) / 6048e5;
              break;
            case c:
              at = (gt - ct) / 864e5;
              break;
            case l:
              at = gt / i;
              break;
            case a:
              at = gt / n;
              break;
            case o:
              at = gt / r;
              break;
            default:
              at = gt;
          }
          return Y ? at : R.a(at);
        }, j.daysInMonth = function() {
          return this.endOf(p).$D;
        }, j.$locale = function() {
          return q[this.$L];
        }, j.locale = function(z, K) {
          if (!z) return this.$L;
          var Y = this.clone(), at = F(z, K, true);
          return at && (Y.$L = at), Y;
        }, j.clone = function() {
          return R.w(this.$d, this);
        }, j.toDate = function() {
          return new Date(this.valueOf());
        }, j.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, j.toISOString = function() {
          return this.$d.toISOString();
        }, j.toString = function() {
          return this.$d.toUTCString();
        }, I;
      }(), rt = J.prototype;
      return W.prototype = rt, [["$ms", s], ["$s", o], ["$m", a], ["$H", l], ["$W", c], ["$M", p], ["$y", g], ["$D", y]].forEach(function(I) {
        rt[I[1]] = function(j) {
          return this.$g(j, I[0], I[1]);
        };
      }), W.extend = function(I, j) {
        return I.$i || (I(j, J, W), I.$i = true), W;
      }, W.locale = F, W.isDayjs = G, W.unix = function(I) {
        return W(1e3 * I);
      }, W.en = q[B], W.Ls = q, W.p = {}, W;
    });
  }(Lf)), Lf.exports;
}
var Zq = Kq();
var Qq = Xq(Zq);
var Mh = {
  /* CLAMP */
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (t15) => t15 >= 255 ? 255 : t15 < 0 ? 0 : t15,
    g: (t15) => t15 >= 255 ? 255 : t15 < 0 ? 0 : t15,
    b: (t15) => t15 >= 255 ? 255 : t15 < 0 ? 0 : t15,
    h: (t15) => t15 % 360,
    s: (t15) => t15 >= 100 ? 100 : t15 < 0 ? 0 : t15,
    l: (t15) => t15 >= 100 ? 100 : t15 < 0 ? 0 : t15,
    a: (t15) => t15 >= 1 ? 1 : t15 < 0 ? 0 : t15
  },
  /* CONVERSION */
  //SOURCE: https://planetcalc.com/7779
  toLinear: (t15) => {
    const e = t15 / 255;
    return t15 > 0.03928 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92;
  },
  //SOURCE: https://gist.github.com/mjackson/5311256
  hue2rgb: (t15, e, r) => (r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t15 + (e - t15) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t15 + (e - t15) * (2 / 3 - r) * 6 : t15),
  hsl2rgb: ({ h: t15, s: e, l: r }, n) => {
    if (!e)
      return r * 2.55;
    t15 /= 360, e /= 100, r /= 100;
    const i = r < 0.5 ? r * (1 + e) : r + e - r * e, s = 2 * r - i;
    switch (n) {
      case "r":
        return Mh.hue2rgb(s, i, t15 + 1 / 3) * 255;
      case "g":
        return Mh.hue2rgb(s, i, t15) * 255;
      case "b":
        return Mh.hue2rgb(s, i, t15 - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: t15, g: e, b: r }, n) => {
    t15 /= 255, e /= 255, r /= 255;
    const i = Math.max(t15, e, r), s = Math.min(t15, e, r), o = (i + s) / 2;
    if (n === "l")
      return o * 100;
    if (i === s)
      return 0;
    const a = i - s, l = o > 0.5 ? a / (2 - i - s) : a / (i + s);
    if (n === "s")
      return l * 100;
    switch (i) {
      case t15:
        return ((e - r) / a + (e < r ? 6 : 0)) * 60;
      case e:
        return ((r - t15) / a + 2) * 60;
      case r:
        return ((t15 - e) / a + 4) * 60;
      default:
        return -1;
    }
  }
};
var Jq = {
  /* API */
  clamp: (t15, e, r) => e > r ? Math.min(e, Math.max(r, t15)) : Math.min(r, Math.max(e, t15)),
  round: (t15) => Math.round(t15 * 1e10) / 1e10
};
var tR = {
  /* API */
  dec2hex: (t15) => {
    const e = Math.round(t15).toString(16);
    return e.length > 1 ? e : `0${e}`;
  }
};
var Vt = {
  channel: Mh,
  lang: Jq,
  unit: tR
};
var Xi = {};
for (let t15 = 0; t15 <= 255; t15++)
  Xi[t15] = Vt.unit.dec2hex(t15);
var fr = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
var eR = class {
  constructor() {
    this.type = fr.ALL;
  }
  /* API */
  get() {
    return this.type;
  }
  set(e) {
    if (this.type && this.type !== e)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = e;
  }
  reset() {
    this.type = fr.ALL;
  }
  is(e) {
    return this.type === e;
  }
};
var rR = class {
  /* CONSTRUCTOR */
  constructor(e, r) {
    this.color = r, this.changed = false, this.data = e, this.type = new eR();
  }
  /* API */
  set(e, r) {
    return this.color = r, this.changed = false, this.data = e, this.type.type = fr.ALL, this;
  }
  /* HELPERS */
  _ensureHSL() {
    const e = this.data, { h: r, s: n, l: i } = e;
    r === void 0 && (e.h = Vt.channel.rgb2hsl(e, "h")), n === void 0 && (e.s = Vt.channel.rgb2hsl(e, "s")), i === void 0 && (e.l = Vt.channel.rgb2hsl(e, "l"));
  }
  _ensureRGB() {
    const e = this.data, { r, g: n, b: i } = e;
    r === void 0 && (e.r = Vt.channel.hsl2rgb(e, "r")), n === void 0 && (e.g = Vt.channel.hsl2rgb(e, "g")), i === void 0 && (e.b = Vt.channel.hsl2rgb(e, "b"));
  }
  /* GETTERS */
  get r() {
    const e = this.data, r = e.r;
    return !this.type.is(fr.HSL) && r !== void 0 ? r : (this._ensureHSL(), Vt.channel.hsl2rgb(e, "r"));
  }
  get g() {
    const e = this.data, r = e.g;
    return !this.type.is(fr.HSL) && r !== void 0 ? r : (this._ensureHSL(), Vt.channel.hsl2rgb(e, "g"));
  }
  get b() {
    const e = this.data, r = e.b;
    return !this.type.is(fr.HSL) && r !== void 0 ? r : (this._ensureHSL(), Vt.channel.hsl2rgb(e, "b"));
  }
  get h() {
    const e = this.data, r = e.h;
    return !this.type.is(fr.RGB) && r !== void 0 ? r : (this._ensureRGB(), Vt.channel.rgb2hsl(e, "h"));
  }
  get s() {
    const e = this.data, r = e.s;
    return !this.type.is(fr.RGB) && r !== void 0 ? r : (this._ensureRGB(), Vt.channel.rgb2hsl(e, "s"));
  }
  get l() {
    const e = this.data, r = e.l;
    return !this.type.is(fr.RGB) && r !== void 0 ? r : (this._ensureRGB(), Vt.channel.rgb2hsl(e, "l"));
  }
  get a() {
    return this.data.a;
  }
  /* SETTERS */
  set r(e) {
    this.type.set(fr.RGB), this.changed = true, this.data.r = e;
  }
  set g(e) {
    this.type.set(fr.RGB), this.changed = true, this.data.g = e;
  }
  set b(e) {
    this.type.set(fr.RGB), this.changed = true, this.data.b = e;
  }
  set h(e) {
    this.type.set(fr.HSL), this.changed = true, this.data.h = e;
  }
  set s(e) {
    this.type.set(fr.HSL), this.changed = true, this.data.s = e;
  }
  set l(e) {
    this.type.set(fr.HSL), this.changed = true, this.data.l = e;
  }
  set a(e) {
    this.changed = true, this.data.a = e;
  }
};
var _0 = new rR({ r: 0, g: 0, b: 0, a: 0 }, "transparent");
var Ro = {
  /* VARIABLES */
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  /* API */
  parse: (t15) => {
    if (t15.charCodeAt(0) !== 35)
      return;
    const e = t15.match(Ro.re);
    if (!e)
      return;
    const r = e[1], n = parseInt(r, 16), i = r.length, s = i % 4 === 0, o = i > 4, a = o ? 1 : 17, l = o ? 8 : 4, c = s ? 0 : -1, h10 = o ? 255 : 15;
    return _0.set({
      r: (n >> l * (c + 3) & h10) * a,
      g: (n >> l * (c + 2) & h10) * a,
      b: (n >> l * (c + 1) & h10) * a,
      a: s ? (n & h10) * a / 255 : 1
    }, t15);
  },
  stringify: (t15) => {
    const { r: e, g: r, b: n, a: i } = t15;
    return i < 1 ? `#${Xi[Math.round(e)]}${Xi[Math.round(r)]}${Xi[Math.round(n)]}${Xi[Math.round(i * 255)]}` : `#${Xi[Math.round(e)]}${Xi[Math.round(r)]}${Xi[Math.round(n)]}`;
  }
};
var Ps = {
  /* VARIABLES */
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  /* HELPERS */
  _hue2deg: (t15) => {
    const e = t15.match(Ps.hueRe);
    if (e) {
      const [, r, n] = e;
      switch (n) {
        case "grad":
          return Vt.channel.clamp.h(parseFloat(r) * 0.9);
        case "rad":
          return Vt.channel.clamp.h(parseFloat(r) * 180 / Math.PI);
        case "turn":
          return Vt.channel.clamp.h(parseFloat(r) * 360);
      }
    }
    return Vt.channel.clamp.h(parseFloat(t15));
  },
  /* API */
  parse: (t15) => {
    const e = t15.charCodeAt(0);
    if (e !== 104 && e !== 72)
      return;
    const r = t15.match(Ps.re);
    if (!r)
      return;
    const [, n, i, s, o, a] = r;
    return _0.set({
      h: Ps._hue2deg(n),
      s: Vt.channel.clamp.s(parseFloat(i)),
      l: Vt.channel.clamp.l(parseFloat(s)),
      a: o ? Vt.channel.clamp.a(a ? parseFloat(o) / 100 : parseFloat(o)) : 1
    }, t15);
  },
  stringify: (t15) => {
    const { h: e, s: r, l: n, a: i } = t15;
    return i < 1 ? `hsla(${Vt.lang.round(e)}, ${Vt.lang.round(r)}%, ${Vt.lang.round(n)}%, ${i})` : `hsl(${Vt.lang.round(e)}, ${Vt.lang.round(r)}%, ${Vt.lang.round(n)}%)`;
  }
};
var bl = {
  /* VARIABLES */
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  /* API */
  parse: (t15) => {
    t15 = t15.toLowerCase();
    const e = bl.colors[t15];
    if (e)
      return Ro.parse(e);
  },
  stringify: (t15) => {
    const e = Ro.stringify(t15);
    for (const r in bl.colors)
      if (bl.colors[r] === e)
        return r;
  }
};
var al = {
  /* VARIABLES */
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  /* API */
  parse: (t15) => {
    const e = t15.charCodeAt(0);
    if (e !== 114 && e !== 82)
      return;
    const r = t15.match(al.re);
    if (!r)
      return;
    const [, n, i, s, o, a, l, c, h10] = r;
    return _0.set({
      r: Vt.channel.clamp.r(i ? parseFloat(n) * 2.55 : parseFloat(n)),
      g: Vt.channel.clamp.g(o ? parseFloat(s) * 2.55 : parseFloat(s)),
      b: Vt.channel.clamp.b(l ? parseFloat(a) * 2.55 : parseFloat(a)),
      a: c ? Vt.channel.clamp.a(h10 ? parseFloat(c) / 100 : parseFloat(c)) : 1
    }, t15);
  },
  stringify: (t15) => {
    const { r: e, g: r, b: n, a: i } = t15;
    return i < 1 ? `rgba(${Vt.lang.round(e)}, ${Vt.lang.round(r)}, ${Vt.lang.round(n)}, ${Vt.lang.round(i)})` : `rgb(${Vt.lang.round(e)}, ${Vt.lang.round(r)}, ${Vt.lang.round(n)})`;
  }
};
var ri = {
  /* VARIABLES */
  format: {
    keyword: bl,
    hex: Ro,
    rgb: al,
    rgba: al,
    hsl: Ps,
    hsla: Ps
  },
  /* API */
  parse: (t15) => {
    if (typeof t15 != "string")
      return t15;
    const e = Ro.parse(t15) || al.parse(t15) || Ps.parse(t15) || bl.parse(t15);
    if (e)
      return e;
    throw new Error(`Unsupported color format: "${t15}"`);
  },
  stringify: (t15) => !t15.changed && t15.color ? t15.color : t15.type.is(fr.HSL) || t15.data.r === void 0 ? Ps.stringify(t15) : t15.a < 1 || !Number.isInteger(t15.r) || !Number.isInteger(t15.g) || !Number.isInteger(t15.b) ? al.stringify(t15) : Ro.stringify(t15)
};
var P6 = (t15, e) => {
  const r = ri.parse(t15);
  for (const n in e)
    r[n] = Vt.channel.clamp[n](e[n]);
  return ri.stringify(r);
};
var xl = (t15, e, r = 0, n = 1) => {
  if (typeof t15 != "number")
    return P6(t15, { a: e });
  const i = _0.set({
    r: Vt.channel.clamp.r(t15),
    g: Vt.channel.clamp.g(e),
    b: Vt.channel.clamp.b(r),
    a: Vt.channel.clamp.a(n)
  });
  return ri.stringify(i);
};
var nR = (t15) => {
  const { r: e, g: r, b: n } = ri.parse(t15), i = 0.2126 * Vt.channel.toLinear(e) + 0.7152 * Vt.channel.toLinear(r) + 0.0722 * Vt.channel.toLinear(n);
  return Vt.lang.round(i);
};
var iR = (t15) => nR(t15) >= 0.5;
var hc = (t15) => !iR(t15);
var j6 = (t15, e, r) => {
  const n = ri.parse(t15), i = n[e], s = Vt.channel.clamp[e](i + r);
  return i !== s && (n[e] = s), ri.stringify(n);
};
var At = (t15, e) => j6(t15, "l", e);
var zt = (t15, e) => j6(t15, "l", -e);
var st = (t15, e) => {
  const r = ri.parse(t15), n = {};
  for (const i in e)
    e[i] && (n[i] = r[i] + e[i]);
  return P6(t15, n);
};
var sR = (t15, e, r = 50) => {
  const { r: n, g: i, b: s, a: o } = ri.parse(t15), { r: a, g: l, b: c, a: h10 } = ri.parse(e), p = r / 100, m = p * 2 - 1, g = o - h10, y = ((m * g === -1 ? m : (m + g) / (1 + m * g)) + 1) / 2, x = 1 - y, k = n * y + a * x, C = i * y + l * x, _ = s * y + c * x, $ = o * p + h10 * (1 - p);
  return xl(k, C, _, $);
};
var vt = (t15, e = 100) => {
  const r = ri.parse(t15);
  return r.r = 255 - r.r, r.g = 255 - r.g, r.b = 255 - r.b, sR(r, t15, e);
};
var {
  entries: W6,
  setPrototypeOf: Nb,
  isFrozen: oR,
  getPrototypeOf: aR,
  getOwnPropertyDescriptor: lR
} = Object;
var {
  freeze: Br,
  seal: xn,
  create: H6
} = Object;
var {
  apply: Df,
  construct: Ff
} = typeof Reflect < "u" && Reflect;
Br || (Br = function(t15) {
  return t15;
});
xn || (xn = function(t15) {
  return t15;
});
Df || (Df = function(t15, e, r) {
  return t15.apply(e, r);
});
Ff || (Ff = function(t15, e) {
  return new t15(...e);
});
var sh = Lr(Array.prototype.forEach);
var cR = Lr(Array.prototype.lastIndexOf);
var Ib = Lr(Array.prototype.pop);
var qa = Lr(Array.prototype.push);
var hR = Lr(Array.prototype.splice);
var Bh = Lr(String.prototype.toLowerCase);
var fp = Lr(String.prototype.toString);
var Ob = Lr(String.prototype.match);
var Ra = Lr(String.prototype.replace);
var uR = Lr(String.prototype.indexOf);
var dR = Lr(String.prototype.trim);
var Cn = Lr(Object.prototype.hasOwnProperty);
var Sr = Lr(RegExp.prototype.test);
var Pa = pR(TypeError);
function Lr(t15) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      n[i - 1] = arguments[i];
    return Df(t15, e, n);
  };
}
function pR(t15) {
  return function() {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return Ff(t15, r);
  };
}
function ne(t15, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Bh;
  Nb && Nb(t15, null);
  let n = e.length;
  for (; n--; ) {
    let i = e[n];
    if (typeof i == "string") {
      const s = r(i);
      s !== i && (oR(e) || (e[n] = s), i = s);
    }
    t15[i] = true;
  }
  return t15;
}
function fR(t15) {
  for (let e = 0; e < t15.length; e++)
    Cn(t15, e) || (t15[e] = null);
  return t15;
}
function _i(t15) {
  const e = H6(null);
  for (const [r, n] of W6(t15))
    Cn(t15, r) && (Array.isArray(n) ? e[r] = fR(n) : n && typeof n == "object" && n.constructor === Object ? e[r] = _i(n) : e[r] = n);
  return e;
}
function ja(t15, e) {
  for (; t15 !== null; ) {
    const n = lR(t15, e);
    if (n) {
      if (n.get)
        return Lr(n.get);
      if (typeof n.value == "function")
        return Lr(n.value);
    }
    t15 = aR(t15);
  }
  function r() {
    return null;
  }
  return r;
}
var zb = Br(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var mp = Br(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var gp = Br(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var mR = Br(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var yp = Br(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var gR = Br(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var qb = Br(["#text"]);
var Rb = Br(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var bp = Br(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var Pb = Br(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var oh = Br(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var yR = xn(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var bR = xn(/<%[\w\W]*|[\w\W]*%>/gm);
var xR = xn(/\$\{[\w\W]*/gm);
var wR = xn(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var kR = xn(/^aria-[\-\w]+$/);
var U6 = xn(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var vR = xn(/^(?:\w+script|data):/i);
var _R = xn(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var V6 = xn(/^html$/i);
var CR = xn(/^[a-z][.\w]*(-[.\w]+)+$/i);
var jb = Object.freeze({
  __proto__: null,
  ARIA_ATTR: kR,
  ATTR_WHITESPACE: _R,
  CUSTOM_ELEMENT: CR,
  DATA_ATTR: wR,
  DOCTYPE_NAME: V6,
  ERB_EXPR: bR,
  IS_ALLOWED_URI: U6,
  IS_SCRIPT_OR_DATA: vR,
  MUSTACHE_EXPR: yR,
  TMPLIT_EXPR: xR
});
var Wa = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
};
var SR = function() {
  return typeof window > "u" ? null : window;
};
var TR = function(t15, e) {
  if (typeof t15 != "object" || typeof t15.createPolicy != "function")
    return null;
  let r = null;
  const n = "data-tt-policy-suffix";
  e && e.hasAttribute(n) && (r = e.getAttribute(n));
  const i = "dompurify" + (r ? "#" + r : "");
  try {
    return t15.createPolicy(i, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + i + " could not be created."), null;
  }
};
var Wb = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function G6() {
  let t15 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : SR();
  const e = (Z) => G6(Z);
  if (e.version = "3.2.6", e.removed = [], !t15 || !t15.document || t15.document.nodeType !== Wa.document || !t15.Element)
    return e.isSupported = false, e;
  let {
    document: r
  } = t15;
  const n = r, i = n.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: a,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: h10 = t15.NamedNodeMap || t15.MozNamedAttrMap,
    HTMLFormElement: p,
    DOMParser: m,
    trustedTypes: g
  } = t15, y = l.prototype, x = ja(y, "cloneNode"), k = ja(y, "remove"), C = ja(y, "nextSibling"), _ = ja(y, "childNodes"), $ = ja(y, "parentNode");
  if (typeof o == "function") {
    const Z = r.createElement("template");
    Z.content && Z.content.ownerDocument && (r = Z.content.ownerDocument);
  }
  let L, B = "";
  const {
    implementation: q,
    createNodeIterator: H,
    createDocumentFragment: G,
    getElementsByTagName: F
  } = r, {
    importNode: W
  } = n;
  let R = Wb();
  e.isSupported = typeof W6 == "function" && typeof $ == "function" && q && q.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: J,
    ERB_EXPR: rt,
    TMPLIT_EXPR: I,
    DATA_ATTR: j,
    ARIA_ATTR: z,
    IS_SCRIPT_OR_DATA: K,
    ATTR_WHITESPACE: Y,
    CUSTOM_ELEMENT: at
  } = jb;
  let {
    IS_ALLOWED_URI: et
  } = jb, ht = null;
  const X = ne({}, [...zb, ...mp, ...gp, ...yp, ...qb]);
  let ct = null;
  const gt = ne({}, [...Rb, ...bp, ...Pb, ...oh]);
  let xt = Object.seal(H6(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  })), Yt = null, U = null, mt = true, wt = true, Tt = false, Ut = true, Ce = false, ue = true, ci = false, mo = false, va = false, sn = false, wr = false, hi = false, _a2 = true, _c = false;
  const Ca = "user-content-";
  let bs = true, xs = false, Pi = {}, ui = null;
  const Sa = ne({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let on = null;
  const Cc = ne({}, ["audio", "video", "img", "source", "image", "track"]);
  let ws = null;
  const Sc = ne({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), ks = "http://www.w3.org/1998/Math/MathML", we = "http://www.w3.org/2000/svg", bt = "http://www.w3.org/1999/xhtml";
  let kr = bt, go = false, yo = null;
  const Z0 = ne({}, [ks, we, bt], fp);
  let vs = ne({}, ["mi", "mo", "mn", "ms", "mtext"]), Nn = ne({}, ["annotation-xml"]);
  const Ta = ne({}, ["title", "style", "font", "a", "script"]);
  let _s = null;
  const Q0 = ["application/xhtml+xml", "text/html"], Dr = "text/html";
  let ke = null, vr = null;
  const Aa = r.createElement("form"), $a = function(Z) {
    return Z instanceof RegExp || Z instanceof Function;
  }, Ea = function() {
    let Z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(vr && vr === Z)) {
      if ((!Z || typeof Z != "object") && (Z = {}), Z = _i(Z), _s = // eslint-disable-next-line unicorn/prefer-includes
      Q0.indexOf(Z.PARSER_MEDIA_TYPE) === -1 ? Dr : Z.PARSER_MEDIA_TYPE, ke = _s === "application/xhtml+xml" ? fp : Bh, ht = Cn(Z, "ALLOWED_TAGS") ? ne({}, Z.ALLOWED_TAGS, ke) : X, ct = Cn(Z, "ALLOWED_ATTR") ? ne({}, Z.ALLOWED_ATTR, ke) : gt, yo = Cn(Z, "ALLOWED_NAMESPACES") ? ne({}, Z.ALLOWED_NAMESPACES, fp) : Z0, ws = Cn(Z, "ADD_URI_SAFE_ATTR") ? ne(_i(Sc), Z.ADD_URI_SAFE_ATTR, ke) : Sc, on = Cn(Z, "ADD_DATA_URI_TAGS") ? ne(_i(Cc), Z.ADD_DATA_URI_TAGS, ke) : Cc, ui = Cn(Z, "FORBID_CONTENTS") ? ne({}, Z.FORBID_CONTENTS, ke) : Sa, Yt = Cn(Z, "FORBID_TAGS") ? ne({}, Z.FORBID_TAGS, ke) : _i({}), U = Cn(Z, "FORBID_ATTR") ? ne({}, Z.FORBID_ATTR, ke) : _i({}), Pi = Cn(Z, "USE_PROFILES") ? Z.USE_PROFILES : false, mt = Z.ALLOW_ARIA_ATTR !== false, wt = Z.ALLOW_DATA_ATTR !== false, Tt = Z.ALLOW_UNKNOWN_PROTOCOLS || false, Ut = Z.ALLOW_SELF_CLOSE_IN_ATTR !== false, Ce = Z.SAFE_FOR_TEMPLATES || false, ue = Z.SAFE_FOR_XML !== false, ci = Z.WHOLE_DOCUMENT || false, sn = Z.RETURN_DOM || false, wr = Z.RETURN_DOM_FRAGMENT || false, hi = Z.RETURN_TRUSTED_TYPE || false, va = Z.FORCE_BODY || false, _a2 = Z.SANITIZE_DOM !== false, _c = Z.SANITIZE_NAMED_PROPS || false, bs = Z.KEEP_CONTENT !== false, xs = Z.IN_PLACE || false, et = Z.ALLOWED_URI_REGEXP || U6, kr = Z.NAMESPACE || bt, vs = Z.MATHML_TEXT_INTEGRATION_POINTS || vs, Nn = Z.HTML_INTEGRATION_POINTS || Nn, xt = Z.CUSTOM_ELEMENT_HANDLING || {}, Z.CUSTOM_ELEMENT_HANDLING && $a(Z.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (xt.tagNameCheck = Z.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Z.CUSTOM_ELEMENT_HANDLING && $a(Z.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (xt.attributeNameCheck = Z.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Z.CUSTOM_ELEMENT_HANDLING && typeof Z.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (xt.allowCustomizedBuiltInElements = Z.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ce && (wt = false), wr && (sn = true), Pi && (ht = ne({}, qb), ct = [], Pi.html === true && (ne(ht, zb), ne(ct, Rb)), Pi.svg === true && (ne(ht, mp), ne(ct, bp), ne(ct, oh)), Pi.svgFilters === true && (ne(ht, gp), ne(ct, bp), ne(ct, oh)), Pi.mathMl === true && (ne(ht, yp), ne(ct, Pb), ne(ct, oh))), Z.ADD_TAGS && (ht === X && (ht = _i(ht)), ne(ht, Z.ADD_TAGS, ke)), Z.ADD_ATTR && (ct === gt && (ct = _i(ct)), ne(ct, Z.ADD_ATTR, ke)), Z.ADD_URI_SAFE_ATTR && ne(ws, Z.ADD_URI_SAFE_ATTR, ke), Z.FORBID_CONTENTS && (ui === Sa && (ui = _i(ui)), ne(ui, Z.FORBID_CONTENTS, ke)), bs && (ht["#text"] = true), ci && ne(ht, ["html", "head", "body"]), ht.table && (ne(ht, ["tbody"]), delete Yt.tbody), Z.TRUSTED_TYPES_POLICY) {
        if (typeof Z.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Pa('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof Z.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Pa('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        L = Z.TRUSTED_TYPES_POLICY, B = L.createHTML("");
      } else
        L === void 0 && (L = TR(g, i)), L !== null && typeof B == "string" && (B = L.createHTML(""));
      Br && Br(Z), vr = Z;
    }
  }, Tc = ne({}, [...mp, ...gp, ...mR]), Ac = ne({}, [...yp, ...gR]), bo = function(Z) {
    let _t = $(Z);
    (!_t || !_t.tagName) && (_t = {
      namespaceURI: kr,
      tagName: "template"
    });
    const O = Bh(Z.tagName), te = Bh(_t.tagName);
    return yo[Z.namespaceURI] ? Z.namespaceURI === we ? _t.namespaceURI === bt ? O === "svg" : _t.namespaceURI === ks ? O === "svg" && (te === "annotation-xml" || vs[te]) : !!Tc[O] : Z.namespaceURI === ks ? _t.namespaceURI === bt ? O === "math" : _t.namespaceURI === we ? O === "math" && Nn[te] : !!Ac[O] : Z.namespaceURI === bt ? _t.namespaceURI === we && !Nn[te] || _t.namespaceURI === ks && !vs[te] ? false : !Ac[O] && (Ta[O] || !Tc[O]) : !!(_s === "application/xhtml+xml" && yo[Z.namespaceURI]) : false;
  }, fe = function(Z) {
    qa(e.removed, {
      element: Z
    });
    try {
      $(Z).removeChild(Z);
    } catch {
      k(Z);
    }
  }, v = function(Z, _t) {
    try {
      qa(e.removed, {
        attribute: _t.getAttributeNode(Z),
        from: _t
      });
    } catch {
      qa(e.removed, {
        attribute: null,
        from: _t
      });
    }
    if (_t.removeAttribute(Z), Z === "is")
      if (sn || wr)
        try {
          fe(_t);
        } catch {
        }
      else
        try {
          _t.setAttribute(Z, "");
        } catch {
        }
  }, A = function(Z) {
    let _t = null, O = null;
    if (va)
      Z = "<remove></remove>" + Z;
    else {
      const Ae = Ob(Z, /^[\r\n\t ]+/);
      O = Ae && Ae[0];
    }
    _s === "application/xhtml+xml" && kr === bt && (Z = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Z + "</body></html>");
    const te = L ? L.createHTML(Z) : Z;
    if (kr === bt)
      try {
        _t = new m().parseFromString(te, _s);
      } catch {
      }
    if (!_t || !_t.documentElement) {
      _t = q.createDocument(kr, "template", null);
      try {
        _t.documentElement.innerHTML = go ? B : te;
      } catch {
      }
    }
    const tt = _t.body || _t.documentElement;
    return Z && O && tt.insertBefore(r.createTextNode(O), tt.childNodes[0] || null), kr === bt ? F.call(_t, ci ? "html" : "body")[0] : ci ? _t.documentElement : tt;
  }, dt = function(Z) {
    return H.call(
      Z.ownerDocument || Z,
      Z,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, M = function(Z) {
    return Z instanceof p && (typeof Z.nodeName != "string" || typeof Z.textContent != "string" || typeof Z.removeChild != "function" || !(Z.attributes instanceof h10) || typeof Z.removeAttribute != "function" || typeof Z.setAttribute != "function" || typeof Z.namespaceURI != "string" || typeof Z.insertBefore != "function" || typeof Z.hasChildNodes != "function");
  }, V = function(Z) {
    return typeof a == "function" && Z instanceof a;
  };
  function se(Z, _t, O) {
    sh(Z, (te) => {
      te.call(e, _t, O, vr);
    });
  }
  const St = function(Z) {
    let _t = null;
    if (se(R.beforeSanitizeElements, Z, null), M(Z))
      return fe(Z), true;
    const O = ke(Z.nodeName);
    if (se(R.uponSanitizeElement, Z, {
      tagName: O,
      allowedTags: ht
    }), ue && Z.hasChildNodes() && !V(Z.firstElementChild) && Sr(/<[/\w!]/g, Z.innerHTML) && Sr(/<[/\w!]/g, Z.textContent) || Z.nodeType === Wa.progressingInstruction || ue && Z.nodeType === Wa.comment && Sr(/<[/\w]/g, Z.data))
      return fe(Z), true;
    if (!ht[O] || Yt[O]) {
      if (!Yt[O] && di(O) && (xt.tagNameCheck instanceof RegExp && Sr(xt.tagNameCheck, O) || xt.tagNameCheck instanceof Function && xt.tagNameCheck(O)))
        return false;
      if (bs && !ui[O]) {
        const te = $(Z) || Z.parentNode, tt = _(Z) || Z.childNodes;
        if (tt && te) {
          const Ae = tt.length;
          for (let an = Ae - 1; an >= 0; --an) {
            const Fr = x(tt[an], true);
            Fr.__removalCount = (Z.__removalCount || 0) + 1, te.insertBefore(Fr, C(Z));
          }
        }
      }
      return fe(Z), true;
    }
    return Z instanceof l && !bo(Z) || (O === "noscript" || O === "noembed" || O === "noframes") && Sr(/<\/no(script|embed|frames)/i, Z.innerHTML) ? (fe(Z), true) : (Ce && Z.nodeType === Wa.text && (_t = Z.textContent, sh([J, rt, I], (te) => {
      _t = Ra(_t, te, " ");
    }), Z.textContent !== _t && (qa(e.removed, {
      element: Z.cloneNode()
    }), Z.textContent = _t)), se(R.afterSanitizeElements, Z, null), false);
  }, tr = function(Z, _t, O) {
    if (_a2 && (_t === "id" || _t === "name") && (O in r || O in Aa))
      return false;
    if (!(wt && !U[_t] && Sr(j, _t)) && !(mt && Sr(z, _t))) {
      if (!ct[_t] || U[_t]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          !(di(Z) && (xt.tagNameCheck instanceof RegExp && Sr(xt.tagNameCheck, Z) || xt.tagNameCheck instanceof Function && xt.tagNameCheck(Z)) && (xt.attributeNameCheck instanceof RegExp && Sr(xt.attributeNameCheck, _t) || xt.attributeNameCheck instanceof Function && xt.attributeNameCheck(_t)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          _t === "is" && xt.allowCustomizedBuiltInElements && (xt.tagNameCheck instanceof RegExp && Sr(xt.tagNameCheck, O) || xt.tagNameCheck instanceof Function && xt.tagNameCheck(O)))
        ) return false;
      } else if (!ws[_t] && !Sr(et, Ra(O, Y, "")) && !((_t === "src" || _t === "xlink:href" || _t === "href") && Z !== "script" && uR(O, "data:") === 0 && on[Z]) && !(Tt && !Sr(K, Ra(O, Y, ""))) && O)
        return false;
    }
    return true;
  }, di = function(Z) {
    return Z !== "annotation-xml" && Ob(Z, at);
  }, Ot = function(Z) {
    se(R.beforeSanitizeAttributes, Z, null);
    const {
      attributes: _t
    } = Z;
    if (!_t || M(Z))
      return;
    const O = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ct,
      forceKeepAttr: void 0
    };
    let te = _t.length;
    for (; te--; ) {
      const tt = _t[te], {
        name: Ae,
        namespaceURI: an,
        value: Fr
      } = tt, _r = ke(Ae), qt = Fr;
      let Ue = Ae === "value" ? qt : dR(qt);
      if (O.attrName = _r, O.attrValue = Ue, O.keepAttr = true, O.forceKeepAttr = void 0, se(R.uponSanitizeAttribute, Z, O), Ue = O.attrValue, _c && (_r === "id" || _r === "name") && (v(Ae, Z), Ue = Ca + Ue), ue && Sr(/((--!?|])>)|<\/(style|title)/i, Ue)) {
        v(Ae, Z);
        continue;
      }
      if (O.forceKeepAttr)
        continue;
      if (!O.keepAttr) {
        v(Ae, Z);
        continue;
      }
      if (!Ut && Sr(/\/>/i, Ue)) {
        v(Ae, Z);
        continue;
      }
      Ce && sh([J, rt, I], ($c) => {
        Ue = Ra(Ue, $c, " ");
      });
      const Cs = ke(Z.nodeName);
      if (!tr(Cs, _r, Ue)) {
        v(Ae, Z);
        continue;
      }
      if (L && typeof g == "object" && typeof g.getAttributeType == "function" && !an)
        switch (g.getAttributeType(Cs, _r)) {
          case "TrustedHTML": {
            Ue = L.createHTML(Ue);
            break;
          }
          case "TrustedScriptURL": {
            Ue = L.createScriptURL(Ue);
            break;
          }
        }
      if (Ue !== qt)
        try {
          an ? Z.setAttributeNS(an, Ae, Ue) : Z.setAttribute(Ae, Ue), M(Z) ? fe(Z) : Ib(e.removed);
        } catch {
          v(Ae, Z);
        }
    }
    se(R.afterSanitizeAttributes, Z, null);
  }, ze = function Z(_t) {
    let O = null;
    const te = dt(_t);
    for (se(R.beforeSanitizeShadowDOM, _t, null); O = te.nextNode(); )
      se(R.uponSanitizeShadowNode, O, null), St(O), Ot(O), O.content instanceof s && Z(O.content);
    se(R.afterSanitizeShadowDOM, _t, null);
  };
  return e.sanitize = function(Z) {
    let _t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, O = null, te = null, tt = null, Ae = null;
    if (go = !Z, go && (Z = "<!-->"), typeof Z != "string" && !V(Z))
      if (typeof Z.toString == "function") {
        if (Z = Z.toString(), typeof Z != "string")
          throw Pa("dirty is not a string, aborting");
      } else
        throw Pa("toString is not a function");
    if (!e.isSupported)
      return Z;
    if (mo || Ea(_t), e.removed = [], typeof Z == "string" && (xs = false), xs) {
      if (Z.nodeName) {
        const _r = ke(Z.nodeName);
        if (!ht[_r] || Yt[_r])
          throw Pa("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Z instanceof a)
      O = A("<!---->"), te = O.ownerDocument.importNode(Z, true), te.nodeType === Wa.element && te.nodeName === "BODY" || te.nodeName === "HTML" ? O = te : O.appendChild(te);
    else {
      if (!sn && !Ce && !ci && // eslint-disable-next-line unicorn/prefer-includes
      Z.indexOf("<") === -1)
        return L && hi ? L.createHTML(Z) : Z;
      if (O = A(Z), !O)
        return sn ? null : hi ? B : "";
    }
    O && va && fe(O.firstChild);
    const an = dt(xs ? Z : O);
    for (; tt = an.nextNode(); )
      St(tt), Ot(tt), tt.content instanceof s && ze(tt.content);
    if (xs)
      return Z;
    if (sn) {
      if (wr)
        for (Ae = G.call(O.ownerDocument); O.firstChild; )
          Ae.appendChild(O.firstChild);
      else
        Ae = O;
      return (ct.shadowroot || ct.shadowrootmode) && (Ae = W.call(n, Ae, true)), Ae;
    }
    let Fr = ci ? O.outerHTML : O.innerHTML;
    return ci && ht["!doctype"] && O.ownerDocument && O.ownerDocument.doctype && O.ownerDocument.doctype.name && Sr(V6, O.ownerDocument.doctype.name) && (Fr = "<!DOCTYPE " + O.ownerDocument.doctype.name + `>
` + Fr), Ce && sh([J, rt, I], (_r) => {
      Fr = Ra(Fr, _r, " ");
    }), L && hi ? L.createHTML(Fr) : Fr;
  }, e.setConfig = function() {
    let Z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Ea(Z), mo = true;
  }, e.clearConfig = function() {
    vr = null, mo = false;
  }, e.isValidAttribute = function(Z, _t, O) {
    vr || Ea({});
    const te = ke(Z), tt = ke(_t);
    return tr(te, tt, O);
  }, e.addHook = function(Z, _t) {
    typeof _t == "function" && qa(R[Z], _t);
  }, e.removeHook = function(Z, _t) {
    if (_t !== void 0) {
      const O = cR(R[Z], _t);
      return O === -1 ? void 0 : hR(R[Z], O, 1)[0];
    }
    return Ib(R[Z]);
  }, e.removeHooks = function(Z) {
    R[Z] = [];
  }, e.removeAllHooks = function() {
    R = Wb();
  }, e;
}
var Zo = G6();
var X6 = Object.defineProperty;
var S = (t15, e) => X6(t15, "name", { value: e, configurable: true });
var AR = (t15, e) => {
  for (var r in e)
    X6(t15, r, { get: e[r], enumerable: true });
};
var xi = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
};
var ut = {
  trace: S((...t15) => {
  }, "trace"),
  debug: S((...t15) => {
  }, "debug"),
  info: S((...t15) => {
  }, "info"),
  warn: S((...t15) => {
  }, "warn"),
  error: S((...t15) => {
  }, "error"),
  fatal: S((...t15) => {
  }, "fatal")
};
var Bm = S(function(t15 = "fatal") {
  let e = xi.fatal;
  typeof t15 == "string" ? t15.toLowerCase() in xi && (e = xi[t15]) : typeof t15 == "number" && (e = t15), ut.trace = () => {
  }, ut.debug = () => {
  }, ut.info = () => {
  }, ut.warn = () => {
  }, ut.error = () => {
  }, ut.fatal = () => {
  }, e <= xi.fatal && (ut.fatal = console.error ? console.error.bind(console, dn("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", dn("FATAL"))), e <= xi.error && (ut.error = console.error ? console.error.bind(console, dn("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", dn("ERROR"))), e <= xi.warn && (ut.warn = console.warn ? console.warn.bind(console, dn("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", dn("WARN"))), e <= xi.info && (ut.info = console.info ? console.info.bind(console, dn("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", dn("INFO"))), e <= xi.debug && (ut.debug = console.debug ? console.debug.bind(console, dn("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", dn("DEBUG"))), e <= xi.trace && (ut.trace = console.debug ? console.debug.bind(console, dn("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", dn("TRACE")));
}, "setLogLevel");
var dn = S((t15) => `%c${Qq().format("ss.SSS")} : ${t15} : `, "format");
var Y6 = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s;
var wl = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
var $R = /\s*%%.*\n/gm;
var xp;
var K6 = (xp = class extends Error {
  constructor(t15) {
    super(t15), this.name = "UnknownDiagramError";
  }
}, S(xp, "UnknownDiagramError"), xp);
var Js = {};
var Lm = S(function(t15, e) {
  t15 = t15.replace(Y6, "").replace(wl, "").replace($R, `
`);
  for (const [r, { detector: n }] of Object.entries(Js))
    if (n(t15, e))
      return r;
  throw new K6(
    `No diagram type detected matching given configuration for text: ${t15}`
  );
}, "detectType");
var Nf = S((...t15) => {
  for (const { id: e, detector: r, loader: n } of t15)
    Z6(e, r, n);
}, "registerLazyLoadedDiagrams");
var Z6 = S((t15, e, r) => {
  Js[t15] && ut.warn(`Detector with key ${t15} already exists. Overwriting.`), Js[t15] = { detector: e, loader: r }, ut.debug(`Detector with key ${t15} added${r ? " with loader" : ""}`);
}, "addDetector");
var ER = S((t15) => Js[t15].loader, "getDiagramLoader");
var If = S((t15, e, { depth: r = 2, clobber: n = false } = {}) => {
  const i = { depth: r, clobber: n };
  return Array.isArray(e) && !Array.isArray(t15) ? (e.forEach((s) => If(t15, s, i)), t15) : Array.isArray(e) && Array.isArray(t15) ? (e.forEach((s) => {
    t15.includes(s) || t15.push(s);
  }), t15) : t15 === void 0 || r <= 0 ? t15 != null && typeof t15 == "object" && typeof e == "object" ? Object.assign(t15, e) : e : (e !== void 0 && typeof t15 == "object" && typeof e == "object" && Object.keys(e).forEach((s) => {
    typeof e[s] == "object" && (t15[s] === void 0 || typeof t15[s] == "object") ? (t15[s] === void 0 && (t15[s] = Array.isArray(e[s]) ? [] : {}), t15[s] = If(t15[s], e[s], { depth: r - 1, clobber: n })) : (n || typeof t15[s] != "object" && typeof e[s] != "object") && (t15[s] = e[s]);
  }), t15);
}, "assignWithDepth");
var pr = If;
var C0 = "#ffffff";
var S0 = "#f2f2f2";
var Ar = S((t15, e) => e ? st(t15, { s: -40, l: 10 }) : st(t15, { s: -40, l: -10 }), "mkBorder");
var wp;
var MR = (wp = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px";
  }
  updateColors() {
    var _a2, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r, _s, _t, _u2;
    if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || st(this.primaryColor, { h: -120 }), this.tertiaryColor = this.tertiaryColor || st(this.primaryColor, { h: 180, l: 5 }), this.primaryBorderColor = this.primaryBorderColor || Ar(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || Ar(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || Ar(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || Ar(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || vt(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || vt(this.tertiaryColor), this.lineColor = this.lineColor || vt(this.background), this.arrowheadColor = this.arrowheadColor || vt(this.background), this.textColor = this.textColor || this.primaryTextColor, this.border2 = this.border2 || this.tertiaryBorderColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? zt(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || this.actorBorder, this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || zt(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || vt(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || At(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.vertLineColor = this.vertLineColor || "navy", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.darkMode ? (this.rowOdd = this.rowOdd || zt(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || zt(this.mainBkg, 10)) : (this.rowOdd = this.rowOdd || At(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || At(this.mainBkg, 5)), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210, l: 150 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.darkMode)
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
        this["cScale" + e] = zt(this["cScale" + e], 75);
    else
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
        this["cScale" + e] = zt(this["cScale" + e], 25);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || vt(this["cScale" + e]);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this.darkMode ? this["cScalePeer" + e] = this["cScalePeer" + e] || At(this["cScale" + e], 10) : this["cScalePeer" + e] = this["cScalePeer" + e] || zt(this["cScale" + e], 10);
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    const t15 = this.darkMode ? -4 : -1;
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || st(this.mainBkg, { h: 180, s: -15, l: t15 * (5 + e * 3) }), this["surfacePeer" + e] = this["surfacePeer" + e] || st(this.mainBkg, { h: 180, s: -15, l: t15 * (8 + e * 3) });
    this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || st(this.primaryColor, { h: 64 }), this.fillType3 = this.fillType3 || st(this.secondaryColor, { h: 64 }), this.fillType4 = this.fillType4 || st(this.primaryColor, { h: -64 }), this.fillType5 = this.fillType5 || st(this.secondaryColor, { h: -64 }), this.fillType6 = this.fillType6 || st(this.primaryColor, { h: 128 }), this.fillType7 = this.fillType7 || st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || st(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -10 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { l: -10 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -20 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -60, l: -20 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -10 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.radar = {
      axisColor: ((_a2 = this.radar) == null ? void 0 : _a2.axisColor) || this.lineColor,
      axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_c = this.radar) == null ? void 0 : _c.axisLabelFontSize) || 12,
      curveOpacity: ((_d = this.radar) == null ? void 0 : _d.curveOpacity) || 0.5,
      curveStrokeWidth: ((_e = this.radar) == null ? void 0 : _e.curveStrokeWidth) || 2,
      graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_g2 = this.radar) == null ? void 0 : _g2.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_h2 = this.radar) == null ? void 0 : _h2.graticuleOpacity) || 0.3,
      legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
      legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
    }, this.archEdgeColor = this.archEdgeColor || "#777", this.archEdgeArrowColor = this.archEdgeArrowColor || "#777", this.archEdgeWidth = this.archEdgeWidth || "3", this.archGroupBorderColor = this.archGroupBorderColor || "#000", this.archGroupBorderWidth = this.archGroupBorderWidth || "2px", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((_k2 = this.xyChart) == null ? void 0 : _k2.backgroundColor) || this.background,
      titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_m2 = this.xyChart) == null ? void 0 : _m2.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_o2 = this.xyChart) == null ? void 0 : _o2.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_q2 = this.xyChart) == null ? void 0 : _q2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_r = this.xyChart) == null ? void 0 : _r.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_s = this.xyChart) == null ? void 0 : _s.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? zt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = At(this.git0, 25), this.git1 = At(this.git1, 25), this.git2 = At(this.git2, 25), this.git3 = At(this.git3, 25), this.git4 = At(this.git4, 25), this.git5 = At(this.git5, 25), this.git6 = At(this.git6, 25), this.git7 = At(this.git7, 25)) : (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || vt(this.git0), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || C0, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || S0;
  }
  calculate(t15) {
    if (typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, S(wp, "Theme"), wp);
var BR = S((t15) => {
  const e = new MR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var kp;
var LR = (kp = class {
  constructor() {
    this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = At(this.primaryColor, 16), this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = vt(this.background), this.secondaryBorderColor = Ar(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Ar(this.tertiaryColor, this.darkMode), this.primaryTextColor = vt(this.primaryColor), this.secondaryTextColor = vt(this.secondaryColor), this.tertiaryTextColor = vt(this.tertiaryColor), this.lineColor = vt(this.background), this.textColor = vt(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = At(vt("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#ccc", this.border2 = xl(255, 255, 255, 0.25), this.arrowheadColor = "calculated", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = zt("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.excludeBkgColor = zt(this.sectionBkgColor, 10), this.taskBorderColor = xl(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = xl(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || At(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || zt(this.mainBkg, 10), this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
  }
  updateColors() {
    var _a2, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r, _s, _t, _u2;
    this.secondBkg = At(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = At(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.actorBorder, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = At(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 });
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleInv" + t15] = this["cScaleInv" + t15] || vt(this["cScale" + t15]);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScalePeer" + t15] = this["cScalePeer" + t15] || At(this["cScale" + t15], 10);
    for (let t15 = 0; t15 < 5; t15++)
      this["surface" + t15] = this["surface" + t15] || st(this.mainBkg, { h: 30, s: -30, l: -(-10 + t15 * 4) }), this["surfacePeer" + t15] = this["surfacePeer" + t15] || st(this.mainBkg, { h: 30, s: -30, l: -(-7 + t15 * 4) });
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleLabel" + t15] = this["cScaleLabel" + t15] || this.scaleLabelColor;
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["pie" + t15] = this["cScale" + t15];
    this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((_a2 = this.xyChart) == null ? void 0 : _a2.backgroundColor) || this.background,
      titleColor: ((_b2 = this.xyChart) == null ? void 0 : _b2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_c = this.xyChart) == null ? void 0 : _c.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_d = this.xyChart) == null ? void 0 : _d.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_e = this.xyChart) == null ? void 0 : _e.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_f2 = this.xyChart) == null ? void 0 : _f2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_g2 = this.xyChart) == null ? void 0 : _g2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_h2 = this.xyChart) == null ? void 0 : _h2.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_i2 = this.xyChart) == null ? void 0 : _i2.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_j2 = this.xyChart) == null ? void 0 : _j2.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_k2 = this.xyChart) == null ? void 0 : _k2.plotColorPalette) || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
    }, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.background
    }, this.radar = {
      axisColor: ((_l2 = this.radar) == null ? void 0 : _l2.axisColor) || this.lineColor,
      axisStrokeWidth: ((_m2 = this.radar) == null ? void 0 : _m2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_n2 = this.radar) == null ? void 0 : _n2.axisLabelFontSize) || 12,
      curveOpacity: ((_o2 = this.radar) == null ? void 0 : _o2.curveOpacity) || 0.5,
      curveStrokeWidth: ((_p2 = this.radar) == null ? void 0 : _p2.curveStrokeWidth) || 2,
      graticuleColor: ((_q2 = this.radar) == null ? void 0 : _q2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_r = this.radar) == null ? void 0 : _r.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_s = this.radar) == null ? void 0 : _s.graticuleOpacity) || 0.3,
      legendBoxSize: ((_t = this.radar) == null ? void 0 : _t.legendBoxSize) || 12,
      legendFontSize: ((_u2 = this.radar) == null ? void 0 : _u2.legendFontSize) || 12
    }, this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? zt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = At(this.secondaryColor, 20), this.git1 = At(this.pie2 || this.secondaryColor, 20), this.git2 = At(this.pie3 || this.tertiaryColor, 20), this.git3 = At(this.pie4 || st(this.primaryColor, { h: -30 }), 20), this.git4 = At(this.pie5 || st(this.primaryColor, { h: -60 }), 20), this.git5 = At(this.pie6 || st(this.primaryColor, { h: -90 }), 10), this.git6 = At(this.pie7 || st(this.primaryColor, { h: 60 }), 10), this.git7 = At(this.pie8 || st(this.primaryColor, { h: 120 }), 20), this.gitInv0 = this.gitInv0 || vt(this.git0), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || vt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || vt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || At(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || At(this.background, 2), this.nodeBorder = this.nodeBorder || "#999";
  }
  calculate(t15) {
    if (typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, S(kp, "Theme"), kp);
var DR = S((t15) => {
  const e = new LR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var vp;
var FR = (vp = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = st(this.primaryColor, { h: 120 }), this.secondaryColor = "#ffffde", this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = Ar(this.primaryColor, this.darkMode), this.secondaryBorderColor = Ar(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Ar(this.tertiaryColor, this.darkMode), this.primaryTextColor = vt(this.primaryColor), this.secondaryTextColor = vt(this.secondaryColor), this.tertiaryTextColor = vt(this.tertiaryColor), this.lineColor = vt(this.background), this.textColor = vt(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "rgba(232,232,232, 0.8)", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.sectionBkgColor = xl(102, 102, 255, 0.49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "navy", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = "calculated", this.rowEven = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
  }
  updateColors() {
    var _a2, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r, _s, _t, _u2;
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || zt(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || zt(this.tertiaryColor, 40);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScale" + t15] = zt(this["cScale" + t15], 10), this["cScalePeer" + t15] = this["cScalePeer" + t15] || zt(this["cScale" + t15], 25);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleInv" + t15] = this["cScaleInv" + t15] || st(this["cScale" + t15], { h: 180 });
    for (let t15 = 0; t15 < 5; t15++)
      this["surface" + t15] = this["surface" + t15] || st(this.mainBkg, { h: 30, l: -(5 + t15 * 5) }), this["surfacePeer" + t15] = this["surfacePeer" + t15] || st(this.mainBkg, { h: 30, l: -(7 + t15 * 5) });
    if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || vt(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || vt(this.labelTextColor);
      for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
        this["cScaleLabel" + t15] = this["cScaleLabel" + t15] || this.labelTextColor;
    }
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = At(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || At(this.primaryColor, 75) || "#ffffff", this.rowEven = this.rowEven || At(this.primaryColor, 1), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || st(this.tertiaryColor, { l: -40 }), this.pie4 = this.pie4 || st(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { l: -20 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -20 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -40 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: -40 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -40 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -90, l: -40 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -30 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.radar = {
      axisColor: ((_a2 = this.radar) == null ? void 0 : _a2.axisColor) || this.lineColor,
      axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_c = this.radar) == null ? void 0 : _c.axisLabelFontSize) || 12,
      curveOpacity: ((_d = this.radar) == null ? void 0 : _d.curveOpacity) || 0.5,
      curveStrokeWidth: ((_e = this.radar) == null ? void 0 : _e.curveStrokeWidth) || 2,
      graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_g2 = this.radar) == null ? void 0 : _g2.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_h2 = this.radar) == null ? void 0 : _h2.graticuleOpacity) || 0.3,
      legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
      legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
    }, this.xyChart = {
      backgroundColor: ((_k2 = this.xyChart) == null ? void 0 : _k2.backgroundColor) || this.background,
      titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_m2 = this.xyChart) == null ? void 0 : _m2.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_o2 = this.xyChart) == null ? void 0 : _o2.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_q2 = this.xyChart) == null ? void 0 : _q2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_r = this.xyChart) == null ? void 0 : _r.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_s = this.xyChart) == null ? void 0 : _s.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = At(this.git0, 25), this.git1 = At(this.git1, 25), this.git2 = At(this.git2, 25), this.git3 = At(this.git3, 25), this.git4 = At(this.git4, 25), this.git5 = At(this.git5, 25), this.git6 = At(this.git6, 25), this.git7 = At(this.git7, 25)) : (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || zt(vt(this.git0), 25), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || vt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || vt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || C0, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || S0;
  }
  calculate(t15) {
    if (Object.keys(this).forEach((r) => {
      this[r] === "calculated" && (this[r] = void 0);
    }), typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, S(vp, "Theme"), vp);
var NR = S((t15) => {
  const e = new FR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var _p;
var IR = (_p = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.tertiaryColor = At("#cde498", 10), this.primaryBorderColor = Ar(this.primaryColor, this.darkMode), this.secondaryBorderColor = Ar(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Ar(this.tertiaryColor, this.darkMode), this.primaryTextColor = vt(this.primaryColor), this.secondaryTextColor = vt(this.secondaryColor), this.tertiaryTextColor = vt(this.primaryColor), this.lineColor = vt(this.background), this.textColor = vt(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    var _a2, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r, _s, _t, _u2;
    this.actorBorder = zt(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || zt(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || zt(this.tertiaryColor, 40);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScale" + t15] = zt(this["cScale" + t15], 10), this["cScalePeer" + t15] = this["cScalePeer" + t15] || zt(this["cScale" + t15], 25);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleInv" + t15] = this["cScaleInv" + t15] || st(this["cScale" + t15], { h: 180 });
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleLabel" + t15] = this["cScaleLabel" + t15] || this.scaleLabelColor;
    for (let t15 = 0; t15 < 5; t15++)
      this["surface" + t15] = this["surface" + t15] || st(this.mainBkg, { h: 30, s: -30, l: -(5 + t15 * 5) }), this["surfacePeer" + t15] = this["surfacePeer" + t15] || st(this.mainBkg, { h: 30, s: -30, l: -(8 + t15 * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || At(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || At(this.mainBkg, 20), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || st(this.primaryColor, { l: -30 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { h: 40, l: -40 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -50 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -60, l: -50 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -50 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.mainBkg
    }, this.radar = {
      axisColor: ((_a2 = this.radar) == null ? void 0 : _a2.axisColor) || this.lineColor,
      axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_c = this.radar) == null ? void 0 : _c.axisLabelFontSize) || 12,
      curveOpacity: ((_d = this.radar) == null ? void 0 : _d.curveOpacity) || 0.5,
      curveStrokeWidth: ((_e = this.radar) == null ? void 0 : _e.curveStrokeWidth) || 2,
      graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_g2 = this.radar) == null ? void 0 : _g2.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_h2 = this.radar) == null ? void 0 : _h2.graticuleOpacity) || 0.3,
      legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
      legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
    }, this.xyChart = {
      backgroundColor: ((_k2 = this.xyChart) == null ? void 0 : _k2.backgroundColor) || this.background,
      titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_m2 = this.xyChart) == null ? void 0 : _m2.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_o2 = this.xyChart) == null ? void 0 : _o2.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_q2 = this.xyChart) == null ? void 0 : _q2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_r = this.xyChart) == null ? void 0 : _r.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_s = this.xyChart) == null ? void 0 : _s.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = At(this.git0, 25), this.git1 = At(this.git1, 25), this.git2 = At(this.git2, 25), this.git3 = At(this.git3, 25), this.git4 = At(this.git4, 25), this.git5 = At(this.git5, 25), this.git6 = At(this.git6, 25), this.git7 = At(this.git7, 25)) : (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || vt(this.git0), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || vt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || vt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || C0, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || S0;
  }
  calculate(t15) {
    if (typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, S(_p, "Theme"), _p);
var OR = S((t15) => {
  const e = new IR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var Cp;
var zR = (Cp = class {
  constructor() {
    this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = At(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = Ar(this.primaryColor, this.darkMode), this.secondaryBorderColor = Ar(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Ar(this.tertiaryColor, this.darkMode), this.primaryTextColor = vt(this.primaryColor), this.secondaryTextColor = vt(this.secondaryColor), this.tertiaryTextColor = vt(this.tertiaryColor), this.lineColor = vt(this.background), this.textColor = vt(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = this.actorBorder, this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || At(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || "#f4f4f4", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    var _a2, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r, _s, _t, _u2;
    this.secondBkg = At(this.contrast, 55), this.border2 = this.contrast, this.actorBorder = At(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.actorBorder, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleInv" + t15] = this["cScaleInv" + t15] || vt(this["cScale" + t15]);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this.darkMode ? this["cScalePeer" + t15] = this["cScalePeer" + t15] || At(this["cScale" + t15], 10) : this["cScalePeer" + t15] = this["cScalePeer" + t15] || zt(this["cScale" + t15], 10);
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleLabel" + t15] = this["cScaleLabel" + t15] || this.scaleLabelColor;
    for (let t15 = 0; t15 < 5; t15++)
      this["surface" + t15] = this["surface" + t15] || st(this.mainBkg, { l: -(5 + t15 * 5) }), this["surfacePeer" + t15] = this["surfacePeer" + t15] || st(this.mainBkg, { l: -(8 + t15 * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.sectionBkgColor = At(this.contrast, 30), this.sectionBkgColor2 = At(this.contrast, 30), this.taskBorderColor = zt(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = At(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = zt(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.vertLineColor = this.critBkgColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 });
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["pie" + t15] = this["cScale" + t15];
    this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || hc(this.quadrant1Fill) ? At(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((_a2 = this.xyChart) == null ? void 0 : _a2.backgroundColor) || this.background,
      titleColor: ((_b2 = this.xyChart) == null ? void 0 : _b2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_c = this.xyChart) == null ? void 0 : _c.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_d = this.xyChart) == null ? void 0 : _d.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_e = this.xyChart) == null ? void 0 : _e.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_f2 = this.xyChart) == null ? void 0 : _f2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_g2 = this.xyChart) == null ? void 0 : _g2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_h2 = this.xyChart) == null ? void 0 : _h2.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_i2 = this.xyChart) == null ? void 0 : _i2.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_j2 = this.xyChart) == null ? void 0 : _j2.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_k2 = this.xyChart) == null ? void 0 : _k2.plotColorPalette) || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
    }, this.radar = {
      axisColor: ((_l2 = this.radar) == null ? void 0 : _l2.axisColor) || this.lineColor,
      axisStrokeWidth: ((_m2 = this.radar) == null ? void 0 : _m2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_n2 = this.radar) == null ? void 0 : _n2.axisLabelFontSize) || 12,
      curveOpacity: ((_o2 = this.radar) == null ? void 0 : _o2.curveOpacity) || 0.5,
      curveStrokeWidth: ((_p2 = this.radar) == null ? void 0 : _p2.curveStrokeWidth) || 2,
      graticuleColor: ((_q2 = this.radar) == null ? void 0 : _q2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_r = this.radar) == null ? void 0 : _r.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_s = this.radar) == null ? void 0 : _s.graticuleOpacity) || 0.3,
      legendBoxSize: ((_t = this.radar) == null ? void 0 : _t.legendBoxSize) || 12,
      legendFontSize: ((_u2 = this.radar) == null ? void 0 : _u2.legendFontSize) || 12
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = zt(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || st(this.primaryColor, { h: -30 }), this.git4 = this.pie5 || st(this.primaryColor, { h: -60 }), this.git5 = this.pie6 || st(this.primaryColor, { h: -90 }), this.git6 = this.pie7 || st(this.primaryColor, { h: 60 }), this.git7 = this.pie8 || st(this.primaryColor, { h: 120 }), this.gitInv0 = this.gitInv0 || vt(this.git0), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || C0, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || S0;
  }
  calculate(t15) {
    if (typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, S(Cp, "Theme"), Cp);
var qR = S((t15) => {
  const e = new zR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var Li = {
  base: {
    getThemeVariables: BR
  },
  dark: {
    getThemeVariables: DR
  },
  default: {
    getThemeVariables: NR
  },
  forest: {
    getThemeVariables: OR
  },
  neutral: {
    getThemeVariables: qR
  }
};
var Rn = {
  flowchart: {
    useMaxWidth: true,
    titleTopMargin: 25,
    subGraphTitleMargin: {
      top: 0,
      bottom: 0
    },
    diagramPadding: 8,
    htmlLabels: true,
    nodeSpacing: 50,
    rankSpacing: 50,
    curve: "basis",
    padding: 15,
    defaultRenderer: "dagre-wrapper",
    wrappingWidth: 200,
    inheritDir: false
  },
  sequence: {
    useMaxWidth: true,
    hideUnusedParticipants: false,
    activationWidth: 10,
    diagramMarginX: 50,
    diagramMarginY: 10,
    actorMargin: 50,
    width: 150,
    height: 65,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    mirrorActors: true,
    forceMenus: false,
    bottomMarginAdj: 1,
    rightAngles: false,
    showSequenceNumbers: false,
    actorFontSize: 14,
    actorFontFamily: '"Open Sans", sans-serif',
    actorFontWeight: 400,
    noteFontSize: 14,
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    noteFontWeight: 400,
    noteAlign: "center",
    messageFontSize: 16,
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    messageFontWeight: 400,
    wrap: false,
    wrapPadding: 10,
    labelBoxWidth: 50,
    labelBoxHeight: 20
  },
  gantt: {
    useMaxWidth: true,
    titleTopMargin: 25,
    barHeight: 20,
    barGap: 4,
    topPadding: 50,
    rightPadding: 75,
    leftPadding: 75,
    gridLineStartPadding: 35,
    fontSize: 11,
    sectionFontSize: 11,
    numberSectionStyles: 4,
    axisFormat: "%Y-%m-%d",
    topAxis: false,
    displayMode: "",
    weekday: "sunday"
  },
  journey: {
    useMaxWidth: true,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    maxLabelWidth: 360,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: false,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    titleColor: "",
    titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    titleFontSize: "4ex"
  },
  class: {
    useMaxWidth: true,
    titleTopMargin: 25,
    arrowMarkerAbsolute: false,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    defaultRenderer: "dagre-wrapper",
    htmlLabels: false,
    hideEmptyMembersBox: false
  },
  state: {
    useMaxWidth: true,
    titleTopMargin: 25,
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    miniPadding: 2,
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    defaultRenderer: "dagre-wrapper"
  },
  er: {
    useMaxWidth: true,
    titleTopMargin: 25,
    diagramPadding: 20,
    layoutDirection: "TB",
    minEntityWidth: 100,
    minEntityHeight: 75,
    entityPadding: 15,
    nodeSpacing: 140,
    rankSpacing: 80,
    stroke: "gray",
    fill: "honeydew",
    fontSize: 12
  },
  pie: {
    useMaxWidth: true,
    textPosition: 0.75
  },
  quadrantChart: {
    useMaxWidth: true,
    chartWidth: 500,
    chartHeight: 500,
    titleFontSize: 20,
    titlePadding: 10,
    quadrantPadding: 5,
    xAxisLabelPadding: 5,
    yAxisLabelPadding: 5,
    xAxisLabelFontSize: 16,
    yAxisLabelFontSize: 16,
    quadrantLabelFontSize: 16,
    quadrantTextTopPadding: 5,
    pointTextPadding: 5,
    pointLabelFontSize: 12,
    pointRadius: 5,
    xAxisPosition: "top",
    yAxisPosition: "left",
    quadrantInternalBorderStrokeWidth: 1,
    quadrantExternalBorderStrokeWidth: 2
  },
  xyChart: {
    useMaxWidth: true,
    width: 700,
    height: 500,
    titleFontSize: 20,
    titlePadding: 10,
    showDataLabel: false,
    showTitle: true,
    xAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: true,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: true,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: true,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: true,
      axisLineWidth: 2
    },
    yAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: true,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: true,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: true,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: true,
      axisLineWidth: 2
    },
    chartOrientation: "vertical",
    plotReservedSpacePercent: 50
  },
  requirement: {
    useMaxWidth: true,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  mindmap: {
    useMaxWidth: true,
    padding: 10,
    maxNodeWidth: 200
  },
  kanban: {
    useMaxWidth: true,
    padding: 8,
    sectionWidth: 200,
    ticketBaseUrl: ""
  },
  timeline: {
    useMaxWidth: true,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: false,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    disableMulticolor: false
  },
  gitGraph: {
    useMaxWidth: true,
    titleTopMargin: 25,
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: true,
    showBranches: true,
    rotateCommitLabel: true,
    parallelCommits: false,
    arrowMarkerAbsolute: false
  },
  c4: {
    useMaxWidth: true,
    diagramMarginX: 50,
    diagramMarginY: 10,
    c4ShapeMargin: 50,
    c4ShapePadding: 20,
    width: 216,
    height: 60,
    boxMargin: 10,
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    c4BoundaryInRow: 2,
    personFontSize: 14,
    personFontFamily: '"Open Sans", sans-serif',
    personFontWeight: "normal",
    external_personFontSize: 14,
    external_personFontFamily: '"Open Sans", sans-serif',
    external_personFontWeight: "normal",
    systemFontSize: 14,
    systemFontFamily: '"Open Sans", sans-serif',
    systemFontWeight: "normal",
    external_systemFontSize: 14,
    external_systemFontFamily: '"Open Sans", sans-serif',
    external_systemFontWeight: "normal",
    system_dbFontSize: 14,
    system_dbFontFamily: '"Open Sans", sans-serif',
    system_dbFontWeight: "normal",
    external_system_dbFontSize: 14,
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    external_system_dbFontWeight: "normal",
    system_queueFontSize: 14,
    system_queueFontFamily: '"Open Sans", sans-serif',
    system_queueFontWeight: "normal",
    external_system_queueFontSize: 14,
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    external_system_queueFontWeight: "normal",
    boundaryFontSize: 14,
    boundaryFontFamily: '"Open Sans", sans-serif',
    boundaryFontWeight: "normal",
    messageFontSize: 12,
    messageFontFamily: '"Open Sans", sans-serif',
    messageFontWeight: "normal",
    containerFontSize: 14,
    containerFontFamily: '"Open Sans", sans-serif',
    containerFontWeight: "normal",
    external_containerFontSize: 14,
    external_containerFontFamily: '"Open Sans", sans-serif',
    external_containerFontWeight: "normal",
    container_dbFontSize: 14,
    container_dbFontFamily: '"Open Sans", sans-serif',
    container_dbFontWeight: "normal",
    external_container_dbFontSize: 14,
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    external_container_dbFontWeight: "normal",
    container_queueFontSize: 14,
    container_queueFontFamily: '"Open Sans", sans-serif',
    container_queueFontWeight: "normal",
    external_container_queueFontSize: 14,
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    external_container_queueFontWeight: "normal",
    componentFontSize: 14,
    componentFontFamily: '"Open Sans", sans-serif',
    componentFontWeight: "normal",
    external_componentFontSize: 14,
    external_componentFontFamily: '"Open Sans", sans-serif',
    external_componentFontWeight: "normal",
    component_dbFontSize: 14,
    component_dbFontFamily: '"Open Sans", sans-serif',
    component_dbFontWeight: "normal",
    external_component_dbFontSize: 14,
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    external_component_dbFontWeight: "normal",
    component_queueFontSize: 14,
    component_queueFontFamily: '"Open Sans", sans-serif',
    component_queueFontWeight: "normal",
    external_component_queueFontSize: 14,
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    external_component_queueFontWeight: "normal",
    wrap: true,
    wrapPadding: 10,
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  sankey: {
    useMaxWidth: true,
    width: 600,
    height: 400,
    linkColor: "gradient",
    nodeAlignment: "justify",
    showValues: true,
    prefix: "",
    suffix: ""
  },
  block: {
    useMaxWidth: true,
    padding: 8
  },
  packet: {
    useMaxWidth: true,
    rowHeight: 32,
    bitWidth: 32,
    bitsPerRow: 32,
    showBits: true,
    paddingX: 5,
    paddingY: 5
  },
  architecture: {
    useMaxWidth: true,
    padding: 40,
    iconSize: 80,
    fontSize: 16
  },
  radar: {
    useMaxWidth: true,
    width: 600,
    height: 600,
    marginTop: 50,
    marginRight: 50,
    marginBottom: 50,
    marginLeft: 50,
    axisScaleFactor: 1,
    axisLabelFactor: 1.05,
    curveTension: 0.17
  },
  theme: "default",
  look: "classic",
  handDrawnSeed: 0,
  layout: "dagre",
  maxTextSize: 5e4,
  maxEdges: 500,
  darkMode: false,
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  logLevel: 5,
  securityLevel: "strict",
  startOnLoad: true,
  arrowMarkerAbsolute: false,
  secure: [
    "secure",
    "securityLevel",
    "startOnLoad",
    "maxTextSize",
    "suppressErrorRendering",
    "maxEdges"
  ],
  legacyMathML: false,
  forceLegacyMathML: false,
  deterministicIds: false,
  fontSize: 16,
  markdownAutoWrap: true,
  suppressErrorRendering: false
};
var Q6 = {
  ...Rn,
  // Set, even though they're `undefined` so that `configKeys` finds these keys
  // TODO: Should we replace these with `null` so that they can go in the JSON Schema?
  deterministicIDSeed: void 0,
  elk: {
    // mergeEdges is needed here to be considered
    mergeEdges: false,
    nodePlacementStrategy: "BRANDES_KOEPF"
  },
  themeCSS: void 0,
  // add non-JSON default config values
  themeVariables: Li.default.getThemeVariables(),
  sequence: {
    ...Rn.sequence,
    messageFont: S(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont"),
    noteFont: S(function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    }, "noteFont"),
    actorFont: S(function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }, "actorFont")
  },
  class: {
    hideEmptyMembersBox: false
  },
  gantt: {
    ...Rn.gantt,
    tickInterval: void 0,
    useWidth: void 0
    // can probably be removed since `configKeys` already includes this
  },
  c4: {
    ...Rn.c4,
    useWidth: void 0,
    personFont: S(function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    }, "personFont"),
    flowchart: {
      ...Rn.flowchart,
      inheritDir: false
      // default to legacy behavior
    },
    external_personFont: S(function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    }, "external_personFont"),
    systemFont: S(function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    }, "systemFont"),
    external_systemFont: S(function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    }, "external_systemFont"),
    system_dbFont: S(function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    }, "system_dbFont"),
    external_system_dbFont: S(function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    }, "external_system_dbFont"),
    system_queueFont: S(function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    }, "system_queueFont"),
    external_system_queueFont: S(function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    }, "external_system_queueFont"),
    containerFont: S(function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    }, "containerFont"),
    external_containerFont: S(function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    }, "external_containerFont"),
    container_dbFont: S(function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    }, "container_dbFont"),
    external_container_dbFont: S(function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    }, "external_container_dbFont"),
    container_queueFont: S(function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    }, "container_queueFont"),
    external_container_queueFont: S(function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    }, "external_container_queueFont"),
    componentFont: S(function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    }, "componentFont"),
    external_componentFont: S(function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    }, "external_componentFont"),
    component_dbFont: S(function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    }, "component_dbFont"),
    external_component_dbFont: S(function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    }, "external_component_dbFont"),
    component_queueFont: S(function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    }, "component_queueFont"),
    external_component_queueFont: S(function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    }, "external_component_queueFont"),
    boundaryFont: S(function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    }, "boundaryFont"),
    messageFont: S(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont")
  },
  pie: {
    ...Rn.pie,
    useWidth: 984
  },
  xyChart: {
    ...Rn.xyChart,
    useWidth: void 0
  },
  requirement: {
    ...Rn.requirement,
    useWidth: void 0
  },
  packet: {
    ...Rn.packet
  },
  radar: {
    ...Rn.radar
  },
  treemap: {
    useMaxWidth: true,
    padding: 10,
    diagramPadding: 8,
    showValues: true,
    nodeWidth: 100,
    nodeHeight: 40,
    borderWidth: 1,
    valueFontSize: 12,
    labelFontSize: 14,
    valueFormat: ","
  }
};
var J6 = S((t15, e = "") => Object.keys(t15).reduce((r, n) => Array.isArray(t15[n]) ? r : typeof t15[n] == "object" && t15[n] !== null ? [...r, e + n, ...J6(t15[n], "")] : [...r, e + n], []), "keyify");
var RR = new Set(J6(Q6, ""));
var tw = Q6;
var mu = S((t15) => {
  if (ut.debug("sanitizeDirective called with", t15), !(typeof t15 != "object" || t15 == null)) {
    if (Array.isArray(t15)) {
      t15.forEach((e) => mu(e));
      return;
    }
    for (const e of Object.keys(t15)) {
      if (ut.debug("Checking key", e), e.startsWith("__") || e.includes("proto") || e.includes("constr") || !RR.has(e) || t15[e] == null) {
        ut.debug("sanitize deleting key: ", e), delete t15[e];
        continue;
      }
      if (typeof t15[e] == "object") {
        ut.debug("sanitizing object", e), mu(t15[e]);
        continue;
      }
      const r = ["themeCSS", "fontFamily", "altFontFamily"];
      for (const n of r)
        e.includes(n) && (ut.debug("sanitizing css option", e), t15[e] = PR(t15[e]));
    }
    if (t15.themeVariables)
      for (const e of Object.keys(t15.themeVariables)) {
        const r = t15.themeVariables[e];
        (r == null ? void 0 : r.match) && !r.match(/^[\d "#%(),.;A-Za-z]+$/) && (t15.themeVariables[e] = "");
      }
    ut.debug("After sanitization", t15);
  }
}, "sanitizeDirective");
var PR = S((t15) => {
  let e = 0, r = 0;
  for (const n of t15) {
    if (e < r)
      return "{ /* ERROR: Unbalanced CSS */ }";
    n === "{" ? e++ : n === "}" && r++;
  }
  return e !== r ? "{ /* ERROR: Unbalanced CSS */ }" : t15;
}, "sanitizeCss");
var Qo = Object.freeze(tw);
var Pr = pr({}, Qo);
var ew;
var Jo = [];
var kl = pr({}, Qo);
var T0 = S((t15, e) => {
  let r = pr({}, t15), n = {};
  for (const i of e)
    iw(i), n = pr(n, i);
  if (r = pr(r, n), n.theme && n.theme in Li) {
    const i = pr({}, ew), s = pr(
      i.themeVariables || {},
      n.themeVariables
    );
    r.theme && r.theme in Li && (r.themeVariables = Li[r.theme].getThemeVariables(s));
  }
  return kl = r, sw(kl), kl;
}, "updateCurrentConfig");
var jR = S((t15) => (Pr = pr({}, Qo), Pr = pr(Pr, t15), t15.theme && Li[t15.theme] && (Pr.themeVariables = Li[t15.theme].getThemeVariables(t15.themeVariables)), T0(Pr, Jo), Pr), "setSiteConfig");
var WR = S((t15) => {
  ew = pr({}, t15);
}, "saveConfigFromInitialize");
var HR = S((t15) => (Pr = pr(Pr, t15), T0(Pr, Jo), Pr), "updateSiteConfig");
var rw = S(() => pr({}, Pr), "getSiteConfig");
var nw = S((t15) => (sw(t15), pr(kl, t15), Vr()), "setConfig");
var Vr = S(() => pr({}, kl), "getConfig");
var iw = S((t15) => {
  t15 && (["secure", ...Pr.secure ?? []].forEach((e) => {
    Object.hasOwn(t15, e) && (ut.debug(`Denied attempt to modify a secure key ${e}`, t15[e]), delete t15[e]);
  }), Object.keys(t15).forEach((e) => {
    e.startsWith("__") && delete t15[e];
  }), Object.keys(t15).forEach((e) => {
    typeof t15[e] == "string" && (t15[e].includes("<") || t15[e].includes(">") || t15[e].includes("url(data:")) && delete t15[e], typeof t15[e] == "object" && iw(t15[e]);
  }));
}, "sanitize");
var UR = S((t15) => {
  var _a2;
  mu(t15), t15.fontFamily && !((_a2 = t15.themeVariables) == null ? void 0 : _a2.fontFamily) && (t15.themeVariables = {
    ...t15.themeVariables,
    fontFamily: t15.fontFamily
  }), Jo.push(t15), T0(Pr, Jo);
}, "addDirective");
var gu = S((t15 = Pr) => {
  Jo = [], T0(t15, Jo);
}, "reset");
var VR = {
  LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
};
var Hb = {};
var GR = S((t15) => {
  Hb[t15] || (ut.warn(VR[t15]), Hb[t15] = true);
}, "issueWarning");
var sw = S((t15) => {
  t15 && (t15.lazyLoadedDiagrams || t15.loadExternalDiagramsAtStartup) && GR("LAZY_LOAD_DEPRECATED");
}, "checkConfig");
var uc = /<br\s*\/?>/gi;
var XR = S((t15) => t15 ? lw(t15).replace(/\\n/g, "#br#").split("#br#") : [""], "getRows");
var YR = /* @__PURE__ */ (() => {
  let t15 = false;
  return () => {
    t15 || (ow(), t15 = true);
  };
})();
function ow() {
  const t15 = "data-temp-href-target";
  Zo.addHook("beforeSanitizeAttributes", (e) => {
    e instanceof Element && e.tagName === "A" && e.hasAttribute("target") && e.setAttribute(t15, e.getAttribute("target") ?? "");
  }), Zo.addHook("afterSanitizeAttributes", (e) => {
    e instanceof Element && e.tagName === "A" && e.hasAttribute(t15) && (e.setAttribute("target", e.getAttribute(t15) ?? ""), e.removeAttribute(t15), e.getAttribute("target") === "_blank" && e.setAttribute("rel", "noopener"));
  });
}
S(ow, "setupDompurifyHooks");
var aw = S((t15) => (YR(), Zo.sanitize(t15)), "removeScript");
var Ub = S((t15, e) => {
  var _a2;
  if (((_a2 = e.flowchart) == null ? void 0 : _a2.htmlLabels) !== false) {
    const r = e.securityLevel;
    r === "antiscript" || r === "strict" ? t15 = aw(t15) : r !== "loose" && (t15 = lw(t15), t15 = t15.replace(/</g, "&lt;").replace(/>/g, "&gt;"), t15 = t15.replace(/=/g, "&equals;"), t15 = JR(t15));
  }
  return t15;
}, "sanitizeMore");
var to = S((t15, e) => t15 && (e.dompurifyConfig ? t15 = Zo.sanitize(Ub(t15, e), e.dompurifyConfig).toString() : t15 = Zo.sanitize(Ub(t15, e), {
  FORBID_TAGS: ["style"]
}).toString(), t15), "sanitizeText");
var KR = S((t15, e) => typeof t15 == "string" ? to(t15, e) : t15.flat().map((r) => to(r, e)), "sanitizeTextOrArray");
var ZR = S((t15) => uc.test(t15), "hasBreaks");
var QR = S((t15) => t15.split(uc), "splitBreaks");
var JR = S((t15) => t15.replace(/#br#/g, "<br/>"), "placeholderToBreak");
var lw = S((t15) => t15.replace(uc, "#br#"), "breakToPlaceholder");
var cw = S((t15) => {
  let e = "";
  return t15 && (e = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, e = CSS.escape(e)), e;
}, "getUrl");
var Qe = S((t15) => !(t15 === false || ["false", "null", "0"].includes(String(t15).trim().toLowerCase())), "evaluate");
var tP = S(function(...t15) {
  const e = t15.filter((r) => !isNaN(r));
  return Math.max(...e);
}, "getMax");
var eP = S(function(...t15) {
  const e = t15.filter((r) => !isNaN(r));
  return Math.min(...e);
}, "getMin");
var Vb = S(function(t15) {
  const e = t15.split(/(,)/), r = [];
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (i === "," && n > 0 && n + 1 < e.length) {
      const s = e[n - 1], o = e[n + 1];
      rP(s, o) && (i = s + "," + o, n++, r.pop());
    }
    r.push(nP(i));
  }
  return r.join("");
}, "parseGenericTypes");
var Of = S((t15, e) => Math.max(0, t15.split(e).length - 1), "countOccurrence");
var rP = S((t15, e) => {
  const r = Of(t15, "~"), n = Of(e, "~");
  return r === 1 && n === 1;
}, "shouldCombineSets");
var nP = S((t15) => {
  const e = Of(t15, "~");
  let r = false;
  if (e <= 1)
    return t15;
  e % 2 !== 0 && t15.startsWith("~") && (t15 = t15.substring(1), r = true);
  const n = [...t15];
  let i = n.indexOf("~"), s = n.lastIndexOf("~");
  for (; i !== -1 && s !== -1 && i !== s; )
    n[i] = "<", n[s] = ">", i = n.indexOf("~"), s = n.lastIndexOf("~");
  return r && n.unshift("~"), n.join("");
}, "processSet");
var Gb = S(() => window.MathMLElement !== void 0, "isMathMLSupported");
var zf = /\$\$(.*)\$\$/g;
var ta = S((t15) => {
  var _a2;
  return (((_a2 = t15.match(zf)) == null ? void 0 : _a2.length) ?? 0) > 0;
}, "hasKatex");
var rnt = S(async (t15, e) => {
  var _a2;
  t15 = await Dm(t15, e);
  const r = document.createElement("div");
  r.innerHTML = t15, r.id = "katex-temp", r.style.visibility = "hidden", r.style.position = "absolute", r.style.top = "0", (_a2 = document.querySelector("body")) == null ? void 0 : _a2.insertAdjacentElement("beforeend", r);
  const n = { width: r.clientWidth, height: r.clientHeight };
  return r.remove(), n;
}, "calculateMathMLDimensions");
var Dm = S(async (t15, e) => {
  if (!ta(t15))
    return t15;
  if (!(Gb() || e.legacyMathML || e.forceLegacyMathML))
    return t15.replace(zf, "MathML is unsupported in this environment.");
  {
    const { default: r } = await import("./katex-CUSbq6rG-DCyV1FlS-B2O2FF3R.js"), n = e.forceLegacyMathML || !Gb() && e.legacyMathML ? "htmlAndMathml" : "mathml";
    return t15.split(uc).map(
      (i) => ta(i) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${i}</div>` : `<div>${i}</div>`
    ).join("").replace(
      zf,
      (i, s) => r.renderToString(s, {
        throwOnError: true,
        displayMode: true,
        output: n
      }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, "")
    );
  }
}, "renderKatex");
var ga = {
  getRows: XR,
  sanitizeText: to,
  sanitizeTextOrArray: KR,
  hasBreaks: ZR,
  splitBreaks: QR,
  lineBreakRegex: uc,
  removeScript: aw,
  getUrl: cw,
  evaluate: Qe,
  getMax: tP,
  getMin: eP
};
var iP = S(function(t15, e) {
  for (let r of e)
    t15.attr(r[0], r[1]);
}, "d3Attrs");
var sP = S(function(t15, e, r) {
  let n = /* @__PURE__ */ new Map();
  return r ? (n.set("width", "100%"), n.set("style", `max-width: ${e}px;`)) : (n.set("height", t15), n.set("width", e)), n;
}, "calculateSvgSizeAttrs");
var hw = S(function(t15, e, r, n) {
  const i = sP(e, r, n);
  iP(t15, i);
}, "configureSvgSize");
var oP = S(function(t15, e, r, n) {
  const i = e.node().getBBox(), s = i.width, o = i.height;
  ut.info(`SVG bounds: ${s}x${o}`, i);
  let a = 0, l = 0;
  ut.info(`Graph bounds: ${a}x${l}`, t15), a = s + r * 2, l = o + r * 2, ut.info(`Calculated bounds: ${a}x${l}`), hw(e, l, a, n);
  const c = `${i.x - r} ${i.y - r} ${i.width + 2 * r} ${i.height + 2 * r}`;
  e.attr("viewBox", c);
}, "setupGraphViewbox");
var Lh = {};
var aP = S((t15, e, r) => {
  let n = "";
  return t15 in Lh && Lh[t15] ? n = Lh[t15](r) : ut.warn(`No theme found for ${t15}`), ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }
   & p {
    margin: 0
   }

  ${n}

  ${e}
`;
}, "getStyles");
var lP = S((t15, e) => {
  e !== void 0 && (Lh[t15] = e);
}, "addStylesForDiagram");
var cP = aP;
var uw = {};
AR(uw, {
  clear: () => hP,
  getAccDescription: () => fP,
  getAccTitle: () => dP,
  getDiagramTitle: () => gP,
  setAccDescription: () => pP,
  setAccTitle: () => uP,
  setDiagramTitle: () => mP
});
var Fm = "";
var Nm = "";
var Im = "";
var Om = S((t15) => to(t15, Vr()), "sanitizeText");
var hP = S(() => {
  Fm = "", Im = "", Nm = "";
}, "clear");
var uP = S((t15) => {
  Fm = Om(t15).replace(/^\s+/g, "");
}, "setAccTitle");
var dP = S(() => Fm, "getAccTitle");
var pP = S((t15) => {
  Im = Om(t15).replace(/\n\s+/g, `
`);
}, "setAccDescription");
var fP = S(() => Im, "getAccDescription");
var mP = S((t15) => {
  Nm = Om(t15);
}, "setDiagramTitle");
var gP = S(() => Nm, "getDiagramTitle");
var Xb = ut;
var yP = Bm;
var me = Vr;
var nnt = nw;
var int = Qo;
var A0 = S((t15) => to(t15, me()), "sanitizeText");
var bP = oP;
var xP = S(() => uw, "getCommonDb");
var yu = {};
var bu = S((t15, e, r) => {
  var _a2;
  yu[t15] && Xb.warn(`Diagram with id ${t15} already registered. Overwriting.`), yu[t15] = e, r && Z6(t15, r), lP(t15, e.styles), (_a2 = e.injectUtils) == null ? void 0 : _a2.call(
    e,
    Xb,
    yP,
    me,
    A0,
    bP,
    xP(),
    () => {
    }
  );
}, "registerDiagram");
var qf = S((t15) => {
  if (t15 in yu)
    return yu[t15];
  throw new wP(t15);
}, "getDiagram");
var Sp;
var wP = (Sp = class extends Error {
  constructor(t15) {
    super(`Diagram ${t15} not found.`);
  }
}, S(Sp, "DiagramNotFoundError"), Sp);
function zm(t15) {
  return typeof t15 > "u" || t15 === null;
}
S(zm, "isNothing");
function dw(t15) {
  return typeof t15 == "object" && t15 !== null;
}
S(dw, "isObject");
function pw(t15) {
  return Array.isArray(t15) ? t15 : zm(t15) ? [] : [t15];
}
S(pw, "toArray");
function fw(t15, e) {
  var r, n, i, s;
  if (e)
    for (s = Object.keys(e), r = 0, n = s.length; r < n; r += 1)
      i = s[r], t15[i] = e[i];
  return t15;
}
S(fw, "extend");
function mw(t15, e) {
  var r = "", n;
  for (n = 0; n < e; n += 1)
    r += t15;
  return r;
}
S(mw, "repeat");
function gw(t15) {
  return t15 === 0 && Number.NEGATIVE_INFINITY === 1 / t15;
}
S(gw, "isNegativeZero");
var kP = zm;
var vP = dw;
var _P = pw;
var CP = mw;
var SP = gw;
var TP = fw;
var Ke = {
  isNothing: kP,
  isObject: vP,
  toArray: _P,
  repeat: CP,
  isNegativeZero: SP,
  extend: TP
};
function qm(t15, e) {
  var r = "", n = t15.reason || "(unknown reason)";
  return t15.mark ? (t15.mark.name && (r += 'in "' + t15.mark.name + '" '), r += "(" + (t15.mark.line + 1) + ":" + (t15.mark.column + 1) + ")", !e && t15.mark.snippet && (r += `

` + t15.mark.snippet), n + " " + r) : n;
}
S(qm, "formatError");
function ea(t15, e) {
  Error.call(this), this.name = "YAMLException", this.reason = t15, this.mark = e, this.message = qm(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
S(ea, "YAMLException$1");
ea.prototype = Object.create(Error.prototype);
ea.prototype.constructor = ea;
ea.prototype.toString = S(function(t15) {
  return this.name + ": " + qm(this, t15);
}, "toString");
var Wr = ea;
function Dh(t15, e, r, n, i) {
  var s = "", o = "", a = Math.floor(i / 2) - 1;
  return n - e > a && (s = " ... ", e = n - a + s.length), r - n > a && (o = " ...", r = n + a - o.length), {
    str: s + t15.slice(e, r).replace(/\t/g, "→") + o,
    pos: n - e + s.length
    // relative position
  };
}
S(Dh, "getLine");
function Fh(t15, e) {
  return Ke.repeat(" ", e - t15.length) + t15;
}
S(Fh, "padStart");
function yw(t15, e) {
  if (e = Object.create(e || null), !t15.buffer) return null;
  e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, n = [0], i = [], s, o = -1; s = r.exec(t15.buffer); )
    i.push(s.index), n.push(s.index + s[0].length), t15.position <= s.index && o < 0 && (o = n.length - 2);
  o < 0 && (o = n.length - 1);
  var a = "", l, c, h10 = Math.min(t15.line + e.linesAfter, i.length).toString().length, p = e.maxLength - (e.indent + h10 + 3);
  for (l = 1; l <= e.linesBefore && !(o - l < 0); l++)
    c = Dh(
      t15.buffer,
      n[o - l],
      i[o - l],
      t15.position - (n[o] - n[o - l]),
      p
    ), a = Ke.repeat(" ", e.indent) + Fh((t15.line - l + 1).toString(), h10) + " | " + c.str + `
` + a;
  for (c = Dh(t15.buffer, n[o], i[o], t15.position, p), a += Ke.repeat(" ", e.indent) + Fh((t15.line + 1).toString(), h10) + " | " + c.str + `
`, a += Ke.repeat("-", e.indent + h10 + 3 + c.pos) + `^
`, l = 1; l <= e.linesAfter && !(o + l >= i.length); l++)
    c = Dh(
      t15.buffer,
      n[o + l],
      i[o + l],
      t15.position - (n[o] - n[o + l]),
      p
    ), a += Ke.repeat(" ", e.indent) + Fh((t15.line + l + 1).toString(), h10) + " | " + c.str + `
`;
  return a.replace(/\n$/, "");
}
S(yw, "makeSnippet");
var AP = yw;
var $P = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var EP = [
  "scalar",
  "sequence",
  "mapping"
];
function bw(t15) {
  var e = {};
  return t15 !== null && Object.keys(t15).forEach(function(r) {
    t15[r].forEach(function(n) {
      e[String(n)] = r;
    });
  }), e;
}
S(bw, "compileStyleAliases");
function xw(t15, e) {
  if (e = e || {}, Object.keys(e).forEach(function(r) {
    if ($P.indexOf(r) === -1)
      throw new Wr('Unknown option "' + r + '" is met in definition of "' + t15 + '" YAML type.');
  }), this.options = e, this.tag = t15, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return true;
  }, this.construct = e.construct || function(r) {
    return r;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || false, this.styleAliases = bw(e.styleAliases || null), EP.indexOf(this.kind) === -1)
    throw new Wr('Unknown kind "' + this.kind + '" is specified for "' + t15 + '" YAML type.');
}
S(xw, "Type$1");
var br = xw;
function Rf(t15, e) {
  var r = [];
  return t15[e].forEach(function(n) {
    var i = r.length;
    r.forEach(function(s, o) {
      s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = o);
    }), r[i] = n;
  }), r;
}
S(Rf, "compileList");
function ww() {
  var t15 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e, r;
  function n(i) {
    i.multi ? (t15.multi[i.kind].push(i), t15.multi.fallback.push(i)) : t15[i.kind][i.tag] = t15.fallback[i.tag] = i;
  }
  for (S(n, "collectType"), e = 0, r = arguments.length; e < r; e += 1)
    arguments[e].forEach(n);
  return t15;
}
S(ww, "compileMap");
function xu(t15) {
  return this.extend(t15);
}
S(xu, "Schema$1");
xu.prototype.extend = S(function(t15) {
  var e = [], r = [];
  if (t15 instanceof br)
    r.push(t15);
  else if (Array.isArray(t15))
    r = r.concat(t15);
  else if (t15 && (Array.isArray(t15.implicit) || Array.isArray(t15.explicit)))
    t15.implicit && (e = e.concat(t15.implicit)), t15.explicit && (r = r.concat(t15.explicit));
  else
    throw new Wr("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  e.forEach(function(i) {
    if (!(i instanceof br))
      throw new Wr("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (i.loadKind && i.loadKind !== "scalar")
      throw new Wr("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (i.multi)
      throw new Wr("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(i) {
    if (!(i instanceof br))
      throw new Wr("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var n = Object.create(xu.prototype);
  return n.implicit = (this.implicit || []).concat(e), n.explicit = (this.explicit || []).concat(r), n.compiledImplicit = Rf(n, "implicit"), n.compiledExplicit = Rf(n, "explicit"), n.compiledTypeMap = ww(n.compiledImplicit, n.compiledExplicit), n;
}, "extend");
var MP = xu;
var BP = new br("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: S(function(t15) {
    return t15 !== null ? t15 : "";
  }, "construct")
});
var LP = new br("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: S(function(t15) {
    return t15 !== null ? t15 : [];
  }, "construct")
});
var DP = new br("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: S(function(t15) {
    return t15 !== null ? t15 : {};
  }, "construct")
});
var FP = new MP({
  explicit: [
    BP,
    LP,
    DP
  ]
});
function kw(t15) {
  if (t15 === null) return true;
  var e = t15.length;
  return e === 1 && t15 === "~" || e === 4 && (t15 === "null" || t15 === "Null" || t15 === "NULL");
}
S(kw, "resolveYamlNull");
function vw() {
  return null;
}
S(vw, "constructYamlNull");
function _w(t15) {
  return t15 === null;
}
S(_w, "isNull");
var NP = new br("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: kw,
  construct: vw,
  predicate: _w,
  represent: {
    canonical: S(function() {
      return "~";
    }, "canonical"),
    lowercase: S(function() {
      return "null";
    }, "lowercase"),
    uppercase: S(function() {
      return "NULL";
    }, "uppercase"),
    camelcase: S(function() {
      return "Null";
    }, "camelcase"),
    empty: S(function() {
      return "";
    }, "empty")
  },
  defaultStyle: "lowercase"
});
function Cw(t15) {
  if (t15 === null) return false;
  var e = t15.length;
  return e === 4 && (t15 === "true" || t15 === "True" || t15 === "TRUE") || e === 5 && (t15 === "false" || t15 === "False" || t15 === "FALSE");
}
S(Cw, "resolveYamlBoolean");
function Sw(t15) {
  return t15 === "true" || t15 === "True" || t15 === "TRUE";
}
S(Sw, "constructYamlBoolean");
function Tw(t15) {
  return Object.prototype.toString.call(t15) === "[object Boolean]";
}
S(Tw, "isBoolean");
var IP = new br("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: Cw,
  construct: Sw,
  predicate: Tw,
  represent: {
    lowercase: S(function(t15) {
      return t15 ? "true" : "false";
    }, "lowercase"),
    uppercase: S(function(t15) {
      return t15 ? "TRUE" : "FALSE";
    }, "uppercase"),
    camelcase: S(function(t15) {
      return t15 ? "True" : "False";
    }, "camelcase")
  },
  defaultStyle: "lowercase"
});
function Aw(t15) {
  return 48 <= t15 && t15 <= 57 || 65 <= t15 && t15 <= 70 || 97 <= t15 && t15 <= 102;
}
S(Aw, "isHexCode");
function $w(t15) {
  return 48 <= t15 && t15 <= 55;
}
S($w, "isOctCode");
function Ew(t15) {
  return 48 <= t15 && t15 <= 57;
}
S(Ew, "isDecCode");
function Mw(t15) {
  if (t15 === null) return false;
  var e = t15.length, r = 0, n = false, i;
  if (!e) return false;
  if (i = t15[r], (i === "-" || i === "+") && (i = t15[++r]), i === "0") {
    if (r + 1 === e) return true;
    if (i = t15[++r], i === "b") {
      for (r++; r < e; r++)
        if (i = t15[r], i !== "_") {
          if (i !== "0" && i !== "1") return false;
          n = true;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < e; r++)
        if (i = t15[r], i !== "_") {
          if (!Aw(t15.charCodeAt(r))) return false;
          n = true;
        }
      return n && i !== "_";
    }
    if (i === "o") {
      for (r++; r < e; r++)
        if (i = t15[r], i !== "_") {
          if (!$w(t15.charCodeAt(r))) return false;
          n = true;
        }
      return n && i !== "_";
    }
  }
  if (i === "_") return false;
  for (; r < e; r++)
    if (i = t15[r], i !== "_") {
      if (!Ew(t15.charCodeAt(r)))
        return false;
      n = true;
    }
  return !(!n || i === "_");
}
S(Mw, "resolveYamlInteger");
function Bw(t15) {
  var e = t15, r = 1, n;
  if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (r = -1), e = e.slice(1), n = e[0]), e === "0") return 0;
  if (n === "0") {
    if (e[1] === "b") return r * parseInt(e.slice(2), 2);
    if (e[1] === "x") return r * parseInt(e.slice(2), 16);
    if (e[1] === "o") return r * parseInt(e.slice(2), 8);
  }
  return r * parseInt(e, 10);
}
S(Bw, "constructYamlInteger");
function Lw(t15) {
  return Object.prototype.toString.call(t15) === "[object Number]" && t15 % 1 === 0 && !Ke.isNegativeZero(t15);
}
S(Lw, "isInteger");
var OP = new br("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: Mw,
  construct: Bw,
  predicate: Lw,
  represent: {
    binary: S(function(t15) {
      return t15 >= 0 ? "0b" + t15.toString(2) : "-0b" + t15.toString(2).slice(1);
    }, "binary"),
    octal: S(function(t15) {
      return t15 >= 0 ? "0o" + t15.toString(8) : "-0o" + t15.toString(8).slice(1);
    }, "octal"),
    decimal: S(function(t15) {
      return t15.toString(10);
    }, "decimal"),
    /* eslint-disable max-len */
    hexadecimal: S(function(t15) {
      return t15 >= 0 ? "0x" + t15.toString(16).toUpperCase() : "-0x" + t15.toString(16).toUpperCase().slice(1);
    }, "hexadecimal")
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var zP = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function Dw(t15) {
  return !(t15 === null || !zP.test(t15) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t15[t15.length - 1] === "_");
}
S(Dw, "resolveYamlFloat");
function Fw(t15) {
  var e, r;
  return e = t15.replace(/_/g, "").toLowerCase(), r = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : r * parseFloat(e, 10);
}
S(Fw, "constructYamlFloat");
var qP = /^[-+]?[0-9]+e/;
function Nw(t15, e) {
  var r;
  if (isNaN(t15))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t15)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t15)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Ke.isNegativeZero(t15))
    return "-0.0";
  return r = t15.toString(10), qP.test(r) ? r.replace("e", ".e") : r;
}
S(Nw, "representYamlFloat");
function Iw(t15) {
  return Object.prototype.toString.call(t15) === "[object Number]" && (t15 % 1 !== 0 || Ke.isNegativeZero(t15));
}
S(Iw, "isFloat");
var RP = new br("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: Dw,
  construct: Fw,
  predicate: Iw,
  represent: Nw,
  defaultStyle: "lowercase"
});
var Ow = FP.extend({
  implicit: [
    NP,
    IP,
    OP,
    RP
  ]
});
var PP = Ow;
var zw = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var qw = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function Rw(t15) {
  return t15 === null ? false : zw.exec(t15) !== null || qw.exec(t15) !== null;
}
S(Rw, "resolveYamlTimestamp");
function Pw(t15) {
  var e, r, n, i, s, o, a, l = 0, c = null, h10, p, m;
  if (e = zw.exec(t15), e === null && (e = qw.exec(t15)), e === null) throw new Error("Date resolve error");
  if (r = +e[1], n = +e[2] - 1, i = +e[3], !e[4])
    return new Date(Date.UTC(r, n, i));
  if (s = +e[4], o = +e[5], a = +e[6], e[7]) {
    for (l = e[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return e[9] && (h10 = +e[10], p = +(e[11] || 0), c = (h10 * 60 + p) * 6e4, e[9] === "-" && (c = -c)), m = new Date(Date.UTC(r, n, i, s, o, a, l)), c && m.setTime(m.getTime() - c), m;
}
S(Pw, "constructYamlTimestamp");
function jw(t15) {
  return t15.toISOString();
}
S(jw, "representYamlTimestamp");
var jP = new br("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: Rw,
  construct: Pw,
  instanceOf: Date,
  represent: jw
});
function Ww(t15) {
  return t15 === "<<" || t15 === null;
}
S(Ww, "resolveYamlMerge");
var WP = new br("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: Ww
});
var Rm = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function Hw(t15) {
  if (t15 === null) return false;
  var e, r, n = 0, i = t15.length, s = Rm;
  for (r = 0; r < i; r++)
    if (e = s.indexOf(t15.charAt(r)), !(e > 64)) {
      if (e < 0) return false;
      n += 6;
    }
  return n % 8 === 0;
}
S(Hw, "resolveYamlBinary");
function Uw(t15) {
  var e, r, n = t15.replace(/[\r\n=]/g, ""), i = n.length, s = Rm, o = 0, a = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)), o = o << 6 | s.indexOf(n.charAt(e));
  return r = i % 4 * 6, r === 0 ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)) : r === 18 ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : r === 12 && a.push(o >> 4 & 255), new Uint8Array(a);
}
S(Uw, "constructYamlBinary");
function Vw(t15) {
  var e = "", r = 0, n, i, s = t15.length, o = Rm;
  for (n = 0; n < s; n++)
    n % 3 === 0 && n && (e += o[r >> 18 & 63], e += o[r >> 12 & 63], e += o[r >> 6 & 63], e += o[r & 63]), r = (r << 8) + t15[n];
  return i = s % 3, i === 0 ? (e += o[r >> 18 & 63], e += o[r >> 12 & 63], e += o[r >> 6 & 63], e += o[r & 63]) : i === 2 ? (e += o[r >> 10 & 63], e += o[r >> 4 & 63], e += o[r << 2 & 63], e += o[64]) : i === 1 && (e += o[r >> 2 & 63], e += o[r << 4 & 63], e += o[64], e += o[64]), e;
}
S(Vw, "representYamlBinary");
function Gw(t15) {
  return Object.prototype.toString.call(t15) === "[object Uint8Array]";
}
S(Gw, "isBinary");
var HP = new br("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: Hw,
  construct: Uw,
  predicate: Gw,
  represent: Vw
});
var UP = Object.prototype.hasOwnProperty;
var VP = Object.prototype.toString;
function Xw(t15) {
  if (t15 === null) return true;
  var e = [], r, n, i, s, o, a = t15;
  for (r = 0, n = a.length; r < n; r += 1) {
    if (i = a[r], o = false, VP.call(i) !== "[object Object]") return false;
    for (s in i)
      if (UP.call(i, s))
        if (!o) o = true;
        else return false;
    if (!o) return false;
    if (e.indexOf(s) === -1) e.push(s);
    else return false;
  }
  return true;
}
S(Xw, "resolveYamlOmap");
function Yw(t15) {
  return t15 !== null ? t15 : [];
}
S(Yw, "constructYamlOmap");
var GP = new br("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: Xw,
  construct: Yw
});
var XP = Object.prototype.toString;
function Kw(t15) {
  if (t15 === null) return true;
  var e, r, n, i, s, o = t15;
  for (s = new Array(o.length), e = 0, r = o.length; e < r; e += 1) {
    if (n = o[e], XP.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1)) return false;
    s[e] = [i[0], n[i[0]]];
  }
  return true;
}
S(Kw, "resolveYamlPairs");
function Zw(t15) {
  if (t15 === null) return [];
  var e, r, n, i, s, o = t15;
  for (s = new Array(o.length), e = 0, r = o.length; e < r; e += 1)
    n = o[e], i = Object.keys(n), s[e] = [i[0], n[i[0]]];
  return s;
}
S(Zw, "constructYamlPairs");
var YP = new br("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: Kw,
  construct: Zw
});
var KP = Object.prototype.hasOwnProperty;
function Qw(t15) {
  if (t15 === null) return true;
  var e, r = t15;
  for (e in r)
    if (KP.call(r, e) && r[e] !== null)
      return false;
  return true;
}
S(Qw, "resolveYamlSet");
function Jw(t15) {
  return t15 !== null ? t15 : {};
}
S(Jw, "constructYamlSet");
var ZP = new br("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: Qw,
  construct: Jw
});
var t7 = PP.extend({
  implicit: [
    jP,
    WP
  ],
  explicit: [
    HP,
    GP,
    YP,
    ZP
  ]
});
var us = Object.prototype.hasOwnProperty;
var wu = 1;
var e7 = 2;
var r7 = 3;
var ku = 4;
var Tp = 1;
var QP = 2;
var Yb = 3;
var JP = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var tj = /[\x85\u2028\u2029]/;
var ej = /[,\[\]\{\}]/;
var n7 = /^(?:!|!!|![a-z\-]+!)$/i;
var i7 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function Pf(t15) {
  return Object.prototype.toString.call(t15);
}
S(Pf, "_class");
function An(t15) {
  return t15 === 10 || t15 === 13;
}
S(An, "is_EOL");
function cs(t15) {
  return t15 === 9 || t15 === 32;
}
S(cs, "is_WHITE_SPACE");
function $r(t15) {
  return t15 === 9 || t15 === 32 || t15 === 10 || t15 === 13;
}
S($r, "is_WS_OR_EOL");
function js(t15) {
  return t15 === 44 || t15 === 91 || t15 === 93 || t15 === 123 || t15 === 125;
}
S(js, "is_FLOW_INDICATOR");
function s7(t15) {
  var e;
  return 48 <= t15 && t15 <= 57 ? t15 - 48 : (e = t15 | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
S(s7, "fromHexCode");
function o7(t15) {
  return t15 === 120 ? 2 : t15 === 117 ? 4 : t15 === 85 ? 8 : 0;
}
S(o7, "escapedHexLen");
function a7(t15) {
  return 48 <= t15 && t15 <= 57 ? t15 - 48 : -1;
}
S(a7, "fromDecimalCode");
function jf(t15) {
  return t15 === 48 ? "\0" : t15 === 97 ? "\x07" : t15 === 98 ? "\b" : t15 === 116 || t15 === 9 ? "	" : t15 === 110 ? `
` : t15 === 118 ? "\v" : t15 === 102 ? "\f" : t15 === 114 ? "\r" : t15 === 101 ? "\x1B" : t15 === 32 ? " " : t15 === 34 ? '"' : t15 === 47 ? "/" : t15 === 92 ? "\\" : t15 === 78 ? "" : t15 === 95 ? " " : t15 === 76 ? "\u2028" : t15 === 80 ? "\u2029" : "";
}
S(jf, "simpleEscapeSequence");
function l7(t15) {
  return t15 <= 65535 ? String.fromCharCode(t15) : String.fromCharCode(
    (t15 - 65536 >> 10) + 55296,
    (t15 - 65536 & 1023) + 56320
  );
}
S(l7, "charFromCodepoint");
var c7 = new Array(256);
var h7 = new Array(256);
for (Ms = 0; Ms < 256; Ms++)
  c7[Ms] = jf(Ms) ? 1 : 0, h7[Ms] = jf(Ms);
var Ms;
function u7(t15, e) {
  this.input = t15, this.filename = e.filename || null, this.schema = e.schema || t7, this.onWarning = e.onWarning || null, this.legacy = e.legacy || false, this.json = e.json || false, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t15.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
S(u7, "State$1");
function Pm(t15, e) {
  var r = {
    name: t15.filename,
    buffer: t15.input.slice(0, -1),
    // omit trailing \0
    position: t15.position,
    line: t15.line,
    column: t15.position - t15.lineStart
  };
  return r.snippet = AP(r), new Wr(e, r);
}
S(Pm, "generateError");
function It(t15, e) {
  throw Pm(t15, e);
}
S(It, "throwError");
function ql(t15, e) {
  t15.onWarning && t15.onWarning.call(null, Pm(t15, e));
}
S(ql, "throwWarning");
var Kb = {
  YAML: S(function(t15, e, r) {
    var n, i, s;
    t15.version !== null && It(t15, "duplication of %YAML directive"), r.length !== 1 && It(t15, "YAML directive accepts exactly one argument"), n = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), n === null && It(t15, "ill-formed argument of the YAML directive"), i = parseInt(n[1], 10), s = parseInt(n[2], 10), i !== 1 && It(t15, "unacceptable YAML version of the document"), t15.version = r[0], t15.checkLineBreaks = s < 2, s !== 1 && s !== 2 && ql(t15, "unsupported YAML version of the document");
  }, "handleYamlDirective"),
  TAG: S(function(t15, e, r) {
    var n, i;
    r.length !== 2 && It(t15, "TAG directive accepts exactly two arguments"), n = r[0], i = r[1], n7.test(n) || It(t15, "ill-formed tag handle (first argument) of the TAG directive"), us.call(t15.tagMap, n) && It(t15, 'there is a previously declared suffix for "' + n + '" tag handle'), i7.test(i) || It(t15, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      i = decodeURIComponent(i);
    } catch {
      It(t15, "tag prefix is malformed: " + i);
    }
    t15.tagMap[n] = i;
  }, "handleTagDirective")
};
function Di(t15, e, r, n) {
  var i, s, o, a;
  if (e < r) {
    if (a = t15.input.slice(e, r), n)
      for (i = 0, s = a.length; i < s; i += 1)
        o = a.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || It(t15, "expected valid JSON character");
    else JP.test(a) && It(t15, "the stream contains non-printable characters");
    t15.result += a;
  }
}
S(Di, "captureSegment");
function Wf(t15, e, r, n) {
  var i, s, o, a;
  for (Ke.isObject(r) || It(t15, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), o = 0, a = i.length; o < a; o += 1)
    s = i[o], us.call(e, s) || (e[s] = r[s], n[s] = true);
}
S(Wf, "mergeMappings");
function Ws(t15, e, r, n, i, s, o, a, l) {
  var c, h10;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), c = 0, h10 = i.length; c < h10; c += 1)
      Array.isArray(i[c]) && It(t15, "nested arrays are not supported inside keys"), typeof i == "object" && Pf(i[c]) === "[object Object]" && (i[c] = "[object Object]");
  if (typeof i == "object" && Pf(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (c = 0, h10 = s.length; c < h10; c += 1)
        Wf(t15, e, s[c], r);
    else
      Wf(t15, e, s, r);
  else
    !t15.json && !us.call(r, i) && us.call(e, i) && (t15.line = o || t15.line, t15.lineStart = a || t15.lineStart, t15.position = l || t15.position, It(t15, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: s
    }) : e[i] = s, delete r[i];
  return e;
}
S(Ws, "storeMappingPair");
function $0(t15) {
  var e;
  e = t15.input.charCodeAt(t15.position), e === 10 ? t15.position++ : e === 13 ? (t15.position++, t15.input.charCodeAt(t15.position) === 10 && t15.position++) : It(t15, "a line break is expected"), t15.line += 1, t15.lineStart = t15.position, t15.firstTabInLine = -1;
}
S($0, "readLineBreak");
function je(t15, e, r) {
  for (var n = 0, i = t15.input.charCodeAt(t15.position); i !== 0; ) {
    for (; cs(i); )
      i === 9 && t15.firstTabInLine === -1 && (t15.firstTabInLine = t15.position), i = t15.input.charCodeAt(++t15.position);
    if (e && i === 35)
      do
        i = t15.input.charCodeAt(++t15.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (An(i))
      for ($0(t15), i = t15.input.charCodeAt(t15.position), n++, t15.lineIndent = 0; i === 32; )
        t15.lineIndent++, i = t15.input.charCodeAt(++t15.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && t15.lineIndent < r && ql(t15, "deficient indentation"), n;
}
S(je, "skipSeparationSpace");
function dc(t15) {
  var e = t15.position, r;
  return r = t15.input.charCodeAt(e), !!((r === 45 || r === 46) && r === t15.input.charCodeAt(e + 1) && r === t15.input.charCodeAt(e + 2) && (e += 3, r = t15.input.charCodeAt(e), r === 0 || $r(r)));
}
S(dc, "testDocumentSeparator");
function E0(t15, e) {
  e === 1 ? t15.result += " " : e > 1 && (t15.result += Ke.repeat(`
`, e - 1));
}
S(E0, "writeFoldedLines");
function d7(t15, e, r) {
  var n, i, s, o, a, l, c, h10, p = t15.kind, m = t15.result, g;
  if (g = t15.input.charCodeAt(t15.position), $r(g) || js(g) || g === 35 || g === 38 || g === 42 || g === 33 || g === 124 || g === 62 || g === 39 || g === 34 || g === 37 || g === 64 || g === 96 || (g === 63 || g === 45) && (i = t15.input.charCodeAt(t15.position + 1), $r(i) || r && js(i)))
    return false;
  for (t15.kind = "scalar", t15.result = "", s = o = t15.position, a = false; g !== 0; ) {
    if (g === 58) {
      if (i = t15.input.charCodeAt(t15.position + 1), $r(i) || r && js(i))
        break;
    } else if (g === 35) {
      if (n = t15.input.charCodeAt(t15.position - 1), $r(n))
        break;
    } else {
      if (t15.position === t15.lineStart && dc(t15) || r && js(g))
        break;
      if (An(g))
        if (l = t15.line, c = t15.lineStart, h10 = t15.lineIndent, je(t15, false, -1), t15.lineIndent >= e) {
          a = true, g = t15.input.charCodeAt(t15.position);
          continue;
        } else {
          t15.position = o, t15.line = l, t15.lineStart = c, t15.lineIndent = h10;
          break;
        }
    }
    a && (Di(t15, s, o, false), E0(t15, t15.line - l), s = o = t15.position, a = false), cs(g) || (o = t15.position + 1), g = t15.input.charCodeAt(++t15.position);
  }
  return Di(t15, s, o, false), t15.result ? true : (t15.kind = p, t15.result = m, false);
}
S(d7, "readPlainScalar");
function p7(t15, e) {
  var r, n, i;
  if (r = t15.input.charCodeAt(t15.position), r !== 39)
    return false;
  for (t15.kind = "scalar", t15.result = "", t15.position++, n = i = t15.position; (r = t15.input.charCodeAt(t15.position)) !== 0; )
    if (r === 39)
      if (Di(t15, n, t15.position, true), r = t15.input.charCodeAt(++t15.position), r === 39)
        n = t15.position, t15.position++, i = t15.position;
      else
        return true;
    else An(r) ? (Di(t15, n, i, true), E0(t15, je(t15, false, e)), n = i = t15.position) : t15.position === t15.lineStart && dc(t15) ? It(t15, "unexpected end of the document within a single quoted scalar") : (t15.position++, i = t15.position);
  It(t15, "unexpected end of the stream within a single quoted scalar");
}
S(p7, "readSingleQuotedScalar");
function f7(t15, e) {
  var r, n, i, s, o, a;
  if (a = t15.input.charCodeAt(t15.position), a !== 34)
    return false;
  for (t15.kind = "scalar", t15.result = "", t15.position++, r = n = t15.position; (a = t15.input.charCodeAt(t15.position)) !== 0; ) {
    if (a === 34)
      return Di(t15, r, t15.position, true), t15.position++, true;
    if (a === 92) {
      if (Di(t15, r, t15.position, true), a = t15.input.charCodeAt(++t15.position), An(a))
        je(t15, false, e);
      else if (a < 256 && c7[a])
        t15.result += h7[a], t15.position++;
      else if ((o = o7(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          a = t15.input.charCodeAt(++t15.position), (o = s7(a)) >= 0 ? s = (s << 4) + o : It(t15, "expected hexadecimal character");
        t15.result += l7(s), t15.position++;
      } else
        It(t15, "unknown escape sequence");
      r = n = t15.position;
    } else An(a) ? (Di(t15, r, n, true), E0(t15, je(t15, false, e)), r = n = t15.position) : t15.position === t15.lineStart && dc(t15) ? It(t15, "unexpected end of the document within a double quoted scalar") : (t15.position++, n = t15.position);
  }
  It(t15, "unexpected end of the stream within a double quoted scalar");
}
S(f7, "readDoubleQuotedScalar");
function m7(t15, e) {
  var r = true, n, i, s, o = t15.tag, a, l = t15.anchor, c, h10, p, m, g, y = /* @__PURE__ */ Object.create(null), x, k, C, _;
  if (_ = t15.input.charCodeAt(t15.position), _ === 91)
    h10 = 93, g = false, a = [];
  else if (_ === 123)
    h10 = 125, g = true, a = {};
  else
    return false;
  for (t15.anchor !== null && (t15.anchorMap[t15.anchor] = a), _ = t15.input.charCodeAt(++t15.position); _ !== 0; ) {
    if (je(t15, true, e), _ = t15.input.charCodeAt(t15.position), _ === h10)
      return t15.position++, t15.tag = o, t15.anchor = l, t15.kind = g ? "mapping" : "sequence", t15.result = a, true;
    r ? _ === 44 && It(t15, "expected the node content, but found ','") : It(t15, "missed comma between flow collection entries"), k = x = C = null, p = m = false, _ === 63 && (c = t15.input.charCodeAt(t15.position + 1), $r(c) && (p = m = true, t15.position++, je(t15, true, e))), n = t15.line, i = t15.lineStart, s = t15.position, eo(t15, e, wu, false, true), k = t15.tag, x = t15.result, je(t15, true, e), _ = t15.input.charCodeAt(t15.position), (m || t15.line === n) && _ === 58 && (p = true, _ = t15.input.charCodeAt(++t15.position), je(t15, true, e), eo(t15, e, wu, false, true), C = t15.result), g ? Ws(t15, a, y, k, x, C, n, i, s) : p ? a.push(Ws(t15, null, y, k, x, C, n, i, s)) : a.push(x), je(t15, true, e), _ = t15.input.charCodeAt(t15.position), _ === 44 ? (r = true, _ = t15.input.charCodeAt(++t15.position)) : r = false;
  }
  It(t15, "unexpected end of the stream within a flow collection");
}
S(m7, "readFlowCollection");
function g7(t15, e) {
  var r, n, i = Tp, s = false, o = false, a = e, l = 0, c = false, h10, p;
  if (p = t15.input.charCodeAt(t15.position), p === 124)
    n = false;
  else if (p === 62)
    n = true;
  else
    return false;
  for (t15.kind = "scalar", t15.result = ""; p !== 0; )
    if (p = t15.input.charCodeAt(++t15.position), p === 43 || p === 45)
      Tp === i ? i = p === 43 ? Yb : QP : It(t15, "repeat of a chomping mode identifier");
    else if ((h10 = a7(p)) >= 0)
      h10 === 0 ? It(t15, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? It(t15, "repeat of an indentation width identifier") : (a = e + h10 - 1, o = true);
    else
      break;
  if (cs(p)) {
    do
      p = t15.input.charCodeAt(++t15.position);
    while (cs(p));
    if (p === 35)
      do
        p = t15.input.charCodeAt(++t15.position);
      while (!An(p) && p !== 0);
  }
  for (; p !== 0; ) {
    for ($0(t15), t15.lineIndent = 0, p = t15.input.charCodeAt(t15.position); (!o || t15.lineIndent < a) && p === 32; )
      t15.lineIndent++, p = t15.input.charCodeAt(++t15.position);
    if (!o && t15.lineIndent > a && (a = t15.lineIndent), An(p)) {
      l++;
      continue;
    }
    if (t15.lineIndent < a) {
      i === Yb ? t15.result += Ke.repeat(`
`, s ? 1 + l : l) : i === Tp && s && (t15.result += `
`);
      break;
    }
    for (n ? cs(p) ? (c = true, t15.result += Ke.repeat(`
`, s ? 1 + l : l)) : c ? (c = false, t15.result += Ke.repeat(`
`, l + 1)) : l === 0 ? s && (t15.result += " ") : t15.result += Ke.repeat(`
`, l) : t15.result += Ke.repeat(`
`, s ? 1 + l : l), s = true, o = true, l = 0, r = t15.position; !An(p) && p !== 0; )
      p = t15.input.charCodeAt(++t15.position);
    Di(t15, r, t15.position, false);
  }
  return true;
}
S(g7, "readBlockScalar");
function Hf(t15, e) {
  var r, n = t15.tag, i = t15.anchor, s = [], o, a = false, l;
  if (t15.firstTabInLine !== -1) return false;
  for (t15.anchor !== null && (t15.anchorMap[t15.anchor] = s), l = t15.input.charCodeAt(t15.position); l !== 0 && (t15.firstTabInLine !== -1 && (t15.position = t15.firstTabInLine, It(t15, "tab characters must not be used in indentation")), !(l !== 45 || (o = t15.input.charCodeAt(t15.position + 1), !$r(o)))); ) {
    if (a = true, t15.position++, je(t15, true, -1) && t15.lineIndent <= e) {
      s.push(null), l = t15.input.charCodeAt(t15.position);
      continue;
    }
    if (r = t15.line, eo(t15, e, r7, false, true), s.push(t15.result), je(t15, true, -1), l = t15.input.charCodeAt(t15.position), (t15.line === r || t15.lineIndent > e) && l !== 0)
      It(t15, "bad indentation of a sequence entry");
    else if (t15.lineIndent < e)
      break;
  }
  return a ? (t15.tag = n, t15.anchor = i, t15.kind = "sequence", t15.result = s, true) : false;
}
S(Hf, "readBlockSequence");
function y7(t15, e, r) {
  var n, i, s, o, a, l, c = t15.tag, h10 = t15.anchor, p = {}, m = /* @__PURE__ */ Object.create(null), g = null, y = null, x = null, k = false, C = false, _;
  if (t15.firstTabInLine !== -1) return false;
  for (t15.anchor !== null && (t15.anchorMap[t15.anchor] = p), _ = t15.input.charCodeAt(t15.position); _ !== 0; ) {
    if (!k && t15.firstTabInLine !== -1 && (t15.position = t15.firstTabInLine, It(t15, "tab characters must not be used in indentation")), n = t15.input.charCodeAt(t15.position + 1), s = t15.line, (_ === 63 || _ === 58) && $r(n))
      _ === 63 ? (k && (Ws(t15, p, m, g, y, null, o, a, l), g = y = x = null), C = true, k = true, i = true) : k ? (k = false, i = true) : It(t15, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t15.position += 1, _ = n;
    else {
      if (o = t15.line, a = t15.lineStart, l = t15.position, !eo(t15, r, e7, false, true))
        break;
      if (t15.line === s) {
        for (_ = t15.input.charCodeAt(t15.position); cs(_); )
          _ = t15.input.charCodeAt(++t15.position);
        if (_ === 58)
          _ = t15.input.charCodeAt(++t15.position), $r(_) || It(t15, "a whitespace character is expected after the key-value separator within a block mapping"), k && (Ws(t15, p, m, g, y, null, o, a, l), g = y = x = null), C = true, k = false, i = false, g = t15.tag, y = t15.result;
        else if (C)
          It(t15, "can not read an implicit mapping pair; a colon is missed");
        else
          return t15.tag = c, t15.anchor = h10, true;
      } else if (C)
        It(t15, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t15.tag = c, t15.anchor = h10, true;
    }
    if ((t15.line === s || t15.lineIndent > e) && (k && (o = t15.line, a = t15.lineStart, l = t15.position), eo(t15, e, ku, true, i) && (k ? y = t15.result : x = t15.result), k || (Ws(t15, p, m, g, y, x, o, a, l), g = y = x = null), je(t15, true, -1), _ = t15.input.charCodeAt(t15.position)), (t15.line === s || t15.lineIndent > e) && _ !== 0)
      It(t15, "bad indentation of a mapping entry");
    else if (t15.lineIndent < e)
      break;
  }
  return k && Ws(t15, p, m, g, y, null, o, a, l), C && (t15.tag = c, t15.anchor = h10, t15.kind = "mapping", t15.result = p), C;
}
S(y7, "readBlockMapping");
function b7(t15) {
  var e, r = false, n = false, i, s, o;
  if (o = t15.input.charCodeAt(t15.position), o !== 33) return false;
  if (t15.tag !== null && It(t15, "duplication of a tag property"), o = t15.input.charCodeAt(++t15.position), o === 60 ? (r = true, o = t15.input.charCodeAt(++t15.position)) : o === 33 ? (n = true, i = "!!", o = t15.input.charCodeAt(++t15.position)) : i = "!", e = t15.position, r) {
    do
      o = t15.input.charCodeAt(++t15.position);
    while (o !== 0 && o !== 62);
    t15.position < t15.length ? (s = t15.input.slice(e, t15.position), o = t15.input.charCodeAt(++t15.position)) : It(t15, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !$r(o); )
      o === 33 && (n ? It(t15, "tag suffix cannot contain exclamation marks") : (i = t15.input.slice(e - 1, t15.position + 1), n7.test(i) || It(t15, "named tag handle cannot contain such characters"), n = true, e = t15.position + 1)), o = t15.input.charCodeAt(++t15.position);
    s = t15.input.slice(e, t15.position), ej.test(s) && It(t15, "tag suffix cannot contain flow indicator characters");
  }
  s && !i7.test(s) && It(t15, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    It(t15, "tag name is malformed: " + s);
  }
  return r ? t15.tag = s : us.call(t15.tagMap, i) ? t15.tag = t15.tagMap[i] + s : i === "!" ? t15.tag = "!" + s : i === "!!" ? t15.tag = "tag:yaml.org,2002:" + s : It(t15, 'undeclared tag handle "' + i + '"'), true;
}
S(b7, "readTagProperty");
function x7(t15) {
  var e, r;
  if (r = t15.input.charCodeAt(t15.position), r !== 38) return false;
  for (t15.anchor !== null && It(t15, "duplication of an anchor property"), r = t15.input.charCodeAt(++t15.position), e = t15.position; r !== 0 && !$r(r) && !js(r); )
    r = t15.input.charCodeAt(++t15.position);
  return t15.position === e && It(t15, "name of an anchor node must contain at least one character"), t15.anchor = t15.input.slice(e, t15.position), true;
}
S(x7, "readAnchorProperty");
function w7(t15) {
  var e, r, n;
  if (n = t15.input.charCodeAt(t15.position), n !== 42) return false;
  for (n = t15.input.charCodeAt(++t15.position), e = t15.position; n !== 0 && !$r(n) && !js(n); )
    n = t15.input.charCodeAt(++t15.position);
  return t15.position === e && It(t15, "name of an alias node must contain at least one character"), r = t15.input.slice(e, t15.position), us.call(t15.anchorMap, r) || It(t15, 'unidentified alias "' + r + '"'), t15.result = t15.anchorMap[r], je(t15, true, -1), true;
}
S(w7, "readAlias");
function eo(t15, e, r, n, i) {
  var s, o, a, l = 1, c = false, h10 = false, p, m, g, y, x, k;
  if (t15.listener !== null && t15.listener("open", t15), t15.tag = null, t15.anchor = null, t15.kind = null, t15.result = null, s = o = a = ku === r || r7 === r, n && je(t15, true, -1) && (c = true, t15.lineIndent > e ? l = 1 : t15.lineIndent === e ? l = 0 : t15.lineIndent < e && (l = -1)), l === 1)
    for (; b7(t15) || x7(t15); )
      je(t15, true, -1) ? (c = true, a = s, t15.lineIndent > e ? l = 1 : t15.lineIndent === e ? l = 0 : t15.lineIndent < e && (l = -1)) : a = false;
  if (a && (a = c || i), (l === 1 || ku === r) && (wu === r || e7 === r ? x = e : x = e + 1, k = t15.position - t15.lineStart, l === 1 ? a && (Hf(t15, k) || y7(t15, k, x)) || m7(t15, x) ? h10 = true : (o && g7(t15, x) || p7(t15, x) || f7(t15, x) ? h10 = true : w7(t15) ? (h10 = true, (t15.tag !== null || t15.anchor !== null) && It(t15, "alias node should not have any properties")) : d7(t15, x, wu === r) && (h10 = true, t15.tag === null && (t15.tag = "?")), t15.anchor !== null && (t15.anchorMap[t15.anchor] = t15.result)) : l === 0 && (h10 = a && Hf(t15, k))), t15.tag === null)
    t15.anchor !== null && (t15.anchorMap[t15.anchor] = t15.result);
  else if (t15.tag === "?") {
    for (t15.result !== null && t15.kind !== "scalar" && It(t15, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t15.kind + '"'), p = 0, m = t15.implicitTypes.length; p < m; p += 1)
      if (y = t15.implicitTypes[p], y.resolve(t15.result)) {
        t15.result = y.construct(t15.result), t15.tag = y.tag, t15.anchor !== null && (t15.anchorMap[t15.anchor] = t15.result);
        break;
      }
  } else if (t15.tag !== "!") {
    if (us.call(t15.typeMap[t15.kind || "fallback"], t15.tag))
      y = t15.typeMap[t15.kind || "fallback"][t15.tag];
    else
      for (y = null, g = t15.typeMap.multi[t15.kind || "fallback"], p = 0, m = g.length; p < m; p += 1)
        if (t15.tag.slice(0, g[p].tag.length) === g[p].tag) {
          y = g[p];
          break;
        }
    y || It(t15, "unknown tag !<" + t15.tag + ">"), t15.result !== null && y.kind !== t15.kind && It(t15, "unacceptable node kind for !<" + t15.tag + '> tag; it should be "' + y.kind + '", not "' + t15.kind + '"'), y.resolve(t15.result, t15.tag) ? (t15.result = y.construct(t15.result, t15.tag), t15.anchor !== null && (t15.anchorMap[t15.anchor] = t15.result)) : It(t15, "cannot resolve a node with !<" + t15.tag + "> explicit tag");
  }
  return t15.listener !== null && t15.listener("close", t15), t15.tag !== null || t15.anchor !== null || h10;
}
S(eo, "composeNode");
function k7(t15) {
  var e = t15.position, r, n, i, s = false, o;
  for (t15.version = null, t15.checkLineBreaks = t15.legacy, t15.tagMap = /* @__PURE__ */ Object.create(null), t15.anchorMap = /* @__PURE__ */ Object.create(null); (o = t15.input.charCodeAt(t15.position)) !== 0 && (je(t15, true, -1), o = t15.input.charCodeAt(t15.position), !(t15.lineIndent > 0 || o !== 37)); ) {
    for (s = true, o = t15.input.charCodeAt(++t15.position), r = t15.position; o !== 0 && !$r(o); )
      o = t15.input.charCodeAt(++t15.position);
    for (n = t15.input.slice(r, t15.position), i = [], n.length < 1 && It(t15, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; cs(o); )
        o = t15.input.charCodeAt(++t15.position);
      if (o === 35) {
        do
          o = t15.input.charCodeAt(++t15.position);
        while (o !== 0 && !An(o));
        break;
      }
      if (An(o)) break;
      for (r = t15.position; o !== 0 && !$r(o); )
        o = t15.input.charCodeAt(++t15.position);
      i.push(t15.input.slice(r, t15.position));
    }
    o !== 0 && $0(t15), us.call(Kb, n) ? Kb[n](t15, n, i) : ql(t15, 'unknown document directive "' + n + '"');
  }
  if (je(t15, true, -1), t15.lineIndent === 0 && t15.input.charCodeAt(t15.position) === 45 && t15.input.charCodeAt(t15.position + 1) === 45 && t15.input.charCodeAt(t15.position + 2) === 45 ? (t15.position += 3, je(t15, true, -1)) : s && It(t15, "directives end mark is expected"), eo(t15, t15.lineIndent - 1, ku, false, true), je(t15, true, -1), t15.checkLineBreaks && tj.test(t15.input.slice(e, t15.position)) && ql(t15, "non-ASCII line breaks are interpreted as content"), t15.documents.push(t15.result), t15.position === t15.lineStart && dc(t15)) {
    t15.input.charCodeAt(t15.position) === 46 && (t15.position += 3, je(t15, true, -1));
    return;
  }
  if (t15.position < t15.length - 1)
    It(t15, "end of the stream or a document separator is expected");
  else
    return;
}
S(k7, "readDocument");
function jm(t15, e) {
  t15 = String(t15), e = e || {}, t15.length !== 0 && (t15.charCodeAt(t15.length - 1) !== 10 && t15.charCodeAt(t15.length - 1) !== 13 && (t15 += `
`), t15.charCodeAt(0) === 65279 && (t15 = t15.slice(1)));
  var r = new u7(t15, e), n = t15.indexOf("\0");
  for (n !== -1 && (r.position = n, It(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    k7(r);
  return r.documents;
}
S(jm, "loadDocuments");
function rj(t15, e, r) {
  e !== null && typeof e == "object" && typeof r > "u" && (r = e, e = null);
  var n = jm(t15, r);
  if (typeof e != "function")
    return n;
  for (var i = 0, s = n.length; i < s; i += 1)
    e(n[i]);
}
S(rj, "loadAll$1");
function v7(t15, e) {
  var r = jm(t15, e);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new Wr("expected a single document in the stream, but found more");
  }
}
S(v7, "load$1");
var nj = v7;
var ij = {
  load: nj
};
var _7 = Object.prototype.toString;
var C7 = Object.prototype.hasOwnProperty;
var Wm = 65279;
var sj = 9;
var Rl = 10;
var oj = 13;
var aj = 32;
var lj = 33;
var cj = 34;
var Uf = 35;
var hj = 37;
var uj = 38;
var dj = 39;
var pj = 42;
var S7 = 44;
var fj = 45;
var vu = 58;
var mj = 61;
var gj = 62;
var yj = 63;
var bj = 64;
var T7 = 91;
var A7 = 93;
var xj = 96;
var $7 = 123;
var wj = 124;
var E7 = 125;
var xr = {};
xr[0] = "\\0";
xr[7] = "\\a";
xr[8] = "\\b";
xr[9] = "\\t";
xr[10] = "\\n";
xr[11] = "\\v";
xr[12] = "\\f";
xr[13] = "\\r";
xr[27] = "\\e";
xr[34] = '\\"';
xr[92] = "\\\\";
xr[133] = "\\N";
xr[160] = "\\_";
xr[8232] = "\\L";
xr[8233] = "\\P";
var kj = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var vj = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function M7(t15, e) {
  var r, n, i, s, o, a, l;
  if (e === null) return {};
  for (r = {}, n = Object.keys(e), i = 0, s = n.length; i < s; i += 1)
    o = n[i], a = String(e[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), l = t15.compiledTypeMap.fallback[o], l && C7.call(l.styleAliases, a) && (a = l.styleAliases[a]), r[o] = a;
  return r;
}
S(M7, "compileStyleMap");
function B7(t15) {
  var e, r, n;
  if (e = t15.toString(16).toUpperCase(), t15 <= 255)
    r = "x", n = 2;
  else if (t15 <= 65535)
    r = "u", n = 4;
  else if (t15 <= 4294967295)
    r = "U", n = 8;
  else
    throw new Wr("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + Ke.repeat("0", n - e.length) + e;
}
S(B7, "encodeHex");
var _j = 1;
var Pl = 2;
function L7(t15) {
  this.schema = t15.schema || t7, this.indent = Math.max(1, t15.indent || 2), this.noArrayIndent = t15.noArrayIndent || false, this.skipInvalid = t15.skipInvalid || false, this.flowLevel = Ke.isNothing(t15.flowLevel) ? -1 : t15.flowLevel, this.styleMap = M7(this.schema, t15.styles || null), this.sortKeys = t15.sortKeys || false, this.lineWidth = t15.lineWidth || 80, this.noRefs = t15.noRefs || false, this.noCompatMode = t15.noCompatMode || false, this.condenseFlow = t15.condenseFlow || false, this.quotingType = t15.quotingType === '"' ? Pl : _j, this.forceQuotes = t15.forceQuotes || false, this.replacer = typeof t15.replacer == "function" ? t15.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
S(L7, "State");
function Vf(t15, e) {
  for (var r = Ke.repeat(" ", e), n = 0, i = -1, s = "", o, a = t15.length; n < a; )
    i = t15.indexOf(`
`, n), i === -1 ? (o = t15.slice(n), n = a) : (o = t15.slice(n, i + 1), n = i + 1), o.length && o !== `
` && (s += r), s += o;
  return s;
}
S(Vf, "indentString");
function _u(t15, e) {
  return `
` + Ke.repeat(" ", t15.indent * e);
}
S(_u, "generateNextLine");
function D7(t15, e) {
  var r, n, i;
  for (r = 0, n = t15.implicitTypes.length; r < n; r += 1)
    if (i = t15.implicitTypes[r], i.resolve(e))
      return true;
  return false;
}
S(D7, "testImplicitResolving");
function jl(t15) {
  return t15 === aj || t15 === sj;
}
S(jl, "isWhitespace");
function ra(t15) {
  return 32 <= t15 && t15 <= 126 || 161 <= t15 && t15 <= 55295 && t15 !== 8232 && t15 !== 8233 || 57344 <= t15 && t15 <= 65533 && t15 !== Wm || 65536 <= t15 && t15 <= 1114111;
}
S(ra, "isPrintable");
function Gf(t15) {
  return ra(t15) && t15 !== Wm && t15 !== oj && t15 !== Rl;
}
S(Gf, "isNsCharOrWhitespace");
function Xf(t15, e, r) {
  var n = Gf(t15), i = n && !jl(t15);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      n
    ) : n && t15 !== S7 && t15 !== T7 && t15 !== A7 && t15 !== $7 && t15 !== E7) && t15 !== Uf && !(e === vu && !i) || Gf(e) && !jl(e) && t15 === Uf || e === vu && i
  );
}
S(Xf, "isPlainSafe");
function F7(t15) {
  return ra(t15) && t15 !== Wm && !jl(t15) && t15 !== fj && t15 !== yj && t15 !== vu && t15 !== S7 && t15 !== T7 && t15 !== A7 && t15 !== $7 && t15 !== E7 && t15 !== Uf && t15 !== uj && t15 !== pj && t15 !== lj && t15 !== wj && t15 !== mj && t15 !== gj && t15 !== dj && t15 !== cj && t15 !== hj && t15 !== bj && t15 !== xj;
}
S(F7, "isPlainSafeFirst");
function N7(t15) {
  return !jl(t15) && t15 !== vu;
}
S(N7, "isPlainSafeLast");
function No(t15, e) {
  var r = t15.charCodeAt(e), n;
  return r >= 55296 && r <= 56319 && e + 1 < t15.length && (n = t15.charCodeAt(e + 1), n >= 56320 && n <= 57343) ? (r - 55296) * 1024 + n - 56320 + 65536 : r;
}
S(No, "codePointAt");
function Hm(t15) {
  var e = /^\n* /;
  return e.test(t15);
}
S(Hm, "needIndentIndicator");
var I7 = 1;
var Yf = 2;
var O7 = 3;
var z7 = 4;
var Eo = 5;
function q7(t15, e, r, n, i, s, o, a) {
  var l, c = 0, h10 = null, p = false, m = false, g = n !== -1, y = -1, x = F7(No(t15, 0)) && N7(No(t15, t15.length - 1));
  if (e || o)
    for (l = 0; l < t15.length; c >= 65536 ? l += 2 : l++) {
      if (c = No(t15, l), !ra(c))
        return Eo;
      x = x && Xf(c, h10, a), h10 = c;
    }
  else {
    for (l = 0; l < t15.length; c >= 65536 ? l += 2 : l++) {
      if (c = No(t15, l), c === Rl)
        p = true, g && (m = m || // Foldable line = too long, and not more-indented.
        l - y - 1 > n && t15[y + 1] !== " ", y = l);
      else if (!ra(c))
        return Eo;
      x = x && Xf(c, h10, a), h10 = c;
    }
    m = m || g && l - y - 1 > n && t15[y + 1] !== " ";
  }
  return !p && !m ? x && !o && !i(t15) ? I7 : s === Pl ? Eo : Yf : r > 9 && Hm(t15) ? Eo : o ? s === Pl ? Eo : Yf : m ? z7 : O7;
}
S(q7, "chooseScalarStyle");
function R7(t15, e, r, n, i) {
  t15.dump = function() {
    if (e.length === 0)
      return t15.quotingType === Pl ? '""' : "''";
    if (!t15.noCompatMode && (kj.indexOf(e) !== -1 || vj.test(e)))
      return t15.quotingType === Pl ? '"' + e + '"' : "'" + e + "'";
    var s = t15.indent * Math.max(1, r), o = t15.lineWidth === -1 ? -1 : Math.max(Math.min(t15.lineWidth, 40), t15.lineWidth - s), a = n || t15.flowLevel > -1 && r >= t15.flowLevel;
    function l(c) {
      return D7(t15, c);
    }
    switch (S(l, "testAmbiguity"), q7(
      e,
      a,
      t15.indent,
      o,
      l,
      t15.quotingType,
      t15.forceQuotes && !n,
      i
    )) {
      case I7:
        return e;
      case Yf:
        return "'" + e.replace(/'/g, "''") + "'";
      case O7:
        return "|" + Kf(e, t15.indent) + Zf(Vf(e, s));
      case z7:
        return ">" + Kf(e, t15.indent) + Zf(Vf(P7(e, o), s));
      case Eo:
        return '"' + j7(e) + '"';
      default:
        throw new Wr("impossible error: invalid scalar style");
    }
  }();
}
S(R7, "writeScalar");
function Kf(t15, e) {
  var r = Hm(t15) ? String(e) : "", n = t15[t15.length - 1] === `
`, i = n && (t15[t15.length - 2] === `
` || t15 === `
`), s = i ? "+" : n ? "" : "-";
  return r + s + `
`;
}
S(Kf, "blockHeader");
function Zf(t15) {
  return t15[t15.length - 1] === `
` ? t15.slice(0, -1) : t15;
}
S(Zf, "dropEndingNewline");
function P7(t15, e) {
  for (var r = /(\n+)([^\n]*)/g, n = function() {
    var c = t15.indexOf(`
`);
    return c = c !== -1 ? c : t15.length, r.lastIndex = c, Qf(t15.slice(0, c), e);
  }(), i = t15[0] === `
` || t15[0] === " ", s, o; o = r.exec(t15); ) {
    var a = o[1], l = o[2];
    s = l[0] === " ", n += a + (!i && !s && l !== "" ? `
` : "") + Qf(l, e), i = s;
  }
  return n;
}
S(P7, "foldString");
function Qf(t15, e) {
  if (t15 === "" || t15[0] === " ") return t15;
  for (var r = / [^ ]/g, n, i = 0, s, o = 0, a = 0, l = ""; n = r.exec(t15); )
    a = n.index, a - i > e && (s = o > i ? o : a, l += `
` + t15.slice(i, s), i = s + 1), o = a;
  return l += `
`, t15.length - i > e && o > i ? l += t15.slice(i, o) + `
` + t15.slice(o + 1) : l += t15.slice(i), l.slice(1);
}
S(Qf, "foldLine");
function j7(t15) {
  for (var e = "", r = 0, n, i = 0; i < t15.length; r >= 65536 ? i += 2 : i++)
    r = No(t15, i), n = xr[r], !n && ra(r) ? (e += t15[i], r >= 65536 && (e += t15[i + 1])) : e += n || B7(r);
  return e;
}
S(j7, "escapeString");
function W7(t15, e, r) {
  var n = "", i = t15.tag, s, o, a;
  for (s = 0, o = r.length; s < o; s += 1)
    a = r[s], t15.replacer && (a = t15.replacer.call(r, String(s), a)), (ni(t15, e, a, false, false) || typeof a > "u" && ni(t15, e, null, false, false)) && (n !== "" && (n += "," + (t15.condenseFlow ? "" : " ")), n += t15.dump);
  t15.tag = i, t15.dump = "[" + n + "]";
}
S(W7, "writeFlowSequence");
function Jf(t15, e, r, n) {
  var i = "", s = t15.tag, o, a, l;
  for (o = 0, a = r.length; o < a; o += 1)
    l = r[o], t15.replacer && (l = t15.replacer.call(r, String(o), l)), (ni(t15, e + 1, l, true, true, false, true) || typeof l > "u" && ni(t15, e + 1, null, true, true, false, true)) && ((!n || i !== "") && (i += _u(t15, e)), t15.dump && Rl === t15.dump.charCodeAt(0) ? i += "-" : i += "- ", i += t15.dump);
  t15.tag = s, t15.dump = i || "[]";
}
S(Jf, "writeBlockSequence");
function H7(t15, e, r) {
  var n = "", i = t15.tag, s = Object.keys(r), o, a, l, c, h10;
  for (o = 0, a = s.length; o < a; o += 1)
    h10 = "", n !== "" && (h10 += ", "), t15.condenseFlow && (h10 += '"'), l = s[o], c = r[l], t15.replacer && (c = t15.replacer.call(r, l, c)), ni(t15, e, l, false, false) && (t15.dump.length > 1024 && (h10 += "? "), h10 += t15.dump + (t15.condenseFlow ? '"' : "") + ":" + (t15.condenseFlow ? "" : " "), ni(t15, e, c, false, false) && (h10 += t15.dump, n += h10));
  t15.tag = i, t15.dump = "{" + n + "}";
}
S(H7, "writeFlowMapping");
function U7(t15, e, r, n) {
  var i = "", s = t15.tag, o = Object.keys(r), a, l, c, h10, p, m;
  if (t15.sortKeys === true)
    o.sort();
  else if (typeof t15.sortKeys == "function")
    o.sort(t15.sortKeys);
  else if (t15.sortKeys)
    throw new Wr("sortKeys must be a boolean or a function");
  for (a = 0, l = o.length; a < l; a += 1)
    m = "", (!n || i !== "") && (m += _u(t15, e)), c = o[a], h10 = r[c], t15.replacer && (h10 = t15.replacer.call(r, c, h10)), ni(t15, e + 1, c, true, true, true) && (p = t15.tag !== null && t15.tag !== "?" || t15.dump && t15.dump.length > 1024, p && (t15.dump && Rl === t15.dump.charCodeAt(0) ? m += "?" : m += "? "), m += t15.dump, p && (m += _u(t15, e)), ni(t15, e + 1, h10, true, p) && (t15.dump && Rl === t15.dump.charCodeAt(0) ? m += ":" : m += ": ", m += t15.dump, i += m));
  t15.tag = s, t15.dump = i || "{}";
}
S(U7, "writeBlockMapping");
function t1(t15, e, r) {
  var n, i, s, o, a, l;
  for (i = r ? t15.explicitTypes : t15.implicitTypes, s = 0, o = i.length; s < o; s += 1)
    if (a = i[s], (a.instanceOf || a.predicate) && (!a.instanceOf || typeof e == "object" && e instanceof a.instanceOf) && (!a.predicate || a.predicate(e))) {
      if (r ? a.multi && a.representName ? t15.tag = a.representName(e) : t15.tag = a.tag : t15.tag = "?", a.represent) {
        if (l = t15.styleMap[a.tag] || a.defaultStyle, _7.call(a.represent) === "[object Function]")
          n = a.represent(e, l);
        else if (C7.call(a.represent, l))
          n = a.represent[l](e, l);
        else
          throw new Wr("!<" + a.tag + '> tag resolver accepts not "' + l + '" style');
        t15.dump = n;
      }
      return true;
    }
  return false;
}
S(t1, "detectType");
function ni(t15, e, r, n, i, s, o) {
  t15.tag = null, t15.dump = r, t1(t15, r, false) || t1(t15, r, true);
  var a = _7.call(t15.dump), l = n, c;
  n && (n = t15.flowLevel < 0 || t15.flowLevel > e);
  var h10 = a === "[object Object]" || a === "[object Array]", p, m;
  if (h10 && (p = t15.duplicates.indexOf(r), m = p !== -1), (t15.tag !== null && t15.tag !== "?" || m || t15.indent !== 2 && e > 0) && (i = false), m && t15.usedDuplicates[p])
    t15.dump = "*ref_" + p;
  else {
    if (h10 && m && !t15.usedDuplicates[p] && (t15.usedDuplicates[p] = true), a === "[object Object]")
      n && Object.keys(t15.dump).length !== 0 ? (U7(t15, e, t15.dump, i), m && (t15.dump = "&ref_" + p + t15.dump)) : (H7(t15, e, t15.dump), m && (t15.dump = "&ref_" + p + " " + t15.dump));
    else if (a === "[object Array]")
      n && t15.dump.length !== 0 ? (t15.noArrayIndent && !o && e > 0 ? Jf(t15, e - 1, t15.dump, i) : Jf(t15, e, t15.dump, i), m && (t15.dump = "&ref_" + p + t15.dump)) : (W7(t15, e, t15.dump), m && (t15.dump = "&ref_" + p + " " + t15.dump));
    else if (a === "[object String]")
      t15.tag !== "?" && R7(t15, t15.dump, e, s, l);
    else {
      if (a === "[object Undefined]" || t15.skipInvalid) return false;
      throw new Wr("unacceptable kind of an object to dump " + a);
    }
    t15.tag !== null && t15.tag !== "?" && (c = encodeURI(
      t15.tag[0] === "!" ? t15.tag.slice(1) : t15.tag
    ).replace(/!/g, "%21"), t15.tag[0] === "!" ? c = "!" + c : c.slice(0, 18) === "tag:yaml.org,2002:" ? c = "!!" + c.slice(18) : c = "!<" + c + ">", t15.dump = c + " " + t15.dump);
  }
  return true;
}
S(ni, "writeNode");
function V7(t15, e) {
  var r = [], n = [], i, s;
  for (Cu(t15, r, n), i = 0, s = n.length; i < s; i += 1)
    e.duplicates.push(r[n[i]]);
  e.usedDuplicates = new Array(s);
}
S(V7, "getDuplicateReferences");
function Cu(t15, e, r) {
  var n, i, s;
  if (t15 !== null && typeof t15 == "object")
    if (i = e.indexOf(t15), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (e.push(t15), Array.isArray(t15))
      for (i = 0, s = t15.length; i < s; i += 1)
        Cu(t15[i], e, r);
    else
      for (n = Object.keys(t15), i = 0, s = n.length; i < s; i += 1)
        Cu(t15[n[i]], e, r);
}
S(Cu, "inspectNode");
function Cj(t15, e) {
  e = e || {};
  var r = new L7(e);
  r.noRefs || V7(t15, r);
  var n = t15;
  return r.replacer && (n = r.replacer.call({ "": n }, "", n)), ni(r, 0, n, true, true) ? r.dump + `
` : "";
}
S(Cj, "dump$1");
function Sj(t15, e) {
  return function() {
    throw new Error("Function yaml." + t15 + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
S(Sj, "renamed");
var Tj = Ow;
var Aj = ij.load;
var pn = {
  aggregation: 18,
  extension: 18,
  composition: 18,
  dependency: 6,
  lollipop: 13.5,
  arrow_point: 4
};
function ll(t15, e) {
  if (t15 === void 0 || e === void 0)
    return { angle: 0, deltaX: 0, deltaY: 0 };
  t15 = Le(t15), e = Le(e);
  const [r, n] = [t15.x, t15.y], [i, s] = [e.x, e.y], o = i - r, a = s - n;
  return { angle: Math.atan(a / o), deltaX: o, deltaY: a };
}
S(ll, "calculateDeltaAndAngle");
var Le = S((t15) => Array.isArray(t15) ? { x: t15[0], y: t15[1] } : t15, "pointTransformer");
var $j = S((t15) => ({
  x: S(function(e, r, n) {
    let i = 0;
    const s = Le(n[0]).x < Le(n[n.length - 1]).x ? "left" : "right";
    if (r === 0 && Object.hasOwn(pn, t15.arrowTypeStart)) {
      const { angle: g, deltaX: y } = ll(n[0], n[1]);
      i = pn[t15.arrowTypeStart] * Math.cos(g) * (y >= 0 ? 1 : -1);
    } else if (r === n.length - 1 && Object.hasOwn(pn, t15.arrowTypeEnd)) {
      const { angle: g, deltaX: y } = ll(
        n[n.length - 1],
        n[n.length - 2]
      );
      i = pn[t15.arrowTypeEnd] * Math.cos(g) * (y >= 0 ? 1 : -1);
    }
    const o = Math.abs(
      Le(e).x - Le(n[n.length - 1]).x
    ), a = Math.abs(
      Le(e).y - Le(n[n.length - 1]).y
    ), l = Math.abs(Le(e).x - Le(n[0]).x), c = Math.abs(Le(e).y - Le(n[0]).y), h10 = pn[t15.arrowTypeStart], p = pn[t15.arrowTypeEnd], m = 1;
    if (o < p && o > 0 && a < p) {
      let g = p + m - o;
      g *= s === "right" ? -1 : 1, i -= g;
    }
    if (l < h10 && l > 0 && c < h10) {
      let g = h10 + m - l;
      g *= s === "right" ? -1 : 1, i += g;
    }
    return Le(e).x + i;
  }, "x"),
  y: S(function(e, r, n) {
    let i = 0;
    const s = Le(n[0]).y < Le(n[n.length - 1]).y ? "down" : "up";
    if (r === 0 && Object.hasOwn(pn, t15.arrowTypeStart)) {
      const { angle: g, deltaY: y } = ll(n[0], n[1]);
      i = pn[t15.arrowTypeStart] * Math.abs(Math.sin(g)) * (y >= 0 ? 1 : -1);
    } else if (r === n.length - 1 && Object.hasOwn(pn, t15.arrowTypeEnd)) {
      const { angle: g, deltaY: y } = ll(
        n[n.length - 1],
        n[n.length - 2]
      );
      i = pn[t15.arrowTypeEnd] * Math.abs(Math.sin(g)) * (y >= 0 ? 1 : -1);
    }
    const o = Math.abs(
      Le(e).y - Le(n[n.length - 1]).y
    ), a = Math.abs(
      Le(e).x - Le(n[n.length - 1]).x
    ), l = Math.abs(Le(e).y - Le(n[0]).y), c = Math.abs(Le(e).x - Le(n[0]).x), h10 = pn[t15.arrowTypeStart], p = pn[t15.arrowTypeEnd], m = 1;
    if (o < p && o > 0 && a < p) {
      let g = p + m - o;
      g *= s === "up" ? -1 : 1, i -= g;
    }
    if (l < h10 && l > 0 && c < h10) {
      let g = h10 + m - l;
      g *= s === "up" ? -1 : 1, i += g;
    }
    return Le(e).y + i;
  }, "y")
}), "getLineFunctionsWithOffset");
var Um = S(({
  flowchart: t15
}) => {
  var _a2, _b2;
  const e = ((_a2 = t15 == null ? void 0 : t15.subGraphTitleMargin) == null ? void 0 : _a2.top) ?? 0, r = ((_b2 = t15 == null ? void 0 : t15.subGraphTitleMargin) == null ? void 0 : _b2.bottom) ?? 0, n = e + r;
  return {
    subGraphTitleTopMargin: e,
    subGraphTitleBottomMargin: r,
    subGraphTitleTotalMargin: n
  };
}, "getSubGraphTitleMargins");
var Ej = S((t15) => {
  const { handDrawnSeed: e } = me();
  return {
    fill: t15,
    hachureAngle: 120,
    // angle of hachure,
    hachureGap: 4,
    fillWeight: 2,
    roughness: 0.7,
    stroke: t15,
    seed: e
  };
}, "solidStateFill");
var ya = S((t15) => {
  const e = Mj([...t15.cssCompiledStyles || [], ...t15.cssStyles || []]);
  return { stylesMap: e, stylesArray: [...e] };
}, "compileStyles");
var Mj = S((t15) => {
  const e = /* @__PURE__ */ new Map();
  return t15.forEach((r) => {
    const [n, i] = r.split(":");
    e.set(n.trim(), i == null ? void 0 : i.trim());
  }), e;
}, "styles2Map");
var G7 = S((t15) => t15 === "color" || t15 === "font-size" || t15 === "font-family" || t15 === "font-weight" || t15 === "font-style" || t15 === "text-decoration" || t15 === "text-align" || t15 === "text-transform" || t15 === "line-height" || t15 === "letter-spacing" || t15 === "word-spacing" || t15 === "text-shadow" || t15 === "text-overflow" || t15 === "white-space" || t15 === "word-wrap" || t15 === "word-break" || t15 === "overflow-wrap" || t15 === "hyphens", "isLabelStyle");
var Nt = S((t15) => {
  const { stylesArray: e } = ya(t15), r = [], n = [], i = [], s = [];
  return e.forEach((o) => {
    const a = o[0];
    G7(a) ? r.push(o.join(":") + " !important") : (n.push(o.join(":") + " !important"), a.includes("stroke") && i.push(o.join(":") + " !important"), a === "fill" && s.push(o.join(":") + " !important"));
  }), {
    labelStyles: r.join(";"),
    nodeStyles: n.join(";"),
    stylesArray: e,
    borderStyles: i,
    backgroundStyles: s
  };
}, "styles2String");
var Lt = S((t15, e) => {
  var _a2;
  const { themeVariables: r, handDrawnSeed: n } = me(), { nodeBorder: i, mainBkg: s } = r, { stylesMap: o } = ya(t15);
  return Object.assign(
    {
      roughness: 0.7,
      fill: o.get("fill") || s,
      fillStyle: "hachure",
      // solid fill
      fillWeight: 4,
      hachureGap: 5.2,
      stroke: o.get("stroke") || i,
      seed: n,
      strokeWidth: ((_a2 = o.get("stroke-width")) == null ? void 0 : _a2.replace("px", "")) || 1.3,
      fillLineDash: [0, 0]
    },
    e
  );
}, "userNodeOverrides");
var Ha = {};
var er = {};
var Zb;
function Bj() {
  return Zb || (Zb = 1, Object.defineProperty(er, "__esModule", { value: true }), er.BLANK_URL = er.relativeFirstCharacters = er.whitespaceEscapeCharsRegex = er.urlSchemeRegex = er.ctrlCharactersRegex = er.htmlCtrlEntityRegex = er.htmlEntitiesRegex = er.invalidProtocolRegex = void 0, er.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im, er.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g, er.htmlCtrlEntityRegex = /&(newline|tab);/gi, er.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, er.urlSchemeRegex = /^.+(:|&colon;)/gim, er.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g, er.relativeFirstCharacters = [".", "/"], er.BLANK_URL = "about:blank"), er;
}
var Qb;
function Lj() {
  if (Qb) return Ha;
  Qb = 1, Object.defineProperty(Ha, "__esModule", { value: true }), Ha.sanitizeUrl = void 0;
  var t15 = Bj();
  function e(o) {
    return t15.relativeFirstCharacters.indexOf(o[0]) > -1;
  }
  function r(o) {
    var a = o.replace(t15.ctrlCharactersRegex, "");
    return a.replace(t15.htmlEntitiesRegex, function(l, c) {
      return String.fromCharCode(c);
    });
  }
  function n(o) {
    return URL.canParse(o);
  }
  function i(o) {
    try {
      return decodeURIComponent(o);
    } catch {
      return o;
    }
  }
  function s(o) {
    if (!o)
      return t15.BLANK_URL;
    var a, l = i(o.trim());
    do
      l = r(l).replace(t15.htmlCtrlEntityRegex, "").replace(t15.ctrlCharactersRegex, "").replace(t15.whitespaceEscapeCharsRegex, "").trim(), l = i(l), a = l.match(t15.ctrlCharactersRegex) || l.match(t15.htmlEntitiesRegex) || l.match(t15.htmlCtrlEntityRegex) || l.match(t15.whitespaceEscapeCharsRegex);
    while (a && a.length > 0);
    var c = l;
    if (!c)
      return t15.BLANK_URL;
    if (e(c))
      return c;
    var h10 = c.trimStart(), p = h10.match(t15.urlSchemeRegex);
    if (!p)
      return c;
    var m = p[0].toLowerCase().trim();
    if (t15.invalidProtocolRegex.test(m))
      return t15.BLANK_URL;
    var g = h10.replace(/\\/g, "/");
    if (m === "mailto:" || m.includes("://"))
      return g;
    if (m === "http:" || m === "https:") {
      if (!n(g))
        return t15.BLANK_URL;
      var y = new URL(g);
      return y.protocol = y.protocol.toLowerCase(), y.hostname = y.hostname.toLowerCase(), y.toString();
    }
    return g;
  }
  return Ha.sanitizeUrl = s, Ha;
}
var Dj = Lj();
var Fj = { value: () => {
} };
function X7() {
  for (var t15 = 0, e = arguments.length, r = {}, n; t15 < e; ++t15) {
    if (!(n = arguments[t15] + "") || n in r || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new Nh(r);
}
function Nh(t15) {
  this._ = t15;
}
function Nj(t15, e) {
  return t15.trim().split(/^|\s+/).map(function(r) {
    var n = "", i = r.indexOf(".");
    if (i >= 0 && (n = r.slice(i + 1), r = r.slice(0, i)), r && !e.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
Nh.prototype = X7.prototype = {
  constructor: Nh,
  on: function(t15, e) {
    var r = this._, n = Nj(t15 + "", r), i, s = -1, o = n.length;
    if (arguments.length < 2) {
      for (; ++s < o; ) if ((i = (t15 = n[s]).type) && (i = Ij(r[i], t15.name))) return i;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++s < o; )
      if (i = (t15 = n[s]).type) r[i] = Jb(r[i], t15.name, e);
      else if (e == null) for (i in r) r[i] = Jb(r[i], t15.name, null);
    return this;
  },
  copy: function() {
    var t15 = {}, e = this._;
    for (var r in e) t15[r] = e[r].slice();
    return new Nh(t15);
  },
  call: function(t15, e) {
    if ((i = arguments.length - 2) > 0) for (var r = new Array(i), n = 0, i, s; n < i; ++n) r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(t15)) throw new Error("unknown type: " + t15);
    for (s = this._[t15], n = 0, i = s.length; n < i; ++n) s[n].value.apply(e, r);
  },
  apply: function(t15, e, r) {
    if (!this._.hasOwnProperty(t15)) throw new Error("unknown type: " + t15);
    for (var n = this._[t15], i = 0, s = n.length; i < s; ++i) n[i].value.apply(e, r);
  }
};
function Ij(t15, e) {
  for (var r = 0, n = t15.length, i; r < n; ++r)
    if ((i = t15[r]).name === e)
      return i.value;
}
function Jb(t15, e, r) {
  for (var n = 0, i = t15.length; n < i; ++n)
    if (t15[n].name === e) {
      t15[n] = Fj, t15 = t15.slice(0, n).concat(t15.slice(n + 1));
      break;
    }
  return r != null && t15.push({ name: e, value: r }), t15;
}
var e1 = "http://www.w3.org/1999/xhtml";
var t42 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: e1,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function M0(t15) {
  var e = t15 += "", r = e.indexOf(":");
  return r >= 0 && (e = t15.slice(0, r)) !== "xmlns" && (t15 = t15.slice(r + 1)), t42.hasOwnProperty(e) ? { space: t42[e], local: t15 } : t15;
}
function Oj(t15) {
  return function() {
    var e = this.ownerDocument, r = this.namespaceURI;
    return r === e1 && e.documentElement.namespaceURI === e1 ? e.createElement(t15) : e.createElementNS(r, t15);
  };
}
function zj(t15) {
  return function() {
    return this.ownerDocument.createElementNS(t15.space, t15.local);
  };
}
function Y7(t15) {
  var e = M0(t15);
  return (e.local ? zj : Oj)(e);
}
function qj() {
}
function Vm(t15) {
  return t15 == null ? qj : function() {
    return this.querySelector(t15);
  };
}
function Rj(t15) {
  typeof t15 != "function" && (t15 = Vm(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], o = s.length, a = n[i] = new Array(o), l, c, h10 = 0; h10 < o; ++h10)
      (l = s[h10]) && (c = t15.call(l, l.__data__, h10, s)) && ("__data__" in l && (c.__data__ = l.__data__), a[h10] = c);
  return new nn(n, this._parents);
}
function Pj(t15) {
  return t15 == null ? [] : Array.isArray(t15) ? t15 : Array.from(t15);
}
function jj() {
  return [];
}
function K7(t15) {
  return t15 == null ? jj : function() {
    return this.querySelectorAll(t15);
  };
}
function Wj(t15) {
  return function() {
    return Pj(t15.apply(this, arguments));
  };
}
function Hj(t15) {
  typeof t15 == "function" ? t15 = Wj(t15) : t15 = K7(t15);
  for (var e = this._groups, r = e.length, n = [], i = [], s = 0; s < r; ++s)
    for (var o = e[s], a = o.length, l, c = 0; c < a; ++c)
      (l = o[c]) && (n.push(t15.call(l, l.__data__, c, o)), i.push(l));
  return new nn(n, i);
}
function Z7(t15) {
  return function() {
    return this.matches(t15);
  };
}
function Q7(t15) {
  return function(e) {
    return e.matches(t15);
  };
}
var Uj = Array.prototype.find;
function Vj(t15) {
  return function() {
    return Uj.call(this.children, t15);
  };
}
function Gj() {
  return this.firstElementChild;
}
function Xj(t15) {
  return this.select(t15 == null ? Gj : Vj(typeof t15 == "function" ? t15 : Q7(t15)));
}
var Yj = Array.prototype.filter;
function Kj() {
  return Array.from(this.children);
}
function Zj(t15) {
  return function() {
    return Yj.call(this.children, t15);
  };
}
function Qj(t15) {
  return this.selectAll(t15 == null ? Kj : Zj(typeof t15 == "function" ? t15 : Q7(t15)));
}
function Jj(t15) {
  typeof t15 != "function" && (t15 = Z7(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], o = s.length, a = n[i] = [], l, c = 0; c < o; ++c)
      (l = s[c]) && t15.call(l, l.__data__, c, s) && a.push(l);
  return new nn(n, this._parents);
}
function J7(t15) {
  return new Array(t15.length);
}
function tW() {
  return new nn(this._enter || this._groups.map(J7), this._parents);
}
function Su(t15, e) {
  this.ownerDocument = t15.ownerDocument, this.namespaceURI = t15.namespaceURI, this._next = null, this._parent = t15, this.__data__ = e;
}
Su.prototype = {
  constructor: Su,
  appendChild: function(t15) {
    return this._parent.insertBefore(t15, this._next);
  },
  insertBefore: function(t15, e) {
    return this._parent.insertBefore(t15, e);
  },
  querySelector: function(t15) {
    return this._parent.querySelector(t15);
  },
  querySelectorAll: function(t15) {
    return this._parent.querySelectorAll(t15);
  }
};
function eW(t15) {
  return function() {
    return t15;
  };
}
function rW(t15, e, r, n, i, s) {
  for (var o = 0, a, l = e.length, c = s.length; o < c; ++o)
    (a = e[o]) ? (a.__data__ = s[o], n[o] = a) : r[o] = new Su(t15, s[o]);
  for (; o < l; ++o)
    (a = e[o]) && (i[o] = a);
}
function nW(t15, e, r, n, i, s, o) {
  var a, l, c = /* @__PURE__ */ new Map(), h10 = e.length, p = s.length, m = new Array(h10), g;
  for (a = 0; a < h10; ++a)
    (l = e[a]) && (m[a] = g = o.call(l, l.__data__, a, e) + "", c.has(g) ? i[a] = l : c.set(g, l));
  for (a = 0; a < p; ++a)
    g = o.call(t15, s[a], a, s) + "", (l = c.get(g)) ? (n[a] = l, l.__data__ = s[a], c.delete(g)) : r[a] = new Su(t15, s[a]);
  for (a = 0; a < h10; ++a)
    (l = e[a]) && c.get(m[a]) === l && (i[a] = l);
}
function iW(t15) {
  return t15.__data__;
}
function sW(t15, e) {
  if (!arguments.length) return Array.from(this, iW);
  var r = e ? nW : rW, n = this._parents, i = this._groups;
  typeof t15 != "function" && (t15 = eW(t15));
  for (var s = i.length, o = new Array(s), a = new Array(s), l = new Array(s), c = 0; c < s; ++c) {
    var h10 = n[c], p = i[c], m = p.length, g = oW(t15.call(h10, h10 && h10.__data__, c, n)), y = g.length, x = a[c] = new Array(y), k = o[c] = new Array(y), C = l[c] = new Array(m);
    r(h10, p, x, k, C, g, e);
    for (var _ = 0, $ = 0, L, B; _ < y; ++_)
      if (L = x[_]) {
        for (_ >= $ && ($ = _ + 1); !(B = k[$]) && ++$ < y; ) ;
        L._next = B || null;
      }
  }
  return o = new nn(o, n), o._enter = a, o._exit = l, o;
}
function oW(t15) {
  return typeof t15 == "object" && "length" in t15 ? t15 : Array.from(t15);
}
function aW() {
  return new nn(this._exit || this._groups.map(J7), this._parents);
}
function lW(t15, e, r) {
  var n = this.enter(), i = this, s = this.exit();
  return typeof t15 == "function" ? (n = t15(n), n && (n = n.selection())) : n = n.append(t15 + ""), e != null && (i = e(i), i && (i = i.selection())), r == null ? s.remove() : r(s), n && i ? n.merge(i).order() : i;
}
function cW(t15) {
  for (var e = t15.selection ? t15.selection() : t15, r = this._groups, n = e._groups, i = r.length, s = n.length, o = Math.min(i, s), a = new Array(i), l = 0; l < o; ++l)
    for (var c = r[l], h10 = n[l], p = c.length, m = a[l] = new Array(p), g, y = 0; y < p; ++y)
      (g = c[y] || h10[y]) && (m[y] = g);
  for (; l < i; ++l)
    a[l] = r[l];
  return new nn(a, this._parents);
}
function hW() {
  for (var t15 = this._groups, e = -1, r = t15.length; ++e < r; )
    for (var n = t15[e], i = n.length - 1, s = n[i], o; --i >= 0; )
      (o = n[i]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function uW(t15) {
  t15 || (t15 = dW);
  function e(p, m) {
    return p && m ? t15(p.__data__, m.__data__) : !p - !m;
  }
  for (var r = this._groups, n = r.length, i = new Array(n), s = 0; s < n; ++s) {
    for (var o = r[s], a = o.length, l = i[s] = new Array(a), c, h10 = 0; h10 < a; ++h10)
      (c = o[h10]) && (l[h10] = c);
    l.sort(e);
  }
  return new nn(i, this._parents).order();
}
function dW(t15, e) {
  return t15 < e ? -1 : t15 > e ? 1 : t15 >= e ? 0 : NaN;
}
function pW() {
  var t15 = arguments[0];
  return arguments[0] = this, t15.apply(null, arguments), this;
}
function fW() {
  return Array.from(this);
}
function mW() {
  for (var t15 = this._groups, e = 0, r = t15.length; e < r; ++e)
    for (var n = t15[e], i = 0, s = n.length; i < s; ++i) {
      var o = n[i];
      if (o) return o;
    }
  return null;
}
function gW() {
  let t15 = 0;
  for (const e of this) ++t15;
  return t15;
}
function yW() {
  return !this.node();
}
function bW(t15) {
  for (var e = this._groups, r = 0, n = e.length; r < n; ++r)
    for (var i = e[r], s = 0, o = i.length, a; s < o; ++s)
      (a = i[s]) && t15.call(a, a.__data__, s, i);
  return this;
}
function xW(t15) {
  return function() {
    this.removeAttribute(t15);
  };
}
function wW(t15) {
  return function() {
    this.removeAttributeNS(t15.space, t15.local);
  };
}
function kW(t15, e) {
  return function() {
    this.setAttribute(t15, e);
  };
}
function vW(t15, e) {
  return function() {
    this.setAttributeNS(t15.space, t15.local, e);
  };
}
function _W(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttribute(t15) : this.setAttribute(t15, r);
  };
}
function CW(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttributeNS(t15.space, t15.local) : this.setAttributeNS(t15.space, t15.local, r);
  };
}
function SW(t15, e) {
  var r = M0(t15);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((e == null ? r.local ? wW : xW : typeof e == "function" ? r.local ? CW : _W : r.local ? vW : kW)(r, e));
}
function tk(t15) {
  return t15.ownerDocument && t15.ownerDocument.defaultView || t15.document && t15 || t15.defaultView;
}
function TW(t15) {
  return function() {
    this.style.removeProperty(t15);
  };
}
function AW(t15, e, r) {
  return function() {
    this.style.setProperty(t15, e, r);
  };
}
function $W(t15, e, r) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(t15) : this.style.setProperty(t15, n, r);
  };
}
function EW(t15, e, r) {
  return arguments.length > 1 ? this.each((e == null ? TW : typeof e == "function" ? $W : AW)(t15, e, r ?? "")) : na(this.node(), t15);
}
function na(t15, e) {
  return t15.style.getPropertyValue(e) || tk(t15).getComputedStyle(t15, null).getPropertyValue(e);
}
function MW(t15) {
  return function() {
    delete this[t15];
  };
}
function BW(t15, e) {
  return function() {
    this[t15] = e;
  };
}
function LW(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? delete this[t15] : this[t15] = r;
  };
}
function DW(t15, e) {
  return arguments.length > 1 ? this.each((e == null ? MW : typeof e == "function" ? LW : BW)(t15, e)) : this.node()[t15];
}
function ek(t15) {
  return t15.trim().split(/^|\s+/);
}
function Gm(t15) {
  return t15.classList || new rk(t15);
}
function rk(t15) {
  this._node = t15, this._names = ek(t15.getAttribute("class") || "");
}
rk.prototype = {
  add: function(t15) {
    var e = this._names.indexOf(t15);
    e < 0 && (this._names.push(t15), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t15) {
    var e = this._names.indexOf(t15);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t15) {
    return this._names.indexOf(t15) >= 0;
  }
};
function nk(t15, e) {
  for (var r = Gm(t15), n = -1, i = e.length; ++n < i; ) r.add(e[n]);
}
function ik(t15, e) {
  for (var r = Gm(t15), n = -1, i = e.length; ++n < i; ) r.remove(e[n]);
}
function FW(t15) {
  return function() {
    nk(this, t15);
  };
}
function NW(t15) {
  return function() {
    ik(this, t15);
  };
}
function IW(t15, e) {
  return function() {
    (e.apply(this, arguments) ? nk : ik)(this, t15);
  };
}
function OW(t15, e) {
  var r = ek(t15 + "");
  if (arguments.length < 2) {
    for (var n = Gm(this.node()), i = -1, s = r.length; ++i < s; ) if (!n.contains(r[i])) return false;
    return true;
  }
  return this.each((typeof e == "function" ? IW : e ? FW : NW)(r, e));
}
function zW() {
  this.textContent = "";
}
function qW(t15) {
  return function() {
    this.textContent = t15;
  };
}
function RW(t15) {
  return function() {
    var e = t15.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function PW(t15) {
  return arguments.length ? this.each(t15 == null ? zW : (typeof t15 == "function" ? RW : qW)(t15)) : this.node().textContent;
}
function jW() {
  this.innerHTML = "";
}
function WW(t15) {
  return function() {
    this.innerHTML = t15;
  };
}
function HW(t15) {
  return function() {
    var e = t15.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function UW(t15) {
  return arguments.length ? this.each(t15 == null ? jW : (typeof t15 == "function" ? HW : WW)(t15)) : this.node().innerHTML;
}
function VW() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function GW() {
  return this.each(VW);
}
function XW() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function YW() {
  return this.each(XW);
}
function KW(t15) {
  var e = typeof t15 == "function" ? t15 : Y7(t15);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function ZW() {
  return null;
}
function QW(t15, e) {
  var r = typeof t15 == "function" ? t15 : Y7(t15), n = e == null ? ZW : typeof e == "function" ? e : Vm(e);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function JW() {
  var t15 = this.parentNode;
  t15 && t15.removeChild(this);
}
function tH() {
  return this.each(JW);
}
function eH() {
  var t15 = this.cloneNode(false), e = this.parentNode;
  return e ? e.insertBefore(t15, this.nextSibling) : t15;
}
function rH() {
  var t15 = this.cloneNode(true), e = this.parentNode;
  return e ? e.insertBefore(t15, this.nextSibling) : t15;
}
function nH(t15) {
  return this.select(t15 ? rH : eH);
}
function iH(t15) {
  return arguments.length ? this.property("__data__", t15) : this.node().__data__;
}
function sH(t15) {
  return function(e) {
    t15.call(this, e, this.__data__);
  };
}
function oH(t15) {
  return t15.trim().split(/^|\s+/).map(function(e) {
    var r = "", n = e.indexOf(".");
    return n >= 0 && (r = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: r };
  });
}
function aH(t15) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var r = 0, n = -1, i = e.length, s; r < i; ++r)
        s = e[r], (!t15.type || s.type === t15.type) && s.name === t15.name ? this.removeEventListener(s.type, s.listener, s.options) : e[++n] = s;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function lH(t15, e, r) {
  return function() {
    var n = this.__on, i, s = sH(e);
    if (n) {
      for (var o = 0, a = n.length; o < a; ++o)
        if ((i = n[o]).type === t15.type && i.name === t15.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = r), i.value = e;
          return;
        }
    }
    this.addEventListener(t15.type, s, r), i = { type: t15.type, name: t15.name, value: e, listener: s, options: r }, n ? n.push(i) : this.__on = [i];
  };
}
function cH(t15, e, r) {
  var n = oH(t15 + ""), i, s = n.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, c = a.length, h10; l < c; ++l)
        for (i = 0, h10 = a[l]; i < s; ++i)
          if ((o = n[i]).type === h10.type && o.name === h10.name)
            return h10.value;
    }
    return;
  }
  for (a = e ? lH : aH, i = 0; i < s; ++i) this.each(a(n[i], e, r));
  return this;
}
function sk(t15, e, r) {
  var n = tk(t15), i = n.CustomEvent;
  typeof i == "function" ? i = new i(e, r) : (i = n.document.createEvent("Event"), r ? (i.initEvent(e, r.bubbles, r.cancelable), i.detail = r.detail) : i.initEvent(e, false, false)), t15.dispatchEvent(i);
}
function hH(t15, e) {
  return function() {
    return sk(this, t15, e);
  };
}
function uH(t15, e) {
  return function() {
    return sk(this, t15, e.apply(this, arguments));
  };
}
function dH(t15, e) {
  return this.each((typeof e == "function" ? uH : hH)(t15, e));
}
function* pH() {
  for (var t15 = this._groups, e = 0, r = t15.length; e < r; ++e)
    for (var n = t15[e], i = 0, s = n.length, o; i < s; ++i)
      (o = n[i]) && (yield o);
}
var ok = [null];
function nn(t15, e) {
  this._groups = t15, this._parents = e;
}
function pc() {
  return new nn([[document.documentElement]], ok);
}
function fH() {
  return this;
}
nn.prototype = pc.prototype = {
  constructor: nn,
  select: Rj,
  selectAll: Hj,
  selectChild: Xj,
  selectChildren: Qj,
  filter: Jj,
  data: sW,
  enter: tW,
  exit: aW,
  join: lW,
  merge: cW,
  selection: fH,
  order: hW,
  sort: uW,
  call: pW,
  nodes: fW,
  node: mW,
  size: gW,
  empty: yW,
  each: bW,
  attr: SW,
  style: EW,
  property: DW,
  classed: OW,
  text: PW,
  html: UW,
  raise: GW,
  lower: YW,
  append: KW,
  insert: QW,
  remove: tH,
  clone: nH,
  datum: iH,
  on: cH,
  dispatch: dH,
  [Symbol.iterator]: pH
};
function ae(t15) {
  return typeof t15 == "string" ? new nn([[document.querySelector(t15)]], [document.documentElement]) : new nn([[t15]], ok);
}
function Xm(t15, e, r) {
  t15.prototype = e.prototype = r, r.constructor = t15;
}
function ak(t15, e) {
  var r = Object.create(t15.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function fc() {
}
var Wl = 0.7;
var Tu = 1 / Wl;
var Po = "\\s*([+-]?\\d+)\\s*";
var Hl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var Jn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var mH = /^#([0-9a-f]{3,8})$/;
var gH = new RegExp(`^rgb\\(${Po},${Po},${Po}\\)$`);
var yH = new RegExp(`^rgb\\(${Jn},${Jn},${Jn}\\)$`);
var bH = new RegExp(`^rgba\\(${Po},${Po},${Po},${Hl}\\)$`);
var xH = new RegExp(`^rgba\\(${Jn},${Jn},${Jn},${Hl}\\)$`);
var wH = new RegExp(`^hsl\\(${Hl},${Jn},${Jn}\\)$`);
var kH = new RegExp(`^hsla\\(${Hl},${Jn},${Jn},${Hl}\\)$`);
var e4 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Xm(fc, Ul, {
  copy(t15) {
    return Object.assign(new this.constructor(), this, t15);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: r4,
  // Deprecated! Use color.formatHex.
  formatHex: r4,
  formatHex8: vH,
  formatHsl: _H,
  formatRgb: n4,
  toString: n4
});
function r4() {
  return this.rgb().formatHex();
}
function vH() {
  return this.rgb().formatHex8();
}
function _H() {
  return lk(this).formatHsl();
}
function n4() {
  return this.rgb().formatRgb();
}
function Ul(t15) {
  var e, r;
  return t15 = (t15 + "").trim().toLowerCase(), (e = mH.exec(t15)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? i4(e) : r === 3 ? new Ur(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? ah(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? ah(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = gH.exec(t15)) ? new Ur(e[1], e[2], e[3], 1) : (e = yH.exec(t15)) ? new Ur(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = bH.exec(t15)) ? ah(e[1], e[2], e[3], e[4]) : (e = xH.exec(t15)) ? ah(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = wH.exec(t15)) ? a4(e[1], e[2] / 100, e[3] / 100, 1) : (e = kH.exec(t15)) ? a4(e[1], e[2] / 100, e[3] / 100, e[4]) : e4.hasOwnProperty(t15) ? i4(e4[t15]) : t15 === "transparent" ? new Ur(NaN, NaN, NaN, 0) : null;
}
function i4(t15) {
  return new Ur(t15 >> 16 & 255, t15 >> 8 & 255, t15 & 255, 1);
}
function ah(t15, e, r, n) {
  return n <= 0 && (t15 = e = r = NaN), new Ur(t15, e, r, n);
}
function CH(t15) {
  return t15 instanceof fc || (t15 = Ul(t15)), t15 ? (t15 = t15.rgb(), new Ur(t15.r, t15.g, t15.b, t15.opacity)) : new Ur();
}
function r1(t15, e, r, n) {
  return arguments.length === 1 ? CH(t15) : new Ur(t15, e, r, n ?? 1);
}
function Ur(t15, e, r, n) {
  this.r = +t15, this.g = +e, this.b = +r, this.opacity = +n;
}
Xm(Ur, r1, ak(fc, {
  brighter(t15) {
    return t15 = t15 == null ? Tu : Math.pow(Tu, t15), new Ur(this.r * t15, this.g * t15, this.b * t15, this.opacity);
  },
  darker(t15) {
    return t15 = t15 == null ? Wl : Math.pow(Wl, t15), new Ur(this.r * t15, this.g * t15, this.b * t15, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Ur(Gs(this.r), Gs(this.g), Gs(this.b), Au(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: s4,
  // Deprecated! Use color.formatHex.
  formatHex: s4,
  formatHex8: SH,
  formatRgb: o4,
  toString: o4
}));
function s4() {
  return `#${Hs(this.r)}${Hs(this.g)}${Hs(this.b)}`;
}
function SH() {
  return `#${Hs(this.r)}${Hs(this.g)}${Hs(this.b)}${Hs((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function o4() {
  const t15 = Au(this.opacity);
  return `${t15 === 1 ? "rgb(" : "rgba("}${Gs(this.r)}, ${Gs(this.g)}, ${Gs(this.b)}${t15 === 1 ? ")" : `, ${t15})`}`;
}
function Au(t15) {
  return isNaN(t15) ? 1 : Math.max(0, Math.min(1, t15));
}
function Gs(t15) {
  return Math.max(0, Math.min(255, Math.round(t15) || 0));
}
function Hs(t15) {
  return t15 = Gs(t15), (t15 < 16 ? "0" : "") + t15.toString(16);
}
function a4(t15, e, r, n) {
  return n <= 0 ? t15 = e = r = NaN : r <= 0 || r >= 1 ? t15 = e = NaN : e <= 0 && (t15 = NaN), new Tn(t15, e, r, n);
}
function lk(t15) {
  if (t15 instanceof Tn) return new Tn(t15.h, t15.s, t15.l, t15.opacity);
  if (t15 instanceof fc || (t15 = Ul(t15)), !t15) return new Tn();
  if (t15 instanceof Tn) return t15;
  t15 = t15.rgb();
  var e = t15.r / 255, r = t15.g / 255, n = t15.b / 255, i = Math.min(e, r, n), s = Math.max(e, r, n), o = NaN, a = s - i, l = (s + i) / 2;
  return a ? (e === s ? o = (r - n) / a + (r < n) * 6 : r === s ? o = (n - e) / a + 2 : o = (e - r) / a + 4, a /= l < 0.5 ? s + i : 2 - s - i, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new Tn(o, a, l, t15.opacity);
}
function TH(t15, e, r, n) {
  return arguments.length === 1 ? lk(t15) : new Tn(t15, e, r, n ?? 1);
}
function Tn(t15, e, r, n) {
  this.h = +t15, this.s = +e, this.l = +r, this.opacity = +n;
}
Xm(Tn, TH, ak(fc, {
  brighter(t15) {
    return t15 = t15 == null ? Tu : Math.pow(Tu, t15), new Tn(this.h, this.s, this.l * t15, this.opacity);
  },
  darker(t15) {
    return t15 = t15 == null ? Wl : Math.pow(Wl, t15), new Tn(this.h, this.s, this.l * t15, this.opacity);
  },
  rgb() {
    var t15 = this.h % 360 + (this.h < 0) * 360, e = isNaN(t15) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new Ur(
      Ap(t15 >= 240 ? t15 - 240 : t15 + 120, i, n),
      Ap(t15, i, n),
      Ap(t15 < 120 ? t15 + 240 : t15 - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new Tn(l4(this.h), lh(this.s), lh(this.l), Au(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t15 = Au(this.opacity);
    return `${t15 === 1 ? "hsl(" : "hsla("}${l4(this.h)}, ${lh(this.s) * 100}%, ${lh(this.l) * 100}%${t15 === 1 ? ")" : `, ${t15})`}`;
  }
}));
function l4(t15) {
  return t15 = (t15 || 0) % 360, t15 < 0 ? t15 + 360 : t15;
}
function lh(t15) {
  return Math.max(0, Math.min(1, t15 || 0));
}
function Ap(t15, e, r) {
  return (t15 < 60 ? e + (r - e) * t15 / 60 : t15 < 180 ? r : t15 < 240 ? e + (r - e) * (240 - t15) / 60 : e) * 255;
}
var Ym = (t15) => () => t15;
function ck(t15, e) {
  return function(r) {
    return t15 + r * e;
  };
}
function AH(t15, e, r) {
  return t15 = Math.pow(t15, r), e = Math.pow(e, r) - t15, r = 1 / r, function(n) {
    return Math.pow(t15 + n * e, r);
  };
}
function snt(t15, e) {
  var r = e - t15;
  return r ? ck(t15, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) : Ym(isNaN(t15) ? e : t15);
}
function $H(t15) {
  return (t15 = +t15) == 1 ? hk : function(e, r) {
    return r - e ? AH(e, r, t15) : Ym(isNaN(e) ? r : e);
  };
}
function hk(t15, e) {
  var r = e - t15;
  return r ? ck(t15, r) : Ym(isNaN(t15) ? e : t15);
}
var c4 = function t5(e) {
  var r = $H(e);
  function n(i, s) {
    var o = r((i = r1(i)).r, (s = r1(s)).r), a = r(i.g, s.g), l = r(i.b, s.b), c = hk(i.opacity, s.opacity);
    return function(h10) {
      return i.r = o(h10), i.g = a(h10), i.b = l(h10), i.opacity = c(h10), i + "";
    };
  }
  return n.gamma = t5, n;
}(1);
function Ji(t15, e) {
  return t15 = +t15, e = +e, function(r) {
    return t15 * (1 - r) + e * r;
  };
}
var n1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var $p = new RegExp(n1.source, "g");
function EH(t15) {
  return function() {
    return t15;
  };
}
function MH(t15) {
  return function(e) {
    return t15(e) + "";
  };
}
function BH(t15, e) {
  var r = n1.lastIndex = $p.lastIndex = 0, n, i, s, o = -1, a = [], l = [];
  for (t15 = t15 + "", e = e + ""; (n = n1.exec(t15)) && (i = $p.exec(e)); )
    (s = i.index) > r && (s = e.slice(r, s), a[o] ? a[o] += s : a[++o] = s), (n = n[0]) === (i = i[0]) ? a[o] ? a[o] += i : a[++o] = i : (a[++o] = null, l.push({ i: o, x: Ji(n, i) })), r = $p.lastIndex;
  return r < e.length && (s = e.slice(r), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? MH(l[0].x) : EH(e) : (e = l.length, function(c) {
    for (var h10 = 0, p; h10 < e; ++h10) a[(p = l[h10]).i] = p.x(c);
    return a.join("");
  });
}
var h4 = 180 / Math.PI;
var uk = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function dk(t15, e, r, n, i, s) {
  var o, a, l;
  return (o = Math.sqrt(t15 * t15 + e * e)) && (t15 /= o, e /= o), (l = t15 * r + e * n) && (r -= t15 * l, n -= e * l), (a = Math.sqrt(r * r + n * n)) && (r /= a, n /= a, l /= a), t15 * n < e * r && (t15 = -t15, e = -e, l = -l, o = -o), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(e, t15) * h4,
    skewX: Math.atan(l) * h4,
    scaleX: o,
    scaleY: a
  };
}
var ch;
function LH(t15) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t15 + "");
  return e.isIdentity ? uk : dk(e.a, e.b, e.c, e.d, e.e, e.f);
}
function DH(t15) {
  return t15 == null || (ch || (ch = document.createElementNS("http://www.w3.org/2000/svg", "g")), ch.setAttribute("transform", t15), !(t15 = ch.transform.baseVal.consolidate())) ? uk : (t15 = t15.matrix, dk(t15.a, t15.b, t15.c, t15.d, t15.e, t15.f));
}
function pk(t15, e, r, n) {
  function i(c) {
    return c.length ? c.pop() + " " : "";
  }
  function s(c, h10, p, m, g, y) {
    if (c !== p || h10 !== m) {
      var x = g.push("translate(", null, e, null, r);
      y.push({ i: x - 4, x: Ji(c, p) }, { i: x - 2, x: Ji(h10, m) });
    } else (p || m) && g.push("translate(" + p + e + m + r);
  }
  function o(c, h10, p, m) {
    c !== h10 ? (c - h10 > 180 ? h10 += 360 : h10 - c > 180 && (c += 360), m.push({ i: p.push(i(p) + "rotate(", null, n) - 2, x: Ji(c, h10) })) : h10 && p.push(i(p) + "rotate(" + h10 + n);
  }
  function a(c, h10, p, m) {
    c !== h10 ? m.push({ i: p.push(i(p) + "skewX(", null, n) - 2, x: Ji(c, h10) }) : h10 && p.push(i(p) + "skewX(" + h10 + n);
  }
  function l(c, h10, p, m, g, y) {
    if (c !== p || h10 !== m) {
      var x = g.push(i(g) + "scale(", null, ",", null, ")");
      y.push({ i: x - 4, x: Ji(c, p) }, { i: x - 2, x: Ji(h10, m) });
    } else (p !== 1 || m !== 1) && g.push(i(g) + "scale(" + p + "," + m + ")");
  }
  return function(c, h10) {
    var p = [], m = [];
    return c = t15(c), h10 = t15(h10), s(c.translateX, c.translateY, h10.translateX, h10.translateY, p, m), o(c.rotate, h10.rotate, p, m), a(c.skewX, h10.skewX, p, m), l(c.scaleX, c.scaleY, h10.scaleX, h10.scaleY, p, m), c = h10 = null, function(g) {
      for (var y = -1, x = m.length, k; ++y < x; ) p[(k = m[y]).i] = k.x(g);
      return p.join("");
    };
  };
}
var FH = pk(LH, "px, ", "px)", "deg)");
var NH = pk(DH, ", ", ")", ")");
var ia = 0;
var cl = 0;
var Ua = 0;
var fk = 1e3;
var $u;
var hl;
var Eu = 0;
var ro = 0;
var B0 = 0;
var Vl = typeof performance == "object" && performance.now ? performance : Date;
var mk = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t15) {
  setTimeout(t15, 17);
};
function Km() {
  return ro || (mk(IH), ro = Vl.now() + B0);
}
function IH() {
  ro = 0;
}
function Mu() {
  this._call = this._time = this._next = null;
}
Mu.prototype = gk.prototype = {
  constructor: Mu,
  restart: function(t15, e, r) {
    if (typeof t15 != "function") throw new TypeError("callback is not a function");
    r = (r == null ? Km() : +r) + (e == null ? 0 : +e), !this._next && hl !== this && (hl ? hl._next = this : $u = this, hl = this), this._call = t15, this._time = r, i1();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, i1());
  }
};
function gk(t15, e, r) {
  var n = new Mu();
  return n.restart(t15, e, r), n;
}
function OH() {
  Km(), ++ia;
  for (var t15 = $u, e; t15; )
    (e = ro - t15._time) >= 0 && t15._call.call(void 0, e), t15 = t15._next;
  --ia;
}
function u4() {
  ro = (Eu = Vl.now()) + B0, ia = cl = 0;
  try {
    OH();
  } finally {
    ia = 0, qH(), ro = 0;
  }
}
function zH() {
  var t15 = Vl.now(), e = t15 - Eu;
  e > fk && (B0 -= e, Eu = t15);
}
function qH() {
  for (var t15, e = $u, r, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), t15 = e, e = e._next) : (r = e._next, e._next = null, e = t15 ? t15._next = r : $u = r);
  hl = t15, i1(n);
}
function i1(t15) {
  if (!ia) {
    cl && (cl = clearTimeout(cl));
    var e = t15 - ro;
    e > 24 ? (t15 < 1 / 0 && (cl = setTimeout(u4, t15 - Vl.now() - B0)), Ua && (Ua = clearInterval(Ua))) : (Ua || (Eu = Vl.now(), Ua = setInterval(zH, fk)), ia = 1, mk(u4));
  }
}
function d4(t15, e, r) {
  var n = new Mu();
  return e = e == null ? 0 : +e, n.restart((i) => {
    n.stop(), t15(i + e);
  }, e, r), n;
}
var RH = X7("start", "end", "cancel", "interrupt");
var PH = [];
var yk = 0;
var p4 = 1;
var s1 = 2;
var Ih = 3;
var f4 = 4;
var o1 = 5;
var Oh = 6;
function L0(t15, e, r, n, i, s) {
  var o = t15.__transition;
  if (!o) t15.__transition = {};
  else if (r in o) return;
  jH(t15, r, {
    name: e,
    index: n,
    // For context during callback.
    group: i,
    // For context during callback.
    on: RH,
    tween: PH,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: yk
  });
}
function Zm(t15, e) {
  var r = Fn(t15, e);
  if (r.state > yk) throw new Error("too late; already scheduled");
  return r;
}
function ai(t15, e) {
  var r = Fn(t15, e);
  if (r.state > Ih) throw new Error("too late; already running");
  return r;
}
function Fn(t15, e) {
  var r = t15.__transition;
  if (!r || !(r = r[e])) throw new Error("transition not found");
  return r;
}
function jH(t15, e, r) {
  var n = t15.__transition, i;
  n[e] = r, r.timer = gk(s, 0, r.time);
  function s(c) {
    r.state = p4, r.timer.restart(o, r.delay, r.time), r.delay <= c && o(c - r.delay);
  }
  function o(c) {
    var h10, p, m, g;
    if (r.state !== p4) return l();
    for (h10 in n)
      if (g = n[h10], g.name === r.name) {
        if (g.state === Ih) return d4(o);
        g.state === f4 ? (g.state = Oh, g.timer.stop(), g.on.call("interrupt", t15, t15.__data__, g.index, g.group), delete n[h10]) : +h10 < e && (g.state = Oh, g.timer.stop(), g.on.call("cancel", t15, t15.__data__, g.index, g.group), delete n[h10]);
      }
    if (d4(function() {
      r.state === Ih && (r.state = f4, r.timer.restart(a, r.delay, r.time), a(c));
    }), r.state = s1, r.on.call("start", t15, t15.__data__, r.index, r.group), r.state === s1) {
      for (r.state = Ih, i = new Array(m = r.tween.length), h10 = 0, p = -1; h10 < m; ++h10)
        (g = r.tween[h10].value.call(t15, t15.__data__, r.index, r.group)) && (i[++p] = g);
      i.length = p + 1;
    }
  }
  function a(c) {
    for (var h10 = c < r.duration ? r.ease.call(null, c / r.duration) : (r.timer.restart(l), r.state = o1, 1), p = -1, m = i.length; ++p < m; )
      i[p].call(t15, h10);
    r.state === o1 && (r.on.call("end", t15, t15.__data__, r.index, r.group), l());
  }
  function l() {
    r.state = Oh, r.timer.stop(), delete n[e];
    for (var c in n) return;
    delete t15.__transition;
  }
}
function WH(t15, e) {
  var r = t15.__transition, n, i, s = true, o;
  if (r) {
    e = e == null ? null : e + "";
    for (o in r) {
      if ((n = r[o]).name !== e) {
        s = false;
        continue;
      }
      i = n.state > s1 && n.state < o1, n.state = Oh, n.timer.stop(), n.on.call(i ? "interrupt" : "cancel", t15, t15.__data__, n.index, n.group), delete r[o];
    }
    s && delete t15.__transition;
  }
}
function HH(t15) {
  return this.each(function() {
    WH(this, t15);
  });
}
function UH(t15, e) {
  var r, n;
  return function() {
    var i = ai(this, t15), s = i.tween;
    if (s !== r) {
      n = r = s;
      for (var o = 0, a = n.length; o < a; ++o)
        if (n[o].name === e) {
          n = n.slice(), n.splice(o, 1);
          break;
        }
    }
    i.tween = n;
  };
}
function VH(t15, e, r) {
  var n, i;
  if (typeof r != "function") throw new Error();
  return function() {
    var s = ai(this, t15), o = s.tween;
    if (o !== n) {
      i = (n = o).slice();
      for (var a = { name: e, value: r }, l = 0, c = i.length; l < c; ++l)
        if (i[l].name === e) {
          i[l] = a;
          break;
        }
      l === c && i.push(a);
    }
    s.tween = i;
  };
}
function GH(t15, e) {
  var r = this._id;
  if (t15 += "", arguments.length < 2) {
    for (var n = Fn(this.node(), r).tween, i = 0, s = n.length, o; i < s; ++i)
      if ((o = n[i]).name === t15)
        return o.value;
    return null;
  }
  return this.each((e == null ? UH : VH)(r, t15, e));
}
function Qm(t15, e, r) {
  var n = t15._id;
  return t15.each(function() {
    var i = ai(this, n);
    (i.value || (i.value = {}))[e] = r.apply(this, arguments);
  }), function(i) {
    return Fn(i, n).value[e];
  };
}
function bk(t15, e) {
  var r;
  return (typeof e == "number" ? Ji : e instanceof Ul ? c4 : (r = Ul(e)) ? (e = r, c4) : BH)(t15, e);
}
function XH(t15) {
  return function() {
    this.removeAttribute(t15);
  };
}
function YH(t15) {
  return function() {
    this.removeAttributeNS(t15.space, t15.local);
  };
}
function KH(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var o = this.getAttribute(t15);
    return o === i ? null : o === n ? s : s = e(n = o, r);
  };
}
function ZH(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var o = this.getAttributeNS(t15.space, t15.local);
    return o === i ? null : o === n ? s : s = e(n = o, r);
  };
}
function QH(t15, e, r) {
  var n, i, s;
  return function() {
    var o, a = r(this), l;
    return a == null ? void this.removeAttribute(t15) : (o = this.getAttribute(t15), l = a + "", o === l ? null : o === n && l === i ? s : (i = l, s = e(n = o, a)));
  };
}
function JH(t15, e, r) {
  var n, i, s;
  return function() {
    var o, a = r(this), l;
    return a == null ? void this.removeAttributeNS(t15.space, t15.local) : (o = this.getAttributeNS(t15.space, t15.local), l = a + "", o === l ? null : o === n && l === i ? s : (i = l, s = e(n = o, a)));
  };
}
function tU(t15, e) {
  var r = M0(t15), n = r === "transform" ? NH : bk;
  return this.attrTween(t15, typeof e == "function" ? (r.local ? JH : QH)(r, n, Qm(this, "attr." + t15, e)) : e == null ? (r.local ? YH : XH)(r) : (r.local ? ZH : KH)(r, n, e));
}
function eU(t15, e) {
  return function(r) {
    this.setAttribute(t15, e.call(this, r));
  };
}
function rU(t15, e) {
  return function(r) {
    this.setAttributeNS(t15.space, t15.local, e.call(this, r));
  };
}
function nU(t15, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && rU(t15, s)), r;
  }
  return i._value = e, i;
}
function iU(t15, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && eU(t15, s)), r;
  }
  return i._value = e, i;
}
function sU(t15, e) {
  var r = "attr." + t15;
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (e == null) return this.tween(r, null);
  if (typeof e != "function") throw new Error();
  var n = M0(t15);
  return this.tween(r, (n.local ? nU : iU)(n, e));
}
function oU(t15, e) {
  return function() {
    Zm(this, t15).delay = +e.apply(this, arguments);
  };
}
function aU(t15, e) {
  return e = +e, function() {
    Zm(this, t15).delay = e;
  };
}
function lU(t15) {
  var e = this._id;
  return arguments.length ? this.each((typeof t15 == "function" ? oU : aU)(e, t15)) : Fn(this.node(), e).delay;
}
function cU(t15, e) {
  return function() {
    ai(this, t15).duration = +e.apply(this, arguments);
  };
}
function hU(t15, e) {
  return e = +e, function() {
    ai(this, t15).duration = e;
  };
}
function uU(t15) {
  var e = this._id;
  return arguments.length ? this.each((typeof t15 == "function" ? cU : hU)(e, t15)) : Fn(this.node(), e).duration;
}
function dU(t15, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    ai(this, t15).ease = e;
  };
}
function pU(t15) {
  var e = this._id;
  return arguments.length ? this.each(dU(e, t15)) : Fn(this.node(), e).ease;
}
function fU(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    if (typeof r != "function") throw new Error();
    ai(this, t15).ease = r;
  };
}
function mU(t15) {
  if (typeof t15 != "function") throw new Error();
  return this.each(fU(this._id, t15));
}
function gU(t15) {
  typeof t15 != "function" && (t15 = Z7(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], o = s.length, a = n[i] = [], l, c = 0; c < o; ++c)
      (l = s[c]) && t15.call(l, l.__data__, c, s) && a.push(l);
  return new Ni(n, this._parents, this._name, this._id);
}
function yU(t15) {
  if (t15._id !== this._id) throw new Error();
  for (var e = this._groups, r = t15._groups, n = e.length, i = r.length, s = Math.min(n, i), o = new Array(n), a = 0; a < s; ++a)
    for (var l = e[a], c = r[a], h10 = l.length, p = o[a] = new Array(h10), m, g = 0; g < h10; ++g)
      (m = l[g] || c[g]) && (p[g] = m);
  for (; a < n; ++a)
    o[a] = e[a];
  return new Ni(o, this._parents, this._name, this._id);
}
function bU(t15) {
  return (t15 + "").trim().split(/^|\s+/).every(function(e) {
    var r = e.indexOf(".");
    return r >= 0 && (e = e.slice(0, r)), !e || e === "start";
  });
}
function xU(t15, e, r) {
  var n, i, s = bU(e) ? Zm : ai;
  return function() {
    var o = s(this, t15), a = o.on;
    a !== n && (i = (n = a).copy()).on(e, r), o.on = i;
  };
}
function wU(t15, e) {
  var r = this._id;
  return arguments.length < 2 ? Fn(this.node(), r).on.on(t15) : this.each(xU(r, t15, e));
}
function kU(t15) {
  return function() {
    var e = this.parentNode;
    for (var r in this.__transition) if (+r !== t15) return;
    e && e.removeChild(this);
  };
}
function vU() {
  return this.on("end.remove", kU(this._id));
}
function _U(t15) {
  var e = this._name, r = this._id;
  typeof t15 != "function" && (t15 = Vm(t15));
  for (var n = this._groups, i = n.length, s = new Array(i), o = 0; o < i; ++o)
    for (var a = n[o], l = a.length, c = s[o] = new Array(l), h10, p, m = 0; m < l; ++m)
      (h10 = a[m]) && (p = t15.call(h10, h10.__data__, m, a)) && ("__data__" in h10 && (p.__data__ = h10.__data__), c[m] = p, L0(c[m], e, r, m, c, Fn(h10, r)));
  return new Ni(s, this._parents, e, r);
}
function CU(t15) {
  var e = this._name, r = this._id;
  typeof t15 != "function" && (t15 = K7(t15));
  for (var n = this._groups, i = n.length, s = [], o = [], a = 0; a < i; ++a)
    for (var l = n[a], c = l.length, h10, p = 0; p < c; ++p)
      if (h10 = l[p]) {
        for (var m = t15.call(h10, h10.__data__, p, l), g, y = Fn(h10, r), x = 0, k = m.length; x < k; ++x)
          (g = m[x]) && L0(g, e, r, x, m, y);
        s.push(m), o.push(h10);
      }
  return new Ni(s, o, e, r);
}
var SU = pc.prototype.constructor;
function TU() {
  return new SU(this._groups, this._parents);
}
function AU(t15, e) {
  var r, n, i;
  return function() {
    var s = na(this, t15), o = (this.style.removeProperty(t15), na(this, t15));
    return s === o ? null : s === r && o === n ? i : i = e(r = s, n = o);
  };
}
function xk(t15) {
  return function() {
    this.style.removeProperty(t15);
  };
}
function $U(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var o = na(this, t15);
    return o === i ? null : o === n ? s : s = e(n = o, r);
  };
}
function EU(t15, e, r) {
  var n, i, s;
  return function() {
    var o = na(this, t15), a = r(this), l = a + "";
    return a == null && (l = a = (this.style.removeProperty(t15), na(this, t15))), o === l ? null : o === n && l === i ? s : (i = l, s = e(n = o, a));
  };
}
function MU(t15, e) {
  var r, n, i, s = "style." + e, o = "end." + s, a;
  return function() {
    var l = ai(this, t15), c = l.on, h10 = l.value[s] == null ? a || (a = xk(e)) : void 0;
    (c !== r || i !== h10) && (n = (r = c).copy()).on(o, i = h10), l.on = n;
  };
}
function BU(t15, e, r) {
  var n = (t15 += "") == "transform" ? FH : bk;
  return e == null ? this.styleTween(t15, AU(t15, n)).on("end.style." + t15, xk(t15)) : typeof e == "function" ? this.styleTween(t15, EU(t15, n, Qm(this, "style." + t15, e))).each(MU(this._id, t15)) : this.styleTween(t15, $U(t15, n, e), r).on("end.style." + t15, null);
}
function LU(t15, e, r) {
  return function(n) {
    this.style.setProperty(t15, e.call(this, n), r);
  };
}
function DU(t15, e, r) {
  var n, i;
  function s() {
    var o = e.apply(this, arguments);
    return o !== i && (n = (i = o) && LU(t15, o, r)), n;
  }
  return s._value = e, s;
}
function FU(t15, e, r) {
  var n = "style." + (t15 += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, DU(t15, e, r ?? ""));
}
function NU(t15) {
  return function() {
    this.textContent = t15;
  };
}
function IU(t15) {
  return function() {
    var e = t15(this);
    this.textContent = e ?? "";
  };
}
function OU(t15) {
  return this.tween("text", typeof t15 == "function" ? IU(Qm(this, "text", t15)) : NU(t15 == null ? "" : t15 + ""));
}
function zU(t15) {
  return function(e) {
    this.textContent = t15.call(this, e);
  };
}
function qU(t15) {
  var e, r;
  function n() {
    var i = t15.apply(this, arguments);
    return i !== r && (e = (r = i) && zU(i)), e;
  }
  return n._value = t15, n;
}
function RU(t15) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t15 == null) return this.tween(e, null);
  if (typeof t15 != "function") throw new Error();
  return this.tween(e, qU(t15));
}
function PU() {
  for (var t15 = this._name, e = this._id, r = wk(), n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var o = n[s], a = o.length, l, c = 0; c < a; ++c)
      if (l = o[c]) {
        var h10 = Fn(l, e);
        L0(l, t15, r, c, o, {
          time: h10.time + h10.delay + h10.duration,
          delay: 0,
          duration: h10.duration,
          ease: h10.ease
        });
      }
  return new Ni(n, this._parents, t15, r);
}
function jU() {
  var t15, e, r = this, n = r._id, i = r.size();
  return new Promise(function(s, o) {
    var a = { value: o }, l = { value: function() {
      --i === 0 && s();
    } };
    r.each(function() {
      var c = ai(this, n), h10 = c.on;
      h10 !== t15 && (e = (t15 = h10).copy(), e._.cancel.push(a), e._.interrupt.push(a), e._.end.push(l)), c.on = e;
    }), i === 0 && s();
  });
}
var WU = 0;
function Ni(t15, e, r, n) {
  this._groups = t15, this._parents = e, this._name = r, this._id = n;
}
function wk() {
  return ++WU;
}
var wi = pc.prototype;
Ni.prototype = {
  constructor: Ni,
  select: _U,
  selectAll: CU,
  selectChild: wi.selectChild,
  selectChildren: wi.selectChildren,
  filter: gU,
  merge: yU,
  selection: TU,
  transition: PU,
  call: wi.call,
  nodes: wi.nodes,
  node: wi.node,
  size: wi.size,
  empty: wi.empty,
  each: wi.each,
  on: wU,
  attr: tU,
  attrTween: sU,
  style: BU,
  styleTween: FU,
  text: OU,
  textTween: RU,
  remove: vU,
  tween: GH,
  delay: lU,
  duration: uU,
  ease: pU,
  easeVarying: mU,
  end: jU,
  [Symbol.iterator]: wi[Symbol.iterator]
};
function HU(t15) {
  return ((t15 *= 2) <= 1 ? t15 * t15 * t15 : (t15 -= 2) * t15 * t15 + 2) / 2;
}
var UU = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: HU
};
function VU(t15, e) {
  for (var r; !(r = t15.__transition) || !(r = r[e]); )
    if (!(t15 = t15.parentNode))
      throw new Error(`transition ${e} not found`);
  return r;
}
function GU(t15) {
  var e, r;
  t15 instanceof Ni ? (e = t15._id, t15 = t15._name) : (e = wk(), (r = UU).time = Km(), t15 = t15 == null ? null : t15 + "");
  for (var n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var o = n[s], a = o.length, l, c = 0; c < a; ++c)
      (l = o[c]) && L0(l, t15, e, c, o, r || VU(l, e));
  return new Ni(n, this._parents, t15, e);
}
pc.prototype.interrupt = HH;
pc.prototype.transition = GU;
var a1 = Math.PI;
var l1 = 2 * a1;
var Fs = 1e-6;
var XU = l1 - Fs;
function kk(t15) {
  this._ += t15[0];
  for (let e = 1, r = t15.length; e < r; ++e)
    this._ += arguments[e] + t15[e];
}
function YU(t15) {
  let e = Math.floor(t15);
  if (!(e >= 0)) throw new Error(`invalid digits: ${t15}`);
  if (e > 15) return kk;
  const r = 10 ** e;
  return function(n) {
    this._ += n[0];
    for (let i = 1, s = n.length; i < s; ++i)
      this._ += Math.round(arguments[i] * r) / r + n[i];
  };
}
var KU = class {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? kk : YU(e);
  }
  moveTo(e, r) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, r) {
    this._append`L${this._x1 = +e},${this._y1 = +r}`;
  }
  quadraticCurveTo(e, r, n, i) {
    this._append`Q${+e},${+r},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(e, r, n, i, s, o) {
    this._append`C${+e},${+r},${+n},${+i},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(e, r, n, i, s) {
    if (e = +e, r = +r, n = +n, i = +i, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, l = n - e, c = i - r, h10 = o - e, p = a - r, m = h10 * h10 + p * p;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = r}`;
    else if (m > Fs) if (!(Math.abs(p * l - c * h10) > Fs) || !s)
      this._append`L${this._x1 = e},${this._y1 = r}`;
    else {
      let g = n - o, y = i - a, x = l * l + c * c, k = g * g + y * y, C = Math.sqrt(x), _ = Math.sqrt(m), $ = s * Math.tan((a1 - Math.acos((x + m - k) / (2 * C * _))) / 2), L = $ / _, B = $ / C;
      Math.abs(L - 1) > Fs && this._append`L${e + L * h10},${r + L * p}`, this._append`A${s},${s},0,0,${+(p * g > h10 * y)},${this._x1 = e + B * l},${this._y1 = r + B * c}`;
    }
  }
  arc(e, r, n, i, s, o) {
    if (e = +e, r = +r, n = +n, o = !!o, n < 0) throw new Error(`negative radius: ${n}`);
    let a = n * Math.cos(i), l = n * Math.sin(i), c = e + a, h10 = r + l, p = 1 ^ o, m = o ? i - s : s - i;
    this._x1 === null ? this._append`M${c},${h10}` : (Math.abs(this._x1 - c) > Fs || Math.abs(this._y1 - h10) > Fs) && this._append`L${c},${h10}`, n && (m < 0 && (m = m % l1 + l1), m > XU ? this._append`A${n},${n},0,1,${p},${e - a},${r - l}A${n},${n},0,1,${p},${this._x1 = c},${this._y1 = h10}` : m > Fs && this._append`A${n},${n},0,${+(m >= a1)},${p},${this._x1 = e + n * Math.cos(s)},${this._y1 = r + n * Math.sin(s)}`);
  }
  rect(e, r, n, i) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function To(t15) {
  return function() {
    return t15;
  };
}
var ont = Math.abs;
var ant = Math.atan2;
var lnt = Math.cos;
var cnt = Math.max;
var hnt = Math.min;
var unt = Math.sin;
var dnt = Math.sqrt;
var m4 = 1e-12;
var Jm = Math.PI;
var g4 = Jm / 2;
var pnt = 2 * Jm;
function fnt(t15) {
  return t15 > 1 ? 0 : t15 < -1 ? Jm : Math.acos(t15);
}
function mnt(t15) {
  return t15 >= 1 ? g4 : t15 <= -1 ? -g4 : Math.asin(t15);
}
function ZU(t15) {
  let e = 3;
  return t15.digits = function(r) {
    if (!arguments.length) return e;
    if (r == null)
      e = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
      e = n;
    }
    return t15;
  }, () => new KU(e);
}
function QU(t15) {
  return typeof t15 == "object" && "length" in t15 ? t15 : Array.from(t15);
}
function vk(t15) {
  this._context = t15;
}
vk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(t15, e);
        break;
    }
  }
};
function Bu(t15) {
  return new vk(t15);
}
function JU(t15) {
  return t15[0];
}
function tV(t15) {
  return t15[1];
}
function eV(t15, e) {
  var r = To(true), n = null, i = Bu, s = null, o = ZU(a);
  t15 = typeof t15 == "function" ? t15 : t15 === void 0 ? JU : To(t15), e = typeof e == "function" ? e : e === void 0 ? tV : To(e);
  function a(l) {
    var c, h10 = (l = QU(l)).length, p, m = false, g;
    for (n == null && (s = i(g = o())), c = 0; c <= h10; ++c)
      !(c < h10 && r(p = l[c], c, l)) === m && ((m = !m) ? s.lineStart() : s.lineEnd()), m && s.point(+t15(p, c, l), +e(p, c, l));
    if (g) return s = null, g + "" || null;
  }
  return a.x = function(l) {
    return arguments.length ? (t15 = typeof l == "function" ? l : To(+l), a) : t15;
  }, a.y = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : To(+l), a) : e;
  }, a.defined = function(l) {
    return arguments.length ? (r = typeof l == "function" ? l : To(!!l), a) : r;
  }, a.curve = function(l) {
    return arguments.length ? (i = l, n != null && (s = i(n)), a) : i;
  }, a.context = function(l) {
    return arguments.length ? (l == null ? n = s = null : s = i(n = l), a) : n;
  }, a;
}
var _k = class {
  constructor(e, r) {
    this._context = e, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, r) {
    switch (e = +e, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, r, e, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, e, this._y0, e, r);
        break;
      }
    }
    this._x0 = e, this._y0 = r;
  }
};
function Ck(t15) {
  return new _k(t15, true);
}
function Sk(t15) {
  return new _k(t15, false);
}
function ds() {
}
function Lu(t15, e, r) {
  t15._context.bezierCurveTo(
    (2 * t15._x0 + t15._x1) / 3,
    (2 * t15._y0 + t15._y1) / 3,
    (t15._x0 + 2 * t15._x1) / 3,
    (t15._y0 + 2 * t15._y1) / 3,
    (t15._x0 + 4 * t15._x1 + e) / 6,
    (t15._y0 + 4 * t15._y1 + r) / 6
  );
}
function D0(t15) {
  this._context = t15;
}
D0.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        Lu(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        Lu(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t15, this._y0 = this._y1, this._y1 = e;
  }
};
function zh(t15) {
  return new D0(t15);
}
function Tk(t15) {
  this._context = t15;
}
Tk.prototype = {
  areaStart: ds,
  areaEnd: ds,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._x2 = t15, this._y2 = e;
        break;
      case 1:
        this._point = 2, this._x3 = t15, this._y3 = e;
        break;
      case 2:
        this._point = 3, this._x4 = t15, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t15) / 6, (this._y0 + 4 * this._y1 + e) / 6);
        break;
      default:
        Lu(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t15, this._y0 = this._y1, this._y1 = e;
  }
};
function rV(t15) {
  return new Tk(t15);
}
function Ak(t15) {
  this._context = t15;
}
Ak.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + t15) / 6, n = (this._y0 + 4 * this._y1 + e) / 6;
        this._line ? this._context.lineTo(r, n) : this._context.moveTo(r, n);
        break;
      case 3:
        this._point = 4;
      default:
        Lu(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t15, this._y0 = this._y1, this._y1 = e;
  }
};
function nV(t15) {
  return new Ak(t15);
}
function $k(t15, e) {
  this._basis = new D0(t15), this._beta = e;
}
$k.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var t15 = this._x, e = this._y, r = t15.length - 1;
    if (r > 0)
      for (var n = t15[0], i = e[0], s = t15[r] - n, o = e[r] - i, a = -1, l; ++a <= r; )
        l = a / r, this._basis.point(
          this._beta * t15[a] + (1 - this._beta) * (n + l * s),
          this._beta * e[a] + (1 - this._beta) * (i + l * o)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(t15, e) {
    this._x.push(+t15), this._y.push(+e);
  }
};
var iV = function t8(e) {
  function r(n) {
    return e === 1 ? new D0(n) : new $k(n, e);
  }
  return r.beta = function(n) {
    return t8(+n);
  }, r;
}(0.85);
function Du(t15, e, r) {
  t15._context.bezierCurveTo(
    t15._x1 + t15._k * (t15._x2 - t15._x0),
    t15._y1 + t15._k * (t15._y2 - t15._y0),
    t15._x2 + t15._k * (t15._x1 - e),
    t15._y2 + t15._k * (t15._y1 - r),
    t15._x2,
    t15._y2
  );
}
function tg(t15, e) {
  this._context = t15, this._k = (1 - e) / 6;
}
tg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Du(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2, this._x1 = t15, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      default:
        Du(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var Ek = function t9(e) {
  function r(n) {
    return new tg(n, e);
  }
  return r.tension = function(n) {
    return t9(+n);
  }, r;
}(0);
function eg(t15, e) {
  this._context = t15, this._k = (1 - e) / 6;
}
eg.prototype = {
  areaStart: ds,
  areaEnd: ds,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._x3 = t15, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t15, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t15, this._y5 = e;
        break;
      default:
        Du(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var sV = function t10(e) {
  function r(n) {
    return new eg(n, e);
  }
  return r.tension = function(n) {
    return t10(+n);
  }, r;
}(0);
function rg(t15, e) {
  this._context = t15, this._k = (1 - e) / 6;
}
rg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Du(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var oV = function t11(e) {
  function r(n) {
    return new rg(n, e);
  }
  return r.tension = function(n) {
    return t11(+n);
  }, r;
}(0);
function ng(t15, e, r) {
  var n = t15._x1, i = t15._y1, s = t15._x2, o = t15._y2;
  if (t15._l01_a > m4) {
    var a = 2 * t15._l01_2a + 3 * t15._l01_a * t15._l12_a + t15._l12_2a, l = 3 * t15._l01_a * (t15._l01_a + t15._l12_a);
    n = (n * a - t15._x0 * t15._l12_2a + t15._x2 * t15._l01_2a) / l, i = (i * a - t15._y0 * t15._l12_2a + t15._y2 * t15._l01_2a) / l;
  }
  if (t15._l23_a > m4) {
    var c = 2 * t15._l23_2a + 3 * t15._l23_a * t15._l12_a + t15._l12_2a, h10 = 3 * t15._l23_a * (t15._l23_a + t15._l12_a);
    s = (s * c + t15._x1 * t15._l23_2a - e * t15._l12_2a) / h10, o = (o * c + t15._y1 * t15._l23_2a - r * t15._l12_2a) / h10;
  }
  t15._context.bezierCurveTo(n, i, s, o, t15._x2, t15._y2);
}
function Mk(t15, e) {
  this._context = t15, this._alpha = e;
}
Mk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    if (t15 = +t15, e = +e, this._point) {
      var r = this._x2 - t15, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        ng(this, t15, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var Bk = function t12(e) {
  function r(n) {
    return e ? new Mk(n, e) : new tg(n, 0);
  }
  return r.alpha = function(n) {
    return t12(+n);
  }, r;
}(0.5);
function Lk(t15, e) {
  this._context = t15, this._alpha = e;
}
Lk.prototype = {
  areaStart: ds,
  areaEnd: ds,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t15, e) {
    if (t15 = +t15, e = +e, this._point) {
      var r = this._x2 - t15, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = t15, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t15, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t15, this._y5 = e;
        break;
      default:
        ng(this, t15, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var aV = function t13(e) {
  function r(n) {
    return e ? new Lk(n, e) : new eg(n, 0);
  }
  return r.alpha = function(n) {
    return t13(+n);
  }, r;
}(0.5);
function Dk(t15, e) {
  this._context = t15, this._alpha = e;
}
Dk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    if (t15 = +t15, e = +e, this._point) {
      var r = this._x2 - t15, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ng(this, t15, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var lV = function t14(e) {
  function r(n) {
    return e ? new Dk(n, e) : new rg(n, 0);
  }
  return r.alpha = function(n) {
    return t14(+n);
  }, r;
}(0.5);
function Fk(t15) {
  this._context = t15;
}
Fk.prototype = {
  areaStart: ds,
  areaEnd: ds,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(t15, e) {
    t15 = +t15, e = +e, this._point ? this._context.lineTo(t15, e) : (this._point = 1, this._context.moveTo(t15, e));
  }
};
function cV(t15) {
  return new Fk(t15);
}
function y4(t15) {
  return t15 < 0 ? -1 : 1;
}
function b4(t15, e, r) {
  var n = t15._x1 - t15._x0, i = e - t15._x1, s = (t15._y1 - t15._y0) / (n || i < 0 && -0), o = (r - t15._y1) / (i || n < 0 && -0), a = (s * i + o * n) / (n + i);
  return (y4(s) + y4(o)) * Math.min(Math.abs(s), Math.abs(o), 0.5 * Math.abs(a)) || 0;
}
function x4(t15, e) {
  var r = t15._x1 - t15._x0;
  return r ? (3 * (t15._y1 - t15._y0) / r - e) / 2 : e;
}
function Ep(t15, e, r) {
  var n = t15._x0, i = t15._y0, s = t15._x1, o = t15._y1, a = (s - n) / 3;
  t15._context.bezierCurveTo(n + a, i + a * e, s - a, o - a * r, s, o);
}
function Fu(t15) {
  this._context = t15;
}
Fu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Ep(this, this._t0, x4(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    var r = NaN;
    if (t15 = +t15, e = +e, !(t15 === this._x1 && e === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Ep(this, x4(this, r = b4(this, t15, e)), r);
          break;
        default:
          Ep(this, this._t0, r = b4(this, t15, e));
          break;
      }
      this._x0 = this._x1, this._x1 = t15, this._y0 = this._y1, this._y1 = e, this._t0 = r;
    }
  }
};
function Nk(t15) {
  this._context = new Ik(t15);
}
(Nk.prototype = Object.create(Fu.prototype)).point = function(t15, e) {
  Fu.prototype.point.call(this, e, t15);
};
function Ik(t15) {
  this._context = t15;
}
Ik.prototype = {
  moveTo: function(t15, e) {
    this._context.moveTo(e, t15);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(t15, e) {
    this._context.lineTo(e, t15);
  },
  bezierCurveTo: function(t15, e, r, n, i, s) {
    this._context.bezierCurveTo(e, t15, n, r, s, i);
  }
};
function Ok(t15) {
  return new Fu(t15);
}
function zk(t15) {
  return new Nk(t15);
}
function qk(t15) {
  this._context = t15;
}
qk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var t15 = this._x, e = this._y, r = t15.length;
    if (r)
      if (this._line ? this._context.lineTo(t15[0], e[0]) : this._context.moveTo(t15[0], e[0]), r === 2)
        this._context.lineTo(t15[1], e[1]);
      else
        for (var n = w4(t15), i = w4(e), s = 0, o = 1; o < r; ++s, ++o)
          this._context.bezierCurveTo(n[0][s], i[0][s], n[1][s], i[1][s], t15[o], e[o]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(t15, e) {
    this._x.push(+t15), this._y.push(+e);
  }
};
function w4(t15) {
  var e, r = t15.length - 1, n, i = new Array(r), s = new Array(r), o = new Array(r);
  for (i[0] = 0, s[0] = 2, o[0] = t15[0] + 2 * t15[1], e = 1; e < r - 1; ++e) i[e] = 1, s[e] = 4, o[e] = 4 * t15[e] + 2 * t15[e + 1];
  for (i[r - 1] = 2, s[r - 1] = 7, o[r - 1] = 8 * t15[r - 1] + t15[r], e = 1; e < r; ++e) n = i[e] / s[e - 1], s[e] -= n, o[e] -= n * o[e - 1];
  for (i[r - 1] = o[r - 1] / s[r - 1], e = r - 2; e >= 0; --e) i[e] = (o[e] - i[e + 1]) / s[e];
  for (s[r - 1] = (t15[r] + i[r - 1]) / 2, e = 0; e < r - 1; ++e) s[e] = 2 * t15[e + 1] - i[e + 1];
  return [i, s];
}
function Rk(t15) {
  return new qk(t15);
}
function F0(t15, e) {
  this._context = t15, this._t = e;
}
F0.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(t15, e);
        else {
          var r = this._x * (1 - this._t) + t15 * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, e);
        }
        break;
      }
    }
    this._x = t15, this._y = e;
  }
};
function Pk(t15) {
  return new F0(t15, 0.5);
}
function jk(t15) {
  return new F0(t15, 0);
}
function Wk(t15) {
  return new F0(t15, 1);
}
function ul(t15, e, r) {
  this.k = t15, this.x = e, this.y = r;
}
ul.prototype = {
  constructor: ul,
  scale: function(t15) {
    return t15 === 1 ? this : new ul(this.k * t15, this.x, this.y);
  },
  translate: function(t15, e) {
    return t15 === 0 & e === 0 ? this : new ul(this.k, this.x + this.k * t15, this.y + this.k * e);
  },
  apply: function(t15) {
    return [t15[0] * this.k + this.x, t15[1] * this.k + this.y];
  },
  applyX: function(t15) {
    return t15 * this.k + this.x;
  },
  applyY: function(t15) {
    return t15 * this.k + this.y;
  },
  invert: function(t15) {
    return [(t15[0] - this.x) / this.k, (t15[1] - this.y) / this.k];
  },
  invertX: function(t15) {
    return (t15 - this.x) / this.k;
  },
  invertY: function(t15) {
    return (t15 - this.y) / this.k;
  },
  rescaleX: function(t15) {
    return t15.copy().domain(t15.range().map(this.invertX, this).map(t15.invert, t15));
  },
  rescaleY: function(t15) {
    return t15.copy().domain(t15.range().map(this.invertY, this).map(t15.invert, t15));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
ul.prototype;
var Hk = typeof global == "object" && global && global.Object === Object && global;
var hV = typeof self == "object" && self && self.Object === Object && self;
var li = Hk || hV || Function("return this")();
var Nu = li.Symbol;
var Uk = Object.prototype;
var uV = Uk.hasOwnProperty;
var dV = Uk.toString;
var Va = Nu ? Nu.toStringTag : void 0;
function pV(t15) {
  var e = uV.call(t15, Va), r = t15[Va];
  try {
    t15[Va] = void 0;
    var n = true;
  } catch {
  }
  var i = dV.call(t15);
  return n && (e ? t15[Va] = r : delete t15[Va]), i;
}
var fV = Object.prototype;
var mV = fV.toString;
function gV(t15) {
  return mV.call(t15);
}
var yV = "[object Null]";
var bV = "[object Undefined]";
var k4 = Nu ? Nu.toStringTag : void 0;
function ba(t15) {
  return t15 == null ? t15 === void 0 ? bV : yV : k4 && k4 in Object(t15) ? pV(t15) : gV(t15);
}
function co(t15) {
  var e = typeof t15;
  return t15 != null && (e == "object" || e == "function");
}
var xV = "[object AsyncFunction]";
var wV = "[object Function]";
var kV = "[object GeneratorFunction]";
var vV = "[object Proxy]";
function ig(t15) {
  if (!co(t15))
    return false;
  var e = ba(t15);
  return e == wV || e == kV || e == xV || e == vV;
}
var Mp = li["__core-js_shared__"];
var v4 = function() {
  var t15 = /[^.]+$/.exec(Mp && Mp.keys && Mp.keys.IE_PROTO || "");
  return t15 ? "Symbol(src)_1." + t15 : "";
}();
function _V(t15) {
  return !!v4 && v4 in t15;
}
var CV = Function.prototype;
var SV = CV.toString;
function ho(t15) {
  if (t15 != null) {
    try {
      return SV.call(t15);
    } catch {
    }
    try {
      return t15 + "";
    } catch {
    }
  }
  return "";
}
var TV = /[\\^$.*+?()[\]{}|]/g;
var AV = /^\[object .+?Constructor\]$/;
var $V = Function.prototype;
var EV = Object.prototype;
var MV = $V.toString;
var BV = EV.hasOwnProperty;
var LV = RegExp(
  "^" + MV.call(BV).replace(TV, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function DV(t15) {
  if (!co(t15) || _V(t15))
    return false;
  var e = ig(t15) ? LV : AV;
  return e.test(ho(t15));
}
function FV(t15, e) {
  return t15 == null ? void 0 : t15[e];
}
function uo(t15, e) {
  var r = FV(t15, e);
  return DV(r) ? r : void 0;
}
var Gl = uo(Object, "create");
function NV() {
  this.__data__ = Gl ? Gl(null) : {}, this.size = 0;
}
function IV(t15) {
  var e = this.has(t15) && delete this.__data__[t15];
  return this.size -= e ? 1 : 0, e;
}
var OV = "__lodash_hash_undefined__";
var zV = Object.prototype;
var qV = zV.hasOwnProperty;
function RV(t15) {
  var e = this.__data__;
  if (Gl) {
    var r = e[t15];
    return r === OV ? void 0 : r;
  }
  return qV.call(e, t15) ? e[t15] : void 0;
}
var PV = Object.prototype;
var jV = PV.hasOwnProperty;
function WV(t15) {
  var e = this.__data__;
  return Gl ? e[t15] !== void 0 : jV.call(e, t15);
}
var HV = "__lodash_hash_undefined__";
function UV(t15, e) {
  var r = this.__data__;
  return this.size += this.has(t15) ? 0 : 1, r[t15] = Gl && e === void 0 ? HV : e, this;
}
function no(t15) {
  var e = -1, r = t15 == null ? 0 : t15.length;
  for (this.clear(); ++e < r; ) {
    var n = t15[e];
    this.set(n[0], n[1]);
  }
}
no.prototype.clear = NV;
no.prototype.delete = IV;
no.prototype.get = RV;
no.prototype.has = WV;
no.prototype.set = UV;
function VV() {
  this.__data__ = [], this.size = 0;
}
function N0(t15, e) {
  return t15 === e || t15 !== t15 && e !== e;
}
function I0(t15, e) {
  for (var r = t15.length; r--; )
    if (N0(t15[r][0], e))
      return r;
  return -1;
}
var GV = Array.prototype;
var XV = GV.splice;
function YV(t15) {
  var e = this.__data__, r = I0(e, t15);
  if (r < 0)
    return false;
  var n = e.length - 1;
  return r == n ? e.pop() : XV.call(e, r, 1), --this.size, true;
}
function KV(t15) {
  var e = this.__data__, r = I0(e, t15);
  return r < 0 ? void 0 : e[r][1];
}
function ZV(t15) {
  return I0(this.__data__, t15) > -1;
}
function QV(t15, e) {
  var r = this.__data__, n = I0(r, t15);
  return n < 0 ? (++this.size, r.push([t15, e])) : r[n][1] = e, this;
}
function zi(t15) {
  var e = -1, r = t15 == null ? 0 : t15.length;
  for (this.clear(); ++e < r; ) {
    var n = t15[e];
    this.set(n[0], n[1]);
  }
}
zi.prototype.clear = VV;
zi.prototype.delete = YV;
zi.prototype.get = KV;
zi.prototype.has = ZV;
zi.prototype.set = QV;
var Xl = uo(li, "Map");
function JV() {
  this.size = 0, this.__data__ = {
    hash: new no(),
    map: new (Xl || zi)(),
    string: new no()
  };
}
function tG(t15) {
  var e = typeof t15;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t15 !== "__proto__" : t15 === null;
}
function O0(t15, e) {
  var r = t15.__data__;
  return tG(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function eG(t15) {
  var e = O0(this, t15).delete(t15);
  return this.size -= e ? 1 : 0, e;
}
function rG(t15) {
  return O0(this, t15).get(t15);
}
function nG(t15) {
  return O0(this, t15).has(t15);
}
function iG(t15, e) {
  var r = O0(this, t15), n = r.size;
  return r.set(t15, e), this.size += r.size == n ? 0 : 1, this;
}
function gs(t15) {
  var e = -1, r = t15 == null ? 0 : t15.length;
  for (this.clear(); ++e < r; ) {
    var n = t15[e];
    this.set(n[0], n[1]);
  }
}
gs.prototype.clear = JV;
gs.prototype.delete = eG;
gs.prototype.get = rG;
gs.prototype.has = nG;
gs.prototype.set = iG;
var sG = "Expected a function";
function mc(t15, e) {
  if (typeof t15 != "function" || e != null && typeof e != "function")
    throw new TypeError(sG);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], s = r.cache;
    if (s.has(i))
      return s.get(i);
    var o = t15.apply(this, n);
    return r.cache = s.set(i, o) || s, o;
  };
  return r.cache = new (mc.Cache || gs)(), r;
}
mc.Cache = gs;
function oG() {
  this.__data__ = new zi(), this.size = 0;
}
function aG(t15) {
  var e = this.__data__, r = e.delete(t15);
  return this.size = e.size, r;
}
function lG(t15) {
  return this.__data__.get(t15);
}
function cG(t15) {
  return this.__data__.has(t15);
}
var hG = 200;
function uG(t15, e) {
  var r = this.__data__;
  if (r instanceof zi) {
    var n = r.__data__;
    if (!Xl || n.length < hG - 1)
      return n.push([t15, e]), this.size = ++r.size, this;
    r = this.__data__ = new gs(n);
  }
  return r.set(t15, e), this.size = r.size, this;
}
function xa(t15) {
  var e = this.__data__ = new zi(t15);
  this.size = e.size;
}
xa.prototype.clear = oG;
xa.prototype.delete = aG;
xa.prototype.get = lG;
xa.prototype.has = cG;
xa.prototype.set = uG;
var Iu = function() {
  try {
    var t15 = uo(Object, "defineProperty");
    return t15({}, "", {}), t15;
  } catch {
  }
}();
function sg(t15, e, r) {
  e == "__proto__" && Iu ? Iu(t15, e, {
    configurable: true,
    enumerable: true,
    value: r,
    writable: true
  }) : t15[e] = r;
}
function c1(t15, e, r) {
  (r !== void 0 && !N0(t15[e], r) || r === void 0 && !(e in t15)) && sg(t15, e, r);
}
function dG(t15) {
  return function(e, r, n) {
    for (var i = -1, s = Object(e), o = n(e), a = o.length; a--; ) {
      var l = o[++i];
      if (r(s[l], l, s) === false)
        break;
    }
    return e;
  };
}
var pG = dG();
var Vk = typeof exports == "object" && exports && !exports.nodeType && exports;
var _4 = Vk && typeof module == "object" && module && !module.nodeType && module;
var fG = _4 && _4.exports === Vk;
var C4 = fG ? li.Buffer : void 0;
var S4 = C4 ? C4.allocUnsafe : void 0;
function mG(t15, e) {
  if (e)
    return t15.slice();
  var r = t15.length, n = S4 ? S4(r) : new t15.constructor(r);
  return t15.copy(n), n;
}
var T4 = li.Uint8Array;
function gG(t15) {
  var e = new t15.constructor(t15.byteLength);
  return new T4(e).set(new T4(t15)), e;
}
function yG(t15, e) {
  var r = e ? gG(t15.buffer) : t15.buffer;
  return new t15.constructor(r, t15.byteOffset, t15.length);
}
function bG(t15, e) {
  var r = -1, n = t15.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t15[r];
  return e;
}
var A4 = Object.create;
var xG = /* @__PURE__ */ function() {
  function t15() {
  }
  return function(e) {
    if (!co(e))
      return {};
    if (A4)
      return A4(e);
    t15.prototype = e;
    var r = new t15();
    return t15.prototype = void 0, r;
  };
}();
function Gk(t15, e) {
  return function(r) {
    return t15(e(r));
  };
}
var Xk = Gk(Object.getPrototypeOf, Object);
var wG = Object.prototype;
function z0(t15) {
  var e = t15 && t15.constructor, r = typeof e == "function" && e.prototype || wG;
  return t15 === r;
}
function kG(t15) {
  return typeof t15.constructor == "function" && !z0(t15) ? xG(Xk(t15)) : {};
}
function gc(t15) {
  return t15 != null && typeof t15 == "object";
}
var vG = "[object Arguments]";
function $4(t15) {
  return gc(t15) && ba(t15) == vG;
}
var Yk = Object.prototype;
var _G = Yk.hasOwnProperty;
var CG = Yk.propertyIsEnumerable;
var Ou = $4(/* @__PURE__ */ function() {
  return arguments;
}()) ? $4 : function(t15) {
  return gc(t15) && _G.call(t15, "callee") && !CG.call(t15, "callee");
};
var zu = Array.isArray;
var SG = 9007199254740991;
function Kk(t15) {
  return typeof t15 == "number" && t15 > -1 && t15 % 1 == 0 && t15 <= SG;
}
function q0(t15) {
  return t15 != null && Kk(t15.length) && !ig(t15);
}
function TG(t15) {
  return gc(t15) && q0(t15);
}
function AG() {
  return false;
}
var Zk = typeof exports == "object" && exports && !exports.nodeType && exports;
var E4 = Zk && typeof module == "object" && module && !module.nodeType && module;
var $G = E4 && E4.exports === Zk;
var M4 = $G ? li.Buffer : void 0;
var EG = M4 ? M4.isBuffer : void 0;
var og = EG || AG;
var MG = "[object Object]";
var BG = Function.prototype;
var LG = Object.prototype;
var Qk = BG.toString;
var DG = LG.hasOwnProperty;
var FG = Qk.call(Object);
function NG(t15) {
  if (!gc(t15) || ba(t15) != MG)
    return false;
  var e = Xk(t15);
  if (e === null)
    return true;
  var r = DG.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && Qk.call(r) == FG;
}
var IG = "[object Arguments]";
var OG = "[object Array]";
var zG = "[object Boolean]";
var qG = "[object Date]";
var RG = "[object Error]";
var PG = "[object Function]";
var jG = "[object Map]";
var WG = "[object Number]";
var HG = "[object Object]";
var UG = "[object RegExp]";
var VG = "[object Set]";
var GG = "[object String]";
var XG = "[object WeakMap]";
var YG = "[object ArrayBuffer]";
var KG = "[object DataView]";
var ZG = "[object Float32Array]";
var QG = "[object Float64Array]";
var JG = "[object Int8Array]";
var tX = "[object Int16Array]";
var eX = "[object Int32Array]";
var rX = "[object Uint8Array]";
var nX = "[object Uint8ClampedArray]";
var iX = "[object Uint16Array]";
var sX = "[object Uint32Array]";
var Me = {};
Me[ZG] = Me[QG] = Me[JG] = Me[tX] = Me[eX] = Me[rX] = Me[nX] = Me[iX] = Me[sX] = true;
Me[IG] = Me[OG] = Me[YG] = Me[zG] = Me[KG] = Me[qG] = Me[RG] = Me[PG] = Me[jG] = Me[WG] = Me[HG] = Me[UG] = Me[VG] = Me[GG] = Me[XG] = false;
function oX(t15) {
  return gc(t15) && Kk(t15.length) && !!Me[ba(t15)];
}
function aX(t15) {
  return function(e) {
    return t15(e);
  };
}
var Jk = typeof exports == "object" && exports && !exports.nodeType && exports;
var vl = Jk && typeof module == "object" && module && !module.nodeType && module;
var lX = vl && vl.exports === Jk;
var Bp = lX && Hk.process;
var B4 = function() {
  try {
    var t15 = vl && vl.require && vl.require("util").types;
    return t15 || Bp && Bp.binding && Bp.binding("util");
  } catch {
  }
}();
var L4 = B4 && B4.isTypedArray;
var ag = L4 ? aX(L4) : oX;
function h1(t15, e) {
  if (!(e === "constructor" && typeof t15[e] == "function") && e != "__proto__")
    return t15[e];
}
var cX = Object.prototype;
var hX = cX.hasOwnProperty;
function uX(t15, e, r) {
  var n = t15[e];
  (!(hX.call(t15, e) && N0(n, r)) || r === void 0 && !(e in t15)) && sg(t15, e, r);
}
function dX(t15, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var a = e[s], l = void 0;
    l === void 0 && (l = t15[a]), i ? sg(r, a, l) : uX(r, a, l);
  }
  return r;
}
function pX(t15, e) {
  for (var r = -1, n = Array(t15); ++r < t15; )
    n[r] = e(r);
  return n;
}
var fX = 9007199254740991;
var mX = /^(?:0|[1-9]\d*)$/;
function tv(t15, e) {
  var r = typeof t15;
  return e = e ?? fX, !!e && (r == "number" || r != "symbol" && mX.test(t15)) && t15 > -1 && t15 % 1 == 0 && t15 < e;
}
var gX = Object.prototype;
var yX = gX.hasOwnProperty;
function bX(t15, e) {
  var r = zu(t15), n = !r && Ou(t15), i = !r && !n && og(t15), s = !r && !n && !i && ag(t15), o = r || n || i || s, a = o ? pX(t15.length, String) : [], l = a.length;
  for (var c in t15)
    (e || yX.call(t15, c)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    tv(c, l))) && a.push(c);
  return a;
}
function xX(t15) {
  var e = [];
  if (t15 != null)
    for (var r in Object(t15))
      e.push(r);
  return e;
}
var wX = Object.prototype;
var kX = wX.hasOwnProperty;
function vX(t15) {
  if (!co(t15))
    return xX(t15);
  var e = z0(t15), r = [];
  for (var n in t15)
    n == "constructor" && (e || !kX.call(t15, n)) || r.push(n);
  return r;
}
function ev(t15) {
  return q0(t15) ? bX(t15, true) : vX(t15);
}
function _X(t15) {
  return dX(t15, ev(t15));
}
function CX(t15, e, r, n, i, s, o) {
  var a = h1(t15, r), l = h1(e, r), c = o.get(l);
  if (c) {
    c1(t15, r, c);
    return;
  }
  var h10 = s ? s(a, l, r + "", t15, e, o) : void 0, p = h10 === void 0;
  if (p) {
    var m = zu(l), g = !m && og(l), y = !m && !g && ag(l);
    h10 = l, m || g || y ? zu(a) ? h10 = a : TG(a) ? h10 = bG(a) : g ? (p = false, h10 = mG(l, true)) : y ? (p = false, h10 = yG(l, true)) : h10 = [] : NG(l) || Ou(l) ? (h10 = a, Ou(a) ? h10 = _X(a) : (!co(a) || ig(a)) && (h10 = kG(l))) : p = false;
  }
  p && (o.set(l, h10), i(h10, l, n, s, o), o.delete(l)), c1(t15, r, h10);
}
function rv(t15, e, r, n, i) {
  t15 !== e && pG(e, function(s, o) {
    if (i || (i = new xa()), co(s))
      CX(t15, e, o, r, rv, n, i);
    else {
      var a = n ? n(h1(t15, o), s, o + "", t15, e, i) : void 0;
      a === void 0 && (a = s), c1(t15, o, a);
    }
  }, ev);
}
function nv(t15) {
  return t15;
}
function SX(t15, e, r) {
  switch (r.length) {
    case 0:
      return t15.call(e);
    case 1:
      return t15.call(e, r[0]);
    case 2:
      return t15.call(e, r[0], r[1]);
    case 3:
      return t15.call(e, r[0], r[1], r[2]);
  }
  return t15.apply(e, r);
}
var D4 = Math.max;
function TX(t15, e, r) {
  return e = D4(e === void 0 ? t15.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, s = D4(n.length - e, 0), o = Array(s); ++i < s; )
      o[i] = n[e + i];
    i = -1;
    for (var a = Array(e + 1); ++i < e; )
      a[i] = n[i];
    return a[e] = r(o), SX(t15, this, a);
  };
}
function AX(t15) {
  return function() {
    return t15;
  };
}
var $X = Iu ? function(t15, e) {
  return Iu(t15, "toString", {
    configurable: true,
    enumerable: false,
    value: AX(e),
    writable: true
  });
} : nv;
var EX = 800;
var MX = 16;
var BX = Date.now;
function LX(t15) {
  var e = 0, r = 0;
  return function() {
    var n = BX(), i = MX - (n - r);
    if (r = n, i > 0) {
      if (++e >= EX)
        return arguments[0];
    } else
      e = 0;
    return t15.apply(void 0, arguments);
  };
}
var DX = LX($X);
function FX(t15, e) {
  return DX(TX(t15, e, nv), t15 + "");
}
function NX(t15, e, r) {
  if (!co(r))
    return false;
  var n = typeof e;
  return (n == "number" ? q0(r) && tv(e, r.length) : n == "string" && e in r) ? N0(r[e], t15) : false;
}
function IX(t15) {
  return FX(function(e, r) {
    var n = -1, i = r.length, s = i > 1 ? r[i - 1] : void 0, o = i > 2 ? r[2] : void 0;
    for (s = t15.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && NX(r[0], r[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++n < i; ) {
      var a = r[n];
      a && t15(e, a, n, s);
    }
    return e;
  });
}
var OX = IX(function(t15, e, r) {
  rv(t15, e, r);
});
var zX = "​";
var qX = {
  curveBasis: zh,
  curveBasisClosed: rV,
  curveBasisOpen: nV,
  curveBumpX: Ck,
  curveBumpY: Sk,
  curveBundle: iV,
  curveCardinalClosed: sV,
  curveCardinalOpen: oV,
  curveCardinal: Ek,
  curveCatmullRomClosed: aV,
  curveCatmullRomOpen: lV,
  curveCatmullRom: Bk,
  curveLinear: Bu,
  curveLinearClosed: cV,
  curveMonotoneX: Ok,
  curveMonotoneY: zk,
  curveNatural: Rk,
  curveStep: Pk,
  curveStepAfter: Wk,
  curveStepBefore: jk
};
var RX = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
var PX = S(function(t15, e) {
  const r = iv(t15, /(?:init\b)|(?:initialize\b)/);
  let n = {};
  if (Array.isArray(r)) {
    const o = r.map((a) => a.args);
    mu(o), n = pr(n, [...o]);
  } else
    n = r.args;
  if (!n)
    return;
  let i = Lm(t15, e);
  const s = "config";
  return n[s] !== void 0 && (i === "flowchart-v2" && (i = "flowchart"), n[i] = n[s], delete n[s]), n;
}, "detectInit");
var iv = S(function(t15, e = null) {
  var _a2, _b2;
  try {
    const r = new RegExp(
      `[%]{2}(?![{]${RX.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    t15 = t15.trim().replace(r, "").replace(/'/gm, '"'), ut.debug(
      `Detecting diagram directive${e !== null ? " type:" + e : ""} based on the text:${t15}`
    );
    let n;
    const i = [];
    for (; (n = wl.exec(t15)) !== null; )
      if (n.index === wl.lastIndex && wl.lastIndex++, n && !e || e && ((_a2 = n[1]) == null ? void 0 : _a2.match(e)) || e && ((_b2 = n[2]) == null ? void 0 : _b2.match(e))) {
        const s = n[1] ? n[1] : n[2], o = n[3] ? n[3].trim() : n[4] ? JSON.parse(n[4].trim()) : null;
        i.push({ type: s, args: o });
      }
    return i.length === 0 ? { type: t15, args: null } : i.length === 1 ? i[0] : i;
  } catch (r) {
    return ut.error(
      `ERROR: ${r.message} - Unable to parse directive type: '${e}' based on the text: '${t15}'`
    ), { type: void 0, args: null };
  }
}, "detectDirective");
var jX = S(function(t15) {
  return t15.replace(wl, "");
}, "removeDirectives");
var WX = S(function(t15, e) {
  for (const [r, n] of e.entries())
    if (n.match(t15))
      return r;
  return -1;
}, "isSubstringInArray");
function lg(t15, e) {
  if (!t15)
    return e;
  const r = `curve${t15.charAt(0).toUpperCase() + t15.slice(1)}`;
  return qX[r] ?? e;
}
S(lg, "interpolateToCurve");
function sv(t15, e) {
  const r = t15.trim();
  if (r)
    return e.securityLevel !== "loose" ? Dj.sanitizeUrl(r) : r;
}
S(sv, "formatUrl");
var HX = S((t15, ...e) => {
  const r = t15.split("."), n = r.length - 1, i = r[n];
  let s = window;
  for (let o = 0; o < n; o++)
    if (s = s[r[o]], !s) {
      ut.error(`Function name: ${t15} not found in window`);
      return;
    }
  s[i](...e);
}, "runFunc");
function cg(t15, e) {
  return !t15 || !e ? 0 : Math.sqrt(Math.pow(e.x - t15.x, 2) + Math.pow(e.y - t15.y, 2));
}
S(cg, "distance");
function ov(t15) {
  let e, r = 0;
  t15.forEach((i) => {
    r += cg(i, e), e = i;
  });
  const n = r / 2;
  return hg(t15, n);
}
S(ov, "traverseEdge");
function av(t15) {
  return t15.length === 1 ? t15[0] : ov(t15);
}
S(av, "calcLabelPosition");
var F4 = S((t15, e = 2) => {
  const r = Math.pow(10, e);
  return Math.round(t15 * r) / r;
}, "roundNumber");
var hg = S((t15, e) => {
  let r, n = e;
  for (const i of t15) {
    if (r) {
      const s = cg(i, r);
      if (s === 0)
        return r;
      if (s < n)
        n -= s;
      else {
        const o = n / s;
        if (o <= 0)
          return r;
        if (o >= 1)
          return { x: i.x, y: i.y };
        if (o > 0 && o < 1)
          return {
            x: F4((1 - o) * r.x + o * i.x, 5),
            y: F4((1 - o) * r.y + o * i.y, 5)
          };
      }
    }
    r = i;
  }
  throw new Error("Could not find a suitable point for the given distance");
}, "calculatePoint");
var UX = S((t15, e, r) => {
  ut.info(`our points ${JSON.stringify(e)}`), e[0] !== r && (e = e.reverse());
  const n = hg(e, 25), i = t15 ? 10 : 5, s = Math.atan2(e[0].y - n.y, e[0].x - n.x), o = { x: 0, y: 0 };
  return o.x = Math.sin(s) * i + (e[0].x + n.x) / 2, o.y = -Math.cos(s) * i + (e[0].y + n.y) / 2, o;
}, "calcCardinalityPosition");
function lv(t15, e, r) {
  const n = structuredClone(r);
  ut.info("our points", n), e !== "start_left" && e !== "start_right" && n.reverse();
  const i = 25 + t15, s = hg(n, i), o = 10 + t15 * 0.5, a = Math.atan2(n[0].y - s.y, n[0].x - s.x), l = { x: 0, y: 0 };
  return e === "start_left" ? (l.x = Math.sin(a + Math.PI) * o + (n[0].x + s.x) / 2, l.y = -Math.cos(a + Math.PI) * o + (n[0].y + s.y) / 2) : e === "end_right" ? (l.x = Math.sin(a - Math.PI) * o + (n[0].x + s.x) / 2 - 5, l.y = -Math.cos(a - Math.PI) * o + (n[0].y + s.y) / 2 - 5) : e === "end_left" ? (l.x = Math.sin(a) * o + (n[0].x + s.x) / 2 - 5, l.y = -Math.cos(a) * o + (n[0].y + s.y) / 2 - 5) : (l.x = Math.sin(a) * o + (n[0].x + s.x) / 2, l.y = -Math.cos(a) * o + (n[0].y + s.y) / 2), l;
}
S(lv, "calcTerminalLabelPosition");
function cv(t15) {
  let e = "", r = "";
  for (const n of t15)
    n !== void 0 && (n.startsWith("color:") || n.startsWith("text-align:") ? r = r + n + ";" : e = e + n + ";");
  return { style: e, labelStyle: r };
}
S(cv, "getStylesFromArray");
var N4 = 0;
var VX = S(() => (N4++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + N4), "generateId");
function hv(t15) {
  let e = "";
  const r = "0123456789abcdef", n = r.length;
  for (let i = 0; i < t15; i++)
    e += r.charAt(Math.floor(Math.random() * n));
  return e;
}
S(hv, "makeRandomHex");
var GX = S((t15) => hv(t15.length), "random");
var XX = S(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0,
    text: ""
  };
}, "getTextObj");
var YX = S(function(t15, e) {
  const r = e.text.replace(ga.lineBreakRegex, " "), [, n] = R0(e.fontSize), i = t15.append("text");
  i.attr("x", e.x), i.attr("y", e.y), i.style("text-anchor", e.anchor), i.style("font-family", e.fontFamily), i.style("font-size", n), i.style("font-weight", e.fontWeight), i.attr("fill", e.fill), e.class !== void 0 && i.attr("class", e.class);
  const s = i.append("tspan");
  return s.attr("x", e.x + e.textMargin * 2), s.attr("fill", e.fill), s.text(r), i;
}, "drawSimpleText");
var KX = mc(
  (t15, e, r) => {
    if (!t15 || (r = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      r
    ), ga.lineBreakRegex.test(t15)))
      return t15;
    const n = t15.split(" ").filter(Boolean), i = [];
    let s = "";
    return n.forEach((o, a) => {
      const l = Ii(`${o} `, r), c = Ii(s, r);
      if (l > e) {
        const { hyphenatedStrings: h10, remainingWord: p } = ZX(o, e, "-", r);
        i.push(s, ...h10), s = p;
      } else c + l >= e ? (i.push(s), s = o) : s = [s, o].filter(Boolean).join(" ");
      a + 1 === n.length && i.push(s);
    }), i.filter((o) => o !== "").join(r.joinWith);
  },
  (t15, e, r) => `${t15}${e}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`
);
var ZX = mc(
  (t15, e, r = "-", n) => {
    n = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      n
    );
    const i = [...t15], s = [];
    let o = "";
    return i.forEach((a, l) => {
      const c = `${o}${a}`;
      if (Ii(c, n) >= e) {
        const h10 = l + 1, p = i.length === h10, m = `${c}${r}`;
        s.push(p ? c : m), o = "";
      } else
        o = c;
    }), { hyphenatedStrings: s, remainingWord: o };
  },
  (t15, e, r = "-", n) => `${t15}${e}${r}${n.fontSize}${n.fontWeight}${n.fontFamily}`
);
function uv(t15, e) {
  return ug(t15, e).height;
}
S(uv, "calculateTextHeight");
function Ii(t15, e) {
  return ug(t15, e).width;
}
S(Ii, "calculateTextWidth");
var ug = mc(
  (t15, e) => {
    const { fontSize: r = 12, fontFamily: n = "Arial", fontWeight: i = 400 } = e;
    if (!t15)
      return { width: 0, height: 0 };
    const [, s] = R0(r), o = ["sans-serif", n], a = t15.split(ga.lineBreakRegex), l = [], c = ae("body");
    if (!c.remove)
      return { width: 0, height: 0, lineHeight: 0 };
    const h10 = c.append("svg");
    for (const m of o) {
      let g = 0;
      const y = { width: 0, height: 0, lineHeight: 0 };
      for (const x of a) {
        const k = XX();
        k.text = x || zX;
        const C = YX(h10, k).style("font-size", s).style("font-weight", i).style("font-family", m), _ = (C._groups || C)[0][0].getBBox();
        if (_.width === 0 && _.height === 0)
          throw new Error("svg element not in render tree");
        y.width = Math.round(Math.max(y.width, _.width)), g = Math.round(_.height), y.height += g, y.lineHeight = Math.round(Math.max(y.lineHeight, g));
      }
      l.push(y);
    }
    h10.remove();
    const p = isNaN(l[1].height) || isNaN(l[1].width) || isNaN(l[1].lineHeight) || l[0].height > l[1].height && l[0].width > l[1].width && l[0].lineHeight > l[1].lineHeight ? 0 : 1;
    return l[p];
  },
  (t15, e) => `${t15}${e.fontSize}${e.fontWeight}${e.fontFamily}`
);
var Lp;
var QX = (Lp = class {
  constructor(t15 = false, e) {
    this.count = 0, this.count = e ? e.length : 0, this.next = t15 ? () => this.count++ : () => Date.now();
  }
}, S(Lp, "InitIDGenerator"), Lp);
var hh;
var JX = S(function(t15) {
  return hh = hh || document.createElement("div"), t15 = escape(t15).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), hh.innerHTML = t15, unescape(hh.textContent);
}, "entityDecode");
function dg(t15) {
  return "str" in t15;
}
S(dg, "isDetailedError");
var tY = S((t15, e, r, n) => {
  var _a2;
  if (!n)
    return;
  const i = (_a2 = t15.node()) == null ? void 0 : _a2.getBBox();
  i && t15.append("text").text(n).attr("text-anchor", "middle").attr("x", i.x + i.width / 2).attr("y", -r).attr("class", e);
}, "insertTitle");
var R0 = S((t15) => {
  if (typeof t15 == "number")
    return [t15, t15 + "px"];
  const e = parseInt(t15 ?? "", 10);
  return Number.isNaN(e) ? [void 0, void 0] : t15 === String(e) ? [e, t15 + "px"] : [e, t15];
}, "parseFontSize");
function pg(t15, e) {
  return OX({}, t15, e);
}
S(pg, "cleanAndMerge");
var Xn = {
  assignWithDepth: pr,
  wrapLabel: KX,
  calculateTextHeight: uv,
  calculateTextWidth: Ii,
  calculateTextDimensions: ug,
  cleanAndMerge: pg,
  detectInit: PX,
  detectDirective: iv,
  isSubstringInArray: WX,
  interpolateToCurve: lg,
  calcLabelPosition: av,
  calcCardinalityPosition: UX,
  calcTerminalLabelPosition: lv,
  formatUrl: sv,
  getStylesFromArray: cv,
  generateId: VX,
  random: GX,
  runFunc: HX,
  entityDecode: JX,
  insertTitle: tY,
  parseFontSize: R0,
  InitIDGenerator: QX
};
var eY = S(function(t15) {
  let e = t15;
  return e = e.replace(/style.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/classDef.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/#\w+;/g, function(r) {
    const n = r.substring(1, r.length - 1);
    return /^\+?\d+$/.test(n) ? "ﬂ°°" + n + "¶ß" : "ﬂ°" + n + "¶ß";
  }), e;
}, "encodeEntities");
var po = S(function(t15) {
  return t15.replace(/ﬂ°°/g, "&#").replace(/ﬂ°/g, "&").replace(/¶ß/g, ";");
}, "decodeEntities");
var gnt = S((t15, e, {
  counter: r = 0,
  prefix: n,
  suffix: i
}, s) => s || `${n ? `${n}_` : ""}${t15}_${e}_${r}${i ? `_${i}` : ""}`, "getEdgeId");
function Mr(t15) {
  return t15 ?? null;
}
S(Mr, "handleUndefinedAttr");
var rY = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var qu = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var dv = Object.freeze({
  ...rY,
  ...qu
});
var nY = Object.freeze({
  ...dv,
  body: "",
  hidden: false
});
var iY = Object.freeze({
  width: null,
  height: null
});
var sY = Object.freeze({
  // Dimensions
  ...iY,
  // Transformations
  ...qu
});
var oY = (t15, e, r, n = "") => {
  const i = t15.split(":");
  if (t15.slice(0, 1) === "@") {
    if (i.length < 2 || i.length > 3)
      return null;
    n = i.shift().slice(1);
  }
  if (i.length > 3 || !i.length)
    return null;
  if (i.length > 1) {
    const a = i.pop(), l = i.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: i.length > 0 ? i[0] : n,
      prefix: l,
      name: a
    };
    return Dp(c) ? c : null;
  }
  const s = i[0], o = s.split("-");
  if (o.length > 1) {
    const a = {
      provider: n,
      prefix: o.shift(),
      name: o.join("-")
    };
    return Dp(a) ? a : null;
  }
  if (r && n === "") {
    const a = {
      provider: n,
      prefix: "",
      name: s
    };
    return Dp(a, r) ? a : null;
  }
  return null;
};
var Dp = (t15, e) => t15 ? !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
// Check name: cannot be empty
((e && t15.prefix === "" || t15.prefix) && t15.name) : false;
function aY(t15, e) {
  const r = {};
  !t15.hFlip != !e.hFlip && (r.hFlip = true), !t15.vFlip != !e.vFlip && (r.vFlip = true);
  const n = ((t15.rotate || 0) + (e.rotate || 0)) % 4;
  return n && (r.rotate = n), r;
}
function I4(t15, e) {
  const r = aY(t15, e);
  for (const n in nY)
    n in qu ? n in t15 && !(n in r) && (r[n] = qu[n]) : n in e ? r[n] = e[n] : n in t15 && (r[n] = t15[n]);
  return r;
}
function lY(t15, e) {
  const r = t15.icons, n = t15.aliases || /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function s(o) {
    if (r[o])
      return i[o] = [];
    if (!(o in i)) {
      i[o] = null;
      const a = n[o] && n[o].parent, l = a && s(a);
      l && (i[o] = [a].concat(l));
    }
    return i[o];
  }
  return (e || Object.keys(r).concat(Object.keys(n))).forEach(s), i;
}
function O4(t15, e, r) {
  const n = t15.icons, i = t15.aliases || /* @__PURE__ */ Object.create(null);
  let s = {};
  function o(a) {
    s = I4(
      n[a] || i[a],
      s
    );
  }
  return o(e), r.forEach(o), I4(t15, s);
}
function cY(t15, e) {
  if (t15.icons[e])
    return O4(t15, e, []);
  const r = lY(t15, [e])[e];
  return r ? O4(t15, e, r) : null;
}
var hY = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var uY = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function z4(t15, e, r) {
  if (e === 1)
    return t15;
  if (r = r || 100, typeof t15 == "number")
    return Math.ceil(t15 * e * r) / r;
  if (typeof t15 != "string")
    return t15;
  const n = t15.split(hY);
  if (n === null || !n.length)
    return t15;
  const i = [];
  let s = n.shift(), o = uY.test(s);
  for (; ; ) {
    if (o) {
      const a = parseFloat(s);
      isNaN(a) ? i.push(s) : i.push(Math.ceil(a * e * r) / r);
    } else
      i.push(s);
    if (s = n.shift(), s === void 0)
      return i.join("");
    o = !o;
  }
}
function dY(t15, e = "defs") {
  let r = "";
  const n = t15.indexOf("<" + e);
  for (; n >= 0; ) {
    const i = t15.indexOf(">", n), s = t15.indexOf("</" + e);
    if (i === -1 || s === -1)
      break;
    const o = t15.indexOf(">", s);
    if (o === -1)
      break;
    r += t15.slice(i + 1, s).trim(), t15 = t15.slice(0, n).trim() + t15.slice(o + 1);
  }
  return {
    defs: r,
    content: t15
  };
}
function pY(t15, e) {
  return t15 ? "<defs>" + t15 + "</defs>" + e : e;
}
function fY(t15, e, r) {
  const n = dY(t15);
  return pY(n.defs, e + n.content + r);
}
var mY = (t15) => t15 === "unset" || t15 === "undefined" || t15 === "none";
function gY(t15, e) {
  const r = {
    ...dv,
    ...t15
  }, n = {
    ...sY,
    ...e
  }, i = {
    left: r.left,
    top: r.top,
    width: r.width,
    height: r.height
  };
  let s = r.body;
  [r, n].forEach((x) => {
    const k = [], C = x.hFlip, _ = x.vFlip;
    let $ = x.rotate;
    C ? _ ? $ += 2 : (k.push(
      "translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"
    ), k.push("scale(-1 1)"), i.top = i.left = 0) : _ && (k.push(
      "translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"
    ), k.push("scale(1 -1)"), i.top = i.left = 0);
    let L;
    switch ($ < 0 && ($ -= Math.floor($ / 4) * 4), $ = $ % 4, $) {
      case 1:
        L = i.height / 2 + i.top, k.unshift(
          "rotate(90 " + L.toString() + " " + L.toString() + ")"
        );
        break;
      case 2:
        k.unshift(
          "rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")"
        );
        break;
      case 3:
        L = i.width / 2 + i.left, k.unshift(
          "rotate(-90 " + L.toString() + " " + L.toString() + ")"
        );
        break;
    }
    $ % 2 === 1 && (i.left !== i.top && (L = i.left, i.left = i.top, i.top = L), i.width !== i.height && (L = i.width, i.width = i.height, i.height = L)), k.length && (s = fY(
      s,
      '<g transform="' + k.join(" ") + '">',
      "</g>"
    ));
  });
  const o = n.width, a = n.height, l = i.width, c = i.height;
  let h10, p;
  o === null ? (p = a === null ? "1em" : a === "auto" ? c : a, h10 = z4(p, l / c)) : (h10 = o === "auto" ? l : o, p = a === null ? z4(h10, c / l) : a === "auto" ? c : a);
  const m = {}, g = (x, k) => {
    mY(k) || (m[x] = k.toString());
  };
  g("width", h10), g("height", p);
  const y = [i.left, i.top, l, c];
  return m.viewBox = y.join(" "), {
    attributes: m,
    viewBox: y,
    body: s
  };
}
var yY = /\sid="(\S+)"/g;
var bY = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
var xY = 0;
function wY(t15, e = bY) {
  const r = [];
  let n;
  for (; n = yY.exec(t15); )
    r.push(n[1]);
  if (!r.length)
    return t15;
  const i = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return r.forEach((s) => {
    const o = typeof e == "function" ? e(s) : e + (xY++).toString(), a = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t15 = t15.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])', "g"),
      "$1" + o + i + "$3"
    );
  }), t15 = t15.replace(new RegExp(i, "g"), ""), t15;
}
function kY(t15, e) {
  let r = t15.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in e)
    r += " " + n + '="' + e[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + r + ">" + t15 + "</svg>";
}
function fg() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var fo = fg();
function pv(t15) {
  fo = t15;
}
var _l = { exec: () => null };
function be(t15, e = "") {
  let r = typeof t15 == "string" ? t15 : t15.source, n = { replace: (i, s) => {
    let o = typeof s == "string" ? s : s.source;
    return o = o.replace(Er.caret, "$1"), r = r.replace(i, o), n;
  }, getRegex: () => new RegExp(r, e) };
  return n;
}
var Er = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t15) => new RegExp(`^( {0,3}${t15})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}#`), htmlBeginRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}<(?:[a-z].*>|!--)`, "i") };
var vY = /^(?:[ \t]*(?:\n|$))+/;
var _Y = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
var CY = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var yc = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var SY = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var mg = /(?:[*+-]|\d{1,9}[.)])/;
var fv = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
var mv = be(fv).replace(/bull/g, mg).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
var TY = be(fv).replace(/bull/g, mg).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
var gg = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var AY = /^[^\n]+/;
var yg = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var $Y = be(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", yg).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var EY = be(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, mg).getRegex();
var P0 = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var bg = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var MY = be("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", bg).replace("tag", P0).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var gv = be(gg).replace("hr", yc).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", P0).getRegex();
var BY = be(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", gv).getRegex();
var xg = { blockquote: BY, code: _Y, def: $Y, fences: CY, heading: SY, hr: yc, html: MY, lheading: mv, list: EY, newline: vY, paragraph: gv, table: _l, text: AY };
var q4 = be("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", yc).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", P0).getRegex();
var LY = { ...xg, lheading: TY, table: q4, paragraph: be(gg).replace("hr", yc).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", q4).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", P0).getRegex() };
var DY = { ...xg, html: be(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", bg).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: _l, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: be(gg).replace("hr", yc).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", mv).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() };
var FY = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var NY = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var yv = /^( {2,}|\\)\n(?!\s*$)/;
var IY = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var j0 = /[\p{P}\p{S}]/u;
var wg = /[\s\p{P}\p{S}]/u;
var bv = /[^\s\p{P}\p{S}]/u;
var OY = be(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, wg).getRegex();
var xv = /(?!~)[\p{P}\p{S}]/u;
var zY = /(?!~)[\s\p{P}\p{S}]/u;
var qY = /(?:[^\s\p{P}\p{S}]|~)/u;
var RY = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g;
var wv = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
var PY = be(wv, "u").replace(/punct/g, j0).getRegex();
var jY = be(wv, "u").replace(/punct/g, xv).getRegex();
var kv = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
var WY = be(kv, "gu").replace(/notPunctSpace/g, bv).replace(/punctSpace/g, wg).replace(/punct/g, j0).getRegex();
var HY = be(kv, "gu").replace(/notPunctSpace/g, qY).replace(/punctSpace/g, zY).replace(/punct/g, xv).getRegex();
var UY = be("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, bv).replace(/punctSpace/g, wg).replace(/punct/g, j0).getRegex();
var VY = be(/\\(punct)/, "gu").replace(/punct/g, j0).getRegex();
var GY = be(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var XY = be(bg).replace("(?:-->|$)", "-->").getRegex();
var YY = be("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", XY).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var Ru = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var KY = be(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", Ru).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var vv = be(/^!?\[(label)\]\[(ref)\]/).replace("label", Ru).replace("ref", yg).getRegex();
var _v = be(/^!?\[(ref)\](?:\[\])?/).replace("ref", yg).getRegex();
var ZY = be("reflink|nolink(?!\\()", "g").replace("reflink", vv).replace("nolink", _v).getRegex();
var kg = { _backpedal: _l, anyPunctuation: VY, autolink: GY, blockSkip: RY, br: yv, code: NY, del: _l, emStrongLDelim: PY, emStrongRDelimAst: WY, emStrongRDelimUnd: UY, escape: FY, link: KY, nolink: _v, punctuation: OY, reflink: vv, reflinkSearch: ZY, tag: YY, text: IY, url: _l };
var QY = { ...kg, link: be(/^!?\[(label)\]\((.*?)\)/).replace("label", Ru).getRegex(), reflink: be(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Ru).getRegex() };
var u1 = { ...kg, emStrongRDelimAst: HY, emStrongLDelim: jY, url: be(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ };
var JY = { ...u1, br: be(yv).replace("{2,}", "*").getRegex(), text: be(u1.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() };
var uh = { normal: xg, gfm: LY, pedantic: DY };
var Ga = { normal: kg, gfm: u1, breaks: JY, pedantic: QY };
var tK = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
var R4 = (t15) => tK[t15];
function Pn(t15, e) {
  if (e) {
    if (Er.escapeTest.test(t15)) return t15.replace(Er.escapeReplace, R4);
  } else if (Er.escapeTestNoEncode.test(t15)) return t15.replace(Er.escapeReplaceNoEncode, R4);
  return t15;
}
function P4(t15) {
  try {
    t15 = encodeURI(t15).replace(Er.percentDecode, "%");
  } catch {
    return null;
  }
  return t15;
}
function j4(t15, e) {
  var _a2;
  let r = t15.replace(Er.findPipe, (s, o, a) => {
    let l = false, c = o;
    for (; --c >= 0 && a[c] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), n = r.split(Er.splitPipe), i = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !((_a2 = n.at(-1)) == null ? void 0 : _a2.trim()) && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; i < n.length; i++) n[i] = n[i].trim().replace(Er.slashPipe, "|");
  return n;
}
function Xa(t15, e, r) {
  let n = t15.length;
  if (n === 0) return "";
  let i = 0;
  for (; i < n && t15.charAt(n - i - 1) === e; )
    i++;
  return t15.slice(0, n - i);
}
function eK(t15, e) {
  if (t15.indexOf(e[1]) === -1) return -1;
  let r = 0;
  for (let n = 0; n < t15.length; n++) if (t15[n] === "\\") n++;
  else if (t15[n] === e[0]) r++;
  else if (t15[n] === e[1] && (r--, r < 0)) return n;
  return r > 0 ? -2 : -1;
}
function W4(t15, e, r, n, i) {
  let s = e.href, o = e.title || null, a = t15[1].replace(i.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let l = { type: t15[0].charAt(0) === "!" ? "image" : "link", raw: r, href: s, title: o, text: a, tokens: n.inlineTokens(a) };
  return n.state.inLink = false, l;
}
function rK(t15, e, r) {
  let n = t15.match(r.other.indentCodeCompensation);
  if (n === null) return e;
  let i = n[1];
  return e.split(`
`).map((s) => {
    let o = s.match(r.other.beginningSpace);
    if (o === null) return s;
    let [a] = o;
    return a.length >= i.length ? s.slice(i.length) : s;
  }).join(`
`);
}
var Pu = class {
  constructor(t15) {
    __publicField(this, "options");
    __publicField(this, "rules");
    __publicField(this, "lexer");
    this.options = t15 || fo;
  }
  space(t15) {
    let e = this.rules.block.newline.exec(t15);
    if (e && e[0].length > 0) return { type: "space", raw: e[0] };
  }
  code(t15) {
    let e = this.rules.block.code.exec(t15);
    if (e) {
      let r = e[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: e[0], codeBlockStyle: "indented", text: this.options.pedantic ? r : Xa(r, `
`) };
    }
  }
  fences(t15) {
    let e = this.rules.block.fences.exec(t15);
    if (e) {
      let r = e[0], n = rK(r, e[3] || "", this.rules);
      return { type: "code", raw: r, lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2], text: n };
    }
  }
  heading(t15) {
    let e = this.rules.block.heading.exec(t15);
    if (e) {
      let r = e[2].trim();
      if (this.rules.other.endingHash.test(r)) {
        let n = Xa(r, "#");
        (this.options.pedantic || !n || this.rules.other.endingSpaceChar.test(n)) && (r = n.trim());
      }
      return { type: "heading", raw: e[0], depth: e[1].length, text: r, tokens: this.lexer.inline(r) };
    }
  }
  hr(t15) {
    let e = this.rules.block.hr.exec(t15);
    if (e) return { type: "hr", raw: Xa(e[0], `
`) };
  }
  blockquote(t15) {
    let e = this.rules.block.blockquote.exec(t15);
    if (e) {
      let r = Xa(e[0], `
`).split(`
`), n = "", i = "", s = [];
      for (; r.length > 0; ) {
        let o = false, a = [], l;
        for (l = 0; l < r.length; l++) if (this.rules.other.blockquoteStart.test(r[l])) a.push(r[l]), o = true;
        else if (!o) a.push(r[l]);
        else break;
        r = r.slice(l);
        let c = a.join(`
`), h10 = c.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        n = n ? `${n}
${c}` : c, i = i ? `${i}
${h10}` : h10;
        let p = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(h10, s, true), this.lexer.state.top = p, r.length === 0) break;
        let m = s.at(-1);
        if ((m == null ? void 0 : m.type) === "code") break;
        if ((m == null ? void 0 : m.type) === "blockquote") {
          let g = m, y = g.raw + `
` + r.join(`
`), x = this.blockquote(y);
          s[s.length - 1] = x, n = n.substring(0, n.length - g.raw.length) + x.raw, i = i.substring(0, i.length - g.text.length) + x.text;
          break;
        } else if ((m == null ? void 0 : m.type) === "list") {
          let g = m, y = g.raw + `
` + r.join(`
`), x = this.list(y);
          s[s.length - 1] = x, n = n.substring(0, n.length - m.raw.length) + x.raw, i = i.substring(0, i.length - g.raw.length) + x.raw, r = y.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: n, tokens: s, text: i };
    }
  }
  list(t15) {
    let e = this.rules.block.list.exec(t15);
    if (e) {
      let r = e[1].trim(), n = r.length > 1, i = { type: "list", raw: "", ordered: n, start: n ? +r.slice(0, -1) : "", loose: false, items: [] };
      r = n ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = n ? r : "[*+-]");
      let s = this.rules.other.listItemRegex(r), o = false;
      for (; t15; ) {
        let l = false, c = "", h10 = "";
        if (!(e = s.exec(t15)) || this.rules.block.hr.test(t15)) break;
        c = e[0], t15 = t15.substring(c.length);
        let p = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (C) => " ".repeat(3 * C.length)), m = t15.split(`
`, 1)[0], g = !p.trim(), y = 0;
        if (this.options.pedantic ? (y = 2, h10 = p.trimStart()) : g ? y = e[1].length + 1 : (y = e[2].search(this.rules.other.nonSpaceChar), y = y > 4 ? 1 : y, h10 = p.slice(y), y += e[1].length), g && this.rules.other.blankLine.test(m) && (c += m + `
`, t15 = t15.substring(m.length + 1), l = true), !l) {
          let C = this.rules.other.nextBulletRegex(y), _ = this.rules.other.hrRegex(y), $ = this.rules.other.fencesBeginRegex(y), L = this.rules.other.headingBeginRegex(y), B = this.rules.other.htmlBeginRegex(y);
          for (; t15; ) {
            let q = t15.split(`
`, 1)[0], H;
            if (m = q, this.options.pedantic ? (m = m.replace(this.rules.other.listReplaceNesting, "  "), H = m) : H = m.replace(this.rules.other.tabCharGlobal, "    "), $.test(m) || L.test(m) || B.test(m) || C.test(m) || _.test(m)) break;
            if (H.search(this.rules.other.nonSpaceChar) >= y || !m.trim()) h10 += `
` + H.slice(y);
            else {
              if (g || p.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || $.test(p) || L.test(p) || _.test(p)) break;
              h10 += `
` + m;
            }
            !g && !m.trim() && (g = true), c += q + `
`, t15 = t15.substring(q.length + 1), p = H.slice(y);
          }
        }
        i.loose || (o ? i.loose = true : this.rules.other.doubleBlankLine.test(c) && (o = true));
        let x = null, k;
        this.options.gfm && (x = this.rules.other.listIsTask.exec(h10), x && (k = x[0] !== "[ ] ", h10 = h10.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: c, task: !!x, checked: k, loose: false, text: h10, tokens: [] }), i.raw += c;
      }
      let a = i.items.at(-1);
      if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let l = 0; l < i.items.length; l++) if (this.lexer.state.top = false, i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, []), !i.loose) {
        let c = i.items[l].tokens.filter((p) => p.type === "space"), h10 = c.length > 0 && c.some((p) => this.rules.other.anyLine.test(p.raw));
        i.loose = h10;
      }
      if (i.loose) for (let l = 0; l < i.items.length; l++) i.items[l].loose = true;
      return i;
    }
  }
  html(t15) {
    let e = this.rules.block.html.exec(t15);
    if (e) return { type: "html", block: true, raw: e[0], pre: e[1] === "pre" || e[1] === "script" || e[1] === "style", text: e[0] };
  }
  def(t15) {
    let e = this.rules.block.def.exec(t15);
    if (e) {
      let r = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), n = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
      return { type: "def", tag: r, raw: e[0], href: n, title: i };
    }
  }
  table(t15) {
    var _a2;
    let e = this.rules.block.table.exec(t15);
    if (!e || !this.rules.other.tableDelimiter.test(e[2])) return;
    let r = j4(e[1]), n = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = ((_a2 = e[3]) == null ? void 0 : _a2.trim()) ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: e[0], header: [], align: [], rows: [] };
    if (r.length === n.length) {
      for (let o of n) this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0; o < r.length; o++) s.header.push({ text: r[o], tokens: this.lexer.inline(r[o]), header: true, align: s.align[o] });
      for (let o of i) s.rows.push(j4(o, s.header.length).map((a, l) => ({ text: a, tokens: this.lexer.inline(a), header: false, align: s.align[l] })));
      return s;
    }
  }
  lheading(t15) {
    let e = this.rules.block.lheading.exec(t15);
    if (e) return { type: "heading", raw: e[0], depth: e[2].charAt(0) === "=" ? 1 : 2, text: e[1], tokens: this.lexer.inline(e[1]) };
  }
  paragraph(t15) {
    let e = this.rules.block.paragraph.exec(t15);
    if (e) {
      let r = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
      return { type: "paragraph", raw: e[0], text: r, tokens: this.lexer.inline(r) };
    }
  }
  text(t15) {
    let e = this.rules.block.text.exec(t15);
    if (e) return { type: "text", raw: e[0], text: e[0], tokens: this.lexer.inline(e[0]) };
  }
  escape(t15) {
    let e = this.rules.inline.escape.exec(t15);
    if (e) return { type: "escape", raw: e[0], text: e[1] };
  }
  tag(t15) {
    let e = this.rules.inline.tag.exec(t15);
    if (e) return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: e[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: e[0] };
  }
  link(t15) {
    let e = this.rules.inline.link.exec(t15);
    if (e) {
      let r = e[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) {
        if (!this.rules.other.endAngleBracket.test(r)) return;
        let s = Xa(r.slice(0, -1), "\\");
        if ((r.length - s.length) % 2 === 0) return;
      } else {
        let s = eK(e[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let o = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + s;
          e[2] = e[2].substring(0, s), e[0] = e[0].substring(0, o).trim(), e[3] = "";
        }
      }
      let n = e[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(n);
        s && (n = s[1], i = s[3]);
      } else i = e[3] ? e[3].slice(1, -1) : "";
      return n = n.trim(), this.rules.other.startAngleBracket.test(n) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(r) ? n = n.slice(1) : n = n.slice(1, -1)), W4(e, { href: n && n.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, e[0], this.lexer, this.rules);
    }
  }
  reflink(t15, e) {
    let r;
    if ((r = this.rules.inline.reflink.exec(t15)) || (r = this.rules.inline.nolink.exec(t15))) {
      let n = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = e[n.toLowerCase()];
      if (!i) {
        let s = r[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return W4(r, i, r[0], this.lexer, this.rules);
    }
  }
  emStrong(t15, e, r = "") {
    let n = this.rules.inline.emStrongLDelim.exec(t15);
    if (!(!n || n[3] && r.match(this.rules.other.unicodeAlphaNumeric)) && (!(n[1] || n[2]) || !r || this.rules.inline.punctuation.exec(r))) {
      let i = [...n[0]].length - 1, s, o, a = i, l = 0, c = n[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, e = e.slice(-1 * t15.length + i); (n = c.exec(e)) != null; ) {
        if (s = n[1] || n[2] || n[3] || n[4] || n[5] || n[6], !s) continue;
        if (o = [...s].length, n[3] || n[4]) {
          a += o;
          continue;
        } else if ((n[5] || n[6]) && i % 3 && !((i + o) % 3)) {
          l += o;
          continue;
        }
        if (a -= o, a > 0) continue;
        o = Math.min(o, o + a + l);
        let h10 = [...n[0]][0].length, p = t15.slice(0, i + n.index + h10 + o);
        if (Math.min(i, o) % 2) {
          let g = p.slice(1, -1);
          return { type: "em", raw: p, text: g, tokens: this.lexer.inlineTokens(g) };
        }
        let m = p.slice(2, -2);
        return { type: "strong", raw: p, text: m, tokens: this.lexer.inlineTokens(m) };
      }
    }
  }
  codespan(t15) {
    let e = this.rules.inline.code.exec(t15);
    if (e) {
      let r = e[2].replace(this.rules.other.newLineCharGlobal, " "), n = this.rules.other.nonSpaceChar.test(r), i = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r);
      return n && i && (r = r.substring(1, r.length - 1)), { type: "codespan", raw: e[0], text: r };
    }
  }
  br(t15) {
    let e = this.rules.inline.br.exec(t15);
    if (e) return { type: "br", raw: e[0] };
  }
  del(t15) {
    let e = this.rules.inline.del.exec(t15);
    if (e) return { type: "del", raw: e[0], text: e[2], tokens: this.lexer.inlineTokens(e[2]) };
  }
  autolink(t15) {
    let e = this.rules.inline.autolink.exec(t15);
    if (e) {
      let r, n;
      return e[2] === "@" ? (r = e[1], n = "mailto:" + r) : (r = e[1], n = r), { type: "link", raw: e[0], text: r, href: n, tokens: [{ type: "text", raw: r, text: r }] };
    }
  }
  url(t15) {
    var _a2;
    let e;
    if (e = this.rules.inline.url.exec(t15)) {
      let r, n;
      if (e[2] === "@") r = e[0], n = "mailto:" + r;
      else {
        let i;
        do
          i = e[0], e[0] = ((_a2 = this.rules.inline._backpedal.exec(e[0])) == null ? void 0 : _a2[0]) ?? "";
        while (i !== e[0]);
        r = e[0], e[1] === "www." ? n = "http://" + e[0] : n = e[0];
      }
      return { type: "link", raw: e[0], text: r, href: n, tokens: [{ type: "text", raw: r, text: r }] };
    }
  }
  inlineText(t15) {
    let e = this.rules.inline.text.exec(t15);
    if (e) {
      let r = this.lexer.state.inRawBlock;
      return { type: "text", raw: e[0], text: e[0], escaped: r };
    }
  }
};
var $i = class d1 {
  constructor(e) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || fo, this.options.tokenizer = this.options.tokenizer || new Pu(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let r = { other: Er, block: uh.normal, inline: Ga.normal };
    this.options.pedantic ? (r.block = uh.pedantic, r.inline = Ga.pedantic) : this.options.gfm && (r.block = uh.gfm, this.options.breaks ? r.inline = Ga.breaks : r.inline = Ga.gfm), this.tokenizer.rules = r;
  }
  static get rules() {
    return { block: uh, inline: Ga };
  }
  static lex(e, r) {
    return new d1(r).lex(e);
  }
  static lexInline(e, r) {
    return new d1(r).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(Er.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      let n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = [], n = false) {
    var _a2, _b2, _c;
    for (this.options.pedantic && (e = e.replace(Er.tabCharGlobal, "    ").replace(Er.spaceLine, "")); e; ) {
      let i;
      if ((_b2 = (_a2 = this.options.extensions) == null ? void 0 : _a2.block) == null ? void 0 : _b2.some((o) => (i = o.call({ lexer: this }, e, r)) ? (e = e.substring(i.raw.length), r.push(i), true) : false)) continue;
      if (i = this.tokenizer.space(e)) {
        e = e.substring(i.raw.length);
        let o = r.at(-1);
        i.raw.length === 1 && o !== void 0 ? o.raw += `
` : r.push(i);
        continue;
      }
      if (i = this.tokenizer.code(e)) {
        e = e.substring(i.raw.length);
        let o = r.at(-1);
        (o == null ? void 0 : o.type) === "paragraph" || (o == null ? void 0 : o.type) === "text" ? (o.raw += `
` + i.raw, o.text += `
` + i.text, this.inlineQueue.at(-1).src = o.text) : r.push(i);
        continue;
      }
      if (i = this.tokenizer.fences(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.heading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.hr(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.blockquote(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.list(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.html(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.def(e)) {
        e = e.substring(i.raw.length);
        let o = r.at(-1);
        (o == null ? void 0 : o.type) === "paragraph" || (o == null ? void 0 : o.type) === "text" ? (o.raw += `
` + i.raw, o.text += `
` + i.raw, this.inlineQueue.at(-1).src = o.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = { href: i.href, title: i.title });
        continue;
      }
      if (i = this.tokenizer.table(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.lheading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      let s = e;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
        let o = 1 / 0, a = e.slice(1), l;
        this.options.extensions.startBlock.forEach((c) => {
          l = c.call({ lexer: this }, a), typeof l == "number" && l >= 0 && (o = Math.min(o, l));
        }), o < 1 / 0 && o >= 0 && (s = e.substring(0, o + 1));
      }
      if (this.state.top && (i = this.tokenizer.paragraph(s))) {
        let o = r.at(-1);
        n && (o == null ? void 0 : o.type) === "paragraph" ? (o.raw += `
` + i.raw, o.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = o.text) : r.push(i), n = s.length !== e.length, e = e.substring(i.raw.length);
        continue;
      }
      if (i = this.tokenizer.text(e)) {
        e = e.substring(i.raw.length);
        let o = r.at(-1);
        (o == null ? void 0 : o.type) === "text" ? (o.raw += `
` + i.raw, o.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = o.text) : r.push(i);
        continue;
      }
      if (e) {
        let o = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(o);
          break;
        } else throw new Error(o);
      }
    }
    return this.state.top = true, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  inlineTokens(e, r = []) {
    var _a2, _b2, _c;
    let n = e, i = null;
    if (this.tokens.links) {
      let a = Object.keys(this.tokens.links);
      if (a.length > 0) for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) a.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, i.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (i = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) n = n.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let s = false, o = "";
    for (; e; ) {
      s || (o = ""), s = false;
      let a;
      if ((_b2 = (_a2 = this.options.extensions) == null ? void 0 : _a2.inline) == null ? void 0 : _b2.some((c) => (a = c.call({ lexer: this }, e, r)) ? (e = e.substring(a.raw.length), r.push(a), true) : false)) continue;
      if (a = this.tokenizer.escape(e)) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      if (a = this.tokenizer.tag(e)) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      if (a = this.tokenizer.link(e)) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      if (a = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(a.raw.length);
        let c = r.at(-1);
        a.type === "text" && (c == null ? void 0 : c.type) === "text" ? (c.raw += a.raw, c.text += a.text) : r.push(a);
        continue;
      }
      if (a = this.tokenizer.emStrong(e, n, o)) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      if (a = this.tokenizer.codespan(e)) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      if (a = this.tokenizer.br(e)) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      if (a = this.tokenizer.del(e)) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      if (a = this.tokenizer.autolink(e)) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      if (!this.state.inLink && (a = this.tokenizer.url(e))) {
        e = e.substring(a.raw.length), r.push(a);
        continue;
      }
      let l = e;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startInline) {
        let c = 1 / 0, h10 = e.slice(1), p;
        this.options.extensions.startInline.forEach((m) => {
          p = m.call({ lexer: this }, h10), typeof p == "number" && p >= 0 && (c = Math.min(c, p));
        }), c < 1 / 0 && c >= 0 && (l = e.substring(0, c + 1));
      }
      if (a = this.tokenizer.inlineText(l)) {
        e = e.substring(a.raw.length), a.raw.slice(-1) !== "_" && (o = a.raw.slice(-1)), s = true;
        let c = r.at(-1);
        (c == null ? void 0 : c.type) === "text" ? (c.raw += a.raw, c.text += a.text) : r.push(a);
        continue;
      }
      if (e) {
        let c = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(c);
          break;
        } else throw new Error(c);
      }
    }
    return r;
  }
};
var ju = class {
  constructor(t15) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = t15 || fo;
  }
  space(t15) {
    return "";
  }
  code({ text: t15, lang: e, escaped: r }) {
    var _a2;
    let n = (_a2 = (e || "").match(Er.notSpaceStart)) == null ? void 0 : _a2[0], i = t15.replace(Er.endingNewline, "") + `
`;
    return n ? '<pre><code class="language-' + Pn(n) + '">' + (r ? i : Pn(i, true)) + `</code></pre>
` : "<pre><code>" + (r ? i : Pn(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: t15 }) {
    return `<blockquote>
${this.parser.parse(t15)}</blockquote>
`;
  }
  html({ text: t15 }) {
    return t15;
  }
  heading({ tokens: t15, depth: e }) {
    return `<h${e}>${this.parser.parseInline(t15)}</h${e}>
`;
  }
  hr(t15) {
    return `<hr>
`;
  }
  list(t15) {
    let e = t15.ordered, r = t15.start, n = "";
    for (let o = 0; o < t15.items.length; o++) {
      let a = t15.items[o];
      n += this.listitem(a);
    }
    let i = e ? "ol" : "ul", s = e && r !== 1 ? ' start="' + r + '"' : "";
    return "<" + i + s + `>
` + n + "</" + i + `>
`;
  }
  listitem(t15) {
    var _a2;
    let e = "";
    if (t15.task) {
      let r = this.checkbox({ checked: !!t15.checked });
      t15.loose ? ((_a2 = t15.tokens[0]) == null ? void 0 : _a2.type) === "paragraph" ? (t15.tokens[0].text = r + " " + t15.tokens[0].text, t15.tokens[0].tokens && t15.tokens[0].tokens.length > 0 && t15.tokens[0].tokens[0].type === "text" && (t15.tokens[0].tokens[0].text = r + " " + Pn(t15.tokens[0].tokens[0].text), t15.tokens[0].tokens[0].escaped = true)) : t15.tokens.unshift({ type: "text", raw: r + " ", text: r + " ", escaped: true }) : e += r + " ";
    }
    return e += this.parser.parse(t15.tokens, !!t15.loose), `<li>${e}</li>
`;
  }
  checkbox({ checked: t15 }) {
    return "<input " + (t15 ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: t15 }) {
    return `<p>${this.parser.parseInline(t15)}</p>
`;
  }
  table(t15) {
    let e = "", r = "";
    for (let i = 0; i < t15.header.length; i++) r += this.tablecell(t15.header[i]);
    e += this.tablerow({ text: r });
    let n = "";
    for (let i = 0; i < t15.rows.length; i++) {
      let s = t15.rows[i];
      r = "";
      for (let o = 0; o < s.length; o++) r += this.tablecell(s[o]);
      n += this.tablerow({ text: r });
    }
    return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + n + `</table>
`;
  }
  tablerow({ text: t15 }) {
    return `<tr>
${t15}</tr>
`;
  }
  tablecell(t15) {
    let e = this.parser.parseInline(t15.tokens), r = t15.header ? "th" : "td";
    return (t15.align ? `<${r} align="${t15.align}">` : `<${r}>`) + e + `</${r}>
`;
  }
  strong({ tokens: t15 }) {
    return `<strong>${this.parser.parseInline(t15)}</strong>`;
  }
  em({ tokens: t15 }) {
    return `<em>${this.parser.parseInline(t15)}</em>`;
  }
  codespan({ text: t15 }) {
    return `<code>${Pn(t15, true)}</code>`;
  }
  br(t15) {
    return "<br>";
  }
  del({ tokens: t15 }) {
    return `<del>${this.parser.parseInline(t15)}</del>`;
  }
  link({ href: t15, title: e, tokens: r }) {
    let n = this.parser.parseInline(r), i = P4(t15);
    if (i === null) return n;
    t15 = i;
    let s = '<a href="' + t15 + '"';
    return e && (s += ' title="' + Pn(e) + '"'), s += ">" + n + "</a>", s;
  }
  image({ href: t15, title: e, text: r, tokens: n }) {
    n && (r = this.parser.parseInline(n, this.parser.textRenderer));
    let i = P4(t15);
    if (i === null) return Pn(r);
    t15 = i;
    let s = `<img src="${t15}" alt="${r}"`;
    return e && (s += ` title="${Pn(e)}"`), s += ">", s;
  }
  text(t15) {
    return "tokens" in t15 && t15.tokens ? this.parser.parseInline(t15.tokens) : "escaped" in t15 && t15.escaped ? t15.text : Pn(t15.text);
  }
};
var vg = class {
  strong({ text: t15 }) {
    return t15;
  }
  em({ text: t15 }) {
    return t15;
  }
  codespan({ text: t15 }) {
    return t15;
  }
  del({ text: t15 }) {
    return t15;
  }
  html({ text: t15 }) {
    return t15;
  }
  text({ text: t15 }) {
    return t15;
  }
  link({ text: t15 }) {
    return "" + t15;
  }
  image({ text: t15 }) {
    return "" + t15;
  }
  br() {
    return "";
  }
};
var Ei = class p1 {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = e || fo, this.options.renderer = this.options.renderer || new ju(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new vg();
  }
  static parse(e, r) {
    return new p1(r).parse(e);
  }
  static parseInline(e, r) {
    return new p1(r).parseInline(e);
  }
  parse(e, r = true) {
    var _a2, _b2;
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if ((_b2 = (_a2 = this.options.extensions) == null ? void 0 : _a2.renderers) == null ? void 0 : _b2[s.type]) {
        let a = s, l = this.options.extensions.renderers[a.type].call({ parser: this }, a);
        if (l !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(a.type)) {
          n += l || "";
          continue;
        }
      }
      let o = s;
      switch (o.type) {
        case "space": {
          n += this.renderer.space(o);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(o);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(o);
          continue;
        }
        case "code": {
          n += this.renderer.code(o);
          continue;
        }
        case "table": {
          n += this.renderer.table(o);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(o);
          continue;
        }
        case "list": {
          n += this.renderer.list(o);
          continue;
        }
        case "html": {
          n += this.renderer.html(o);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(o);
          continue;
        }
        case "text": {
          let a = o, l = this.renderer.text(a);
          for (; i + 1 < e.length && e[i + 1].type === "text"; ) a = e[++i], l += `
` + this.renderer.text(a);
          r ? n += this.renderer.paragraph({ type: "paragraph", raw: l, text: l, tokens: [{ type: "text", raw: l, text: l, escaped: true }] }) : n += l;
          continue;
        }
        default: {
          let a = 'Token with "' + o.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
  parseInline(e, r = this.renderer) {
    var _a2, _b2;
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if ((_b2 = (_a2 = this.options.extensions) == null ? void 0 : _a2.renderers) == null ? void 0 : _b2[s.type]) {
        let a = this.options.extensions.renderers[s.type].call({ parser: this }, s);
        if (a !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type)) {
          n += a || "";
          continue;
        }
      }
      let o = s;
      switch (o.type) {
        case "escape": {
          n += r.text(o);
          break;
        }
        case "html": {
          n += r.html(o);
          break;
        }
        case "link": {
          n += r.link(o);
          break;
        }
        case "image": {
          n += r.image(o);
          break;
        }
        case "strong": {
          n += r.strong(o);
          break;
        }
        case "em": {
          n += r.em(o);
          break;
        }
        case "codespan": {
          n += r.codespan(o);
          break;
        }
        case "br": {
          n += r.br(o);
          break;
        }
        case "del": {
          n += r.del(o);
          break;
        }
        case "text": {
          n += r.text(o);
          break;
        }
        default: {
          let a = 'Token with "' + o.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
};
var _a;
var qh = (_a = class {
  constructor(t15) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = t15 || fo;
  }
  preprocess(t15) {
    return t15;
  }
  postprocess(t15) {
    return t15;
  }
  processAllTokens(t15) {
    return t15;
  }
  provideLexer() {
    return this.block ? $i.lex : $i.lexInline;
  }
  provideParser() {
    return this.block ? Ei.parse : Ei.parseInline;
  }
}, __publicField(_a, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"])), _a);
var nK = class {
  constructor(...t15) {
    __publicField(this, "defaults", fg());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", Ei);
    __publicField(this, "Renderer", ju);
    __publicField(this, "TextRenderer", vg);
    __publicField(this, "Lexer", $i);
    __publicField(this, "Tokenizer", Pu);
    __publicField(this, "Hooks", qh);
    this.use(...t15);
  }
  walkTokens(t15, e) {
    var _a2, _b2;
    let r = [];
    for (let n of t15) switch (r = r.concat(e.call(this, n)), n.type) {
      case "table": {
        let i = n;
        for (let s of i.header) r = r.concat(this.walkTokens(s.tokens, e));
        for (let s of i.rows) for (let o of s) r = r.concat(this.walkTokens(o.tokens, e));
        break;
      }
      case "list": {
        let i = n;
        r = r.concat(this.walkTokens(i.items, e));
        break;
      }
      default: {
        let i = n;
        ((_b2 = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b2[i.type]) ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let o = i[s].flat(1 / 0);
          r = r.concat(this.walkTokens(o, e));
        }) : i.tokens && (r = r.concat(this.walkTokens(i.tokens, e)));
      }
    }
    return r;
  }
  use(...t15) {
    let e = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return t15.forEach((r) => {
      let n = { ...r };
      if (n.async = this.defaults.async || n.async || false, r.extensions && (r.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = e.renderers[i.name];
          s ? e.renderers[i.name] = function(...o) {
            let a = i.renderer.apply(this, o);
            return a === false && (a = s.apply(this, o)), a;
          } : e.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = e[i.level];
          s ? s.unshift(i.tokenizer) : e[i.level] = [i.tokenizer], i.start && (i.level === "block" ? e.startBlock ? e.startBlock.push(i.start) : e.startBlock = [i.start] : i.level === "inline" && (e.startInline ? e.startInline.push(i.start) : e.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (e.childTokens[i.name] = i.childTokens);
      }), n.extensions = e), r.renderer) {
        let i = this.defaults.renderer || new ju(this.defaults);
        for (let s in r.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, a = r.renderer[o], l = i[o];
          i[o] = (...c) => {
            let h10 = a.apply(i, c);
            return h10 === false && (h10 = l.apply(i, c)), h10 || "";
          };
        }
        n.renderer = i;
      }
      if (r.tokenizer) {
        let i = this.defaults.tokenizer || new Pu(this.defaults);
        for (let s in r.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, a = r.tokenizer[o], l = i[o];
          i[o] = (...c) => {
            let h10 = a.apply(i, c);
            return h10 === false && (h10 = l.apply(i, c)), h10;
          };
        }
        n.tokenizer = i;
      }
      if (r.hooks) {
        let i = this.defaults.hooks || new qh();
        for (let s in r.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, a = r.hooks[o], l = i[o];
          qh.passThroughHooks.has(s) ? i[o] = (c) => {
            if (this.defaults.async) return Promise.resolve(a.call(i, c)).then((p) => l.call(i, p));
            let h10 = a.call(i, c);
            return l.call(i, h10);
          } : i[o] = (...c) => {
            let h10 = a.apply(i, c);
            return h10 === false && (h10 = l.apply(i, c)), h10;
          };
        }
        n.hooks = i;
      }
      if (r.walkTokens) {
        let i = this.defaults.walkTokens, s = r.walkTokens;
        n.walkTokens = function(o) {
          let a = [];
          return a.push(s.call(this, o)), i && (a = a.concat(i.call(this, o))), a;
        };
      }
      this.defaults = { ...this.defaults, ...n };
    }), this;
  }
  setOptions(t15) {
    return this.defaults = { ...this.defaults, ...t15 }, this;
  }
  lexer(t15, e) {
    return $i.lex(t15, e ?? this.defaults);
  }
  parser(t15, e) {
    return Ei.parse(t15, e ?? this.defaults);
  }
  parseMarkdown(t15) {
    return (e, r) => {
      let n = { ...r }, i = { ...this.defaults, ...n }, s = this.onError(!!i.silent, !!i.async);
      if (this.defaults.async === true && n.async === false) return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof e > "u" || e === null) return s(new Error("marked(): input parameter is undefined or null"));
      if (typeof e != "string") return s(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"));
      i.hooks && (i.hooks.options = i, i.hooks.block = t15);
      let o = i.hooks ? i.hooks.provideLexer() : t15 ? $i.lex : $i.lexInline, a = i.hooks ? i.hooks.provideParser() : t15 ? Ei.parse : Ei.parseInline;
      if (i.async) return Promise.resolve(i.hooks ? i.hooks.preprocess(e) : e).then((l) => o(l, i)).then((l) => i.hooks ? i.hooks.processAllTokens(l) : l).then((l) => i.walkTokens ? Promise.all(this.walkTokens(l, i.walkTokens)).then(() => l) : l).then((l) => a(l, i)).then((l) => i.hooks ? i.hooks.postprocess(l) : l).catch(s);
      try {
        i.hooks && (e = i.hooks.preprocess(e));
        let l = o(e, i);
        i.hooks && (l = i.hooks.processAllTokens(l)), i.walkTokens && this.walkTokens(l, i.walkTokens);
        let c = a(l, i);
        return i.hooks && (c = i.hooks.postprocess(c)), c;
      } catch (l) {
        return s(l);
      }
    };
  }
  onError(t15, e) {
    return (r) => {
      if (r.message += `
Please report this to https://github.com/markedjs/marked.`, t15) {
        let n = "<p>An error occurred:</p><pre>" + Pn(r.message + "", true) + "</pre>";
        return e ? Promise.resolve(n) : n;
      }
      if (e) return Promise.reject(r);
      throw r;
    };
  }
};
var io = new nK();
function ye(t15, e) {
  return io.parse(t15, e);
}
ye.options = ye.setOptions = function(t15) {
  return io.setOptions(t15), ye.defaults = io.defaults, pv(ye.defaults), ye;
};
ye.getDefaults = fg;
ye.defaults = fo;
ye.use = function(...t15) {
  return io.use(...t15), ye.defaults = io.defaults, pv(ye.defaults), ye;
};
ye.walkTokens = function(t15, e) {
  return io.walkTokens(t15, e);
};
ye.parseInline = io.parseInline;
ye.Parser = Ei;
ye.parser = Ei.parse;
ye.Renderer = ju;
ye.TextRenderer = vg;
ye.Lexer = $i;
ye.lexer = $i.lex;
ye.Tokenizer = Pu;
ye.Hooks = qh;
ye.parse = ye;
ye.options;
ye.setOptions;
ye.use;
ye.walkTokens;
ye.parseInline;
Ei.parse;
$i.lex;
function Cv(t15) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var n = Array.from(typeof t15 == "string" ? [t15] : t15);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i = n.reduce(function(a, l) {
    var c = l.match(/\n([\t ]+|(?!\s).)/g);
    return c ? a.concat(c.map(function(h10) {
      var p, m;
      return (m = (p = h10.match(/[\t ]/g)) === null || p === void 0 ? void 0 : p.length) !== null && m !== void 0 ? m : 0;
    })) : a;
  }, []);
  if (i.length) {
    var s = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
    n = n.map(function(a) {
      return a.replace(s, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var o = n[0];
  return e.forEach(function(a, l) {
    var c = o.match(/(?:^|\n)( *)$/), h10 = c ? c[1] : "", p = a;
    typeof a == "string" && a.includes(`
`) && (p = String(a).split(`
`).map(function(m, g) {
      return g === 0 ? m : "" + h10 + m;
    }).join(`
`)), o += p + n[l + 1];
  }), o;
}
var iK = {
  body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
  height: 80,
  width: 80
};
var f1 = /* @__PURE__ */ new Map();
var Sv = /* @__PURE__ */ new Map();
var sK = S((t15) => {
  for (const e of t15) {
    if (!e.name)
      throw new Error(
        'Invalid icon loader. Must have a "name" property with non-empty string value.'
      );
    if (ut.debug("Registering icon pack:", e.name), "loader" in e)
      Sv.set(e.name, e.loader);
    else if ("icons" in e)
      f1.set(e.name, e.icons);
    else
      throw ut.error("Invalid icon loader:", e), new Error('Invalid icon loader. Must have either "icons" or "loader" property.');
  }
}, "registerIconPacks");
var Tv = S(async (t15, e) => {
  const r = oY(t15, true, e !== void 0);
  if (!r)
    throw new Error(`Invalid icon name: ${t15}`);
  const n = r.prefix || e;
  if (!n)
    throw new Error(`Icon name must contain a prefix: ${t15}`);
  let i = f1.get(n);
  if (!i) {
    const o = Sv.get(n);
    if (!o)
      throw new Error(`Icon set not found: ${r.prefix}`);
    try {
      i = { ...await o(), prefix: n }, f1.set(n, i);
    } catch (a) {
      throw ut.error(a), new Error(`Failed to load icon set: ${r.prefix}`);
    }
  }
  const s = cY(i, r.name);
  if (!s)
    throw new Error(`Icon not found: ${t15}`);
  return s;
}, "getRegisteredIconData");
var oK = S(async (t15) => {
  try {
    return await Tv(t15), true;
  } catch {
    return false;
  }
}, "isIconAvailable");
var bc = S(async (t15, e, r) => {
  let n;
  try {
    n = await Tv(t15, e == null ? void 0 : e.fallbackPrefix);
  } catch (s) {
    ut.error(s), n = iK;
  }
  const i = gY(n, e);
  return kY(wY(i.body), {
    ...i.attributes,
    ...r
  });
}, "getIconSVG");
function Av(t15, { markdownAutoWrap: e }) {
  const r = t15.replace(/<br\/>/g, `
`).replace(/\n{2,}/g, `
`), n = Cv(r);
  return e === false ? n.replace(/ /g, "&nbsp;") : n;
}
S(Av, "preprocessMarkdown");
function $v(t15, e = {}) {
  const r = Av(t15, e), n = ye.lexer(r), i = [[]];
  let s = 0;
  function o(a, l = "normal") {
    a.type === "text" ? a.text.split(`
`).forEach((c, h10) => {
      h10 !== 0 && (s++, i.push([])), c.split(" ").forEach((p) => {
        p = p.replace(/&#39;/g, "'"), p && i[s].push({ content: p, type: l });
      });
    }) : a.type === "strong" || a.type === "em" ? a.tokens.forEach((c) => {
      o(c, a.type);
    }) : a.type === "html" && i[s].push({ content: a.text, type: "normal" });
  }
  return S(o, "processNode"), n.forEach((a) => {
    var _a2;
    a.type === "paragraph" ? (_a2 = a.tokens) == null ? void 0 : _a2.forEach((l) => {
      o(l);
    }) : a.type === "html" && i[s].push({ content: a.text, type: "normal" });
  }), i;
}
S($v, "markdownToLines");
function Ev(t15, { markdownAutoWrap: e } = {}) {
  const r = ye.lexer(t15);
  function n(i) {
    var _a2, _b2, _c;
    return i.type === "text" ? e === false ? i.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;") : i.text.replace(/\n */g, "<br/>") : i.type === "strong" ? `<strong>${(_a2 = i.tokens) == null ? void 0 : _a2.map(n).join("")}</strong>` : i.type === "em" ? `<em>${(_b2 = i.tokens) == null ? void 0 : _b2.map(n).join("")}</em>` : i.type === "paragraph" ? `<p>${(_c = i.tokens) == null ? void 0 : _c.map(n).join("")}</p>` : i.type === "space" ? "" : i.type === "html" ? `${i.text}` : i.type === "escape" ? i.text : `Unsupported markdown: ${i.type}`;
  }
  return S(n, "output"), r.map(n).join("");
}
S(Ev, "markdownToHTML");
function Mv(t15) {
  return Intl.Segmenter ? [...new Intl.Segmenter().segment(t15)].map((e) => e.segment) : [...t15];
}
S(Mv, "splitTextToChars");
function Bv(t15, e) {
  const r = Mv(e.content);
  return _g(t15, [], r, e.type);
}
S(Bv, "splitWordToFitWidth");
function _g(t15, e, r, n) {
  if (r.length === 0)
    return [
      { content: e.join(""), type: n },
      { content: "", type: n }
    ];
  const [i, ...s] = r, o = [...e, i];
  return t15([{ content: o.join(""), type: n }]) ? _g(t15, o, s, n) : (e.length === 0 && i && (e.push(i), r.shift()), [
    { content: e.join(""), type: n },
    { content: r.join(""), type: n }
  ]);
}
S(_g, "splitWordToFitWidthRecursion");
function Lv(t15, e) {
  if (t15.some(({ content: r }) => r.includes(`
`)))
    throw new Error("splitLineToFitWidth does not support newlines in the line");
  return Wu(t15, e);
}
S(Lv, "splitLineToFitWidth");
function Wu(t15, e, r = [], n = []) {
  if (t15.length === 0)
    return n.length > 0 && r.push(n), r.length > 0 ? r : [];
  let i = "";
  t15[0].content === " " && (i = " ", t15.shift());
  const s = t15.shift() ?? { content: " ", type: "normal" }, o = [...n];
  if (i !== "" && o.push({ content: i, type: "normal" }), o.push(s), e(o))
    return Wu(t15, e, r, o);
  if (n.length > 0)
    r.push(n), t15.unshift(s);
  else if (s.content) {
    const [a, l] = Bv(e, s);
    r.push([a]), l.content && t15.unshift(l);
  }
  return Wu(t15, e, r);
}
S(Wu, "splitLineToFitWidthRecursion");
function m1(t15, e) {
  e && t15.attr("style", e);
}
S(m1, "applyStyle");
async function Dv(t15, e, r, n, i = false) {
  const s = t15.append("foreignObject");
  s.attr("width", `${10 * r}px`), s.attr("height", `${10 * r}px`);
  const o = s.append("xhtml:div");
  let a = e.label;
  e.label && ta(e.label) && (a = await Dm(e.label.replace(ga.lineBreakRegex, `
`), me()));
  const l = e.isNode ? "nodeLabel" : "edgeLabel", c = o.append("span");
  c.html(a), m1(c, e.labelStyle), c.attr("class", `${l} ${n}`), m1(o, e.labelStyle), o.style("display", "table-cell"), o.style("white-space", "nowrap"), o.style("line-height", "1.5"), o.style("max-width", r + "px"), o.style("text-align", "center"), o.attr("xmlns", "http://www.w3.org/1999/xhtml"), i && o.attr("class", "labelBkg");
  let h10 = o.node().getBoundingClientRect();
  return h10.width === r && (o.style("display", "table"), o.style("white-space", "break-spaces"), o.style("width", r + "px"), h10 = o.node().getBoundingClientRect()), s.node();
}
S(Dv, "addHtmlSpan");
function W0(t15, e, r) {
  return t15.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", e * r - 0.1 + "em").attr("dy", r + "em");
}
S(W0, "createTspan");
function Fv(t15, e, r) {
  const n = t15.append("text"), i = W0(n, 1, e);
  H0(i, r);
  const s = i.node().getComputedTextLength();
  return n.remove(), s;
}
S(Fv, "computeWidthOfText");
function aK(t15, e, r) {
  var _a2;
  const n = t15.append("text"), i = W0(n, 1, e);
  H0(i, [{ content: r, type: "normal" }]);
  const s = (_a2 = i.node()) == null ? void 0 : _a2.getBoundingClientRect();
  return s && n.remove(), s;
}
S(aK, "computeDimensionOfText");
function Nv(t15, e, r, n = false) {
  const i = e.append("g"), s = i.insert("rect").attr("class", "background").attr("style", "stroke: none"), o = i.append("text").attr("y", "-10.1");
  let a = 0;
  for (const l of r) {
    const c = S((p) => Fv(i, 1.1, p) <= t15, "checkWidth"), h10 = c(l) ? [l] : Lv(l, c);
    for (const p of h10) {
      const m = W0(o, a, 1.1);
      H0(m, p), a++;
    }
  }
  if (n) {
    const l = o.node().getBBox(), c = 2;
    return s.attr("x", l.x - c).attr("y", l.y - c).attr("width", l.width + 2 * c).attr("height", l.height + 2 * c), i.node();
  } else
    return o.node();
}
S(Nv, "createFormattedText");
function H0(t15, e) {
  t15.text(""), e.forEach((r, n) => {
    const i = t15.append("tspan").attr("font-style", r.type === "em" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", r.type === "strong" ? "bold" : "normal");
    n === 0 ? i.text(r.content) : i.text(" " + r.content);
  });
}
S(H0, "updateTextContentAndStyles");
async function Iv(t15) {
  const e = [];
  t15.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (n, i, s) => (e.push(
    (async () => {
      const o = `${i}:${s}`;
      return await oK(o) ? await bc(o, void 0, { class: "label-icon" }) : `<i class='${A0(n).replace(":", " ")}'></i>`;
    })()
  ), n));
  const r = await Promise.all(e);
  return t15.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => r.shift() ?? "");
}
S(Iv, "replaceIconSubstring");
var ys = S(async (t15, e = "", {
  style: r = "",
  isTitle: n = false,
  classes: i = "",
  useHtmlLabels: s = true,
  isNode: o = true,
  width: a = 200,
  addSvgBackground: l = false
} = {}, c) => {
  if (ut.debug(
    "XYZ createText",
    e,
    r,
    n,
    i,
    s,
    o,
    "addSvgBackground: ",
    l
  ), s) {
    const h10 = Ev(e, c), p = await Iv(po(h10)), m = e.replace(/\\\\/g, "\\"), g = {
      isNode: o,
      label: ta(e) ? m : p,
      labelStyle: r.replace("fill:", "color:")
    };
    return await Dv(t15, g, a, i, l);
  } else {
    const h10 = e.replace(/<br\s*\/?>/g, "<br/>"), p = $v(h10.replace("<br>", "<br/>"), c), m = Nv(
      a,
      t15,
      p,
      e ? l : false
    );
    if (o) {
      /stroke:/.exec(r) && (r = r.replace("stroke:", "lineColor:"));
      const g = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      ae(m).attr("style", g);
    } else {
      const g = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
      ae(m).select("rect").attr("style", g.replace(/background:/g, "fill:"));
      const y = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      ae(m).select("text").attr("style", y);
    }
    return m;
  }
}, "createText");
function Fp(t15, e, r) {
  if (t15 && t15.length) {
    const [n, i] = e, s = Math.PI / 180 * r, o = Math.cos(s), a = Math.sin(s);
    for (const l of t15) {
      const [c, h10] = l;
      l[0] = (c - n) * o - (h10 - i) * a + n, l[1] = (c - n) * a + (h10 - i) * o + i;
    }
  }
}
function lK(t15, e) {
  return t15[0] === e[0] && t15[1] === e[1];
}
function cK(t15, e, r, n = 1) {
  const i = r, s = Math.max(e, 0.1), o = t15[0] && t15[0][0] && typeof t15[0][0] == "number" ? [t15] : t15, a = [0, 0];
  if (i) for (const c of o) Fp(c, a, i);
  const l = function(c, h10, p) {
    const m = [];
    for (const _ of c) {
      const $ = [..._];
      lK($[0], $[$.length - 1]) || $.push([$[0][0], $[0][1]]), $.length > 2 && m.push($);
    }
    const g = [];
    h10 = Math.max(h10, 0.1);
    const y = [];
    for (const _ of m) for (let $ = 0; $ < _.length - 1; $++) {
      const L = _[$], B = _[$ + 1];
      if (L[1] !== B[1]) {
        const q = Math.min(L[1], B[1]);
        y.push({ ymin: q, ymax: Math.max(L[1], B[1]), x: q === L[1] ? L[0] : B[0], islope: (B[0] - L[0]) / (B[1] - L[1]) });
      }
    }
    if (y.sort((_, $) => _.ymin < $.ymin ? -1 : _.ymin > $.ymin ? 1 : _.x < $.x ? -1 : _.x > $.x ? 1 : _.ymax === $.ymax ? 0 : (_.ymax - $.ymax) / Math.abs(_.ymax - $.ymax)), !y.length) return g;
    let x = [], k = y[0].ymin, C = 0;
    for (; x.length || y.length; ) {
      if (y.length) {
        let _ = -1;
        for (let $ = 0; $ < y.length && !(y[$].ymin > k); $++) _ = $;
        y.splice(0, _ + 1).forEach(($) => {
          x.push({ s: k, edge: $ });
        });
      }
      if (x = x.filter((_) => !(_.edge.ymax <= k)), x.sort((_, $) => _.edge.x === $.edge.x ? 0 : (_.edge.x - $.edge.x) / Math.abs(_.edge.x - $.edge.x)), (p !== 1 || C % h10 == 0) && x.length > 1) for (let _ = 0; _ < x.length; _ += 2) {
        const $ = _ + 1;
        if ($ >= x.length) break;
        const L = x[_].edge, B = x[$].edge;
        g.push([[Math.round(L.x), k], [Math.round(B.x), k]]);
      }
      k += p, x.forEach((_) => {
        _.edge.x = _.edge.x + p * _.edge.islope;
      }), C++;
    }
    return g;
  }(o, s, n);
  if (i) {
    for (const c of o) Fp(c, a, -i);
    (function(c, h10, p) {
      const m = [];
      c.forEach((g) => m.push(...g)), Fp(m, h10, p);
    })(l, a, -i);
  }
  return l;
}
function xc(t15, e) {
  var r;
  const n = e.hachureAngle + 90;
  let i = e.hachureGap;
  i < 0 && (i = 4 * e.strokeWidth), i = Math.round(Math.max(i, 0.1));
  let s = 1;
  return e.roughness >= 1 && (((r = e.randomizer) === null || r === void 0 ? void 0 : r.next()) || Math.random()) > 0.7 && (s = i), cK(t15, i, n, s || 1);
}
var Cg = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    return this._fillPolygons(e, r);
  }
  _fillPolygons(e, r) {
    const n = xc(e, r);
    return { type: "fillSketch", ops: this.renderLines(n, r) };
  }
  renderLines(e, r) {
    const n = [];
    for (const i of e) n.push(...this.helper.doubleLineOps(i[0][0], i[0][1], i[1][0], i[1][1], r));
    return n;
  }
};
function U0(t15) {
  const e = t15[0], r = t15[1];
  return Math.sqrt(Math.pow(e[0] - r[0], 2) + Math.pow(e[1] - r[1], 2));
}
var hK = class extends Cg {
  fillPolygons(e, r) {
    let n = r.hachureGap;
    n < 0 && (n = 4 * r.strokeWidth), n = Math.max(n, 0.1);
    const i = xc(e, Object.assign({}, r, { hachureGap: n })), s = Math.PI / 180 * r.hachureAngle, o = [], a = 0.5 * n * Math.cos(s), l = 0.5 * n * Math.sin(s);
    for (const [c, h10] of i) U0([c, h10]) && o.push([[c[0] - a, c[1] + l], [...h10]], [[c[0] + a, c[1] - l], [...h10]]);
    return { type: "fillSketch", ops: this.renderLines(o, r) };
  }
};
var uK = class extends Cg {
  fillPolygons(e, r) {
    const n = this._fillPolygons(e, r), i = Object.assign({}, r, { hachureAngle: r.hachureAngle + 90 }), s = this._fillPolygons(e, i);
    return n.ops = n.ops.concat(s.ops), n;
  }
};
var dK = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = xc(e, r = Object.assign({}, r, { hachureAngle: 0 }));
    return this.dotsOnLines(n, r);
  }
  dotsOnLines(e, r) {
    const n = [];
    let i = r.hachureGap;
    i < 0 && (i = 4 * r.strokeWidth), i = Math.max(i, 0.1);
    let s = r.fillWeight;
    s < 0 && (s = r.strokeWidth / 2);
    const o = i / 4;
    for (const a of e) {
      const l = U0(a), c = l / i, h10 = Math.ceil(c) - 1, p = l - h10 * i, m = (a[0][0] + a[1][0]) / 2 - i / 4, g = Math.min(a[0][1], a[1][1]);
      for (let y = 0; y < h10; y++) {
        const x = g + p + y * i, k = m - o + 2 * Math.random() * o, C = x - o + 2 * Math.random() * o, _ = this.helper.ellipse(k, C, s, s, r);
        n.push(..._.ops);
      }
    }
    return { type: "fillSketch", ops: n };
  }
};
var pK = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = xc(e, r);
    return { type: "fillSketch", ops: this.dashedLine(n, r) };
  }
  dashedLine(e, r) {
    const n = r.dashOffset < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashOffset, i = r.dashGap < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashGap, s = [];
    return e.forEach((o) => {
      const a = U0(o), l = Math.floor(a / (n + i)), c = (a + i - l * (n + i)) / 2;
      let h10 = o[0], p = o[1];
      h10[0] > p[0] && (h10 = o[1], p = o[0]);
      const m = Math.atan((p[1] - h10[1]) / (p[0] - h10[0]));
      for (let g = 0; g < l; g++) {
        const y = g * (n + i), x = y + n, k = [h10[0] + y * Math.cos(m) + c * Math.cos(m), h10[1] + y * Math.sin(m) + c * Math.sin(m)], C = [h10[0] + x * Math.cos(m) + c * Math.cos(m), h10[1] + x * Math.sin(m) + c * Math.sin(m)];
        s.push(...this.helper.doubleLineOps(k[0], k[1], C[0], C[1], r));
      }
    }), s;
  }
};
var fK = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap, i = r.zigzagOffset < 0 ? n : r.zigzagOffset, s = xc(e, r = Object.assign({}, r, { hachureGap: n + i }));
    return { type: "fillSketch", ops: this.zigzagLines(s, i, r) };
  }
  zigzagLines(e, r, n) {
    const i = [];
    return e.forEach((s) => {
      const o = U0(s), a = Math.round(o / (2 * r));
      let l = s[0], c = s[1];
      l[0] > c[0] && (l = s[1], c = s[0]);
      const h10 = Math.atan((c[1] - l[1]) / (c[0] - l[0]));
      for (let p = 0; p < a; p++) {
        const m = 2 * p * r, g = 2 * (p + 1) * r, y = Math.sqrt(2 * Math.pow(r, 2)), x = [l[0] + m * Math.cos(h10), l[1] + m * Math.sin(h10)], k = [l[0] + g * Math.cos(h10), l[1] + g * Math.sin(h10)], C = [x[0] + y * Math.cos(h10 + Math.PI / 4), x[1] + y * Math.sin(h10 + Math.PI / 4)];
        i.push(...this.helper.doubleLineOps(x[0], x[1], C[0], C[1], n), ...this.helper.doubleLineOps(C[0], C[1], k[0], k[1], n));
      }
    }), i;
  }
};
var Or = {};
var mK = class {
  constructor(e) {
    this.seed = e;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
};
var gK = 0;
var Np = 1;
var H4 = 2;
var dh = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function Ip(t15, e) {
  return t15.type === e;
}
function Sg(t15) {
  const e = [], r = function(o) {
    const a = new Array();
    for (; o !== ""; ) if (o.match(/^([ \t\r\n,]+)/)) o = o.substr(RegExp.$1.length);
    else if (o.match(/^([aAcChHlLmMqQsStTvVzZ])/)) a[a.length] = { type: gK, text: RegExp.$1 }, o = o.substr(RegExp.$1.length);
    else {
      if (!o.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
      a[a.length] = { type: Np, text: `${parseFloat(RegExp.$1)}` }, o = o.substr(RegExp.$1.length);
    }
    return a[a.length] = { type: H4, text: "" }, a;
  }(t15);
  let n = "BOD", i = 0, s = r[i];
  for (; !Ip(s, H4); ) {
    let o = 0;
    const a = [];
    if (n === "BOD") {
      if (s.text !== "M" && s.text !== "m") return Sg("M0,0" + t15);
      i++, o = dh[s.text], n = s.text;
    } else Ip(s, Np) ? o = dh[n] : (i++, o = dh[s.text], n = s.text);
    if (!(i + o < r.length)) throw new Error("Path data ended short");
    for (let l = i; l < i + o; l++) {
      const c = r[l];
      if (!Ip(c, Np)) throw new Error("Param not a number: " + n + "," + c.text);
      a[a.length] = +c.text;
    }
    if (typeof dh[n] != "number") throw new Error("Bad segment: " + n);
    {
      const l = { key: n, data: a };
      e.push(l), i += o, s = r[i], n === "M" && (n = "L"), n === "m" && (n = "l");
    }
  }
  return e;
}
function Ov(t15) {
  let e = 0, r = 0, n = 0, i = 0;
  const s = [];
  for (const { key: o, data: a } of t15) switch (o) {
    case "M":
      s.push({ key: "M", data: [...a] }), [e, r] = a, [n, i] = a;
      break;
    case "m":
      e += a[0], r += a[1], s.push({ key: "M", data: [e, r] }), n = e, i = r;
      break;
    case "L":
      s.push({ key: "L", data: [...a] }), [e, r] = a;
      break;
    case "l":
      e += a[0], r += a[1], s.push({ key: "L", data: [e, r] });
      break;
    case "C":
      s.push({ key: "C", data: [...a] }), e = a[4], r = a[5];
      break;
    case "c": {
      const l = a.map((c, h10) => h10 % 2 ? c + r : c + e);
      s.push({ key: "C", data: l }), e = l[4], r = l[5];
      break;
    }
    case "Q":
      s.push({ key: "Q", data: [...a] }), e = a[2], r = a[3];
      break;
    case "q": {
      const l = a.map((c, h10) => h10 % 2 ? c + r : c + e);
      s.push({ key: "Q", data: l }), e = l[2], r = l[3];
      break;
    }
    case "A":
      s.push({ key: "A", data: [...a] }), e = a[5], r = a[6];
      break;
    case "a":
      e += a[5], r += a[6], s.push({ key: "A", data: [a[0], a[1], a[2], a[3], a[4], e, r] });
      break;
    case "H":
      s.push({ key: "H", data: [...a] }), e = a[0];
      break;
    case "h":
      e += a[0], s.push({ key: "H", data: [e] });
      break;
    case "V":
      s.push({ key: "V", data: [...a] }), r = a[0];
      break;
    case "v":
      r += a[0], s.push({ key: "V", data: [r] });
      break;
    case "S":
      s.push({ key: "S", data: [...a] }), e = a[2], r = a[3];
      break;
    case "s": {
      const l = a.map((c, h10) => h10 % 2 ? c + r : c + e);
      s.push({ key: "S", data: l }), e = l[2], r = l[3];
      break;
    }
    case "T":
      s.push({ key: "T", data: [...a] }), e = a[0], r = a[1];
      break;
    case "t":
      e += a[0], r += a[1], s.push({ key: "T", data: [e, r] });
      break;
    case "Z":
    case "z":
      s.push({ key: "Z", data: [] }), e = n, r = i;
  }
  return s;
}
function zv(t15) {
  const e = [];
  let r = "", n = 0, i = 0, s = 0, o = 0, a = 0, l = 0;
  for (const { key: c, data: h10 } of t15) {
    switch (c) {
      case "M":
        e.push({ key: "M", data: [...h10] }), [n, i] = h10, [s, o] = h10;
        break;
      case "C":
        e.push({ key: "C", data: [...h10] }), n = h10[4], i = h10[5], a = h10[2], l = h10[3];
        break;
      case "L":
        e.push({ key: "L", data: [...h10] }), [n, i] = h10;
        break;
      case "H":
        n = h10[0], e.push({ key: "L", data: [n, i] });
        break;
      case "V":
        i = h10[0], e.push({ key: "L", data: [n, i] });
        break;
      case "S": {
        let p = 0, m = 0;
        r === "C" || r === "S" ? (p = n + (n - a), m = i + (i - l)) : (p = n, m = i), e.push({ key: "C", data: [p, m, ...h10] }), a = h10[0], l = h10[1], n = h10[2], i = h10[3];
        break;
      }
      case "T": {
        const [p, m] = h10;
        let g = 0, y = 0;
        r === "Q" || r === "T" ? (g = n + (n - a), y = i + (i - l)) : (g = n, y = i);
        const x = n + 2 * (g - n) / 3, k = i + 2 * (y - i) / 3, C = p + 2 * (g - p) / 3, _ = m + 2 * (y - m) / 3;
        e.push({ key: "C", data: [x, k, C, _, p, m] }), a = g, l = y, n = p, i = m;
        break;
      }
      case "Q": {
        const [p, m, g, y] = h10, x = n + 2 * (p - n) / 3, k = i + 2 * (m - i) / 3, C = g + 2 * (p - g) / 3, _ = y + 2 * (m - y) / 3;
        e.push({ key: "C", data: [x, k, C, _, g, y] }), a = p, l = m, n = g, i = y;
        break;
      }
      case "A": {
        const p = Math.abs(h10[0]), m = Math.abs(h10[1]), g = h10[2], y = h10[3], x = h10[4], k = h10[5], C = h10[6];
        p === 0 || m === 0 ? (e.push({ key: "C", data: [n, i, k, C, k, C] }), n = k, i = C) : (n !== k || i !== C) && (qv(n, i, k, C, p, m, g, y, x).forEach(function(_) {
          e.push({ key: "C", data: _ });
        }), n = k, i = C);
        break;
      }
      case "Z":
        e.push({ key: "Z", data: [] }), n = s, i = o;
    }
    r = c;
  }
  return e;
}
function Ya(t15, e, r) {
  return [t15 * Math.cos(r) - e * Math.sin(r), t15 * Math.sin(r) + e * Math.cos(r)];
}
function qv(t15, e, r, n, i, s, o, a, l, c) {
  const h10 = (p = o, Math.PI * p / 180);
  var p;
  let m = [], g = 0, y = 0, x = 0, k = 0;
  if (c) [g, y, x, k] = c;
  else {
    [t15, e] = Ya(t15, e, -h10), [r, n] = Ya(r, n, -h10);
    const rt = (t15 - r) / 2, I = (e - n) / 2;
    let j = rt * rt / (i * i) + I * I / (s * s);
    j > 1 && (j = Math.sqrt(j), i *= j, s *= j);
    const z = i * i, K = s * s, Y = z * K - z * I * I - K * rt * rt, at = z * I * I + K * rt * rt, et = (a === l ? -1 : 1) * Math.sqrt(Math.abs(Y / at));
    x = et * i * I / s + (t15 + r) / 2, k = et * -s * rt / i + (e + n) / 2, g = Math.asin(parseFloat(((e - k) / s).toFixed(9))), y = Math.asin(parseFloat(((n - k) / s).toFixed(9))), t15 < x && (g = Math.PI - g), r < x && (y = Math.PI - y), g < 0 && (g = 2 * Math.PI + g), y < 0 && (y = 2 * Math.PI + y), l && g > y && (g -= 2 * Math.PI), !l && y > g && (y -= 2 * Math.PI);
  }
  let C = y - g;
  if (Math.abs(C) > 120 * Math.PI / 180) {
    const rt = y, I = r, j = n;
    y = l && y > g ? g + 120 * Math.PI / 180 * 1 : g + 120 * Math.PI / 180 * -1, m = qv(r = x + i * Math.cos(y), n = k + s * Math.sin(y), I, j, i, s, o, 0, l, [y, rt, x, k]);
  }
  C = y - g;
  const _ = Math.cos(g), $ = Math.sin(g), L = Math.cos(y), B = Math.sin(y), q = Math.tan(C / 4), H = 4 / 3 * i * q, G = 4 / 3 * s * q, F = [t15, e], W = [t15 + H * $, e - G * _], R = [r + H * B, n - G * L], J = [r, n];
  if (W[0] = 2 * F[0] - W[0], W[1] = 2 * F[1] - W[1], c) return [W, R, J].concat(m);
  {
    m = [W, R, J].concat(m);
    const rt = [];
    for (let I = 0; I < m.length; I += 3) {
      const j = Ya(m[I][0], m[I][1], h10), z = Ya(m[I + 1][0], m[I + 1][1], h10), K = Ya(m[I + 2][0], m[I + 2][1], h10);
      rt.push([j[0], j[1], z[0], z[1], K[0], K[1]]);
    }
    return rt;
  }
}
var yK = { randOffset: function(t15, e) {
  return jt(t15, e);
}, randOffsetWithRange: function(t15, e, r) {
  return Hu(t15, e, r);
}, ellipse: function(t15, e, r, n, i) {
  const s = Pv(r, n, i);
  return g1(t15, e, i, s).opset;
}, doubleLineOps: function(t15, e, r, n, i) {
  return ps(t15, e, r, n, i, true);
} };
function Rv(t15, e, r, n, i) {
  return { type: "path", ops: ps(t15, e, r, n, i) };
}
function Rh(t15, e, r) {
  const n = (t15 || []).length;
  if (n > 2) {
    const i = [];
    for (let s = 0; s < n - 1; s++) i.push(...ps(t15[s][0], t15[s][1], t15[s + 1][0], t15[s + 1][1], r));
    return e && i.push(...ps(t15[n - 1][0], t15[n - 1][1], t15[0][0], t15[0][1], r)), { type: "path", ops: i };
  }
  return n === 2 ? Rv(t15[0][0], t15[0][1], t15[1][0], t15[1][1], r) : { type: "path", ops: [] };
}
function bK(t15, e, r, n, i) {
  return function(s, o) {
    return Rh(s, true, o);
  }([[t15, e], [t15 + r, e], [t15 + r, e + n], [t15, e + n]], i);
}
function U4(t15, e) {
  if (t15.length) {
    const r = typeof t15[0][0] == "number" ? [t15] : t15, n = ph(r[0], 1 * (1 + 0.2 * e.roughness), e), i = e.disableMultiStroke ? [] : ph(r[0], 1.5 * (1 + 0.22 * e.roughness), X4(e));
    for (let s = 1; s < r.length; s++) {
      const o = r[s];
      if (o.length) {
        const a = ph(o, 1 * (1 + 0.2 * e.roughness), e), l = e.disableMultiStroke ? [] : ph(o, 1.5 * (1 + 0.22 * e.roughness), X4(e));
        for (const c of a) c.op !== "move" && n.push(c);
        for (const c of l) c.op !== "move" && i.push(c);
      }
    }
    return { type: "path", ops: n.concat(i) };
  }
  return { type: "path", ops: [] };
}
function Pv(t15, e, r) {
  const n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t15 / 2, 2) + Math.pow(e / 2, 2)) / 2)), i = Math.ceil(Math.max(r.curveStepCount, r.curveStepCount / Math.sqrt(200) * n)), s = 2 * Math.PI / i;
  let o = Math.abs(t15 / 2), a = Math.abs(e / 2);
  const l = 1 - r.curveFitting;
  return o += jt(o * l, r), a += jt(a * l, r), { increment: s, rx: o, ry: a };
}
function g1(t15, e, r, n) {
  const [i, s] = Y4(n.increment, t15, e, n.rx, n.ry, 1, n.increment * Hu(0.1, Hu(0.4, 1, r), r), r);
  let o = Uu(i, null, r);
  if (!r.disableMultiStroke && r.roughness !== 0) {
    const [a] = Y4(n.increment, t15, e, n.rx, n.ry, 1.5, 0, r), l = Uu(a, null, r);
    o = o.concat(l);
  }
  return { estimatedPoints: s, opset: { type: "path", ops: o } };
}
function V4(t15, e, r, n, i, s, o, a, l) {
  const c = t15, h10 = e;
  let p = Math.abs(r / 2), m = Math.abs(n / 2);
  p += jt(0.01 * p, l), m += jt(0.01 * m, l);
  let g = i, y = s;
  for (; g < 0; ) g += 2 * Math.PI, y += 2 * Math.PI;
  y - g > 2 * Math.PI && (g = 0, y = 2 * Math.PI);
  const x = 2 * Math.PI / l.curveStepCount, k = Math.min(x / 2, (y - g) / 2), C = K4(k, c, h10, p, m, g, y, 1, l);
  if (!l.disableMultiStroke) {
    const _ = K4(k, c, h10, p, m, g, y, 1.5, l);
    C.push(..._);
  }
  return o && (a ? C.push(...ps(c, h10, c + p * Math.cos(g), h10 + m * Math.sin(g), l), ...ps(c, h10, c + p * Math.cos(y), h10 + m * Math.sin(y), l)) : C.push({ op: "lineTo", data: [c, h10] }, { op: "lineTo", data: [c + p * Math.cos(g), h10 + m * Math.sin(g)] })), { type: "path", ops: C };
}
function G4(t15, e) {
  const r = zv(Ov(Sg(t15))), n = [];
  let i = [0, 0], s = [0, 0];
  for (const { key: o, data: a } of r) switch (o) {
    case "M":
      s = [a[0], a[1]], i = [a[0], a[1]];
      break;
    case "L":
      n.push(...ps(s[0], s[1], a[0], a[1], e)), s = [a[0], a[1]];
      break;
    case "C": {
      const [l, c, h10, p, m, g] = a;
      n.push(...xK(l, c, h10, p, m, g, s, e)), s = [m, g];
      break;
    }
    case "Z":
      n.push(...ps(s[0], s[1], i[0], i[1], e)), s = [i[0], i[1]];
  }
  return { type: "path", ops: n };
}
function Op(t15, e) {
  const r = [];
  for (const n of t15) if (n.length) {
    const i = e.maxRandomnessOffset || 0, s = n.length;
    if (s > 2) {
      r.push({ op: "move", data: [n[0][0] + jt(i, e), n[0][1] + jt(i, e)] });
      for (let o = 1; o < s; o++) r.push({ op: "lineTo", data: [n[o][0] + jt(i, e), n[o][1] + jt(i, e)] });
    }
  }
  return { type: "fillPath", ops: r };
}
function Ao(t15, e) {
  return function(r, n) {
    let i = r.fillStyle || "hachure";
    if (!Or[i]) switch (i) {
      case "zigzag":
        Or[i] || (Or[i] = new hK(n));
        break;
      case "cross-hatch":
        Or[i] || (Or[i] = new uK(n));
        break;
      case "dots":
        Or[i] || (Or[i] = new dK(n));
        break;
      case "dashed":
        Or[i] || (Or[i] = new pK(n));
        break;
      case "zigzag-line":
        Or[i] || (Or[i] = new fK(n));
        break;
      default:
        i = "hachure", Or[i] || (Or[i] = new Cg(n));
    }
    return Or[i];
  }(e, yK).fillPolygons(t15, e);
}
function X4(t15) {
  const e = Object.assign({}, t15);
  return e.randomizer = void 0, t15.seed && (e.seed = t15.seed + 1), e;
}
function jv(t15) {
  return t15.randomizer || (t15.randomizer = new mK(t15.seed || 0)), t15.randomizer.next();
}
function Hu(t15, e, r, n = 1) {
  return r.roughness * n * (jv(r) * (e - t15) + t15);
}
function jt(t15, e, r = 1) {
  return Hu(-t15, t15, e, r);
}
function ps(t15, e, r, n, i, s = false) {
  const o = s ? i.disableMultiStrokeFill : i.disableMultiStroke, a = y1(t15, e, r, n, i, true, false);
  if (o) return a;
  const l = y1(t15, e, r, n, i, true, true);
  return a.concat(l);
}
function y1(t15, e, r, n, i, s, o) {
  const a = Math.pow(t15 - r, 2) + Math.pow(e - n, 2), l = Math.sqrt(a);
  let c = 1;
  c = l < 200 ? 1 : l > 500 ? 0.4 : -16668e-7 * l + 1.233334;
  let h10 = i.maxRandomnessOffset || 0;
  h10 * h10 * 100 > a && (h10 = l / 10);
  const p = h10 / 2, m = 0.2 + 0.2 * jv(i);
  let g = i.bowing * i.maxRandomnessOffset * (n - e) / 200, y = i.bowing * i.maxRandomnessOffset * (t15 - r) / 200;
  g = jt(g, i, c), y = jt(y, i, c);
  const x = [], k = () => jt(p, i, c), C = () => jt(h10, i, c), _ = i.preserveVertices;
  return o ? x.push({ op: "move", data: [t15 + (_ ? 0 : k()), e + (_ ? 0 : k())] }) : x.push({ op: "move", data: [t15 + (_ ? 0 : jt(h10, i, c)), e + (_ ? 0 : jt(h10, i, c))] }), o ? x.push({ op: "bcurveTo", data: [g + t15 + (r - t15) * m + k(), y + e + (n - e) * m + k(), g + t15 + 2 * (r - t15) * m + k(), y + e + 2 * (n - e) * m + k(), r + (_ ? 0 : k()), n + (_ ? 0 : k())] }) : x.push({ op: "bcurveTo", data: [g + t15 + (r - t15) * m + C(), y + e + (n - e) * m + C(), g + t15 + 2 * (r - t15) * m + C(), y + e + 2 * (n - e) * m + C(), r + (_ ? 0 : C()), n + (_ ? 0 : C())] }), x;
}
function ph(t15, e, r) {
  if (!t15.length) return [];
  const n = [];
  n.push([t15[0][0] + jt(e, r), t15[0][1] + jt(e, r)]), n.push([t15[0][0] + jt(e, r), t15[0][1] + jt(e, r)]);
  for (let i = 1; i < t15.length; i++) n.push([t15[i][0] + jt(e, r), t15[i][1] + jt(e, r)]), i === t15.length - 1 && n.push([t15[i][0] + jt(e, r), t15[i][1] + jt(e, r)]);
  return Uu(n, null, r);
}
function Uu(t15, e, r) {
  const n = t15.length, i = [];
  if (n > 3) {
    const s = [], o = 1 - r.curveTightness;
    i.push({ op: "move", data: [t15[1][0], t15[1][1]] });
    for (let a = 1; a + 2 < n; a++) {
      const l = t15[a];
      s[0] = [l[0], l[1]], s[1] = [l[0] + (o * t15[a + 1][0] - o * t15[a - 1][0]) / 6, l[1] + (o * t15[a + 1][1] - o * t15[a - 1][1]) / 6], s[2] = [t15[a + 1][0] + (o * t15[a][0] - o * t15[a + 2][0]) / 6, t15[a + 1][1] + (o * t15[a][1] - o * t15[a + 2][1]) / 6], s[3] = [t15[a + 1][0], t15[a + 1][1]], i.push({ op: "bcurveTo", data: [s[1][0], s[1][1], s[2][0], s[2][1], s[3][0], s[3][1]] });
    }
  } else n === 3 ? (i.push({ op: "move", data: [t15[1][0], t15[1][1]] }), i.push({ op: "bcurveTo", data: [t15[1][0], t15[1][1], t15[2][0], t15[2][1], t15[2][0], t15[2][1]] })) : n === 2 && i.push(...y1(t15[0][0], t15[0][1], t15[1][0], t15[1][1], r, true, true));
  return i;
}
function Y4(t15, e, r, n, i, s, o, a) {
  const l = [], c = [];
  if (a.roughness === 0) {
    t15 /= 4, c.push([e + n * Math.cos(-t15), r + i * Math.sin(-t15)]);
    for (let h10 = 0; h10 <= 2 * Math.PI; h10 += t15) {
      const p = [e + n * Math.cos(h10), r + i * Math.sin(h10)];
      l.push(p), c.push(p);
    }
    c.push([e + n * Math.cos(0), r + i * Math.sin(0)]), c.push([e + n * Math.cos(t15), r + i * Math.sin(t15)]);
  } else {
    const h10 = jt(0.5, a) - Math.PI / 2;
    c.push([jt(s, a) + e + 0.9 * n * Math.cos(h10 - t15), jt(s, a) + r + 0.9 * i * Math.sin(h10 - t15)]);
    const p = 2 * Math.PI + h10 - 0.01;
    for (let m = h10; m < p; m += t15) {
      const g = [jt(s, a) + e + n * Math.cos(m), jt(s, a) + r + i * Math.sin(m)];
      l.push(g), c.push(g);
    }
    c.push([jt(s, a) + e + n * Math.cos(h10 + 2 * Math.PI + 0.5 * o), jt(s, a) + r + i * Math.sin(h10 + 2 * Math.PI + 0.5 * o)]), c.push([jt(s, a) + e + 0.98 * n * Math.cos(h10 + o), jt(s, a) + r + 0.98 * i * Math.sin(h10 + o)]), c.push([jt(s, a) + e + 0.9 * n * Math.cos(h10 + 0.5 * o), jt(s, a) + r + 0.9 * i * Math.sin(h10 + 0.5 * o)]);
  }
  return [c, l];
}
function K4(t15, e, r, n, i, s, o, a, l) {
  const c = s + jt(0.1, l), h10 = [];
  h10.push([jt(a, l) + e + 0.9 * n * Math.cos(c - t15), jt(a, l) + r + 0.9 * i * Math.sin(c - t15)]);
  for (let p = c; p <= o; p += t15) h10.push([jt(a, l) + e + n * Math.cos(p), jt(a, l) + r + i * Math.sin(p)]);
  return h10.push([e + n * Math.cos(o), r + i * Math.sin(o)]), h10.push([e + n * Math.cos(o), r + i * Math.sin(o)]), Uu(h10, null, l);
}
function xK(t15, e, r, n, i, s, o, a) {
  const l = [], c = [a.maxRandomnessOffset || 1, (a.maxRandomnessOffset || 1) + 0.3];
  let h10 = [0, 0];
  const p = a.disableMultiStroke ? 1 : 2, m = a.preserveVertices;
  for (let g = 0; g < p; g++) g === 0 ? l.push({ op: "move", data: [o[0], o[1]] }) : l.push({ op: "move", data: [o[0] + (m ? 0 : jt(c[0], a)), o[1] + (m ? 0 : jt(c[0], a))] }), h10 = m ? [i, s] : [i + jt(c[g], a), s + jt(c[g], a)], l.push({ op: "bcurveTo", data: [t15 + jt(c[g], a), e + jt(c[g], a), r + jt(c[g], a), n + jt(c[g], a), h10[0], h10[1]] });
  return l;
}
function Ka(t15) {
  return [...t15];
}
function Z4(t15, e = 0) {
  const r = t15.length;
  if (r < 3) throw new Error("A curve must have at least three points.");
  const n = [];
  if (r === 3) n.push(Ka(t15[0]), Ka(t15[1]), Ka(t15[2]), Ka(t15[2]));
  else {
    const i = [];
    i.push(t15[0], t15[0]);
    for (let a = 1; a < t15.length; a++) i.push(t15[a]), a === t15.length - 1 && i.push(t15[a]);
    const s = [], o = 1 - e;
    n.push(Ka(i[0]));
    for (let a = 1; a + 2 < i.length; a++) {
      const l = i[a];
      s[0] = [l[0], l[1]], s[1] = [l[0] + (o * i[a + 1][0] - o * i[a - 1][0]) / 6, l[1] + (o * i[a + 1][1] - o * i[a - 1][1]) / 6], s[2] = [i[a + 1][0] + (o * i[a][0] - o * i[a + 2][0]) / 6, i[a + 1][1] + (o * i[a][1] - o * i[a + 2][1]) / 6], s[3] = [i[a + 1][0], i[a + 1][1]], n.push(s[1], s[2], s[3]);
    }
  }
  return n;
}
function Ph(t15, e) {
  return Math.pow(t15[0] - e[0], 2) + Math.pow(t15[1] - e[1], 2);
}
function wK(t15, e, r) {
  const n = Ph(e, r);
  if (n === 0) return Ph(t15, e);
  let i = ((t15[0] - e[0]) * (r[0] - e[0]) + (t15[1] - e[1]) * (r[1] - e[1])) / n;
  return i = Math.max(0, Math.min(1, i)), Ph(t15, Ns(e, r, i));
}
function Ns(t15, e, r) {
  return [t15[0] + (e[0] - t15[0]) * r, t15[1] + (e[1] - t15[1]) * r];
}
function b1(t15, e, r, n) {
  const i = n || [];
  if (function(a, l) {
    const c = a[l + 0], h10 = a[l + 1], p = a[l + 2], m = a[l + 3];
    let g = 3 * h10[0] - 2 * c[0] - m[0];
    g *= g;
    let y = 3 * h10[1] - 2 * c[1] - m[1];
    y *= y;
    let x = 3 * p[0] - 2 * m[0] - c[0];
    x *= x;
    let k = 3 * p[1] - 2 * m[1] - c[1];
    return k *= k, g < x && (g = x), y < k && (y = k), g + y;
  }(t15, e) < r) {
    const a = t15[e + 0];
    i.length ? (s = i[i.length - 1], o = a, Math.sqrt(Ph(s, o)) > 1 && i.push(a)) : i.push(a), i.push(t15[e + 3]);
  } else {
    const a = t15[e + 0], l = t15[e + 1], c = t15[e + 2], h10 = t15[e + 3], p = Ns(a, l, 0.5), m = Ns(l, c, 0.5), g = Ns(c, h10, 0.5), y = Ns(p, m, 0.5), x = Ns(m, g, 0.5), k = Ns(y, x, 0.5);
    b1([a, p, y, k], 0, r, i), b1([k, x, g, h10], 0, r, i);
  }
  var s, o;
  return i;
}
function kK(t15, e) {
  return Vu(t15, 0, t15.length, e);
}
function Vu(t15, e, r, n, i) {
  const s = i || [], o = t15[e], a = t15[r - 1];
  let l = 0, c = 1;
  for (let h10 = e + 1; h10 < r - 1; ++h10) {
    const p = wK(t15[h10], o, a);
    p > l && (l = p, c = h10);
  }
  return Math.sqrt(l) > n ? (Vu(t15, e, c + 1, n, s), Vu(t15, c, r, n, s)) : (s.length || s.push(o), s.push(a)), s;
}
function zp(t15, e = 0.15, r) {
  const n = [], i = (t15.length - 1) / 3;
  for (let s = 0; s < i; s++)
    b1(t15, 3 * s, e, n);
  return r && r > 0 ? Vu(n, 0, n.length, r) : n;
}
var Qr = "none";
var Gu = class {
  constructor(e) {
    this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: 0.95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: false, disableMultiStrokeFill: false, preserveVertices: false, fillShapeRoughnessGain: 0.8 }, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(e) {
    return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
  }
  _d(e, r, n) {
    return { shape: e, sets: r || [], options: n || this.defaultOptions };
  }
  line(e, r, n, i, s) {
    const o = this._o(s);
    return this._d("line", [Rv(e, r, n, i, o)], o);
  }
  rectangle(e, r, n, i, s) {
    const o = this._o(s), a = [], l = bK(e, r, n, i, o);
    if (o.fill) {
      const c = [[e, r], [e + n, r], [e + n, r + i], [e, r + i]];
      o.fillStyle === "solid" ? a.push(Op([c], o)) : a.push(Ao([c], o));
    }
    return o.stroke !== Qr && a.push(l), this._d("rectangle", a, o);
  }
  ellipse(e, r, n, i, s) {
    const o = this._o(s), a = [], l = Pv(n, i, o), c = g1(e, r, o, l);
    if (o.fill) if (o.fillStyle === "solid") {
      const h10 = g1(e, r, o, l).opset;
      h10.type = "fillPath", a.push(h10);
    } else a.push(Ao([c.estimatedPoints], o));
    return o.stroke !== Qr && a.push(c.opset), this._d("ellipse", a, o);
  }
  circle(e, r, n, i) {
    const s = this.ellipse(e, r, n, n, i);
    return s.shape = "circle", s;
  }
  linearPath(e, r) {
    const n = this._o(r);
    return this._d("linearPath", [Rh(e, false, n)], n);
  }
  arc(e, r, n, i, s, o, a = false, l) {
    const c = this._o(l), h10 = [], p = V4(e, r, n, i, s, o, a, true, c);
    if (a && c.fill) if (c.fillStyle === "solid") {
      const m = Object.assign({}, c);
      m.disableMultiStroke = true;
      const g = V4(e, r, n, i, s, o, true, false, m);
      g.type = "fillPath", h10.push(g);
    } else h10.push(function(m, g, y, x, k, C, _) {
      const $ = m, L = g;
      let B = Math.abs(y / 2), q = Math.abs(x / 2);
      B += jt(0.01 * B, _), q += jt(0.01 * q, _);
      let H = k, G = C;
      for (; H < 0; ) H += 2 * Math.PI, G += 2 * Math.PI;
      G - H > 2 * Math.PI && (H = 0, G = 2 * Math.PI);
      const F = (G - H) / _.curveStepCount, W = [];
      for (let R = H; R <= G; R += F) W.push([$ + B * Math.cos(R), L + q * Math.sin(R)]);
      return W.push([$ + B * Math.cos(G), L + q * Math.sin(G)]), W.push([$, L]), Ao([W], _);
    }(e, r, n, i, s, o, c));
    return c.stroke !== Qr && h10.push(p), this._d("arc", h10, c);
  }
  curve(e, r) {
    const n = this._o(r), i = [], s = U4(e, n);
    if (n.fill && n.fill !== Qr) if (n.fillStyle === "solid") {
      const o = U4(e, Object.assign(Object.assign({}, n), { disableMultiStroke: true, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      i.push({ type: "fillPath", ops: this._mergedShape(o.ops) });
    } else {
      const o = [], a = e;
      if (a.length) {
        const l = typeof a[0][0] == "number" ? [a] : a;
        for (const c of l) c.length < 3 ? o.push(...c) : c.length === 3 ? o.push(...zp(Z4([c[0], c[0], c[1], c[2]]), 10, (1 + n.roughness) / 2)) : o.push(...zp(Z4(c), 10, (1 + n.roughness) / 2));
      }
      o.length && i.push(Ao([o], n));
    }
    return n.stroke !== Qr && i.push(s), this._d("curve", i, n);
  }
  polygon(e, r) {
    const n = this._o(r), i = [], s = Rh(e, true, n);
    return n.fill && (n.fillStyle === "solid" ? i.push(Op([e], n)) : i.push(Ao([e], n))), n.stroke !== Qr && i.push(s), this._d("polygon", i, n);
  }
  path(e, r) {
    const n = this._o(r), i = [];
    if (!e) return this._d("path", i, n);
    e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const s = n.fill && n.fill !== "transparent" && n.fill !== Qr, o = n.stroke !== Qr, a = !!(n.simplification && n.simplification < 1), l = function(h10, p, m) {
      const g = zv(Ov(Sg(h10))), y = [];
      let x = [], k = [0, 0], C = [];
      const _ = () => {
        C.length >= 4 && x.push(...zp(C, p)), C = [];
      }, $ = () => {
        _(), x.length && (y.push(x), x = []);
      };
      for (const { key: B, data: q } of g) switch (B) {
        case "M":
          $(), k = [q[0], q[1]], x.push(k);
          break;
        case "L":
          _(), x.push([q[0], q[1]]);
          break;
        case "C":
          if (!C.length) {
            const H = x.length ? x[x.length - 1] : k;
            C.push([H[0], H[1]]);
          }
          C.push([q[0], q[1]]), C.push([q[2], q[3]]), C.push([q[4], q[5]]);
          break;
        case "Z":
          _(), x.push([k[0], k[1]]);
      }
      if ($(), !m) return y;
      const L = [];
      for (const B of y) {
        const q = kK(B, m);
        q.length && L.push(q);
      }
      return L;
    }(e, 1, a ? 4 - 4 * (n.simplification || 1) : (1 + n.roughness) / 2), c = G4(e, n);
    if (s) if (n.fillStyle === "solid") if (l.length === 1) {
      const h10 = G4(e, Object.assign(Object.assign({}, n), { disableMultiStroke: true, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      i.push({ type: "fillPath", ops: this._mergedShape(h10.ops) });
    } else i.push(Op(l, n));
    else i.push(Ao(l, n));
    return o && (a ? l.forEach((h10) => {
      i.push(Rh(h10, false, n));
    }) : i.push(c)), this._d("path", i, n);
  }
  opsToPath(e, r) {
    let n = "";
    for (const i of e.ops) {
      const s = typeof r == "number" && r >= 0 ? i.data.map((o) => +o.toFixed(r)) : i.data;
      switch (i.op) {
        case "move":
          n += `M${s[0]} ${s[1]} `;
          break;
        case "bcurveTo":
          n += `C${s[0]} ${s[1]}, ${s[2]} ${s[3]}, ${s[4]} ${s[5]} `;
          break;
        case "lineTo":
          n += `L${s[0]} ${s[1]} `;
      }
    }
    return n.trim();
  }
  toPaths(e) {
    const r = e.sets || [], n = e.options || this.defaultOptions, i = [];
    for (const s of r) {
      let o = null;
      switch (s.type) {
        case "path":
          o = { d: this.opsToPath(s), stroke: n.stroke, strokeWidth: n.strokeWidth, fill: Qr };
          break;
        case "fillPath":
          o = { d: this.opsToPath(s), stroke: Qr, strokeWidth: 0, fill: n.fill || Qr };
          break;
        case "fillSketch":
          o = this.fillSketch(s, n);
      }
      o && i.push(o);
    }
    return i;
  }
  fillSketch(e, r) {
    let n = r.fillWeight;
    return n < 0 && (n = r.strokeWidth / 2), { d: this.opsToPath(e), stroke: r.fill || Qr, strokeWidth: n, fill: Qr };
  }
  _mergedShape(e) {
    return e.filter((r, n) => n === 0 || r.op !== "move");
  }
};
var vK = class {
  constructor(e, r) {
    this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new Gu(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), i = this.ctx, s = e.options.fixedDecimalPlaceDigits;
    for (const o of r) switch (o.type) {
      case "path":
        i.save(), i.strokeStyle = n.stroke === "none" ? "transparent" : n.stroke, i.lineWidth = n.strokeWidth, n.strokeLineDash && i.setLineDash(n.strokeLineDash), n.strokeLineDashOffset && (i.lineDashOffset = n.strokeLineDashOffset), this._drawToContext(i, o, s), i.restore();
        break;
      case "fillPath": {
        i.save(), i.fillStyle = n.fill || "";
        const a = e.shape === "curve" || e.shape === "polygon" || e.shape === "path" ? "evenodd" : "nonzero";
        this._drawToContext(i, o, s, a), i.restore();
        break;
      }
      case "fillSketch":
        this.fillSketch(i, o, n);
    }
  }
  fillSketch(e, r, n) {
    let i = n.fillWeight;
    i < 0 && (i = n.strokeWidth / 2), e.save(), n.fillLineDash && e.setLineDash(n.fillLineDash), n.fillLineDashOffset && (e.lineDashOffset = n.fillLineDashOffset), e.strokeStyle = n.fill || "", e.lineWidth = i, this._drawToContext(e, r, n.fixedDecimalPlaceDigits), e.restore();
  }
  _drawToContext(e, r, n, i = "nonzero") {
    e.beginPath();
    for (const s of r.ops) {
      const o = typeof n == "number" && n >= 0 ? s.data.map((a) => +a.toFixed(n)) : s.data;
      switch (s.op) {
        case "move":
          e.moveTo(o[0], o[1]);
          break;
        case "bcurveTo":
          e.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]);
          break;
        case "lineTo":
          e.lineTo(o[0], o[1]);
      }
    }
    r.type === "fillPath" ? e.fill(i) : e.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(e, r, n, i, s) {
    const o = this.gen.line(e, r, n, i, s);
    return this.draw(o), o;
  }
  rectangle(e, r, n, i, s) {
    const o = this.gen.rectangle(e, r, n, i, s);
    return this.draw(o), o;
  }
  ellipse(e, r, n, i, s) {
    const o = this.gen.ellipse(e, r, n, i, s);
    return this.draw(o), o;
  }
  circle(e, r, n, i) {
    const s = this.gen.circle(e, r, n, i);
    return this.draw(s), s;
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n), n;
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n), n;
  }
  arc(e, r, n, i, s, o, a = false, l) {
    const c = this.gen.arc(e, r, n, i, s, o, a, l);
    return this.draw(c), c;
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n), n;
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n), n;
  }
};
var fh = "http://www.w3.org/2000/svg";
var _K = class {
  constructor(e, r) {
    this.svg = e, this.gen = new Gu(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), i = this.svg.ownerDocument || window.document, s = i.createElementNS(fh, "g"), o = e.options.fixedDecimalPlaceDigits;
    for (const a of r) {
      let l = null;
      switch (a.type) {
        case "path":
          l = i.createElementNS(fh, "path"), l.setAttribute("d", this.opsToPath(a, o)), l.setAttribute("stroke", n.stroke), l.setAttribute("stroke-width", n.strokeWidth + ""), l.setAttribute("fill", "none"), n.strokeLineDash && l.setAttribute("stroke-dasharray", n.strokeLineDash.join(" ").trim()), n.strokeLineDashOffset && l.setAttribute("stroke-dashoffset", `${n.strokeLineDashOffset}`);
          break;
        case "fillPath":
          l = i.createElementNS(fh, "path"), l.setAttribute("d", this.opsToPath(a, o)), l.setAttribute("stroke", "none"), l.setAttribute("stroke-width", "0"), l.setAttribute("fill", n.fill || ""), e.shape !== "curve" && e.shape !== "polygon" || l.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          l = this.fillSketch(i, a, n);
      }
      l && s.appendChild(l);
    }
    return s;
  }
  fillSketch(e, r, n) {
    let i = n.fillWeight;
    i < 0 && (i = n.strokeWidth / 2);
    const s = e.createElementNS(fh, "path");
    return s.setAttribute("d", this.opsToPath(r, n.fixedDecimalPlaceDigits)), s.setAttribute("stroke", n.fill || ""), s.setAttribute("stroke-width", i + ""), s.setAttribute("fill", "none"), n.fillLineDash && s.setAttribute("stroke-dasharray", n.fillLineDash.join(" ").trim()), n.fillLineDashOffset && s.setAttribute("stroke-dashoffset", `${n.fillLineDashOffset}`), s;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(e, r) {
    return this.gen.opsToPath(e, r);
  }
  line(e, r, n, i, s) {
    const o = this.gen.line(e, r, n, i, s);
    return this.draw(o);
  }
  rectangle(e, r, n, i, s) {
    const o = this.gen.rectangle(e, r, n, i, s);
    return this.draw(o);
  }
  ellipse(e, r, n, i, s) {
    const o = this.gen.ellipse(e, r, n, i, s);
    return this.draw(o);
  }
  circle(e, r, n, i) {
    const s = this.gen.circle(e, r, n, i);
    return this.draw(s);
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n);
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n);
  }
  arc(e, r, n, i, s, o, a = false, l) {
    const c = this.gen.arc(e, r, n, i, s, o, a, l);
    return this.draw(c);
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n);
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n);
  }
};
var Bt = { canvas: (t15, e) => new vK(t15, e), svg: (t15, e) => new _K(t15, e), generator: (t15) => new Gu(t15), newSeed: () => Gu.newSeed() };
var Gt = S(async (t15, e, r) => {
  var _a2, _b2;
  let n;
  const i = e.useHtmlLabels || Qe((_a2 = me()) == null ? void 0 : _a2.htmlLabels);
  r ? n = r : n = "node default";
  const s = t15.insert("g").attr("class", n).attr("id", e.domId || e.id), o = s.insert("g").attr("class", "label").attr("style", Mr(e.labelStyle));
  let a;
  e.label === void 0 ? a = "" : a = typeof e.label == "string" ? e.label : e.label[0];
  const l = await ys(o, to(po(a), me()), {
    useHtmlLabels: i,
    width: e.width || ((_b2 = me().flowchart) == null ? void 0 : _b2.wrappingWidth),
    // @ts-expect-error -- This is currently not used. Should this be `classes` instead?
    cssClasses: "markdown-node-label",
    style: e.labelStyle,
    addSvgBackground: !!e.icon || !!e.img
  });
  let c = l.getBBox();
  const h10 = ((e == null ? void 0 : e.padding) ?? 0) / 2;
  if (i) {
    const p = l.children[0], m = ae(l), g = p.getElementsByTagName("img");
    if (g) {
      const y = a.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...g].map(
          (x) => new Promise((k) => {
            function C() {
              if (x.style.display = "flex", x.style.flexDirection = "column", y) {
                const _ = me().fontSize ? me().fontSize : window.getComputedStyle(document.body).fontSize, $ = 5, [L = tw.fontSize] = R0(_), B = L * $ + "px";
                x.style.minWidth = B, x.style.maxWidth = B;
              } else
                x.style.width = "100%";
              k(x);
            }
            S(C, "setupImage"), setTimeout(() => {
              x.complete && C();
            }), x.addEventListener("error", C), x.addEventListener("load", C);
          })
        )
      );
    }
    c = p.getBoundingClientRect(), m.attr("width", c.width), m.attr("height", c.height);
  }
  return i ? o.attr("transform", "translate(" + -c.width / 2 + ", " + -c.height / 2 + ")") : o.attr("transform", "translate(0, " + -c.height / 2 + ")"), e.centerLabel && o.attr("transform", "translate(" + -c.width / 2 + ", " + -c.height / 2 + ")"), o.insert("rect", ":first-child"), { shapeSvg: s, bbox: c, halfPadding: h10, label: o };
}, "labelHelper");
var qp = S(async (t15, e, r) => {
  var _a2, _b2, _c, _d, _e, _f2;
  const n = r.useHtmlLabels || Qe((_b2 = (_a2 = me()) == null ? void 0 : _a2.flowchart) == null ? void 0 : _b2.htmlLabels), i = t15.insert("g").attr("class", "label").attr("style", r.labelStyle || ""), s = await ys(i, to(po(e), me()), {
    useHtmlLabels: n,
    width: r.width || ((_d = (_c = me()) == null ? void 0 : _c.flowchart) == null ? void 0 : _d.wrappingWidth),
    style: r.labelStyle,
    addSvgBackground: !!r.icon || !!r.img
  });
  let o = s.getBBox();
  const a = r.padding / 2;
  if (Qe((_f2 = (_e = me()) == null ? void 0 : _e.flowchart) == null ? void 0 : _f2.htmlLabels)) {
    const l = s.children[0], c = ae(s);
    o = l.getBoundingClientRect(), c.attr("width", o.width), c.attr("height", o.height);
  }
  return n ? i.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")") : i.attr("transform", "translate(0, " + -o.height / 2 + ")"), r.centerLabel && i.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")"), i.insert("rect", ":first-child"), { shapeSvg: t15, bbox: o, halfPadding: a, label: i };
}, "insertLabel");
var Ft = S((t15, e) => {
  const r = e.node().getBBox();
  t15.width = r.width, t15.height = r.height;
}, "updateNodeBounds");
var Ht = S((t15, e) => (t15.look === "handDrawn" ? "rough-node" : "node") + " " + t15.cssClasses + " " + (e || ""), "getNodeClasses");
function le(t15) {
  const e = t15.map((r, n) => `${n === 0 ? "M" : "L"}${r.x},${r.y}`);
  return e.push("Z"), e.join(" ");
}
S(le, "createPathFromPoints");
function fs(t15, e, r, n, i, s) {
  const o = [], a = r - t15, l = n - e, c = a / s, h10 = 2 * Math.PI / c, p = e + l / 2;
  for (let m = 0; m <= 50; m++) {
    const g = m / 50, y = t15 + g * a, x = p + i * Math.sin(h10 * (y - t15));
    o.push({ x: y, y: x });
  }
  return o;
}
S(fs, "generateFullSineWavePoints");
function Tg(t15, e, r, n, i, s) {
  const o = [], a = i * Math.PI / 180, l = (s * Math.PI / 180 - a) / (n - 1);
  for (let c = 0; c < n; c++) {
    const h10 = a + c * l, p = t15 + r * Math.cos(h10), m = e + r * Math.sin(h10);
    o.push({ x: -p, y: -m });
  }
  return o;
}
S(Tg, "generateCirclePoints");
var CK = S((t15, e) => {
  var r = t15.x, n = t15.y, i = e.x - r, s = e.y - n, o = t15.width / 2, a = t15.height / 2, l, c;
  return Math.abs(s) * o > Math.abs(i) * a ? (s < 0 && (a = -a), l = s === 0 ? 0 : a * i / s, c = a) : (i < 0 && (o = -o), l = o, c = i === 0 ? 0 : o * s / i), { x: r + l, y: n + c };
}, "intersectRect");
var wa = CK;
function Wv(t15, e) {
  e && t15.attr("style", e);
}
S(Wv, "applyStyle");
async function Hv(t15) {
  const e = ae(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), r = e.append("xhtml:div");
  let n = t15.label;
  t15.label && ta(t15.label) && (n = await Dm(t15.label.replace(ga.lineBreakRegex, `
`), me()));
  const i = t15.isNode ? "nodeLabel" : "edgeLabel";
  return r.html(
    '<span class="' + i + '" ' + (t15.labelStyle ? 'style="' + t15.labelStyle + '"' : "") + // codeql [js/html-constructed-from-input] : false positive
    ">" + n + "</span>"
  ), Wv(r, t15.labelStyle), r.style("display", "inline-block"), r.style("padding-right", "1px"), r.style("white-space", "nowrap"), r.attr("xmlns", "http://www.w3.org/1999/xhtml"), e.node();
}
S(Hv, "addHtmlLabel");
var SK = S(async (t15, e, r, n) => {
  let i = t15 || "";
  if (typeof i == "object" && (i = i[0]), Qe(me().flowchart.htmlLabels)) {
    i = i.replace(/\\n|\n/g, "<br />"), ut.info("vertexText" + i);
    const s = {
      isNode: n,
      label: po(i).replace(
        /fa[blrs]?:fa-[\w-]+/g,
        (o) => `<i class='${o.replace(":", " ")}'></i>`
      ),
      labelStyle: e && e.replace("fill:", "color:")
    };
    return await Hv(s);
  } else {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "text");
    s.setAttribute("style", e.replace("color:", "fill:"));
    let o = [];
    typeof i == "string" ? o = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? o = i : o = [];
    for (const a of o) {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), l.setAttribute("dy", "1em"), l.setAttribute("x", "0"), r ? l.setAttribute("class", "title-row") : l.setAttribute("class", "row"), l.textContent = a.trim(), s.appendChild(l);
    }
    return s;
  }
}, "createLabel");
var Us = SK;
var qi = S((t15, e, r, n, i) => [
  "M",
  t15 + i,
  e,
  // Move to the first point
  "H",
  t15 + r - i,
  // Draw horizontal line to the beginning of the right corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t15 + r,
  e + i,
  // Draw arc to the right top corner
  "V",
  e + n - i,
  // Draw vertical line down to the beginning of the right bottom corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t15 + r - i,
  e + n,
  // Draw arc to the right bottom corner
  "H",
  t15 + i,
  // Draw horizontal line to the beginning of the left bottom corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t15,
  e + n - i,
  // Draw arc to the left bottom corner
  "V",
  e + i,
  // Draw vertical line up to the beginning of the left top corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t15 + i,
  e,
  // Draw arc to the left top corner
  "Z"
  // Close the path
].join(" "), "createRoundedRectPathD");
var Uv = S(async (t15, e) => {
  ut.info("Creating subgraph rect for ", e.id, e);
  const r = me(), { themeVariables: n, handDrawnSeed: i } = r, { clusterBkg: s, clusterBorder: o } = n, { labelStyles: a, nodeStyles: l, borderStyles: c, backgroundStyles: h10 } = Nt(e), p = t15.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), m = Qe(r.flowchart.htmlLabels), g = p.insert("g").attr("class", "cluster-label "), y = await ys(g, e.label, {
    style: e.labelStyle,
    useHtmlLabels: m,
    isNode: true
  });
  let x = y.getBBox();
  if (Qe(r.flowchart.htmlLabels)) {
    const H = y.children[0], G = ae(y);
    x = H.getBoundingClientRect(), G.attr("width", x.width), G.attr("height", x.height);
  }
  const k = e.width <= x.width + e.padding ? x.width + e.padding : e.width;
  e.width <= x.width + e.padding ? e.diff = (k - e.width) / 2 - e.padding : e.diff = -e.padding;
  const C = e.height, _ = e.x - k / 2, $ = e.y - C / 2;
  ut.trace("Data ", e, JSON.stringify(e));
  let L;
  if (e.look === "handDrawn") {
    const H = Bt.svg(p), G = Lt(e, {
      roughness: 0.7,
      fill: s,
      // fill: 'red',
      stroke: o,
      fillWeight: 3,
      seed: i
    }), F = H.path(qi(_, $, k, C, 0), G);
    L = p.insert(() => (ut.debug("Rough node insert CXC", F), F), ":first-child"), L.select("path:nth-child(2)").attr("style", c.join(";")), L.select("path").attr("style", h10.join(";").replace("fill", "stroke"));
  } else
    L = p.insert("rect", ":first-child"), L.attr("style", l).attr("rx", e.rx).attr("ry", e.ry).attr("x", _).attr("y", $).attr("width", k).attr("height", C);
  const { subGraphTitleTopMargin: B } = Um(r);
  if (g.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${e.x - x.width / 2}, ${e.y - e.height / 2 + B})`
  ), a) {
    const H = g.select("span");
    H && H.attr("style", a);
  }
  const q = L.node().getBBox();
  return e.offsetX = 0, e.width = q.width, e.height = q.height, e.offsetY = x.height - e.padding / 2, e.intersect = function(H) {
    return wa(e, H);
  }, { cluster: p, labelBBox: x };
}, "rect");
var TK = S((t15, e) => {
  const r = t15.insert("g").attr("class", "note-cluster").attr("id", e.id), n = r.insert("rect", ":first-child"), i = 0 * e.padding, s = i / 2;
  n.attr("rx", e.rx).attr("ry", e.ry).attr("x", e.x - e.width / 2 - s).attr("y", e.y - e.height / 2 - s).attr("width", e.width + i).attr("height", e.height + i).attr("fill", "none");
  const o = n.node().getBBox();
  return e.width = o.width, e.height = o.height, e.intersect = function(a) {
    return wa(e, a);
  }, { cluster: r, labelBBox: { width: 0, height: 0 } };
}, "noteGroup");
var AK = S(async (t15, e) => {
  const r = me(), { themeVariables: n, handDrawnSeed: i } = r, { altBackground: s, compositeBackground: o, compositeTitleBackground: a, nodeBorder: l } = n, c = t15.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-id", e.id).attr("data-look", e.look), h10 = c.insert("g", ":first-child"), p = c.insert("g").attr("class", "cluster-label");
  let m = c.append("rect");
  const g = p.node().appendChild(await Us(e.label, e.labelStyle, void 0, true));
  let y = g.getBBox();
  if (Qe(r.flowchart.htmlLabels)) {
    const F = g.children[0], W = ae(g);
    y = F.getBoundingClientRect(), W.attr("width", y.width), W.attr("height", y.height);
  }
  const x = 0 * e.padding, k = x / 2, C = (e.width <= y.width + e.padding ? y.width + e.padding : e.width) + x;
  e.width <= y.width + e.padding ? e.diff = (C - e.width) / 2 - e.padding : e.diff = -e.padding;
  const _ = e.height + x, $ = e.height + x - y.height - 6, L = e.x - C / 2, B = e.y - _ / 2;
  e.width = C;
  const q = e.y - e.height / 2 - k + y.height + 2;
  let H;
  if (e.look === "handDrawn") {
    const F = e.cssClasses.includes("statediagram-cluster-alt"), W = Bt.svg(c), R = e.rx || e.ry ? W.path(qi(L, B, C, _, 10), {
      roughness: 0.7,
      fill: a,
      fillStyle: "solid",
      stroke: l,
      seed: i
    }) : W.rectangle(L, B, C, _, { seed: i });
    H = c.insert(() => R, ":first-child");
    const J = W.rectangle(L, q, C, $, {
      fill: F ? s : o,
      fillStyle: F ? "hachure" : "solid",
      stroke: l,
      seed: i
    });
    H = c.insert(() => R, ":first-child"), m = c.insert(() => J);
  } else
    H = h10.insert("rect", ":first-child"), H.attr("class", "outer").attr("x", L).attr("y", B).attr("width", C).attr("height", _).attr("data-look", e.look), m.attr("class", "inner").attr("x", L).attr("y", q).attr("width", C).attr("height", $);
  p.attr(
    "transform",
    `translate(${e.x - y.width / 2}, ${B + 1 - (Qe(r.flowchart.htmlLabels) ? 0 : 3)})`
  );
  const G = H.node().getBBox();
  return e.height = G.height, e.offsetX = 0, e.offsetY = y.height - e.padding / 2, e.labelBBox = y, e.intersect = function(F) {
    return wa(e, F);
  }, { cluster: c, labelBBox: y };
}, "roundedWithTitle");
var $K = S(async (t15, e) => {
  ut.info("Creating subgraph rect for ", e.id, e);
  const r = me(), { themeVariables: n, handDrawnSeed: i } = r, { clusterBkg: s, clusterBorder: o } = n, { labelStyles: a, nodeStyles: l, borderStyles: c, backgroundStyles: h10 } = Nt(e), p = t15.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), m = Qe(r.flowchart.htmlLabels), g = p.insert("g").attr("class", "cluster-label "), y = await ys(g, e.label, {
    style: e.labelStyle,
    useHtmlLabels: m,
    isNode: true,
    width: e.width
  });
  let x = y.getBBox();
  if (Qe(r.flowchart.htmlLabels)) {
    const H = y.children[0], G = ae(y);
    x = H.getBoundingClientRect(), G.attr("width", x.width), G.attr("height", x.height);
  }
  const k = e.width <= x.width + e.padding ? x.width + e.padding : e.width;
  e.width <= x.width + e.padding ? e.diff = (k - e.width) / 2 - e.padding : e.diff = -e.padding;
  const C = e.height, _ = e.x - k / 2, $ = e.y - C / 2;
  ut.trace("Data ", e, JSON.stringify(e));
  let L;
  if (e.look === "handDrawn") {
    const H = Bt.svg(p), G = Lt(e, {
      roughness: 0.7,
      fill: s,
      // fill: 'red',
      stroke: o,
      fillWeight: 4,
      seed: i
    }), F = H.path(qi(_, $, k, C, e.rx), G);
    L = p.insert(() => (ut.debug("Rough node insert CXC", F), F), ":first-child"), L.select("path:nth-child(2)").attr("style", c.join(";")), L.select("path").attr("style", h10.join(";").replace("fill", "stroke"));
  } else
    L = p.insert("rect", ":first-child"), L.attr("style", l).attr("rx", e.rx).attr("ry", e.ry).attr("x", _).attr("y", $).attr("width", k).attr("height", C);
  const { subGraphTitleTopMargin: B } = Um(r);
  if (g.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${e.x - x.width / 2}, ${e.y - e.height / 2 + B})`
  ), a) {
    const H = g.select("span");
    H && H.attr("style", a);
  }
  const q = L.node().getBBox();
  return e.offsetX = 0, e.width = q.width, e.height = q.height, e.offsetY = x.height - e.padding / 2, e.intersect = function(H) {
    return wa(e, H);
  }, { cluster: p, labelBBox: x };
}, "kanbanSection");
var EK = S((t15, e) => {
  const r = me(), { themeVariables: n, handDrawnSeed: i } = r, { nodeBorder: s } = n, o = t15.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-look", e.look), a = o.insert("g", ":first-child"), l = 0 * e.padding, c = e.width + l;
  e.diff = -e.padding;
  const h10 = e.height + l, p = e.x - c / 2, m = e.y - h10 / 2;
  e.width = c;
  let g;
  if (e.look === "handDrawn") {
    const x = Bt.svg(o).rectangle(p, m, c, h10, {
      fill: "lightgrey",
      roughness: 0.5,
      strokeLineDash: [5],
      stroke: s,
      seed: i
    });
    g = o.insert(() => x, ":first-child");
  } else
    g = a.insert("rect", ":first-child"), g.attr("class", "divider").attr("x", p).attr("y", m).attr("width", c).attr("height", h10).attr("data-look", e.look);
  const y = g.node().getBBox();
  return e.height = y.height, e.offsetX = 0, e.offsetY = 0, e.intersect = function(x) {
    return wa(e, x);
  }, { cluster: o, labelBBox: {} };
}, "divider");
var MK = Uv;
var BK = {
  rect: Uv,
  squareRect: MK,
  roundedWithTitle: AK,
  noteGroup: TK,
  divider: EK,
  kanbanSection: $K
};
var Vv = /* @__PURE__ */ new Map();
var LK = S(async (t15, e) => {
  const r = e.shape || "rect", n = await BK[r](t15, e);
  return Vv.set(e.id, n), n;
}, "insertCluster");
var ynt = S(() => {
  Vv = /* @__PURE__ */ new Map();
}, "clear");
function Gv(t15, e) {
  return t15.intersect(e);
}
S(Gv, "intersectNode");
var DK = Gv;
function Xv(t15, e, r, n) {
  var i = t15.x, s = t15.y, o = i - n.x, a = s - n.y, l = Math.sqrt(e * e * a * a + r * r * o * o), c = Math.abs(e * r * o / l);
  n.x < i && (c = -c);
  var h10 = Math.abs(e * r * a / l);
  return n.y < s && (h10 = -h10), { x: i + c, y: s + h10 };
}
S(Xv, "intersectEllipse");
var Yv = Xv;
function Kv(t15, e, r) {
  return Yv(t15, e, e, r);
}
S(Kv, "intersectCircle");
var FK = Kv;
function Zv(t15, e, r, n) {
  var i, s, o, a, l, c, h10, p, m, g, y, x, k, C, _;
  if (i = e.y - t15.y, o = t15.x - e.x, l = e.x * t15.y - t15.x * e.y, m = i * r.x + o * r.y + l, g = i * n.x + o * n.y + l, !(m !== 0 && g !== 0 && x1(m, g)) && (s = n.y - r.y, a = r.x - n.x, c = n.x * r.y - r.x * n.y, h10 = s * t15.x + a * t15.y + c, p = s * e.x + a * e.y + c, !(h10 !== 0 && p !== 0 && x1(h10, p)) && (y = i * a - s * o, y !== 0)))
    return x = Math.abs(y / 2), k = o * c - a * l, C = k < 0 ? (k - x) / y : (k + x) / y, k = s * l - i * c, _ = k < 0 ? (k - x) / y : (k + x) / y, { x: C, y: _ };
}
S(Zv, "intersectLine");
function x1(t15, e) {
  return t15 * e > 0;
}
S(x1, "sameSign");
var NK = Zv;
function Qv(t15, e, r) {
  let n = t15.x, i = t15.y, s = [], o = Number.POSITIVE_INFINITY, a = Number.POSITIVE_INFINITY;
  typeof e.forEach == "function" ? e.forEach(function(h10) {
    o = Math.min(o, h10.x), a = Math.min(a, h10.y);
  }) : (o = Math.min(o, e.x), a = Math.min(a, e.y));
  let l = n - t15.width / 2 - o, c = i - t15.height / 2 - a;
  for (let h10 = 0; h10 < e.length; h10++) {
    let p = e[h10], m = e[h10 < e.length - 1 ? h10 + 1 : 0], g = NK(
      t15,
      r,
      { x: l + p.x, y: c + p.y },
      { x: l + m.x, y: c + m.y }
    );
    g && s.push(g);
  }
  return s.length ? (s.length > 1 && s.sort(function(h10, p) {
    let m = h10.x - r.x, g = h10.y - r.y, y = Math.sqrt(m * m + g * g), x = p.x - r.x, k = p.y - r.y, C = Math.sqrt(x * x + k * k);
    return y < C ? -1 : y === C ? 0 : 1;
  }), s[0]) : t15;
}
S(Qv, "intersectPolygon");
var IK = Qv;
var Et = {
  node: DK,
  circle: FK,
  ellipse: Yv,
  polygon: IK,
  rect: wa
};
function Jv(t15, e) {
  const { labelStyles: r } = Nt(e);
  e.labelStyle = r;
  const n = Ht(e);
  let i = n;
  n || (i = "anchor");
  const s = t15.insert("g").attr("class", i).attr("id", e.domId || e.id), o = 1, { cssStyles: a } = e, l = Bt.svg(s), c = Lt(e, { fill: "black", stroke: "none", fillStyle: "solid" });
  e.look !== "handDrawn" && (c.roughness = 0);
  const h10 = l.circle(0, 0, o * 2, c), p = s.insert(() => h10, ":first-child");
  return p.attr("class", "anchor").attr("style", Mr(a)), Ft(e, p), e.intersect = function(m) {
    return ut.info("Circle intersect", e, o, m), Et.circle(e, o, m);
  }, s;
}
S(Jv, "anchor");
function w1(t15, e, r, n, i, s, o) {
  const a = (t15 + r) / 2, l = (e + n) / 2, c = Math.atan2(n - e, r - t15), h10 = (r - t15) / 2, p = (n - e) / 2, m = h10 / i, g = p / s, y = Math.sqrt(m ** 2 + g ** 2);
  if (y > 1)
    throw new Error("The given radii are too small to create an arc between the points.");
  const x = Math.sqrt(1 - y ** 2), k = a + x * s * Math.sin(c) * (o ? -1 : 1), C = l - x * i * Math.cos(c) * (o ? -1 : 1), _ = Math.atan2((e - C) / s, (t15 - k) / i);
  let $ = Math.atan2((n - C) / s, (r - k) / i) - _;
  o && $ < 0 && ($ += 2 * Math.PI), !o && $ > 0 && ($ -= 2 * Math.PI);
  const L = [];
  for (let B = 0; B < 20; B++) {
    const q = B / 19, H = _ + q * $, G = k + i * Math.cos(H), F = C + s * Math.sin(H);
    L.push({ x: G, y: F });
  }
  return L;
}
S(w1, "generateArcPoints");
async function t82(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = s.width + e.padding + 20, a = s.height + e.padding, l = a / 2, c = l / (2.5 + a / 50), { cssStyles: h10 } = e, p = [
    { x: o / 2, y: -a / 2 },
    { x: -o / 2, y: -a / 2 },
    ...w1(-o / 2, -a / 2, -o / 2, a / 2, c, l, false),
    { x: o / 2, y: a / 2 },
    ...w1(o / 2, a / 2, o / 2, -a / 2, c, l, true)
  ], m = Bt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = le(p), x = m.path(y, g), k = i.insert(() => x, ":first-child");
  return k.attr("class", "basic label-container"), h10 && e.look !== "handDrawn" && k.selectAll("path").attr("style", h10), n && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), k.attr("transform", `translate(${c / 2}, 0)`), Ft(e, k), e.intersect = function(C) {
    return Et.polygon(e, p, C);
  }, i;
}
S(t82, "bowTieRect");
function Ri(t15, e, r, n) {
  return t15.insert("polygon", ":first-child").attr(
    "points",
    n.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
}
S(Ri, "insertPolygonShape");
async function e8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = s.height + e.padding, a = 12, l = s.width + e.padding + a, c = 0, h10 = l, p = -o, m = 0, g = [
    { x: c + a, y: p },
    { x: h10, y: p },
    { x: h10, y: m },
    { x: c, y: m },
    { x: c, y: p + a },
    { x: c + a, y: p }
  ];
  let y;
  const { cssStyles: x } = e;
  if (e.look === "handDrawn") {
    const k = Bt.svg(i), C = Lt(e, {}), _ = le(g), $ = k.path(_, C);
    y = i.insert(() => $, ":first-child").attr("transform", `translate(${-l / 2}, ${o / 2})`), x && y.attr("style", x);
  } else
    y = Ri(i, l, o, g);
  return n && y.attr("style", n), Ft(e, y), e.intersect = function(k) {
    return Et.polygon(e, g, k);
  }, i;
}
S(e8, "card");
function r8(t15, e) {
  const { nodeStyles: r } = Nt(e);
  e.label = "";
  const n = t15.insert("g").attr("class", Ht(e)).attr("id", e.domId ?? e.id), { cssStyles: i } = e, s = Math.max(28, e.width ?? 0), o = [
    { x: 0, y: s / 2 },
    { x: s / 2, y: 0 },
    { x: 0, y: -s / 2 },
    { x: -s / 2, y: 0 }
  ], a = Bt.svg(n), l = Lt(e, {});
  e.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const c = le(o), h10 = a.path(c, l), p = n.insert(() => h10, ":first-child");
  return i && e.look !== "handDrawn" && p.selectAll("path").attr("style", i), r && e.look !== "handDrawn" && p.selectAll("path").attr("style", r), e.width = 28, e.height = 28, e.intersect = function(m) {
    return Et.polygon(e, o, m);
  }, n;
}
S(r8, "choice");
async function n8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, halfPadding: o } = await Gt(t15, e, Ht(e)), a = s.width / 2 + o;
  let l;
  const { cssStyles: c } = e;
  if (e.look === "handDrawn") {
    const h10 = Bt.svg(i), p = Lt(e, {}), m = h10.circle(0, 0, a * 2, p);
    l = i.insert(() => m, ":first-child"), l.attr("class", "basic label-container").attr("style", Mr(c));
  } else
    l = i.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", n).attr("r", a).attr("cx", 0).attr("cy", 0);
  return Ft(e, l), e.intersect = function(h10) {
    return ut.info("Circle intersect", e, a, h10), Et.circle(e, a, h10);
  }, i;
}
S(n8, "circle");
function i8(t15) {
  const e = Math.cos(Math.PI / 4), r = Math.sin(Math.PI / 4), n = t15 * 2, i = { x: n / 2 * e, y: n / 2 * r }, s = { x: -(n / 2) * e, y: n / 2 * r }, o = { x: -(n / 2) * e, y: -(n / 2) * r }, a = { x: n / 2 * e, y: -(n / 2) * r };
  return `M ${s.x},${s.y} L ${a.x},${a.y}
                   M ${i.x},${i.y} L ${o.x},${o.y}`;
}
S(i8, "createLine");
function s8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r, e.label = "";
  const i = t15.insert("g").attr("class", Ht(e)).attr("id", e.domId ?? e.id), s = Math.max(30, (e == null ? void 0 : e.width) ?? 0), { cssStyles: o } = e, a = Bt.svg(i), l = Lt(e, {});
  e.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const c = a.circle(0, 0, s * 2, l), h10 = i8(s), p = a.path(h10, l), m = i.insert(() => c, ":first-child");
  return m.insert(() => p), o && e.look !== "handDrawn" && m.selectAll("path").attr("style", o), n && e.look !== "handDrawn" && m.selectAll("path").attr("style", n), Ft(e, m), e.intersect = function(g) {
    return ut.info("crossedCircle intersect", e, { radius: s, point: g }), Et.circle(e, s, g);
  }, i;
}
S(s8, "crossedCircle");
function Ci(t15, e, r, n = 100, i = 0, s = 180) {
  const o = [], a = i * Math.PI / 180, l = (s * Math.PI / 180 - a) / (n - 1);
  for (let c = 0; c < n; c++) {
    const h10 = a + c * l, p = t15 + r * Math.cos(h10), m = e + r * Math.sin(h10);
    o.push({ x: -p, y: -m });
  }
  return o;
}
S(Ci, "generateCirclePoints");
async function o8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = s.width + (e.padding ?? 0), l = s.height + (e.padding ?? 0), c = Math.max(5, l * 0.1), { cssStyles: h10 } = e, p = [
    ...Ci(a / 2, -l / 2, c, 30, -90, 0),
    { x: -a / 2 - c, y: c },
    ...Ci(a / 2 + c * 2, -c, c, 20, -180, -270),
    ...Ci(a / 2 + c * 2, c, c, 20, -90, -180),
    { x: -a / 2 - c, y: -l / 2 },
    ...Ci(a / 2, l / 2, c, 20, 0, 90)
  ], m = [
    { x: a / 2, y: -l / 2 - c },
    { x: -a / 2, y: -l / 2 - c },
    ...Ci(a / 2, -l / 2, c, 20, -90, 0),
    { x: -a / 2 - c, y: -c },
    ...Ci(a / 2 + a * 0.1, -c, c, 20, -180, -270),
    ...Ci(a / 2 + a * 0.1, c, c, 20, -90, -180),
    { x: -a / 2 - c, y: l / 2 },
    ...Ci(a / 2, l / 2, c, 20, 0, 90),
    { x: -a / 2, y: l / 2 + c },
    { x: a / 2, y: l / 2 + c }
  ], g = Bt.svg(i), y = Lt(e, { fill: "none" });
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = le(p).replace("Z", ""), k = g.path(x, y), C = le(m), _ = g.path(C, { ...y }), $ = i.insert("g", ":first-child");
  return $.insert(() => _, ":first-child").attr("stroke-opacity", 0), $.insert(() => k, ":first-child"), $.attr("class", "text"), h10 && e.look !== "handDrawn" && $.selectAll("path").attr("style", h10), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(${c}, 0)`), o.attr(
    "transform",
    `translate(${-a / 2 + c - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`
  ), Ft(e, $), e.intersect = function(L) {
    return Et.polygon(e, m, L);
  }, i;
}
S(o8, "curlyBraceLeft");
function Si(t15, e, r, n = 100, i = 0, s = 180) {
  const o = [], a = i * Math.PI / 180, l = (s * Math.PI / 180 - a) / (n - 1);
  for (let c = 0; c < n; c++) {
    const h10 = a + c * l, p = t15 + r * Math.cos(h10), m = e + r * Math.sin(h10);
    o.push({ x: p, y: m });
  }
  return o;
}
S(Si, "generateCirclePoints");
async function a8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = s.width + (e.padding ?? 0), l = s.height + (e.padding ?? 0), c = Math.max(5, l * 0.1), { cssStyles: h10 } = e, p = [
    ...Si(a / 2, -l / 2, c, 20, -90, 0),
    { x: a / 2 + c, y: -c },
    ...Si(a / 2 + c * 2, -c, c, 20, -180, -270),
    ...Si(a / 2 + c * 2, c, c, 20, -90, -180),
    { x: a / 2 + c, y: l / 2 },
    ...Si(a / 2, l / 2, c, 20, 0, 90)
  ], m = [
    { x: -a / 2, y: -l / 2 - c },
    { x: a / 2, y: -l / 2 - c },
    ...Si(a / 2, -l / 2, c, 20, -90, 0),
    { x: a / 2 + c, y: -c },
    ...Si(a / 2 + c * 2, -c, c, 20, -180, -270),
    ...Si(a / 2 + c * 2, c, c, 20, -90, -180),
    { x: a / 2 + c, y: l / 2 },
    ...Si(a / 2, l / 2, c, 20, 0, 90),
    { x: a / 2, y: l / 2 + c },
    { x: -a / 2, y: l / 2 + c }
  ], g = Bt.svg(i), y = Lt(e, { fill: "none" });
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = le(p).replace("Z", ""), k = g.path(x, y), C = le(m), _ = g.path(C, { ...y }), $ = i.insert("g", ":first-child");
  return $.insert(() => _, ":first-child").attr("stroke-opacity", 0), $.insert(() => k, ":first-child"), $.attr("class", "text"), h10 && e.look !== "handDrawn" && $.selectAll("path").attr("style", h10), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(${-c}, 0)`), o.attr(
    "transform",
    `translate(${-a / 2 + (e.padding ?? 0) / 2 - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`
  ), Ft(e, $), e.intersect = function(L) {
    return Et.polygon(e, m, L);
  }, i;
}
S(a8, "curlyBraceRight");
function ur(t15, e, r, n = 100, i = 0, s = 180) {
  const o = [], a = i * Math.PI / 180, l = (s * Math.PI / 180 - a) / (n - 1);
  for (let c = 0; c < n; c++) {
    const h10 = a + c * l, p = t15 + r * Math.cos(h10), m = e + r * Math.sin(h10);
    o.push({ x: -p, y: -m });
  }
  return o;
}
S(ur, "generateCirclePoints");
async function l8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = s.width + (e.padding ?? 0), l = s.height + (e.padding ?? 0), c = Math.max(5, l * 0.1), { cssStyles: h10 } = e, p = [
    ...ur(a / 2, -l / 2, c, 30, -90, 0),
    { x: -a / 2 - c, y: c },
    ...ur(a / 2 + c * 2, -c, c, 20, -180, -270),
    ...ur(a / 2 + c * 2, c, c, 20, -90, -180),
    { x: -a / 2 - c, y: -l / 2 },
    ...ur(a / 2, l / 2, c, 20, 0, 90)
  ], m = [
    ...ur(-a / 2 + c + c / 2, -l / 2, c, 20, -90, -180),
    { x: a / 2 - c / 2, y: c },
    ...ur(-a / 2 - c / 2, -c, c, 20, 0, 90),
    ...ur(-a / 2 - c / 2, c, c, 20, -90, 0),
    { x: a / 2 - c / 2, y: -c },
    ...ur(-a / 2 + c + c / 2, l / 2, c, 30, -180, -270)
  ], g = [
    { x: a / 2, y: -l / 2 - c },
    { x: -a / 2, y: -l / 2 - c },
    ...ur(a / 2, -l / 2, c, 20, -90, 0),
    { x: -a / 2 - c, y: -c },
    ...ur(a / 2 + c * 2, -c, c, 20, -180, -270),
    ...ur(a / 2 + c * 2, c, c, 20, -90, -180),
    { x: -a / 2 - c, y: l / 2 },
    ...ur(a / 2, l / 2, c, 20, 0, 90),
    { x: -a / 2, y: l / 2 + c },
    { x: a / 2 - c - c / 2, y: l / 2 + c },
    ...ur(-a / 2 + c + c / 2, -l / 2, c, 20, -90, -180),
    { x: a / 2 - c / 2, y: c },
    ...ur(-a / 2 - c / 2, -c, c, 20, 0, 90),
    ...ur(-a / 2 - c / 2, c, c, 20, -90, 0),
    { x: a / 2 - c / 2, y: -c },
    ...ur(-a / 2 + c + c / 2, l / 2, c, 30, -180, -270)
  ], y = Bt.svg(i), x = Lt(e, { fill: "none" });
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const k = le(p).replace("Z", ""), C = y.path(k, x), _ = le(m).replace("Z", ""), $ = y.path(_, x), L = le(g), B = y.path(L, { ...x }), q = i.insert("g", ":first-child");
  return q.insert(() => B, ":first-child").attr("stroke-opacity", 0), q.insert(() => C, ":first-child"), q.insert(() => $, ":first-child"), q.attr("class", "text"), h10 && e.look !== "handDrawn" && q.selectAll("path").attr("style", h10), n && e.look !== "handDrawn" && q.selectAll("path").attr("style", n), q.attr("transform", `translate(${c - c / 4}, 0)`), o.attr(
    "transform",
    `translate(${-a / 2 + (e.padding ?? 0) / 2 - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`
  ), Ft(e, q), e.intersect = function(H) {
    return Et.polygon(e, g, H);
  }, i;
}
S(l8, "curlyBraces");
async function c8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = 80, a = 20, l = Math.max(o, (s.width + (e.padding ?? 0) * 2) * 1.25, (e == null ? void 0 : e.width) ?? 0), c = Math.max(a, s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h10 = c / 2, { cssStyles: p } = e, m = Bt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = l, x = c, k = y - h10, C = x / 4, _ = [
    { x: k, y: 0 },
    { x: C, y: 0 },
    { x: 0, y: x / 2 },
    { x: C, y: x },
    { x: k, y: x },
    ...Tg(-k, -x / 2, h10, 50, 270, 90)
  ], $ = le(_), L = m.path($, g), B = i.insert(() => L, ":first-child");
  return B.attr("class", "basic label-container"), p && e.look !== "handDrawn" && B.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && B.selectChildren("path").attr("style", n), B.attr("transform", `translate(${-l / 2}, ${-c / 2})`), Ft(e, B), e.intersect = function(q) {
    return Et.polygon(e, _, q);
  }, i;
}
S(c8, "curvedTrapezoid");
var OK = S((t15, e, r, n, i, s) => [
  `M${t15},${e + s}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `a${i},${s} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `l0,${-n}`
].join(" "), "createCylinderPathD");
var zK = S((t15, e, r, n, i, s) => [
  `M${t15},${e + s}`,
  `M${t15 + r},${e + s}`,
  `a${i},${s} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `l0,${-n}`
].join(" "), "createOuterCylinderPathD");
var qK = S((t15, e, r, n, i, s) => [`M${t15 - r / 2},${-n / 2}`, `a${i},${s} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function h8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + e.padding, e.width ?? 0), l = a / 2, c = l / (2.5 + a / 50), h10 = Math.max(s.height + c + e.padding, e.height ?? 0);
  let p;
  const { cssStyles: m } = e;
  if (e.look === "handDrawn") {
    const g = Bt.svg(i), y = zK(0, 0, a, h10, l, c), x = qK(0, c, a, h10, l, c), k = g.path(y, Lt(e, {})), C = g.path(x, Lt(e, { fill: "none" }));
    p = i.insert(() => C, ":first-child"), p = i.insert(() => k, ":first-child"), p.attr("class", "basic label-container"), m && p.attr("style", m);
  } else {
    const g = OK(0, 0, a, h10, l, c);
    p = i.insert("path", ":first-child").attr("d", g).attr("class", "basic label-container").attr("style", Mr(m)).attr("style", n);
  }
  return p.attr("label-offset-y", c), p.attr("transform", `translate(${-a / 2}, ${-(h10 / 2 + c)})`), Ft(e, p), o.attr(
    "transform",
    `translate(${-(s.width / 2) - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + (e.padding ?? 0) / 1.5 - (s.y - (s.top ?? 0))})`
  ), e.intersect = function(g) {
    const y = Et.rect(e, g), x = y.x - (e.x ?? 0);
    if (l != 0 && (Math.abs(x) < (e.width ?? 0) / 2 || Math.abs(x) == (e.width ?? 0) / 2 && Math.abs(y.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - c)) {
      let k = c * c * (1 - x * x / (l * l));
      k > 0 && (k = Math.sqrt(k)), k = c - k, g.y - (e.y ?? 0) > 0 && (k = -k), y.y += k;
    }
    return y;
  }, i;
}
S(h8, "cylinder");
async function u8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = s.width + e.padding, l = s.height + e.padding, c = l * 0.2, h10 = -a / 2, p = -l / 2 - c / 2, { cssStyles: m } = e, g = Bt.svg(i), y = Lt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = [
    { x: h10, y: p + c },
    { x: -h10, y: p + c },
    { x: -h10, y: -p },
    { x: h10, y: -p },
    { x: h10, y: p },
    { x: -h10, y: p },
    { x: -h10, y: p + c }
  ], k = g.polygon(
    x.map((_) => [_.x, _.y]),
    y
  ), C = i.insert(() => k, ":first-child");
  return C.attr("class", "basic label-container"), m && e.look !== "handDrawn" && C.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && C.selectAll("path").attr("style", n), o.attr(
    "transform",
    `translate(${h10 + (e.padding ?? 0) / 2 - (s.x - (s.left ?? 0))}, ${p + c + (e.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`
  ), Ft(e, C), e.intersect = function(_) {
    return Et.rect(e, _);
  }, i;
}
S(u8, "dividedRectangle");
async function d8(t15, e) {
  var _a2, _b2;
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, halfPadding: o } = await Gt(t15, e, Ht(e)), a = s.width / 2 + o + 5, l = s.width / 2 + o;
  let c;
  const { cssStyles: h10 } = e;
  if (e.look === "handDrawn") {
    const p = Bt.svg(i), m = Lt(e, { roughness: 0.2, strokeWidth: 2.5 }), g = Lt(e, { roughness: 0.2, strokeWidth: 1.5 }), y = p.circle(0, 0, a * 2, m), x = p.circle(0, 0, l * 2, g);
    c = i.insert("g", ":first-child"), c.attr("class", Mr(e.cssClasses)).attr("style", Mr(h10)), (_a2 = c.node()) == null ? void 0 : _a2.appendChild(y), (_b2 = c.node()) == null ? void 0 : _b2.appendChild(x);
  } else {
    c = i.insert("g", ":first-child");
    const p = c.insert("circle", ":first-child"), m = c.insert("circle");
    c.attr("class", "basic label-container").attr("style", n), p.attr("class", "outer-circle").attr("style", n).attr("r", a).attr("cx", 0).attr("cy", 0), m.attr("class", "inner-circle").attr("style", n).attr("r", l).attr("cx", 0).attr("cy", 0);
  }
  return Ft(e, c), e.intersect = function(p) {
    return ut.info("DoubleCircle intersect", e, a, p), Et.circle(e, a, p);
  }, i;
}
S(d8, "doublecircle");
function p8(t15, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = Nt(e);
  e.label = "", e.labelStyle = n;
  const s = t15.insert("g").attr("class", Ht(e)).attr("id", e.domId ?? e.id), o = 7, { cssStyles: a } = e, l = Bt.svg(s), { nodeBorder: c } = r, h10 = Lt(e, { fillStyle: "solid" });
  e.look !== "handDrawn" && (h10.roughness = 0);
  const p = l.circle(0, 0, o * 2, h10), m = s.insert(() => p, ":first-child");
  return m.selectAll("path").attr("style", `fill: ${c} !important;`), a && a.length > 0 && e.look !== "handDrawn" && m.selectAll("path").attr("style", a), i && e.look !== "handDrawn" && m.selectAll("path").attr("style", i), Ft(e, m), e.intersect = function(g) {
    return ut.info("filledCircle intersect", e, { radius: o, point: g }), Et.circle(e, o, g);
  }, s;
}
S(p8, "filledCircle");
async function f8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = s.width + (e.padding ?? 0), l = a + s.height, c = a + s.height, h10 = [
    { x: 0, y: -l },
    { x: c, y: -l },
    { x: c / 2, y: 0 }
  ], { cssStyles: p } = e, m = Bt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = le(h10), x = m.path(y, g), k = i.insert(() => x, ":first-child").attr("transform", `translate(${-l / 2}, ${l / 2})`);
  return p && e.look !== "handDrawn" && k.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && k.selectChildren("path").attr("style", n), e.width = a, e.height = l, Ft(e, k), o.attr(
    "transform",
    `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${-l / 2 + (e.padding ?? 0) / 2 + (s.y - (s.top ?? 0))})`
  ), e.intersect = function(C) {
    return ut.info("Triangle intersect", e, h10, C), Et.polygon(e, h10, C);
  }, i;
}
S(f8, "flippedTriangle");
function m8(t15, e, { dir: r, config: { state: n, themeVariables: i } }) {
  const { nodeStyles: s } = Nt(e);
  e.label = "";
  const o = t15.insert("g").attr("class", Ht(e)).attr("id", e.domId ?? e.id), { cssStyles: a } = e;
  let l = Math.max(70, (e == null ? void 0 : e.width) ?? 0), c = Math.max(10, (e == null ? void 0 : e.height) ?? 0);
  r === "LR" && (l = Math.max(10, (e == null ? void 0 : e.width) ?? 0), c = Math.max(70, (e == null ? void 0 : e.height) ?? 0));
  const h10 = -1 * l / 2, p = -1 * c / 2, m = Bt.svg(o), g = Lt(e, {
    stroke: i.lineColor,
    fill: i.lineColor
  });
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = m.rectangle(h10, p, l, c, g), x = o.insert(() => y, ":first-child");
  a && e.look !== "handDrawn" && x.selectAll("path").attr("style", a), s && e.look !== "handDrawn" && x.selectAll("path").attr("style", s), Ft(e, x);
  const k = (n == null ? void 0 : n.padding) ?? 0;
  return e.width && e.height && (e.width += k / 2 || 0, e.height += k / 2 || 0), e.intersect = function(C) {
    return Et.rect(e, C);
  }, o;
}
S(m8, "forkJoin");
async function g8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const i = 80, s = 50, { shapeSvg: o, bbox: a } = await Gt(t15, e, Ht(e)), l = Math.max(i, a.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(s, a.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h10 = c / 2, { cssStyles: p } = e, m = Bt.svg(o), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = [
    { x: -l / 2, y: -c / 2 },
    { x: l / 2 - h10, y: -c / 2 },
    ...Tg(-l / 2 + h10, 0, h10, 50, 90, 270),
    { x: l / 2 - h10, y: c / 2 },
    { x: -l / 2, y: c / 2 }
  ], x = le(y), k = m.path(x, g), C = o.insert(() => k, ":first-child");
  return C.attr("class", "basic label-container"), p && e.look !== "handDrawn" && C.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && C.selectChildren("path").attr("style", n), Ft(e, C), e.intersect = function(_) {
    return ut.info("Pill intersect", e, { radius: h10, point: _ }), Et.polygon(e, y, _);
  }, o;
}
S(g8, "halfRoundedRectangle");
var RK = S((t15, e, r, n, i) => [
  `M${t15 + i},${e}`,
  `L${t15 + r - i},${e}`,
  `L${t15 + r},${e - n / 2}`,
  `L${t15 + r - i},${e - n}`,
  `L${t15 + i},${e - n}`,
  `L${t15},${e - n / 2}`,
  "Z"
].join(" "), "createHexagonPathD");
async function y8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = 4, a = s.height + e.padding, l = a / o, c = s.width + 2 * l + e.padding, h10 = [
    { x: l, y: 0 },
    { x: c - l, y: 0 },
    { x: c, y: -a / 2 },
    { x: c - l, y: -a },
    { x: l, y: -a },
    { x: 0, y: -a / 2 }
  ];
  let p;
  const { cssStyles: m } = e;
  if (e.look === "handDrawn") {
    const g = Bt.svg(i), y = Lt(e, {}), x = RK(0, 0, c, a, l), k = g.path(x, y);
    p = i.insert(() => k, ":first-child").attr("transform", `translate(${-c / 2}, ${a / 2})`), m && p.attr("style", m);
  } else
    p = Ri(i, c, a, h10);
  return n && p.attr("style", n), e.width = c, e.height = a, Ft(e, p), e.intersect = function(g) {
    return Et.polygon(e, h10, g);
  }, i;
}
S(y8, "hexagon");
async function b8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.label = "", e.labelStyle = r;
  const { shapeSvg: i } = await Gt(t15, e, Ht(e)), s = Math.max(30, (e == null ? void 0 : e.width) ?? 0), o = Math.max(30, (e == null ? void 0 : e.height) ?? 0), { cssStyles: a } = e, l = Bt.svg(i), c = Lt(e, {});
  e.look !== "handDrawn" && (c.roughness = 0, c.fillStyle = "solid");
  const h10 = [
    { x: 0, y: 0 },
    { x: s, y: 0 },
    { x: 0, y: o },
    { x: s, y: o }
  ], p = le(h10), m = l.path(p, c), g = i.insert(() => m, ":first-child");
  return g.attr("class", "basic label-container"), a && e.look !== "handDrawn" && g.selectChildren("path").attr("style", a), n && e.look !== "handDrawn" && g.selectChildren("path").attr("style", n), g.attr("transform", `translate(${-s / 2}, ${-o / 2})`), Ft(e, g), e.intersect = function(y) {
    return ut.info("Pill intersect", e, { points: h10 }), Et.polygon(e, h10, y);
  }, i;
}
S(b8, "hourglass");
async function x8(t15, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Nt(e);
  e.labelStyle = i;
  const s = e.assetHeight ?? 48, o = e.assetWidth ?? 48, a = Math.max(s, o), l = n == null ? void 0 : n.wrappingWidth;
  e.width = Math.max(a, l ?? 0);
  const { shapeSvg: c, bbox: h10, label: p } = await Gt(t15, e, "icon-shape default"), m = e.pos === "t", g = a, y = a, { nodeBorder: x } = r, { stylesMap: k } = ya(e), C = -y / 2, _ = -g / 2, $ = e.label ? 8 : 0, L = Bt.svg(c), B = Lt(e, { stroke: "none", fill: "none" });
  e.look !== "handDrawn" && (B.roughness = 0, B.fillStyle = "solid");
  const q = L.rectangle(C, _, y, g, B), H = Math.max(y, h10.width), G = g + h10.height + $, F = L.rectangle(-H / 2, -G / 2, H, G, {
    ...B,
    fill: "transparent",
    stroke: "none"
  }), W = c.insert(() => q, ":first-child"), R = c.insert(() => F);
  if (e.icon) {
    const J = c.append("g");
    J.html(
      `<g>${await bc(e.icon, {
        height: a,
        width: a,
        fallbackPrefix: ""
      })}</g>`
    );
    const rt = J.node().getBBox(), I = rt.width, j = rt.height, z = rt.x, K = rt.y;
    J.attr(
      "transform",
      `translate(${-I / 2 - z},${m ? h10.height / 2 + $ / 2 - j / 2 - K : -h10.height / 2 - $ / 2 - j / 2 - K})`
    ), J.attr("style", `color: ${k.get("stroke") ?? x};`);
  }
  return p.attr(
    "transform",
    `translate(${-h10.width / 2 - (h10.x - (h10.left ?? 0))},${m ? -G / 2 : G / 2 - h10.height})`
  ), W.attr(
    "transform",
    `translate(0,${m ? h10.height / 2 + $ / 2 : -h10.height / 2 - $ / 2})`
  ), Ft(e, R), e.intersect = function(J) {
    if (ut.info("iconSquare intersect", e, J), !e.label)
      return Et.rect(e, J);
    const rt = e.x ?? 0, I = e.y ?? 0, j = e.height ?? 0;
    let z = [];
    return m ? z = [
      { x: rt - h10.width / 2, y: I - j / 2 },
      { x: rt + h10.width / 2, y: I - j / 2 },
      { x: rt + h10.width / 2, y: I - j / 2 + h10.height + $ },
      { x: rt + y / 2, y: I - j / 2 + h10.height + $ },
      { x: rt + y / 2, y: I + j / 2 },
      { x: rt - y / 2, y: I + j / 2 },
      { x: rt - y / 2, y: I - j / 2 + h10.height + $ },
      { x: rt - h10.width / 2, y: I - j / 2 + h10.height + $ }
    ] : z = [
      { x: rt - y / 2, y: I - j / 2 },
      { x: rt + y / 2, y: I - j / 2 },
      { x: rt + y / 2, y: I - j / 2 + g },
      { x: rt + h10.width / 2, y: I - j / 2 + g },
      { x: rt + h10.width / 2 / 2, y: I + j / 2 },
      { x: rt - h10.width / 2, y: I + j / 2 },
      { x: rt - h10.width / 2, y: I - j / 2 + g },
      { x: rt - y / 2, y: I - j / 2 + g }
    ], Et.polygon(e, z, J);
  }, c;
}
S(x8, "icon");
async function w8(t15, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Nt(e);
  e.labelStyle = i;
  const s = e.assetHeight ?? 48, o = e.assetWidth ?? 48, a = Math.max(s, o), l = n == null ? void 0 : n.wrappingWidth;
  e.width = Math.max(a, l ?? 0);
  const { shapeSvg: c, bbox: h10, label: p } = await Gt(t15, e, "icon-shape default"), m = 20, g = e.label ? 8 : 0, y = e.pos === "t", { nodeBorder: x, mainBkg: k } = r, { stylesMap: C } = ya(e), _ = Bt.svg(c), $ = Lt(e, {});
  e.look !== "handDrawn" && ($.roughness = 0, $.fillStyle = "solid");
  const L = C.get("fill");
  $.stroke = L ?? k;
  const B = c.append("g");
  e.icon && B.html(
    `<g>${await bc(e.icon, {
      height: a,
      width: a,
      fallbackPrefix: ""
    })}</g>`
  );
  const q = B.node().getBBox(), H = q.width, G = q.height, F = q.x, W = q.y, R = Math.max(H, G) * Math.SQRT2 + m * 2, J = _.circle(0, 0, R, $), rt = Math.max(R, h10.width), I = R + h10.height + g, j = _.rectangle(-rt / 2, -I / 2, rt, I, {
    ...$,
    fill: "transparent",
    stroke: "none"
  }), z = c.insert(() => J, ":first-child"), K = c.insert(() => j);
  return B.attr(
    "transform",
    `translate(${-H / 2 - F},${y ? h10.height / 2 + g / 2 - G / 2 - W : -h10.height / 2 - g / 2 - G / 2 - W})`
  ), B.attr("style", `color: ${C.get("stroke") ?? x};`), p.attr(
    "transform",
    `translate(${-h10.width / 2 - (h10.x - (h10.left ?? 0))},${y ? -I / 2 : I / 2 - h10.height})`
  ), z.attr(
    "transform",
    `translate(0,${y ? h10.height / 2 + g / 2 : -h10.height / 2 - g / 2})`
  ), Ft(e, K), e.intersect = function(Y) {
    return ut.info("iconSquare intersect", e, Y), Et.rect(e, Y);
  }, c;
}
S(w8, "iconCircle");
async function k8(t15, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Nt(e);
  e.labelStyle = i;
  const s = e.assetHeight ?? 48, o = e.assetWidth ?? 48, a = Math.max(s, o), l = n == null ? void 0 : n.wrappingWidth;
  e.width = Math.max(a, l ?? 0);
  const { shapeSvg: c, bbox: h10, halfPadding: p, label: m } = await Gt(
    t15,
    e,
    "icon-shape default"
  ), g = e.pos === "t", y = a + p * 2, x = a + p * 2, { nodeBorder: k, mainBkg: C } = r, { stylesMap: _ } = ya(e), $ = -x / 2, L = -y / 2, B = e.label ? 8 : 0, q = Bt.svg(c), H = Lt(e, {});
  e.look !== "handDrawn" && (H.roughness = 0, H.fillStyle = "solid");
  const G = _.get("fill");
  H.stroke = G ?? C;
  const F = q.path(qi($, L, x, y, 5), H), W = Math.max(x, h10.width), R = y + h10.height + B, J = q.rectangle(-W / 2, -R / 2, W, R, {
    ...H,
    fill: "transparent",
    stroke: "none"
  }), rt = c.insert(() => F, ":first-child").attr("class", "icon-shape2"), I = c.insert(() => J);
  if (e.icon) {
    const j = c.append("g");
    j.html(
      `<g>${await bc(e.icon, {
        height: a,
        width: a,
        fallbackPrefix: ""
      })}</g>`
    );
    const z = j.node().getBBox(), K = z.width, Y = z.height, at = z.x, et = z.y;
    j.attr(
      "transform",
      `translate(${-K / 2 - at},${g ? h10.height / 2 + B / 2 - Y / 2 - et : -h10.height / 2 - B / 2 - Y / 2 - et})`
    ), j.attr("style", `color: ${_.get("stroke") ?? k};`);
  }
  return m.attr(
    "transform",
    `translate(${-h10.width / 2 - (h10.x - (h10.left ?? 0))},${g ? -R / 2 : R / 2 - h10.height})`
  ), rt.attr(
    "transform",
    `translate(0,${g ? h10.height / 2 + B / 2 : -h10.height / 2 - B / 2})`
  ), Ft(e, I), e.intersect = function(j) {
    if (ut.info("iconSquare intersect", e, j), !e.label)
      return Et.rect(e, j);
    const z = e.x ?? 0, K = e.y ?? 0, Y = e.height ?? 0;
    let at = [];
    return g ? at = [
      { x: z - h10.width / 2, y: K - Y / 2 },
      { x: z + h10.width / 2, y: K - Y / 2 },
      { x: z + h10.width / 2, y: K - Y / 2 + h10.height + B },
      { x: z + x / 2, y: K - Y / 2 + h10.height + B },
      { x: z + x / 2, y: K + Y / 2 },
      { x: z - x / 2, y: K + Y / 2 },
      { x: z - x / 2, y: K - Y / 2 + h10.height + B },
      { x: z - h10.width / 2, y: K - Y / 2 + h10.height + B }
    ] : at = [
      { x: z - x / 2, y: K - Y / 2 },
      { x: z + x / 2, y: K - Y / 2 },
      { x: z + x / 2, y: K - Y / 2 + y },
      { x: z + h10.width / 2, y: K - Y / 2 + y },
      { x: z + h10.width / 2 / 2, y: K + Y / 2 },
      { x: z - h10.width / 2, y: K + Y / 2 },
      { x: z - h10.width / 2, y: K - Y / 2 + y },
      { x: z - x / 2, y: K - Y / 2 + y }
    ], Et.polygon(e, at, j);
  }, c;
}
S(k8, "iconRounded");
async function v8(t15, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Nt(e);
  e.labelStyle = i;
  const s = e.assetHeight ?? 48, o = e.assetWidth ?? 48, a = Math.max(s, o), l = n == null ? void 0 : n.wrappingWidth;
  e.width = Math.max(a, l ?? 0);
  const { shapeSvg: c, bbox: h10, halfPadding: p, label: m } = await Gt(
    t15,
    e,
    "icon-shape default"
  ), g = e.pos === "t", y = a + p * 2, x = a + p * 2, { nodeBorder: k, mainBkg: C } = r, { stylesMap: _ } = ya(e), $ = -x / 2, L = -y / 2, B = e.label ? 8 : 0, q = Bt.svg(c), H = Lt(e, {});
  e.look !== "handDrawn" && (H.roughness = 0, H.fillStyle = "solid");
  const G = _.get("fill");
  H.stroke = G ?? C;
  const F = q.path(qi($, L, x, y, 0.1), H), W = Math.max(x, h10.width), R = y + h10.height + B, J = q.rectangle(-W / 2, -R / 2, W, R, {
    ...H,
    fill: "transparent",
    stroke: "none"
  }), rt = c.insert(() => F, ":first-child"), I = c.insert(() => J);
  if (e.icon) {
    const j = c.append("g");
    j.html(
      `<g>${await bc(e.icon, {
        height: a,
        width: a,
        fallbackPrefix: ""
      })}</g>`
    );
    const z = j.node().getBBox(), K = z.width, Y = z.height, at = z.x, et = z.y;
    j.attr(
      "transform",
      `translate(${-K / 2 - at},${g ? h10.height / 2 + B / 2 - Y / 2 - et : -h10.height / 2 - B / 2 - Y / 2 - et})`
    ), j.attr("style", `color: ${_.get("stroke") ?? k};`);
  }
  return m.attr(
    "transform",
    `translate(${-h10.width / 2 - (h10.x - (h10.left ?? 0))},${g ? -R / 2 : R / 2 - h10.height})`
  ), rt.attr(
    "transform",
    `translate(0,${g ? h10.height / 2 + B / 2 : -h10.height / 2 - B / 2})`
  ), Ft(e, I), e.intersect = function(j) {
    if (ut.info("iconSquare intersect", e, j), !e.label)
      return Et.rect(e, j);
    const z = e.x ?? 0, K = e.y ?? 0, Y = e.height ?? 0;
    let at = [];
    return g ? at = [
      { x: z - h10.width / 2, y: K - Y / 2 },
      { x: z + h10.width / 2, y: K - Y / 2 },
      { x: z + h10.width / 2, y: K - Y / 2 + h10.height + B },
      { x: z + x / 2, y: K - Y / 2 + h10.height + B },
      { x: z + x / 2, y: K + Y / 2 },
      { x: z - x / 2, y: K + Y / 2 },
      { x: z - x / 2, y: K - Y / 2 + h10.height + B },
      { x: z - h10.width / 2, y: K - Y / 2 + h10.height + B }
    ] : at = [
      { x: z - x / 2, y: K - Y / 2 },
      { x: z + x / 2, y: K - Y / 2 },
      { x: z + x / 2, y: K - Y / 2 + y },
      { x: z + h10.width / 2, y: K - Y / 2 + y },
      { x: z + h10.width / 2 / 2, y: K + Y / 2 },
      { x: z - h10.width / 2, y: K + Y / 2 },
      { x: z - h10.width / 2, y: K - Y / 2 + y },
      { x: z - x / 2, y: K - Y / 2 + y }
    ], Et.polygon(e, at, j);
  }, c;
}
S(v8, "iconSquare");
async function _8(t15, e, { config: { flowchart: r } }) {
  const n = new Image();
  n.src = (e == null ? void 0 : e.img) ?? "", await n.decode();
  const i = Number(n.naturalWidth.toString().replace("px", "")), s = Number(n.naturalHeight.toString().replace("px", ""));
  e.imageAspectRatio = i / s;
  const { labelStyles: o } = Nt(e);
  e.labelStyle = o;
  const a = r == null ? void 0 : r.wrappingWidth;
  e.defaultWidth = r == null ? void 0 : r.wrappingWidth;
  const l = Math.max(
    e.label ? a ?? 0 : 0,
    (e == null ? void 0 : e.assetWidth) ?? i
  ), c = e.constraint === "on" && (e == null ? void 0 : e.assetHeight) ? e.assetHeight * e.imageAspectRatio : l, h10 = e.constraint === "on" ? c / e.imageAspectRatio : (e == null ? void 0 : e.assetHeight) ?? s;
  e.width = Math.max(c, a ?? 0);
  const { shapeSvg: p, bbox: m, label: g } = await Gt(t15, e, "image-shape default"), y = e.pos === "t", x = -c / 2, k = -h10 / 2, C = e.label ? 8 : 0, _ = Bt.svg(p), $ = Lt(e, {});
  e.look !== "handDrawn" && ($.roughness = 0, $.fillStyle = "solid");
  const L = _.rectangle(x, k, c, h10, $), B = Math.max(c, m.width), q = h10 + m.height + C, H = _.rectangle(-B / 2, -q / 2, B, q, {
    ...$,
    fill: "none",
    stroke: "none"
  }), G = p.insert(() => L, ":first-child"), F = p.insert(() => H);
  if (e.img) {
    const W = p.append("image");
    W.attr("href", e.img), W.attr("width", c), W.attr("height", h10), W.attr("preserveAspectRatio", "none"), W.attr(
      "transform",
      `translate(${-c / 2},${y ? q / 2 - h10 : -q / 2})`
    );
  }
  return g.attr(
    "transform",
    `translate(${-m.width / 2 - (m.x - (m.left ?? 0))},${y ? -h10 / 2 - m.height / 2 - C / 2 : h10 / 2 - m.height / 2 + C / 2})`
  ), G.attr(
    "transform",
    `translate(0,${y ? m.height / 2 + C / 2 : -m.height / 2 - C / 2})`
  ), Ft(e, F), e.intersect = function(W) {
    if (ut.info("iconSquare intersect", e, W), !e.label)
      return Et.rect(e, W);
    const R = e.x ?? 0, J = e.y ?? 0, rt = e.height ?? 0;
    let I = [];
    return y ? I = [
      { x: R - m.width / 2, y: J - rt / 2 },
      { x: R + m.width / 2, y: J - rt / 2 },
      { x: R + m.width / 2, y: J - rt / 2 + m.height + C },
      { x: R + c / 2, y: J - rt / 2 + m.height + C },
      { x: R + c / 2, y: J + rt / 2 },
      { x: R - c / 2, y: J + rt / 2 },
      { x: R - c / 2, y: J - rt / 2 + m.height + C },
      { x: R - m.width / 2, y: J - rt / 2 + m.height + C }
    ] : I = [
      { x: R - c / 2, y: J - rt / 2 },
      { x: R + c / 2, y: J - rt / 2 },
      { x: R + c / 2, y: J - rt / 2 + h10 },
      { x: R + m.width / 2, y: J - rt / 2 + h10 },
      { x: R + m.width / 2 / 2, y: J + rt / 2 },
      { x: R - m.width / 2, y: J + rt / 2 },
      { x: R - m.width / 2, y: J - rt / 2 + h10 },
      { x: R - c / 2, y: J - rt / 2 + h10 }
    ], Et.polygon(e, I, W);
  }, p;
}
S(_8, "imageSquare");
async function C8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), a = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), l = [
    { x: 0, y: 0 },
    { x: o, y: 0 },
    { x: o + 3 * a / 6, y: -a },
    { x: -3 * a / 6, y: -a }
  ];
  let c;
  const { cssStyles: h10 } = e;
  if (e.look === "handDrawn") {
    const p = Bt.svg(i), m = Lt(e, {}), g = le(l), y = p.path(g, m);
    c = i.insert(() => y, ":first-child").attr("transform", `translate(${-o / 2}, ${a / 2})`), h10 && c.attr("style", h10);
  } else
    c = Ri(i, o, a, l);
  return n && c.attr("style", n), e.width = o, e.height = a, Ft(e, c), e.intersect = function(p) {
    return Et.polygon(e, l, p);
  }, i;
}
S(C8, "inv_trapezoid");
async function wc(t15, e, r) {
  const { labelStyles: n, nodeStyles: i } = Nt(e);
  e.labelStyle = n;
  const { shapeSvg: s, bbox: o } = await Gt(t15, e, Ht(e)), a = Math.max(o.width + r.labelPaddingX * 2, (e == null ? void 0 : e.width) || 0), l = Math.max(o.height + r.labelPaddingY * 2, (e == null ? void 0 : e.height) || 0), c = -a / 2, h10 = -l / 2;
  let p, { rx: m, ry: g } = e;
  const { cssStyles: y } = e;
  if ((r == null ? void 0 : r.rx) && r.ry && (m = r.rx, g = r.ry), e.look === "handDrawn") {
    const x = Bt.svg(s), k = Lt(e, {}), C = m || g ? x.path(qi(c, h10, a, l, m || 0), k) : x.rectangle(c, h10, a, l, k);
    p = s.insert(() => C, ":first-child"), p.attr("class", "basic label-container").attr("style", Mr(y));
  } else
    p = s.insert("rect", ":first-child"), p.attr("class", "basic label-container").attr("style", i).attr("rx", Mr(m)).attr("ry", Mr(g)).attr("x", c).attr("y", h10).attr("width", a).attr("height", l);
  return Ft(e, p), e.intersect = function(x) {
    return Et.rect(e, x);
  }, s;
}
S(wc, "drawRect");
async function S8(t15, e) {
  const { shapeSvg: r, bbox: n, label: i } = await Gt(t15, e, "label"), s = r.insert("rect", ":first-child");
  return s.attr("width", 0.1).attr("height", 0.1), r.attr("class", "label edgeLabel"), i.attr(
    "transform",
    `translate(${-(n.width / 2) - (n.x - (n.left ?? 0))}, ${-(n.height / 2) - (n.y - (n.top ?? 0))})`
  ), Ft(e, s), e.intersect = function(o) {
    return Et.rect(e, o);
  }, r;
}
S(S8, "labelRect");
async function T8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = Math.max(s.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), a = Math.max(s.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), l = [
    { x: 0, y: 0 },
    { x: o + 3 * a / 6, y: 0 },
    { x: o, y: -a },
    { x: -(3 * a) / 6, y: -a }
  ];
  let c;
  const { cssStyles: h10 } = e;
  if (e.look === "handDrawn") {
    const p = Bt.svg(i), m = Lt(e, {}), g = le(l), y = p.path(g, m);
    c = i.insert(() => y, ":first-child").attr("transform", `translate(${-o / 2}, ${a / 2})`), h10 && c.attr("style", h10);
  } else
    c = Ri(i, o, a, l);
  return n && c.attr("style", n), e.width = o, e.height = a, Ft(e, c), e.intersect = function(p) {
    return Et.polygon(e, l, p);
  }, i;
}
S(T8, "lean_left");
async function A8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = Math.max(s.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), a = Math.max(s.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), l = [
    { x: -3 * a / 6, y: 0 },
    { x: o, y: 0 },
    { x: o + 3 * a / 6, y: -a },
    { x: 0, y: -a }
  ];
  let c;
  const { cssStyles: h10 } = e;
  if (e.look === "handDrawn") {
    const p = Bt.svg(i), m = Lt(e, {}), g = le(l), y = p.path(g, m);
    c = i.insert(() => y, ":first-child").attr("transform", `translate(${-o / 2}, ${a / 2})`), h10 && c.attr("style", h10);
  } else
    c = Ri(i, o, a, l);
  return n && c.attr("style", n), e.width = o, e.height = a, Ft(e, c), e.intersect = function(p) {
    return Et.polygon(e, l, p);
  }, i;
}
S(A8, "lean_right");
function $8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.label = "", e.labelStyle = r;
  const i = t15.insert("g").attr("class", Ht(e)).attr("id", e.domId ?? e.id), { cssStyles: s } = e, o = Math.max(35, (e == null ? void 0 : e.width) ?? 0), a = Math.max(35, (e == null ? void 0 : e.height) ?? 0), l = 7, c = [
    { x: o, y: 0 },
    { x: 0, y: a + l / 2 },
    { x: o - 2 * l, y: a + l / 2 },
    { x: 0, y: 2 * a },
    { x: o, y: a - l / 2 },
    { x: 2 * l, y: a - l / 2 }
  ], h10 = Bt.svg(i), p = Lt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const m = le(c), g = h10.path(m, p), y = i.insert(() => g, ":first-child");
  return s && e.look !== "handDrawn" && y.selectAll("path").attr("style", s), n && e.look !== "handDrawn" && y.selectAll("path").attr("style", n), y.attr("transform", `translate(-${o / 2},${-a})`), Ft(e, y), e.intersect = function(x) {
    return ut.info("lightningBolt intersect", e, x), Et.polygon(e, c, x);
  }, i;
}
S($8, "lightningBolt");
var PK = S((t15, e, r, n, i, s, o) => [
  `M${t15},${e + s}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `a${i},${s} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `l0,${-n}`,
  `M${t15},${e + s + o}`,
  `a${i},${s} 0,0,0 ${r},0`
].join(" "), "createCylinderPathD");
var jK = S((t15, e, r, n, i, s, o) => [
  `M${t15},${e + s}`,
  `M${t15 + r},${e + s}`,
  `a${i},${s} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `l0,${-n}`,
  `M${t15},${e + s + o}`,
  `a${i},${s} 0,0,0 ${r},0`
].join(" "), "createOuterCylinderPathD");
var WK = S((t15, e, r, n, i, s) => [`M${t15 - r / 2},${-n / 2}`, `a${i},${s} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function E8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0), e.width ?? 0), l = a / 2, c = l / (2.5 + a / 50), h10 = Math.max(s.height + c + (e.padding ?? 0), e.height ?? 0), p = h10 * 0.1;
  let m;
  const { cssStyles: g } = e;
  if (e.look === "handDrawn") {
    const y = Bt.svg(i), x = jK(0, 0, a, h10, l, c, p), k = WK(0, c, a, h10, l, c), C = Lt(e, {}), _ = y.path(x, C), $ = y.path(k, C);
    i.insert(() => $, ":first-child").attr("class", "line"), m = i.insert(() => _, ":first-child"), m.attr("class", "basic label-container"), g && m.attr("style", g);
  } else {
    const y = PK(0, 0, a, h10, l, c, p);
    m = i.insert("path", ":first-child").attr("d", y).attr("class", "basic label-container").attr("style", Mr(g)).attr("style", n);
  }
  return m.attr("label-offset-y", c), m.attr("transform", `translate(${-a / 2}, ${-(h10 / 2 + c)})`), Ft(e, m), o.attr(
    "transform",
    `translate(${-(s.width / 2) - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + c - (s.y - (s.top ?? 0))})`
  ), e.intersect = function(y) {
    const x = Et.rect(e, y), k = x.x - (e.x ?? 0);
    if (l != 0 && (Math.abs(k) < (e.width ?? 0) / 2 || Math.abs(k) == (e.width ?? 0) / 2 && Math.abs(x.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - c)) {
      let C = c * c * (1 - k * k / (l * l));
      C > 0 && (C = Math.sqrt(C)), C = c - C, y.y - (e.y ?? 0) > 0 && (C = -C), x.y += C;
    }
    return x;
  }, i;
}
S(E8, "linedCylinder");
async function M8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = l / 4, h10 = l + c, { cssStyles: p } = e, m = Bt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = [
    { x: -a / 2 - a / 2 * 0.1, y: -h10 / 2 },
    { x: -a / 2 - a / 2 * 0.1, y: h10 / 2 },
    ...fs(
      -a / 2 - a / 2 * 0.1,
      h10 / 2,
      a / 2 + a / 2 * 0.1,
      h10 / 2,
      c,
      0.8
    ),
    { x: a / 2 + a / 2 * 0.1, y: -h10 / 2 },
    { x: -a / 2 - a / 2 * 0.1, y: -h10 / 2 },
    { x: -a / 2, y: -h10 / 2 },
    { x: -a / 2, y: h10 / 2 * 1.1 },
    { x: -a / 2, y: -h10 / 2 }
  ], x = m.polygon(
    y.map((C) => [C.x, C.y]),
    g
  ), k = i.insert(() => x, ":first-child");
  return k.attr("class", "basic label-container"), p && e.look !== "handDrawn" && k.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), k.attr("transform", `translate(0,${-c / 2})`), o.attr(
    "transform",
    `translate(${-a / 2 + (e.padding ?? 0) + a / 2 * 0.1 / 2 - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) - c / 2 - (s.y - (s.top ?? 0))})`
  ), Ft(e, k), e.intersect = function(C) {
    return Et.polygon(e, y, C);
  }, i;
}
S(M8, "linedWaveEdgedRect");
async function B8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = 5, h10 = -a / 2, p = -l / 2, { cssStyles: m } = e, g = Bt.svg(i), y = Lt(e, {}), x = [
    { x: h10 - c, y: p + c },
    { x: h10 - c, y: p + l + c },
    { x: h10 + a - c, y: p + l + c },
    { x: h10 + a - c, y: p + l },
    { x: h10 + a, y: p + l },
    { x: h10 + a, y: p + l - c },
    { x: h10 + a + c, y: p + l - c },
    { x: h10 + a + c, y: p - c },
    { x: h10 + c, y: p - c },
    { x: h10 + c, y: p },
    { x: h10, y: p },
    { x: h10, y: p + c }
  ], k = [
    { x: h10, y: p + c },
    { x: h10 + a - c, y: p + c },
    { x: h10 + a - c, y: p + l },
    { x: h10 + a, y: p + l },
    { x: h10 + a, y: p },
    { x: h10, y: p }
  ];
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const C = le(x), _ = g.path(C, y), $ = le(k), L = g.path($, { ...y, fill: "none" }), B = i.insert(() => L, ":first-child");
  return B.insert(() => _, ":first-child"), B.attr("class", "basic label-container"), m && e.look !== "handDrawn" && B.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && B.selectAll("path").attr("style", n), o.attr(
    "transform",
    `translate(${-(s.width / 2) - c - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + c - (s.y - (s.top ?? 0))})`
  ), Ft(e, B), e.intersect = function(q) {
    return Et.polygon(e, x, q);
  }, i;
}
S(B8, "multiRect");
async function L8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = l / 4, h10 = l + c, p = -a / 2, m = -h10 / 2, g = 5, { cssStyles: y } = e, x = fs(
    p - g,
    m + h10 + g,
    p + a - g,
    m + h10 + g,
    c,
    0.8
  ), k = x == null ? void 0 : x[x.length - 1], C = [
    { x: p - g, y: m + g },
    { x: p - g, y: m + h10 + g },
    ...x,
    { x: p + a - g, y: k.y - g },
    { x: p + a, y: k.y - g },
    { x: p + a, y: k.y - 2 * g },
    { x: p + a + g, y: k.y - 2 * g },
    { x: p + a + g, y: m - g },
    { x: p + g, y: m - g },
    { x: p + g, y: m },
    { x: p, y: m },
    { x: p, y: m + g }
  ], _ = [
    { x: p, y: m + g },
    { x: p + a - g, y: m + g },
    { x: p + a - g, y: k.y - g },
    { x: p + a, y: k.y - g },
    { x: p + a, y: m },
    { x: p, y: m }
  ], $ = Bt.svg(i), L = Lt(e, {});
  e.look !== "handDrawn" && (L.roughness = 0, L.fillStyle = "solid");
  const B = le(C), q = $.path(B, L), H = le(_), G = $.path(H, L), F = i.insert(() => q, ":first-child");
  return F.insert(() => G), F.attr("class", "basic label-container"), y && e.look !== "handDrawn" && F.selectAll("path").attr("style", y), n && e.look !== "handDrawn" && F.selectAll("path").attr("style", n), F.attr("transform", `translate(0,${-c / 2})`), o.attr(
    "transform",
    `translate(${-(s.width / 2) - g - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + g - c / 2 - (s.y - (s.top ?? 0))})`
  ), Ft(e, F), e.intersect = function(W) {
    return Et.polygon(e, C, W);
  }, i;
}
S(L8, "multiWaveEdgedRectangle");
async function D8(t15, e, { config: { themeVariables: r } }) {
  var _a2;
  const { labelStyles: n, nodeStyles: i } = Nt(e);
  e.labelStyle = n, e.useHtmlLabels || ((_a2 = Vr().flowchart) == null ? void 0 : _a2.htmlLabels) !== false || (e.centerLabel = true);
  const { shapeSvg: s, bbox: o, label: a } = await Gt(t15, e, Ht(e)), l = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h10 = -l / 2, p = -c / 2, { cssStyles: m } = e, g = Bt.svg(s), y = Lt(e, {
    fill: r.noteBkgColor,
    stroke: r.noteBorderColor
  });
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = g.rectangle(h10, p, l, c, y), k = s.insert(() => x, ":first-child");
  return k.attr("class", "basic label-container"), m && e.look !== "handDrawn" && k.selectAll("path").attr("style", m), i && e.look !== "handDrawn" && k.selectAll("path").attr("style", i), a.attr(
    "transform",
    `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${-(o.height / 2) - (o.y - (o.top ?? 0))})`
  ), Ft(e, k), e.intersect = function(C) {
    return Et.rect(e, C);
  }, s;
}
S(D8, "note");
var HK = S((t15, e, r) => [
  `M${t15 + r / 2},${e}`,
  `L${t15 + r},${e - r / 2}`,
  `L${t15 + r / 2},${e - r}`,
  `L${t15},${e - r / 2}`,
  "Z"
].join(" "), "createDecisionBoxPathD");
async function F8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = s.width + e.padding, a = s.height + e.padding, l = o + a, c = [
    { x: l / 2, y: 0 },
    { x: l, y: -l / 2 },
    { x: l / 2, y: -l },
    { x: 0, y: -l / 2 }
  ];
  let h10;
  const { cssStyles: p } = e;
  if (e.look === "handDrawn") {
    const m = Bt.svg(i), g = Lt(e, {}), y = HK(0, 0, l), x = m.path(y, g);
    h10 = i.insert(() => x, ":first-child").attr("transform", `translate(${-l / 2}, ${l / 2})`), p && h10.attr("style", p);
  } else
    h10 = Ri(i, l, l, c);
  return n && h10.attr("style", n), Ft(e, h10), e.intersect = function(m) {
    return ut.debug(
      `APA12 Intersect called SPLIT
point:`,
      m,
      `
node:
`,
      e,
      `
res:`,
      Et.polygon(e, c, m)
    ), Et.polygon(e, c, m);
  }, i;
}
S(F8, "question");
async function N8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), c = -a / 2, h10 = -l / 2, p = h10 / 2, m = [
    { x: c + p, y: h10 },
    { x: c, y: 0 },
    { x: c + p, y: -h10 },
    { x: -c, y: -h10 },
    { x: -c, y: h10 }
  ], { cssStyles: g } = e, y = Bt.svg(i), x = Lt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const k = le(m), C = y.path(k, x), _ = i.insert(() => C, ":first-child");
  return _.attr("class", "basic label-container"), g && e.look !== "handDrawn" && _.selectAll("path").attr("style", g), n && e.look !== "handDrawn" && _.selectAll("path").attr("style", n), _.attr("transform", `translate(${-p / 2},0)`), o.attr(
    "transform",
    `translate(${-p / 2 - s.width / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`
  ), Ft(e, _), e.intersect = function($) {
    return Et.polygon(e, m, $);
  }, i;
}
S(N8, "rect_left_inv_arrow");
async function I8(t15, e) {
  var _a2, _b2;
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  let i;
  e.cssClasses ? i = "node " + e.cssClasses : i = "node default";
  const s = t15.insert("g").attr("class", i).attr("id", e.domId || e.id), o = s.insert("g"), a = s.insert("g").attr("class", "label").attr("style", n), l = e.description, c = e.label, h10 = a.node().appendChild(await Us(c, e.labelStyle, true, true));
  let p = { width: 0, height: 0 };
  if (Qe((_b2 = (_a2 = me()) == null ? void 0 : _a2.flowchart) == null ? void 0 : _b2.htmlLabels)) {
    const G = h10.children[0], F = ae(h10);
    p = G.getBoundingClientRect(), F.attr("width", p.width), F.attr("height", p.height);
  }
  ut.info("Text 2", l);
  const m = l || [], g = h10.getBBox(), y = a.node().appendChild(
    await Us(
      m.join ? m.join("<br/>") : m,
      e.labelStyle,
      true,
      true
    )
  ), x = y.children[0], k = ae(y);
  p = x.getBoundingClientRect(), k.attr("width", p.width), k.attr("height", p.height);
  const C = (e.padding || 0) / 2;
  ae(y).attr(
    "transform",
    "translate( " + (p.width > g.width ? 0 : (g.width - p.width) / 2) + ", " + (g.height + C + 5) + ")"
  ), ae(h10).attr(
    "transform",
    "translate( " + (p.width < g.width ? 0 : -(g.width - p.width) / 2) + ", 0)"
  ), p = a.node().getBBox(), a.attr(
    "transform",
    "translate(" + -p.width / 2 + ", " + (-p.height / 2 - C + 3) + ")"
  );
  const _ = p.width + (e.padding || 0), $ = p.height + (e.padding || 0), L = -p.width / 2 - C, B = -p.height / 2 - C;
  let q, H;
  if (e.look === "handDrawn") {
    const G = Bt.svg(s), F = Lt(e, {}), W = G.path(
      qi(L, B, _, $, e.rx || 0),
      F
    ), R = G.line(
      -p.width / 2 - C,
      -p.height / 2 - C + g.height + C,
      p.width / 2 + C,
      -p.height / 2 - C + g.height + C,
      F
    );
    H = s.insert(() => (ut.debug("Rough node insert CXC", W), R), ":first-child"), q = s.insert(() => (ut.debug("Rough node insert CXC", W), W), ":first-child");
  } else
    q = o.insert("rect", ":first-child"), H = o.insert("line"), q.attr("class", "outer title-state").attr("style", n).attr("x", -p.width / 2 - C).attr("y", -p.height / 2 - C).attr("width", p.width + (e.padding || 0)).attr("height", p.height + (e.padding || 0)), H.attr("class", "divider").attr("x1", -p.width / 2 - C).attr("x2", p.width / 2 + C).attr("y1", -p.height / 2 - C + g.height + C).attr("y2", -p.height / 2 - C + g.height + C);
  return Ft(e, q), e.intersect = function(G) {
    return Et.rect(e, G);
  }, s;
}
S(I8, "rectWithTitle");
async function O8(t15, e) {
  const r = {
    rx: 5,
    ry: 5,
    labelPaddingX: ((e == null ? void 0 : e.padding) || 0) * 1,
    labelPaddingY: ((e == null ? void 0 : e.padding) || 0) * 1
  };
  return wc(t15, e, r);
}
S(O8, "roundedRect");
async function z8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = (e == null ? void 0 : e.padding) ?? 0, l = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h10 = -s.width / 2 - a, p = -s.height / 2 - a, { cssStyles: m } = e, g = Bt.svg(i), y = Lt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = [
    { x: h10, y: p },
    { x: h10 + l + 8, y: p },
    { x: h10 + l + 8, y: p + c },
    { x: h10 - 8, y: p + c },
    { x: h10 - 8, y: p },
    { x: h10, y: p },
    { x: h10, y: p + c }
  ], k = g.polygon(
    x.map((_) => [_.x, _.y]),
    y
  ), C = i.insert(() => k, ":first-child");
  return C.attr("class", "basic label-container").attr("style", Mr(m)), n && e.look !== "handDrawn" && C.selectAll("path").attr("style", n), m && e.look !== "handDrawn" && C.selectAll("path").attr("style", n), o.attr(
    "transform",
    `translate(${-l / 2 + 4 + (e.padding ?? 0) - (s.x - (s.left ?? 0))},${-c / 2 + (e.padding ?? 0) - (s.y - (s.top ?? 0))})`
  ), Ft(e, C), e.intersect = function(_) {
    return Et.rect(e, _);
  }, i;
}
S(z8, "shadedProcess");
async function q8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = -a / 2, h10 = -l / 2, { cssStyles: p } = e, m = Bt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = [
    { x: c, y: h10 },
    { x: c, y: h10 + l },
    { x: c + a, y: h10 + l },
    { x: c + a, y: h10 - l / 2 }
  ], x = le(y), k = m.path(x, g), C = i.insert(() => k, ":first-child");
  return C.attr("class", "basic label-container"), p && e.look !== "handDrawn" && C.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && C.selectChildren("path").attr("style", n), C.attr("transform", `translate(0, ${l / 4})`), o.attr(
    "transform",
    `translate(${-a / 2 + (e.padding ?? 0) - (s.x - (s.left ?? 0))}, ${-l / 4 + (e.padding ?? 0) - (s.y - (s.top ?? 0))})`
  ), Ft(e, C), e.intersect = function(_) {
    return Et.polygon(e, y, _);
  }, i;
}
S(q8, "slopedRect");
async function R8(t15, e) {
  const r = {
    rx: 0,
    ry: 0,
    labelPaddingX: ((e == null ? void 0 : e.padding) || 0) * 2,
    labelPaddingY: ((e == null ? void 0 : e.padding) || 0) * 1
  };
  return wc(t15, e, r);
}
S(R8, "squareRect");
async function P8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = s.height + e.padding, a = s.width + o / 4 + e.padding;
  let l;
  const { cssStyles: c } = e;
  if (e.look === "handDrawn") {
    const h10 = Bt.svg(i), p = Lt(e, {}), m = qi(-a / 2, -o / 2, a, o, o / 2), g = h10.path(m, p);
    l = i.insert(() => g, ":first-child"), l.attr("class", "basic label-container").attr("style", Mr(c));
  } else
    l = i.insert("rect", ":first-child"), l.attr("class", "basic label-container").attr("style", n).attr("rx", o / 2).attr("ry", o / 2).attr("x", -a / 2).attr("y", -o / 2).attr("width", a).attr("height", o);
  return Ft(e, l), e.intersect = function(h10) {
    return Et.rect(e, h10);
  }, i;
}
S(P8, "stadium");
async function j8(t15, e) {
  return wc(t15, e, {
    rx: 5,
    ry: 5
  });
}
S(j8, "state");
function W8(t15, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = Nt(e);
  e.labelStyle = n;
  const { cssStyles: s } = e, { lineColor: o, stateBorder: a, nodeBorder: l } = r, c = t15.insert("g").attr("class", "node default").attr("id", e.domId || e.id), h10 = Bt.svg(c), p = Lt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const m = h10.circle(0, 0, 14, {
    ...p,
    stroke: o,
    strokeWidth: 2
  }), g = a ?? l, y = h10.circle(0, 0, 5, {
    ...p,
    fill: g,
    stroke: g,
    strokeWidth: 2,
    fillStyle: "solid"
  }), x = c.insert(() => m, ":first-child");
  return x.insert(() => y), s && x.selectAll("path").attr("style", s), i && x.selectAll("path").attr("style", i), Ft(e, x), e.intersect = function(k) {
    return Et.circle(e, 7, k);
  }, c;
}
S(W8, "stateEnd");
function H8(t15, e, { config: { themeVariables: r } }) {
  const { lineColor: n } = r, i = t15.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
  let s;
  if (e.look === "handDrawn") {
    const o = Bt.svg(i).circle(0, 0, 14, Ej(n));
    s = i.insert(() => o), s.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  } else
    s = i.insert("circle", ":first-child"), s.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  return Ft(e, s), e.intersect = function(o) {
    return Et.circle(e, 7, o);
  }, i;
}
S(H8, "stateStart");
async function U8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = ((e == null ? void 0 : e.padding) || 0) / 2, a = s.width + e.padding, l = s.height + e.padding, c = -s.width / 2 - o, h10 = -s.height / 2 - o, p = [
    { x: 0, y: 0 },
    { x: a, y: 0 },
    { x: a, y: -l },
    { x: 0, y: -l },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: a + 8, y: 0 },
    { x: a + 8, y: -l },
    { x: -8, y: -l },
    { x: -8, y: 0 }
  ];
  if (e.look === "handDrawn") {
    const m = Bt.svg(i), g = Lt(e, {}), y = m.rectangle(c - 8, h10, a + 16, l, g), x = m.line(c, h10, c, h10 + l, g), k = m.line(c + a, h10, c + a, h10 + l, g);
    i.insert(() => x, ":first-child"), i.insert(() => k, ":first-child");
    const C = i.insert(() => y, ":first-child"), { cssStyles: _ } = e;
    C.attr("class", "basic label-container").attr("style", Mr(_)), Ft(e, C);
  } else {
    const m = Ri(i, a, l, p);
    n && m.attr("style", n), Ft(e, m);
  }
  return e.intersect = function(m) {
    return Et.polygon(e, p, m);
  }, i;
}
S(U8, "subroutine");
async function V8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), a = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), l = -o / 2, c = -a / 2, h10 = 0.2 * a, p = 0.2 * a, { cssStyles: m } = e, g = Bt.svg(i), y = Lt(e, {}), x = [
    { x: l - h10 / 2, y: c },
    { x: l + o + h10 / 2, y: c },
    { x: l + o + h10 / 2, y: c + a },
    { x: l - h10 / 2, y: c + a }
  ], k = [
    { x: l + o - h10 / 2, y: c + a },
    { x: l + o + h10 / 2, y: c + a },
    { x: l + o + h10 / 2, y: c + a - p }
  ];
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const C = le(x), _ = g.path(C, y), $ = le(k), L = g.path($, { ...y, fillStyle: "solid" }), B = i.insert(() => L, ":first-child");
  return B.insert(() => _, ":first-child"), B.attr("class", "basic label-container"), m && e.look !== "handDrawn" && B.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && B.selectAll("path").attr("style", n), Ft(e, B), e.intersect = function(q) {
    return Et.polygon(e, x, q);
  }, i;
}
S(V8, "taggedRect");
async function G8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = l / 4, h10 = 0.2 * a, p = 0.2 * l, m = l + c, { cssStyles: g } = e, y = Bt.svg(i), x = Lt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const k = [
    { x: -a / 2 - a / 2 * 0.1, y: m / 2 },
    ...fs(
      -a / 2 - a / 2 * 0.1,
      m / 2,
      a / 2 + a / 2 * 0.1,
      m / 2,
      c,
      0.8
    ),
    { x: a / 2 + a / 2 * 0.1, y: -m / 2 },
    { x: -a / 2 - a / 2 * 0.1, y: -m / 2 }
  ], C = -a / 2 + a / 2 * 0.1, _ = -m / 2 - p * 0.4, $ = [
    { x: C + a - h10, y: (_ + l) * 1.4 },
    { x: C + a, y: _ + l - p },
    { x: C + a, y: (_ + l) * 0.9 },
    ...fs(
      C + a,
      (_ + l) * 1.3,
      C + a - h10,
      (_ + l) * 1.5,
      -l * 0.03,
      0.5
    )
  ], L = le(k), B = y.path(L, x), q = le($), H = y.path(q, {
    ...x,
    fillStyle: "solid"
  }), G = i.insert(() => H, ":first-child");
  return G.insert(() => B, ":first-child"), G.attr("class", "basic label-container"), g && e.look !== "handDrawn" && G.selectAll("path").attr("style", g), n && e.look !== "handDrawn" && G.selectAll("path").attr("style", n), G.attr("transform", `translate(0,${-c / 2})`), o.attr(
    "transform",
    `translate(${-a / 2 + (e.padding ?? 0) - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) - c / 2 - (s.y - (s.top ?? 0))})`
  ), Ft(e, G), e.intersect = function(F) {
    return Et.polygon(e, k, F);
  }, i;
}
S(G8, "taggedWaveEdgedRectangle");
async function X8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = Math.max(s.width + e.padding, (e == null ? void 0 : e.width) || 0), a = Math.max(s.height + e.padding, (e == null ? void 0 : e.height) || 0), l = -o / 2, c = -a / 2, h10 = i.insert("rect", ":first-child");
  return h10.attr("class", "text").attr("style", n).attr("rx", 0).attr("ry", 0).attr("x", l).attr("y", c).attr("width", o).attr("height", a), Ft(e, h10), e.intersect = function(p) {
    return Et.rect(e, p);
  }, i;
}
S(X8, "text");
var UK = S((t15, e, r, n, i, s) => `M${t15},${e}
    a${i},${s} 0,0,1 0,${-n}
    l${r},0
    a${i},${s} 0,0,1 0,${n}
    M${r},${-n}
    a${i},${s} 0,0,0 0,${n}
    l${-r},0`, "createCylinderPathD");
var VK = S((t15, e, r, n, i, s) => [
  `M${t15},${e}`,
  `M${t15 + r},${e}`,
  `a${i},${s} 0,0,0 0,${-n}`,
  `l${-r},0`,
  `a${i},${s} 0,0,0 0,${n}`,
  `l${r},0`
].join(" "), "createOuterCylinderPathD");
var GK = S((t15, e, r, n, i, s) => [`M${t15 + r / 2},${-n / 2}`, `a${i},${s} 0,0,0 0,${n}`].join(" "), "createInnerCylinderPathD");
async function Y8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o, halfPadding: a } = await Gt(
    t15,
    e,
    Ht(e)
  ), l = e.look === "neo" ? a * 2 : a, c = s.height + l, h10 = c / 2, p = h10 / (2.5 + c / 50), m = s.width + p + l, { cssStyles: g } = e;
  let y;
  if (e.look === "handDrawn") {
    const x = Bt.svg(i), k = VK(0, 0, m, c, p, h10), C = GK(0, 0, m, c, p, h10), _ = x.path(k, Lt(e, {})), $ = x.path(C, Lt(e, { fill: "none" }));
    y = i.insert(() => $, ":first-child"), y = i.insert(() => _, ":first-child"), y.attr("class", "basic label-container"), g && y.attr("style", g);
  } else {
    const x = UK(0, 0, m, c, p, h10);
    y = i.insert("path", ":first-child").attr("d", x).attr("class", "basic label-container").attr("style", Mr(g)).attr("style", n), y.attr("class", "basic label-container"), g && y.selectAll("path").attr("style", g), n && y.selectAll("path").attr("style", n);
  }
  return y.attr("label-offset-x", p), y.attr("transform", `translate(${-m / 2}, ${c / 2} )`), o.attr(
    "transform",
    `translate(${-(s.width / 2) - p - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`
  ), Ft(e, y), e.intersect = function(x) {
    const k = Et.rect(e, x), C = k.y - (e.y ?? 0);
    if (h10 != 0 && (Math.abs(C) < (e.height ?? 0) / 2 || Math.abs(C) == (e.height ?? 0) / 2 && Math.abs(k.x - (e.x ?? 0)) > (e.width ?? 0) / 2 - p)) {
      let _ = p * p * (1 - C * C / (h10 * h10));
      _ != 0 && (_ = Math.sqrt(Math.abs(_))), _ = p - _, x.x - (e.x ?? 0) > 0 && (_ = -_), k.x += _;
    }
    return k;
  }, i;
}
S(Y8, "tiltedCylinder");
async function K8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = s.width + e.padding, a = s.height + e.padding, l = [
    { x: -3 * a / 6, y: 0 },
    { x: o + 3 * a / 6, y: 0 },
    { x: o, y: -a },
    { x: 0, y: -a }
  ];
  let c;
  const { cssStyles: h10 } = e;
  if (e.look === "handDrawn") {
    const p = Bt.svg(i), m = Lt(e, {}), g = le(l), y = p.path(g, m);
    c = i.insert(() => y, ":first-child").attr("transform", `translate(${-o / 2}, ${a / 2})`), h10 && c.attr("style", h10);
  } else
    c = Ri(i, o, a, l);
  return n && c.attr("style", n), e.width = o, e.height = a, Ft(e, c), e.intersect = function(p) {
    return Et.polygon(e, l, p);
  }, i;
}
S(K8, "trapezoid");
async function Z8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = 60, a = 20, l = Math.max(o, s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(a, s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), { cssStyles: h10 } = e, p = Bt.svg(i), m = Lt(e, {});
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const g = [
    { x: -l / 2 * 0.8, y: -c / 2 },
    { x: l / 2 * 0.8, y: -c / 2 },
    { x: l / 2, y: -c / 2 * 0.6 },
    { x: l / 2, y: c / 2 },
    { x: -l / 2, y: c / 2 },
    { x: -l / 2, y: -c / 2 * 0.6 }
  ], y = le(g), x = p.path(y, m), k = i.insert(() => x, ":first-child");
  return k.attr("class", "basic label-container"), h10 && e.look !== "handDrawn" && k.selectChildren("path").attr("style", h10), n && e.look !== "handDrawn" && k.selectChildren("path").attr("style", n), Ft(e, k), e.intersect = function(C) {
    return Et.polygon(e, g, C);
  }, i;
}
S(Z8, "trapezoidalPentagon");
async function Q8(t15, e) {
  var _a2;
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Qe((_a2 = me().flowchart) == null ? void 0 : _a2.htmlLabels), l = s.width + (e.padding ?? 0), c = l + s.height, h10 = l + s.height, p = [
    { x: 0, y: 0 },
    { x: h10, y: 0 },
    { x: h10 / 2, y: -c }
  ], { cssStyles: m } = e, g = Bt.svg(i), y = Lt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = le(p), k = g.path(x, y), C = i.insert(() => k, ":first-child").attr("transform", `translate(${-c / 2}, ${c / 2})`);
  return m && e.look !== "handDrawn" && C.selectChildren("path").attr("style", m), n && e.look !== "handDrawn" && C.selectChildren("path").attr("style", n), e.width = l, e.height = c, Ft(e, C), o.attr(
    "transform",
    `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${c / 2 - (s.height + (e.padding ?? 0) / (a ? 2 : 1) - (s.y - (s.top ?? 0)))})`
  ), e.intersect = function(_) {
    return ut.info("Triangle intersect", e, p, _), Et.polygon(e, p, _);
  }, i;
}
S(Q8, "triangle");
async function J8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = l / 8, h10 = l + c, { cssStyles: p } = e, m = 70 - a, g = m > 0 ? m / 2 : 0, y = Bt.svg(i), x = Lt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const k = [
    { x: -a / 2 - g, y: h10 / 2 },
    ...fs(
      -a / 2 - g,
      h10 / 2,
      a / 2 + g,
      h10 / 2,
      c,
      0.8
    ),
    { x: a / 2 + g, y: -h10 / 2 },
    { x: -a / 2 - g, y: -h10 / 2 }
  ], C = le(k), _ = y.path(C, x), $ = i.insert(() => _, ":first-child");
  return $.attr("class", "basic label-container"), p && e.look !== "handDrawn" && $.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(0,${-c / 2})`), o.attr(
    "transform",
    `translate(${-a / 2 + (e.padding ?? 0) - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) - c - (s.y - (s.top ?? 0))})`
  ), Ft(e, $), e.intersect = function(L) {
    return Et.polygon(e, k, L);
  }, i;
}
S(J8, "waveEdgedRectangle");
async function t92(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Gt(t15, e, Ht(e)), o = 100, a = 50, l = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h10 = l / c;
  let p = l, m = c;
  p > m * h10 ? m = p / h10 : p = m * h10, p = Math.max(p, o), m = Math.max(m, a);
  const g = Math.min(m * 0.2, m / 4), y = m + g * 2, { cssStyles: x } = e, k = Bt.svg(i), C = Lt(e, {});
  e.look !== "handDrawn" && (C.roughness = 0, C.fillStyle = "solid");
  const _ = [
    { x: -p / 2, y: y / 2 },
    ...fs(-p / 2, y / 2, p / 2, y / 2, g, 1),
    { x: p / 2, y: -y / 2 },
    ...fs(p / 2, -y / 2, -p / 2, -y / 2, g, -1)
  ], $ = le(_), L = k.path($, C), B = i.insert(() => L, ":first-child");
  return B.attr("class", "basic label-container"), x && e.look !== "handDrawn" && B.selectAll("path").attr("style", x), n && e.look !== "handDrawn" && B.selectAll("path").attr("style", n), Ft(e, B), e.intersect = function(q) {
    return Et.polygon(e, _, q);
  }, i;
}
S(t92, "waveRectangle");
async function e9(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: o } = await Gt(t15, e, Ht(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = 5, h10 = -a / 2, p = -l / 2, { cssStyles: m } = e, g = Bt.svg(i), y = Lt(e, {}), x = [
    { x: h10 - c, y: p - c },
    { x: h10 - c, y: p + l },
    { x: h10 + a, y: p + l },
    { x: h10 + a, y: p - c }
  ], k = `M${h10 - c},${p - c} L${h10 + a},${p - c} L${h10 + a},${p + l} L${h10 - c},${p + l} L${h10 - c},${p - c}
                M${h10 - c},${p} L${h10 + a},${p}
                M${h10},${p - c} L${h10},${p + l}`;
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const C = g.path(k, y), _ = i.insert(() => C, ":first-child");
  return _.attr("transform", `translate(${c / 2}, ${c / 2})`), _.attr("class", "basic label-container"), m && e.look !== "handDrawn" && _.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && _.selectAll("path").attr("style", n), o.attr(
    "transform",
    `translate(${-(s.width / 2) + c / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + c / 2 - (s.y - (s.top ?? 0))})`
  ), Ft(e, _), e.intersect = function($) {
    return Et.polygon(e, x, $);
  }, i;
}
S(e9, "windowPane");
async function Ag(t15, e) {
  var _a2, _b2, _c, _d, _e;
  const r = e;
  if (r.alias && (e.label = r.alias), e.look === "handDrawn") {
    const { themeVariables: X } = Vr(), { background: ct } = X, gt = {
      ...e,
      id: e.id + "-background",
      look: "default",
      cssStyles: ["stroke: none", `fill: ${ct}`]
    };
    await Ag(t15, gt);
  }
  const n = Vr();
  e.useHtmlLabels = n.htmlLabels;
  let i = ((_a2 = n.er) == null ? void 0 : _a2.diagramPadding) ?? 10, s = ((_b2 = n.er) == null ? void 0 : _b2.entityPadding) ?? 6;
  const { cssStyles: o } = e, { labelStyles: a, nodeStyles: l } = Nt(e);
  if (r.attributes.length === 0 && e.label) {
    const X = {
      rx: 0,
      ry: 0,
      labelPaddingX: i,
      labelPaddingY: i * 1.5
    };
    Ii(e.label, n) + X.labelPaddingX * 2 < n.er.minEntityWidth && (e.width = n.er.minEntityWidth);
    const ct = await wc(t15, e, X);
    if (!Qe(n.htmlLabels)) {
      const gt = ct.select("text"), xt = (_c = gt.node()) == null ? void 0 : _c.getBBox();
      gt.attr("transform", `translate(${-xt.width / 2}, 0)`);
    }
    return ct;
  }
  n.htmlLabels || (i *= 1.25, s *= 1.25);
  let c = Ht(e);
  c || (c = "node default");
  const h10 = t15.insert("g").attr("class", c).attr("id", e.domId || e.id), p = await Mo(h10, e.label ?? "", n, 0, 0, ["name"], a);
  p.height += s;
  let m = 0;
  const g = [], y = [];
  let x = 0, k = 0, C = 0, _ = 0, $ = true, L = true;
  for (const X of r.attributes) {
    const ct = await Mo(
      h10,
      X.type,
      n,
      0,
      m,
      ["attribute-type"],
      a
    );
    x = Math.max(x, ct.width + i);
    const gt = await Mo(
      h10,
      X.name,
      n,
      0,
      m,
      ["attribute-name"],
      a
    );
    k = Math.max(k, gt.width + i);
    const xt = await Mo(
      h10,
      X.keys.join(),
      n,
      0,
      m,
      ["attribute-keys"],
      a
    );
    C = Math.max(C, xt.width + i);
    const Yt = await Mo(
      h10,
      X.comment,
      n,
      0,
      m,
      ["attribute-comment"],
      a
    );
    _ = Math.max(_, Yt.width + i);
    const U = Math.max(ct.height, gt.height, xt.height, Yt.height) + s;
    y.push({ yOffset: m, rowHeight: U }), m += U;
  }
  let B = 4;
  C <= i && ($ = false, C = 0, B--), _ <= i && (L = false, _ = 0, B--);
  const q = h10.node().getBBox();
  if (p.width + i * 2 - (x + k + C + _) > 0) {
    const X = p.width + i * 2 - (x + k + C + _);
    x += X / B, k += X / B, C > 0 && (C += X / B), _ > 0 && (_ += X / B);
  }
  const H = x + k + C + _, G = Bt.svg(h10), F = Lt(e, {});
  e.look !== "handDrawn" && (F.roughness = 0, F.fillStyle = "solid");
  let W = 0;
  y.length > 0 && (W = y.reduce((X, ct) => X + ((ct == null ? void 0 : ct.rowHeight) ?? 0), 0));
  const R = Math.max(q.width + i * 2, (e == null ? void 0 : e.width) || 0, H), J = Math.max((W ?? 0) + p.height, (e == null ? void 0 : e.height) || 0), rt = -R / 2, I = -J / 2;
  h10.selectAll("g:not(:first-child)").each((X, ct, gt) => {
    const xt = ae(gt[ct]), Yt = xt.attr("transform");
    let U = 0, mt = 0;
    if (Yt) {
      const wt = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(Yt);
      wt && (U = parseFloat(wt[1]), mt = parseFloat(wt[2]), xt.attr("class").includes("attribute-name") ? U += x : xt.attr("class").includes("attribute-keys") ? U += x + k : xt.attr("class").includes("attribute-comment") && (U += x + k + C));
    }
    xt.attr(
      "transform",
      `translate(${rt + i / 2 + U}, ${mt + I + p.height + s / 2})`
    );
  }), h10.select(".name").attr("transform", "translate(" + -p.width / 2 + ", " + (I + s / 2) + ")");
  const j = G.rectangle(rt, I, R, J, F), z = h10.insert(() => j, ":first-child").attr("style", o.join("")), { themeVariables: K } = Vr(), { rowEven: Y, rowOdd: at, nodeBorder: et } = K;
  g.push(0);
  for (const [X, ct] of y.entries()) {
    const gt = (X + 1) % 2 === 0 && ct.yOffset !== 0, xt = G.rectangle(rt, p.height + I + (ct == null ? void 0 : ct.yOffset), R, ct == null ? void 0 : ct.rowHeight, {
      ...F,
      fill: gt ? Y : at,
      stroke: et
    });
    h10.insert(() => xt, "g.label").attr("style", o.join("")).attr("class", `row-rect-${gt ? "even" : "odd"}`);
  }
  let ht = G.line(rt, p.height + I, R + rt, p.height + I, F);
  h10.insert(() => ht).attr("class", "divider"), ht = G.line(x + rt, p.height + I, x + rt, J + I, F), h10.insert(() => ht).attr("class", "divider"), $ && (ht = G.line(
    x + k + rt,
    p.height + I,
    x + k + rt,
    J + I,
    F
  ), h10.insert(() => ht).attr("class", "divider")), L && (ht = G.line(
    x + k + C + rt,
    p.height + I,
    x + k + C + rt,
    J + I,
    F
  ), h10.insert(() => ht).attr("class", "divider"));
  for (const X of g)
    ht = G.line(
      rt,
      p.height + I + X,
      R + rt,
      p.height + I + X,
      F
    ), h10.insert(() => ht).attr("class", "divider");
  if (Ft(e, z), l && e.look !== "handDrawn") {
    const X = (_e = (_d = l.split(";")) == null ? void 0 : _d.filter((ct) => ct.includes("stroke"))) == null ? void 0 : _e.map((ct) => `${ct}`).join("; ");
    h10.selectAll("path").attr("style", X ?? ""), h10.selectAll(".row-rect-even path").attr("style", l);
  }
  return e.intersect = function(X) {
    return Et.rect(e, X);
  }, h10;
}
S(Ag, "erBox");
async function Mo(t15, e, r, n = 0, i = 0, s = [], o = "") {
  const a = t15.insert("g").attr("class", `label ${s.join(" ")}`).attr("transform", `translate(${n}, ${i})`).attr("style", o);
  e !== Vb(e) && (e = Vb(e), e = e.replaceAll("<", "&lt;").replaceAll(">", "&gt;"));
  const l = a.node().appendChild(
    await ys(
      a,
      e,
      {
        width: Ii(e, r) + 100,
        style: o,
        useHtmlLabels: r.htmlLabels
      },
      r
    )
  );
  if (e.includes("&lt;") || e.includes("&gt;")) {
    let h10 = l.children[0];
    for (h10.textContent = h10.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">"); h10.childNodes[0]; )
      h10 = h10.childNodes[0], h10.textContent = h10.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
  }
  let c = l.getBBox();
  if (Qe(r.htmlLabels)) {
    const h10 = l.children[0];
    h10.style.textAlign = "start";
    const p = ae(l);
    c = h10.getBoundingClientRect(), p.attr("width", c.width), p.attr("height", c.height);
  }
  return c;
}
S(Mo, "addText");
async function r9(t15, e, r, n, i = r.class.padding ?? 12) {
  const s = n ? 0 : 3, o = t15.insert("g").attr("class", Ht(e)).attr("id", e.domId || e.id);
  let a = null, l = null, c = null, h10 = null, p = 0, m = 0, g = 0;
  if (a = o.insert("g").attr("class", "annotation-group text"), e.annotations.length > 0) {
    const _ = e.annotations[0];
    await dl(a, { text: `«${_}»` }, 0), p = a.node().getBBox().height;
  }
  l = o.insert("g").attr("class", "label-group text"), await dl(l, e, 0, ["font-weight: bolder"]);
  const y = l.node().getBBox();
  m = y.height, c = o.insert("g").attr("class", "members-group text");
  let x = 0;
  for (const _ of e.members) {
    const $ = await dl(c, _, x, [_.parseClassifier()]);
    x += $ + s;
  }
  g = c.node().getBBox().height, g <= 0 && (g = i / 2), h10 = o.insert("g").attr("class", "methods-group text");
  let k = 0;
  for (const _ of e.methods) {
    const $ = await dl(h10, _, k, [_.parseClassifier()]);
    k += $ + s;
  }
  let C = o.node().getBBox();
  if (a !== null) {
    const _ = a.node().getBBox();
    a.attr("transform", `translate(${-_.width / 2})`);
  }
  return l.attr("transform", `translate(${-y.width / 2}, ${p})`), C = o.node().getBBox(), c.attr(
    "transform",
    `translate(0, ${p + m + i * 2})`
  ), C = o.node().getBBox(), h10.attr(
    "transform",
    `translate(0, ${p + m + (g ? g + i * 4 : i * 2)})`
  ), C = o.node().getBBox(), { shapeSvg: o, bbox: C };
}
S(r9, "textHelper");
async function dl(t15, e, r, n = []) {
  const i = t15.insert("g").attr("class", "label").attr("style", n.join("; ")), s = Vr();
  let o = "useHtmlLabels" in e ? e.useHtmlLabels : Qe(s.htmlLabels) ?? true, a = "";
  "text" in e ? a = e.text : a = e.label, !o && a.startsWith("\\") && (a = a.substring(1)), ta(a) && (o = true);
  const l = await ys(
    i,
    A0(po(a)),
    {
      width: Ii(a, s) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: o
    },
    s
  );
  let c, h10 = 1;
  if (o) {
    const p = l.children[0], m = ae(l);
    h10 = p.innerHTML.split("<br>").length, p.innerHTML.includes("</math>") && (h10 += p.innerHTML.split("<mrow>").length - 1);
    const g = p.getElementsByTagName("img");
    if (g) {
      const y = a.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...g].map(
          (x) => new Promise((k) => {
            function C() {
              var _a2;
              if (x.style.display = "flex", x.style.flexDirection = "column", y) {
                const _ = ((_a2 = s.fontSize) == null ? void 0 : _a2.toString()) ?? window.getComputedStyle(document.body).fontSize, $ = parseInt(_, 10) * 5 + "px";
                x.style.minWidth = $, x.style.maxWidth = $;
              } else
                x.style.width = "100%";
              k(x);
            }
            S(C, "setupImage"), setTimeout(() => {
              x.complete && C();
            }), x.addEventListener("error", C), x.addEventListener("load", C);
          })
        )
      );
    }
    c = p.getBoundingClientRect(), m.attr("width", c.width), m.attr("height", c.height);
  } else {
    n.includes("font-weight: bolder") && ae(l).selectAll("tspan").attr("font-weight", ""), h10 = l.children.length;
    const p = l.children[0];
    (l.textContent === "" || l.textContent.includes("&gt")) && (p.textContent = a[0] + a.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim(), a[1] === " " && (p.textContent = p.textContent[0] + " " + p.textContent.substring(1))), p.textContent === "undefined" && (p.textContent = ""), c = l.getBBox();
  }
  return i.attr("transform", "translate(0," + (-c.height / (2 * h10) + r) + ")"), c.height;
}
S(dl, "addText");
async function n9(t15, e) {
  var _a2, _b2;
  const r = me(), n = r.class.padding ?? 12, i = n, s = e.useHtmlLabels ?? Qe(r.htmlLabels) ?? true, o = e;
  o.annotations = o.annotations ?? [], o.members = o.members ?? [], o.methods = o.methods ?? [];
  const { shapeSvg: a, bbox: l } = await r9(t15, e, r, s, i), { labelStyles: c, nodeStyles: h10 } = Nt(e);
  e.labelStyle = c, e.cssStyles = o.styles || "";
  const p = ((_a2 = o.styles) == null ? void 0 : _a2.join(";")) || h10 || "";
  e.cssStyles || (e.cssStyles = p.replaceAll("!important", "").split(";"));
  const m = o.members.length === 0 && o.methods.length === 0 && !((_b2 = r.class) == null ? void 0 : _b2.hideEmptyMembersBox), g = Bt.svg(a), y = Lt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = l.width;
  let k = l.height;
  o.members.length === 0 && o.methods.length === 0 ? k += i : o.members.length > 0 && o.methods.length === 0 && (k += i * 2);
  const C = -x / 2, _ = -k / 2, $ = g.rectangle(
    C - n,
    _ - n - (m ? n : o.members.length === 0 && o.methods.length === 0 ? -n / 2 : 0),
    x + 2 * n,
    k + 2 * n + (m ? n * 2 : o.members.length === 0 && o.methods.length === 0 ? -n : 0),
    y
  ), L = a.insert(() => $, ":first-child");
  L.attr("class", "basic label-container");
  const B = L.node().getBBox();
  a.selectAll(".text").each((F, W, R) => {
    var _a3;
    const J = ae(R[W]), rt = J.attr("transform");
    let I = 0;
    if (rt) {
      const K = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(rt);
      K && (I = parseFloat(K[2]));
    }
    let j = I + _ + n - (m ? n : o.members.length === 0 && o.methods.length === 0 ? -n / 2 : 0);
    s || (j -= 4);
    let z = C;
    (J.attr("class").includes("label-group") || J.attr("class").includes("annotation-group")) && (z = -((_a3 = J.node()) == null ? void 0 : _a3.getBBox().width) / 2 || 0, a.selectAll("text").each(function(K, Y, at) {
      window.getComputedStyle(at[Y]).textAnchor === "middle" && (z = 0);
    })), J.attr("transform", `translate(${z}, ${j})`);
  });
  const q = a.select(".annotation-group").node().getBBox().height - (m ? n / 2 : 0) || 0, H = a.select(".label-group").node().getBBox().height - (m ? n / 2 : 0) || 0, G = a.select(".members-group").node().getBBox().height - (m ? n / 2 : 0) || 0;
  if (o.members.length > 0 || o.methods.length > 0 || m) {
    const F = g.line(
      B.x,
      q + H + _ + n,
      B.x + B.width,
      q + H + _ + n,
      y
    );
    a.insert(() => F).attr("class", "divider").attr("style", p);
  }
  if (m || o.members.length > 0 || o.methods.length > 0) {
    const F = g.line(
      B.x,
      q + H + G + _ + i * 2 + n,
      B.x + B.width,
      q + H + G + _ + n + i * 2,
      y
    );
    a.insert(() => F).attr("class", "divider").attr("style", p);
  }
  if (o.look !== "handDrawn" && a.selectAll("path").attr("style", p), L.select(":nth-child(2)").attr("style", p), a.selectAll(".divider").select("path").attr("style", p), e.labelStyle ? a.selectAll("span").attr("style", e.labelStyle) : a.selectAll("span").attr("style", p), !s) {
    const F = RegExp(/color\s*:\s*([^;]*)/), W = F.exec(p);
    if (W) {
      const R = W[0].replace("color", "fill");
      a.selectAll("tspan").attr("style", R);
    } else if (c) {
      const R = F.exec(c);
      if (R) {
        const J = R[0].replace("color", "fill");
        a.selectAll("tspan").attr("style", J);
      }
    }
  }
  return Ft(e, L), e.intersect = function(F) {
    return Et.rect(e, F);
  }, a;
}
S(n9, "classBox");
async function i9(t15, e) {
  var _a2, _b2;
  const { labelStyles: r, nodeStyles: n } = Nt(e);
  e.labelStyle = r;
  const i = e, s = e, o = 20, a = 20, l = "verifyMethod" in e, c = Ht(e), h10 = t15.insert("g").attr("class", c).attr("id", e.domId ?? e.id);
  let p;
  l ? p = await jn(
    h10,
    `&lt;&lt;${i.type}&gt;&gt;`,
    0,
    e.labelStyle
  ) : p = await jn(h10, "&lt;&lt;Element&gt;&gt;", 0, e.labelStyle);
  let m = p;
  const g = await jn(
    h10,
    i.name,
    m,
    e.labelStyle + "; font-weight: bold;"
  );
  if (m += g + a, l) {
    const q = await jn(
      h10,
      `${i.requirementId ? `id: ${i.requirementId}` : ""}`,
      m,
      e.labelStyle
    );
    m += q;
    const H = await jn(
      h10,
      `${i.text ? `Text: ${i.text}` : ""}`,
      m,
      e.labelStyle
    );
    m += H;
    const G = await jn(
      h10,
      `${i.risk ? `Risk: ${i.risk}` : ""}`,
      m,
      e.labelStyle
    );
    m += G, await jn(
      h10,
      `${i.verifyMethod ? `Verification: ${i.verifyMethod}` : ""}`,
      m,
      e.labelStyle
    );
  } else {
    const q = await jn(
      h10,
      `${s.type ? `Type: ${s.type}` : ""}`,
      m,
      e.labelStyle
    );
    m += q, await jn(
      h10,
      `${s.docRef ? `Doc Ref: ${s.docRef}` : ""}`,
      m,
      e.labelStyle
    );
  }
  const y = (((_a2 = h10.node()) == null ? void 0 : _a2.getBBox().width) ?? 200) + o, x = (((_b2 = h10.node()) == null ? void 0 : _b2.getBBox().height) ?? 200) + o, k = -y / 2, C = -x / 2, _ = Bt.svg(h10), $ = Lt(e, {});
  e.look !== "handDrawn" && ($.roughness = 0, $.fillStyle = "solid");
  const L = _.rectangle(k, C, y, x, $), B = h10.insert(() => L, ":first-child");
  if (B.attr("class", "basic label-container").attr("style", n), h10.selectAll(".label").each((q, H, G) => {
    const F = ae(G[H]), W = F.attr("transform");
    let R = 0, J = 0;
    if (W) {
      const j = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(W);
      j && (R = parseFloat(j[1]), J = parseFloat(j[2]));
    }
    const rt = J - x / 2;
    let I = k + o / 2;
    (H === 0 || H === 1) && (I = R), F.attr("transform", `translate(${I}, ${rt + o})`);
  }), m > p + g + a) {
    const q = _.line(
      k,
      C + p + g + a,
      k + y,
      C + p + g + a,
      $
    );
    h10.insert(() => q).attr("style", n);
  }
  return Ft(e, B), e.intersect = function(q) {
    return Et.rect(e, q);
  }, h10;
}
S(i9, "requirementBox");
async function jn(t15, e, r, n = "") {
  if (e === "")
    return 0;
  const i = t15.insert("g").attr("class", "label").attr("style", n), s = me(), o = s.htmlLabels ?? true, a = await ys(
    i,
    A0(po(e)),
    {
      width: Ii(e, s) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: o,
      style: n
    },
    s
  );
  let l;
  if (o) {
    const c = a.children[0], h10 = ae(a);
    l = c.getBoundingClientRect(), h10.attr("width", l.width), h10.attr("height", l.height);
  } else {
    const c = a.children[0];
    for (const h10 of c.children)
      h10.textContent = h10.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<"), n && h10.setAttribute("style", n);
    l = a.getBBox(), l.height += 6;
  }
  return i.attr("transform", `translate(${-l.width / 2},${-l.height / 2 + r})`), l.height;
}
S(jn, "addText");
var XK = S((t15) => {
  switch (t15) {
    case "Very High":
      return "red";
    case "High":
      return "orange";
    case "Medium":
      return null;
    case "Low":
      return "blue";
    case "Very Low":
      return "lightblue";
  }
}, "colorFromPriority");
async function s9(t15, e, { config: r }) {
  var _a2, _b2;
  const { labelStyles: n, nodeStyles: i } = Nt(e);
  e.labelStyle = n || "";
  const s = 10, o = e.width;
  e.width = (e.width ?? 200) - 10;
  const {
    shapeSvg: a,
    bbox: l,
    label: c
  } = await Gt(t15, e, Ht(e)), h10 = e.padding || 10;
  let p = "", m;
  "ticket" in e && e.ticket && ((_a2 = r == null ? void 0 : r.kanban) == null ? void 0 : _a2.ticketBaseUrl) && (p = (_b2 = r == null ? void 0 : r.kanban) == null ? void 0 : _b2.ticketBaseUrl.replace("#TICKET#", e.ticket), m = a.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", p).attr("target", "_blank"));
  const g = {
    useHtmlLabels: e.useHtmlLabels,
    labelStyle: e.labelStyle || "",
    width: e.width,
    img: e.img,
    padding: e.padding || 8,
    centerLabel: false
  };
  let y, x;
  m ? { label: y, bbox: x } = await qp(
    m,
    "ticket" in e && e.ticket || "",
    g
  ) : { label: y, bbox: x } = await qp(
    a,
    "ticket" in e && e.ticket || "",
    g
  );
  const { label: k, bbox: C } = await qp(
    a,
    "assigned" in e && e.assigned || "",
    g
  );
  e.width = o;
  const _ = 10, $ = (e == null ? void 0 : e.width) || 0, L = Math.max(x.height, C.height) / 2, B = Math.max(l.height + _ * 2, (e == null ? void 0 : e.height) || 0) + L, q = -$ / 2, H = -B / 2;
  c.attr(
    "transform",
    "translate(" + (h10 - $ / 2) + ", " + (-L - l.height / 2) + ")"
  ), y.attr(
    "transform",
    "translate(" + (h10 - $ / 2) + ", " + (-L + l.height / 2) + ")"
  ), k.attr(
    "transform",
    "translate(" + (h10 + $ / 2 - C.width - 2 * s) + ", " + (-L + l.height / 2) + ")"
  );
  let G;
  const { rx: F, ry: W } = e, { cssStyles: R } = e;
  if (e.look === "handDrawn") {
    const J = Bt.svg(a), rt = Lt(e, {}), I = F || W ? J.path(qi(q, H, $, B, F || 0), rt) : J.rectangle(q, H, $, B, rt);
    G = a.insert(() => I, ":first-child"), G.attr("class", "basic label-container").attr("style", R || null);
  } else {
    G = a.insert("rect", ":first-child"), G.attr("class", "basic label-container __APA__").attr("style", i).attr("rx", F ?? 5).attr("ry", W ?? 5).attr("x", q).attr("y", H).attr("width", $).attr("height", B);
    const J = "priority" in e && e.priority;
    if (J) {
      const rt = a.append("line"), I = q + 2, j = H + Math.floor((F ?? 0) / 2), z = H + B - Math.floor((F ?? 0) / 2);
      rt.attr("x1", I).attr("y1", j).attr("x2", I).attr("y2", z).attr("stroke-width", "4").attr("stroke", XK(J));
    }
  }
  return Ft(e, G), e.height = B, e.intersect = function(J) {
    return Et.rect(e, J);
  }, a;
}
S(s9, "kanbanItem");
var YK = [
  {
    semanticName: "Process",
    name: "Rectangle",
    shortName: "rect",
    description: "Standard process shape",
    aliases: ["proc", "process", "rectangle"],
    internalAliases: ["squareRect"],
    handler: R8
  },
  {
    semanticName: "Event",
    name: "Rounded Rectangle",
    shortName: "rounded",
    description: "Represents an event",
    aliases: ["event"],
    internalAliases: ["roundedRect"],
    handler: O8
  },
  {
    semanticName: "Terminal Point",
    name: "Stadium",
    shortName: "stadium",
    description: "Terminal point",
    aliases: ["terminal", "pill"],
    handler: P8
  },
  {
    semanticName: "Subprocess",
    name: "Framed Rectangle",
    shortName: "fr-rect",
    description: "Subprocess",
    aliases: ["subprocess", "subproc", "framed-rectangle", "subroutine"],
    handler: U8
  },
  {
    semanticName: "Database",
    name: "Cylinder",
    shortName: "cyl",
    description: "Database storage",
    aliases: ["db", "database", "cylinder"],
    handler: h8
  },
  {
    semanticName: "Start",
    name: "Circle",
    shortName: "circle",
    description: "Starting point",
    aliases: ["circ"],
    handler: n8
  },
  {
    semanticName: "Decision",
    name: "Diamond",
    shortName: "diam",
    description: "Decision-making step",
    aliases: ["decision", "diamond", "question"],
    handler: F8
  },
  {
    semanticName: "Prepare Conditional",
    name: "Hexagon",
    shortName: "hex",
    description: "Preparation or condition step",
    aliases: ["hexagon", "prepare"],
    handler: y8
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Right",
    shortName: "lean-r",
    description: "Represents input or output",
    aliases: ["lean-right", "in-out"],
    internalAliases: ["lean_right"],
    handler: A8
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Left",
    shortName: "lean-l",
    description: "Represents output or input",
    aliases: ["lean-left", "out-in"],
    internalAliases: ["lean_left"],
    handler: T8
  },
  {
    semanticName: "Priority Action",
    name: "Trapezoid Base Bottom",
    shortName: "trap-b",
    description: "Priority action",
    aliases: ["priority", "trapezoid-bottom", "trapezoid"],
    handler: K8
  },
  {
    semanticName: "Manual Operation",
    name: "Trapezoid Base Top",
    shortName: "trap-t",
    description: "Represents a manual task",
    aliases: ["manual", "trapezoid-top", "inv-trapezoid"],
    internalAliases: ["inv_trapezoid"],
    handler: C8
  },
  {
    semanticName: "Stop",
    name: "Double Circle",
    shortName: "dbl-circ",
    description: "Represents a stop point",
    aliases: ["double-circle"],
    internalAliases: ["doublecircle"],
    handler: d8
  },
  {
    semanticName: "Text Block",
    name: "Text Block",
    shortName: "text",
    description: "Text block",
    handler: X8
  },
  {
    semanticName: "Card",
    name: "Notched Rectangle",
    shortName: "notch-rect",
    description: "Represents a card",
    aliases: ["card", "notched-rectangle"],
    handler: e8
  },
  {
    semanticName: "Lined/Shaded Process",
    name: "Lined Rectangle",
    shortName: "lin-rect",
    description: "Lined process shape",
    aliases: ["lined-rectangle", "lined-process", "lin-proc", "shaded-process"],
    handler: z8
  },
  {
    semanticName: "Start",
    name: "Small Circle",
    shortName: "sm-circ",
    description: "Small starting point",
    aliases: ["start", "small-circle"],
    internalAliases: ["stateStart"],
    handler: H8
  },
  {
    semanticName: "Stop",
    name: "Framed Circle",
    shortName: "fr-circ",
    description: "Stop point",
    aliases: ["stop", "framed-circle"],
    internalAliases: ["stateEnd"],
    handler: W8
  },
  {
    semanticName: "Fork/Join",
    name: "Filled Rectangle",
    shortName: "fork",
    description: "Fork or join in process flow",
    aliases: ["join"],
    internalAliases: ["forkJoin"],
    handler: m8
  },
  {
    semanticName: "Collate",
    name: "Hourglass",
    shortName: "hourglass",
    description: "Represents a collate operation",
    aliases: ["hourglass", "collate"],
    handler: b8
  },
  {
    semanticName: "Comment",
    name: "Curly Brace",
    shortName: "brace",
    description: "Adds a comment",
    aliases: ["comment", "brace-l"],
    handler: o8
  },
  {
    semanticName: "Comment Right",
    name: "Curly Brace",
    shortName: "brace-r",
    description: "Adds a comment",
    handler: a8
  },
  {
    semanticName: "Comment with braces on both sides",
    name: "Curly Braces",
    shortName: "braces",
    description: "Adds a comment",
    handler: l8
  },
  {
    semanticName: "Com Link",
    name: "Lightning Bolt",
    shortName: "bolt",
    description: "Communication link",
    aliases: ["com-link", "lightning-bolt"],
    handler: $8
  },
  {
    semanticName: "Document",
    name: "Document",
    shortName: "doc",
    description: "Represents a document",
    aliases: ["doc", "document"],
    handler: J8
  },
  {
    semanticName: "Delay",
    name: "Half-Rounded Rectangle",
    shortName: "delay",
    description: "Represents a delay",
    aliases: ["half-rounded-rectangle"],
    handler: g8
  },
  {
    semanticName: "Direct Access Storage",
    name: "Horizontal Cylinder",
    shortName: "h-cyl",
    description: "Direct access storage",
    aliases: ["das", "horizontal-cylinder"],
    handler: Y8
  },
  {
    semanticName: "Disk Storage",
    name: "Lined Cylinder",
    shortName: "lin-cyl",
    description: "Disk storage",
    aliases: ["disk", "lined-cylinder"],
    handler: E8
  },
  {
    semanticName: "Display",
    name: "Curved Trapezoid",
    shortName: "curv-trap",
    description: "Represents a display",
    aliases: ["curved-trapezoid", "display"],
    handler: c8
  },
  {
    semanticName: "Divided Process",
    name: "Divided Rectangle",
    shortName: "div-rect",
    description: "Divided process shape",
    aliases: ["div-proc", "divided-rectangle", "divided-process"],
    handler: u8
  },
  {
    semanticName: "Extract",
    name: "Triangle",
    shortName: "tri",
    description: "Extraction process",
    aliases: ["extract", "triangle"],
    handler: Q8
  },
  {
    semanticName: "Internal Storage",
    name: "Window Pane",
    shortName: "win-pane",
    description: "Internal storage",
    aliases: ["internal-storage", "window-pane"],
    handler: e9
  },
  {
    semanticName: "Junction",
    name: "Filled Circle",
    shortName: "f-circ",
    description: "Junction point",
    aliases: ["junction", "filled-circle"],
    handler: p8
  },
  {
    semanticName: "Loop Limit",
    name: "Trapezoidal Pentagon",
    shortName: "notch-pent",
    description: "Loop limit step",
    aliases: ["loop-limit", "notched-pentagon"],
    handler: Z8
  },
  {
    semanticName: "Manual File",
    name: "Flipped Triangle",
    shortName: "flip-tri",
    description: "Manual file operation",
    aliases: ["manual-file", "flipped-triangle"],
    handler: f8
  },
  {
    semanticName: "Manual Input",
    name: "Sloped Rectangle",
    shortName: "sl-rect",
    description: "Manual input step",
    aliases: ["manual-input", "sloped-rectangle"],
    handler: q8
  },
  {
    semanticName: "Multi-Document",
    name: "Stacked Document",
    shortName: "docs",
    description: "Multiple documents",
    aliases: ["documents", "st-doc", "stacked-document"],
    handler: L8
  },
  {
    semanticName: "Multi-Process",
    name: "Stacked Rectangle",
    shortName: "st-rect",
    description: "Multiple processes",
    aliases: ["procs", "processes", "stacked-rectangle"],
    handler: B8
  },
  {
    semanticName: "Stored Data",
    name: "Bow Tie Rectangle",
    shortName: "bow-rect",
    description: "Stored data",
    aliases: ["stored-data", "bow-tie-rectangle"],
    handler: t82
  },
  {
    semanticName: "Summary",
    name: "Crossed Circle",
    shortName: "cross-circ",
    description: "Summary",
    aliases: ["summary", "crossed-circle"],
    handler: s8
  },
  {
    semanticName: "Tagged Document",
    name: "Tagged Document",
    shortName: "tag-doc",
    description: "Tagged document",
    aliases: ["tag-doc", "tagged-document"],
    handler: G8
  },
  {
    semanticName: "Tagged Process",
    name: "Tagged Rectangle",
    shortName: "tag-rect",
    description: "Tagged process",
    aliases: ["tagged-rectangle", "tag-proc", "tagged-process"],
    handler: V8
  },
  {
    semanticName: "Paper Tape",
    name: "Flag",
    shortName: "flag",
    description: "Paper tape",
    aliases: ["paper-tape"],
    handler: t92
  },
  {
    semanticName: "Odd",
    name: "Odd",
    shortName: "odd",
    description: "Odd shape",
    internalAliases: ["rect_left_inv_arrow"],
    handler: N8
  },
  {
    semanticName: "Lined Document",
    name: "Lined Document",
    shortName: "lin-doc",
    description: "Lined document",
    aliases: ["lined-document"],
    handler: M8
  }
];
var KK = S(() => {
  const t15 = [
    ...Object.entries({
      // States
      state: j8,
      choice: r8,
      note: D8,
      // Rectangles
      rectWithTitle: I8,
      labelRect: S8,
      // Icons
      iconSquare: v8,
      iconCircle: w8,
      icon: x8,
      iconRounded: k8,
      imageSquare: _8,
      anchor: Jv,
      // Kanban diagram
      kanbanItem: s9,
      // class diagram
      classBox: n9,
      // er diagram
      erBox: Ag,
      // Requirement diagram
      requirementBox: i9
    }),
    ...YK.flatMap((e) => [
      e.shortName,
      ..."aliases" in e ? e.aliases : [],
      ..."internalAliases" in e ? e.internalAliases : []
    ].map((r) => [r, e.handler]))
  ];
  return Object.fromEntries(t15);
}, "generateShapeMap");
var o9 = KK();
function ZK(t15) {
  return t15 in o9;
}
S(ZK, "isValidShape");
var V0 = /* @__PURE__ */ new Map();
async function a9(t15, e, r) {
  let n, i;
  e.shape === "rect" && (e.rx && e.ry ? e.shape = "roundedRect" : e.shape = "squareRect");
  const s = e.shape ? o9[e.shape] : void 0;
  if (!s)
    throw new Error(`No such shape: ${e.shape}. Please check your syntax.`);
  if (e.link) {
    let o;
    r.config.securityLevel === "sandbox" ? o = "_top" : e.linkTarget && (o = e.linkTarget || "_blank"), n = t15.insert("svg:a").attr("xlink:href", e.link).attr("target", o ?? null), i = await s(n, e, r);
  } else
    i = await s(t15, e, r), n = i;
  return e.tooltip && i.attr("title", e.tooltip), V0.set(e.id, n), e.haveCallback && n.attr("class", n.attr("class") + " clickable"), n;
}
S(a9, "insertNode");
var bnt = S((t15, e) => {
  V0.set(e.id, t15);
}, "setNodeElem");
var xnt = S(() => {
  V0.clear();
}, "clear");
var wnt = S((t15) => {
  const e = V0.get(t15.id);
  ut.trace(
    "Transforming node",
    t15.diff,
    t15,
    "translate(" + (t15.x - t15.width / 2 - 5) + ", " + t15.width / 2 + ")"
  );
  const r = 8, n = t15.diff || 0;
  return t15.clusterNode ? e.attr(
    "transform",
    "translate(" + (t15.x + n - t15.width / 2) + ", " + (t15.y - t15.height / 2 - r) + ")"
  ) : e.attr("transform", "translate(" + t15.x + ", " + t15.y + ")"), n;
}, "positionNode");
var QK = S((t15, e, r, n, i, s) => {
  e.arrowTypeStart && Q4(t15, "start", e.arrowTypeStart, r, n, i, s), e.arrowTypeEnd && Q4(t15, "end", e.arrowTypeEnd, r, n, i, s);
}, "addEdgeMarkers");
var JK = {
  arrow_cross: { type: "cross", fill: false },
  arrow_point: { type: "point", fill: true },
  arrow_barb: { type: "barb", fill: true },
  arrow_circle: { type: "circle", fill: false },
  aggregation: { type: "aggregation", fill: false },
  extension: { type: "extension", fill: false },
  composition: { type: "composition", fill: true },
  dependency: { type: "dependency", fill: true },
  lollipop: { type: "lollipop", fill: false },
  only_one: { type: "onlyOne", fill: false },
  zero_or_one: { type: "zeroOrOne", fill: false },
  one_or_more: { type: "oneOrMore", fill: false },
  zero_or_more: { type: "zeroOrMore", fill: false },
  requirement_arrow: { type: "requirement_arrow", fill: false },
  requirement_contains: { type: "requirement_contains", fill: false }
};
var Q4 = S((t15, e, r, n, i, s, o) => {
  var _a2;
  const a = JK[r];
  if (!a) {
    ut.warn(`Unknown arrow type: ${r}`);
    return;
  }
  const l = a.type, c = `${i}_${s}-${l}${e === "start" ? "Start" : "End"}`;
  if (o && o.trim() !== "") {
    const h10 = o.replace(/[^\dA-Za-z]/g, "_"), p = `${c}_${h10}`;
    if (!document.getElementById(p)) {
      const m = document.getElementById(c);
      if (m) {
        const g = m.cloneNode(true);
        g.id = p, g.querySelectorAll("path, circle, line").forEach((y) => {
          y.setAttribute("stroke", o), a.fill && y.setAttribute("fill", o);
        }), (_a2 = m.parentNode) == null ? void 0 : _a2.appendChild(g);
      }
    }
    t15.attr(`marker-${e}`, `url(${n}#${p})`);
  } else
    t15.attr(`marker-${e}`, `url(${n}#${c})`);
}, "addEdgeMarker");
var Xu = /* @__PURE__ */ new Map();
var dr = /* @__PURE__ */ new Map();
var knt = S(() => {
  Xu.clear(), dr.clear();
}, "clear");
var Za = S((t15) => t15 ? t15.reduce((e, r) => e + ";" + r, "") : "", "getLabelStyles");
var tZ = S(async (t15, e) => {
  let r = Qe(me().flowchart.htmlLabels);
  const n = await ys(t15, e.label, {
    style: Za(e.labelStyle),
    useHtmlLabels: r,
    addSvgBackground: true,
    isNode: false
  });
  ut.info("abc82", e, e.labelType);
  const i = t15.insert("g").attr("class", "edgeLabel"), s = i.insert("g").attr("class", "label");
  s.node().appendChild(n);
  let o = n.getBBox();
  if (r) {
    const l = n.children[0], c = ae(n);
    o = l.getBoundingClientRect(), c.attr("width", o.width), c.attr("height", o.height);
  }
  s.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")"), Xu.set(e.id, i), e.width = o.width, e.height = o.height;
  let a;
  if (e.startLabelLeft) {
    const l = await Us(
      e.startLabelLeft,
      Za(e.labelStyle)
    ), c = t15.insert("g").attr("class", "edgeTerminals"), h10 = c.insert("g").attr("class", "inner");
    a = h10.node().appendChild(l);
    const p = l.getBBox();
    h10.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), dr.get(e.id) || dr.set(e.id, {}), dr.get(e.id).startLeft = c, pl(a, e.startLabelLeft);
  }
  if (e.startLabelRight) {
    const l = await Us(
      e.startLabelRight,
      Za(e.labelStyle)
    ), c = t15.insert("g").attr("class", "edgeTerminals"), h10 = c.insert("g").attr("class", "inner");
    a = c.node().appendChild(l), h10.node().appendChild(l);
    const p = l.getBBox();
    h10.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), dr.get(e.id) || dr.set(e.id, {}), dr.get(e.id).startRight = c, pl(a, e.startLabelRight);
  }
  if (e.endLabelLeft) {
    const l = await Us(e.endLabelLeft, Za(e.labelStyle)), c = t15.insert("g").attr("class", "edgeTerminals"), h10 = c.insert("g").attr("class", "inner");
    a = h10.node().appendChild(l);
    const p = l.getBBox();
    h10.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), c.node().appendChild(l), dr.get(e.id) || dr.set(e.id, {}), dr.get(e.id).endLeft = c, pl(a, e.endLabelLeft);
  }
  if (e.endLabelRight) {
    const l = await Us(e.endLabelRight, Za(e.labelStyle)), c = t15.insert("g").attr("class", "edgeTerminals"), h10 = c.insert("g").attr("class", "inner");
    a = h10.node().appendChild(l);
    const p = l.getBBox();
    h10.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), c.node().appendChild(l), dr.get(e.id) || dr.set(e.id, {}), dr.get(e.id).endRight = c, pl(a, e.endLabelRight);
  }
  return n;
}, "insertEdgeLabel");
function pl(t15, e) {
  me().flowchart.htmlLabels && t15 && (t15.style.width = e.length * 9 + "px", t15.style.height = "12px");
}
S(pl, "setTerminalWidth");
var eZ = S((t15, e) => {
  ut.debug("Moving label abc88 ", t15.id, t15.label, Xu.get(t15.id), e);
  let r = e.updatedPath ? e.updatedPath : e.originalPath;
  const n = me(), { subGraphTitleTotalMargin: i } = Um(n);
  if (t15.label) {
    const s = Xu.get(t15.id);
    let o = t15.x, a = t15.y;
    if (r) {
      const l = Xn.calcLabelPosition(r);
      ut.debug(
        "Moving label " + t15.label + " from (",
        o,
        ",",
        a,
        ") to (",
        l.x,
        ",",
        l.y,
        ") abc88"
      ), e.updatedPath && (o = l.x, a = l.y);
    }
    s.attr("transform", `translate(${o}, ${a + i / 2})`);
  }
  if (t15.startLabelLeft) {
    const s = dr.get(t15.id).startLeft;
    let o = t15.x, a = t15.y;
    if (r) {
      const l = Xn.calcTerminalLabelPosition(t15.arrowTypeStart ? 10 : 0, "start_left", r);
      o = l.x, a = l.y;
    }
    s.attr("transform", `translate(${o}, ${a})`);
  }
  if (t15.startLabelRight) {
    const s = dr.get(t15.id).startRight;
    let o = t15.x, a = t15.y;
    if (r) {
      const l = Xn.calcTerminalLabelPosition(
        t15.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      o = l.x, a = l.y;
    }
    s.attr("transform", `translate(${o}, ${a})`);
  }
  if (t15.endLabelLeft) {
    const s = dr.get(t15.id).endLeft;
    let o = t15.x, a = t15.y;
    if (r) {
      const l = Xn.calcTerminalLabelPosition(t15.arrowTypeEnd ? 10 : 0, "end_left", r);
      o = l.x, a = l.y;
    }
    s.attr("transform", `translate(${o}, ${a})`);
  }
  if (t15.endLabelRight) {
    const s = dr.get(t15.id).endRight;
    let o = t15.x, a = t15.y;
    if (r) {
      const l = Xn.calcTerminalLabelPosition(t15.arrowTypeEnd ? 10 : 0, "end_right", r);
      o = l.x, a = l.y;
    }
    s.attr("transform", `translate(${o}, ${a})`);
  }
}, "positionEdgeLabel");
var rZ = S((t15, e) => {
  const r = t15.x, n = t15.y, i = Math.abs(e.x - r), s = Math.abs(e.y - n), o = t15.width / 2, a = t15.height / 2;
  return i >= o || s >= a;
}, "outsideNode");
var nZ = S((t15, e, r) => {
  ut.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(e)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${t15.x} y:${t15.y} w:${t15.width} h:${t15.height}`);
  const n = t15.x, i = t15.y, s = Math.abs(n - r.x), o = t15.width / 2;
  let a = r.x < e.x ? o - s : o + s;
  const l = t15.height / 2, c = Math.abs(e.y - r.y), h10 = Math.abs(e.x - r.x);
  if (Math.abs(i - e.y) * o > Math.abs(n - e.x) * l) {
    let p = r.y < e.y ? e.y - l - i : i - l - e.y;
    a = h10 * p / c;
    const m = {
      x: r.x < e.x ? r.x + a : r.x - h10 + a,
      y: r.y < e.y ? r.y + c - p : r.y - c + p
    };
    return a === 0 && (m.x = e.x, m.y = e.y), h10 === 0 && (m.x = e.x), c === 0 && (m.y = e.y), ut.debug(`abc89 top/bottom calc, Q ${c}, q ${p}, R ${h10}, r ${a}`, m), m;
  } else {
    r.x < e.x ? a = e.x - o - n : a = n - o - e.x;
    let p = c * a / h10, m = r.x < e.x ? r.x + h10 - a : r.x - h10 + a, g = r.y < e.y ? r.y + p : r.y - p;
    return ut.debug(`sides calc abc89, Q ${c}, q ${p}, R ${h10}, r ${a}`, { _x: m, _y: g }), a === 0 && (m = e.x, g = e.y), h10 === 0 && (m = e.x), c === 0 && (g = e.y), { x: m, y: g };
  }
}, "intersection");
var J4 = S((t15, e) => {
  ut.warn("abc88 cutPathAtIntersect", t15, e);
  let r = [], n = t15[0], i = false;
  return t15.forEach((s) => {
    if (ut.info("abc88 checking point", s, e), !rZ(e, s) && !i) {
      const o = nZ(e, n, s);
      ut.debug("abc88 inside", s, n, o), ut.debug("abc88 intersection", o, e);
      let a = false;
      r.forEach((l) => {
        a = a || l.x === o.x && l.y === o.y;
      }), r.some((l) => l.x === o.x && l.y === o.y) ? ut.warn("abc88 no intersect", o, r) : r.push(o), i = true;
    } else
      ut.warn("abc88 outside", s, n), n = s, i || r.push(s);
  }), ut.debug("returning points", r), r;
}, "cutPathAtIntersect");
function l9(t15) {
  const e = [], r = [];
  for (let n = 1; n < t15.length - 1; n++) {
    const i = t15[n - 1], s = t15[n], o = t15[n + 1];
    (i.x === s.x && s.y === o.y && Math.abs(s.x - o.x) > 5 && Math.abs(s.y - i.y) > 5 || i.y === s.y && s.x === o.x && Math.abs(s.x - i.x) > 5 && Math.abs(s.y - o.y) > 5) && (e.push(s), r.push(n));
  }
  return { cornerPoints: e, cornerPointPositions: r };
}
S(l9, "extractCornerPoints");
var t52 = S(function(t15, e, r) {
  const n = e.x - t15.x, i = e.y - t15.y, s = Math.sqrt(n * n + i * i), o = r / s;
  return { x: e.x - o * n, y: e.y - o * i };
}, "findAdjacentPoint");
var iZ = S(function(t15) {
  const { cornerPointPositions: e } = l9(t15), r = [];
  for (let n = 0; n < t15.length; n++)
    if (e.includes(n)) {
      const i = t15[n - 1], s = t15[n + 1], o = t15[n], a = t52(i, o, 5), l = t52(s, o, 5), c = l.x - a.x, h10 = l.y - a.y;
      r.push(a);
      const p = Math.sqrt(2) * 2;
      let m = { x: o.x, y: o.y };
      if (Math.abs(s.x - i.x) > 10 && Math.abs(s.y - i.y) >= 10) {
        ut.debug(
          "Corner point fixing",
          Math.abs(s.x - i.x),
          Math.abs(s.y - i.y)
        );
        const g = 5;
        o.x === a.x ? m = {
          x: c < 0 ? a.x - g + p : a.x + g - p,
          y: h10 < 0 ? a.y - p : a.y + p
        } : m = {
          x: c < 0 ? a.x - p : a.x + p,
          y: h10 < 0 ? a.y - g + p : a.y + g - p
        };
      } else
        ut.debug(
          "Corner point skipping fixing",
          Math.abs(s.x - i.x),
          Math.abs(s.y - i.y)
        );
      r.push(m, l);
    } else
      r.push(t15[n]);
  return r;
}, "fixCorners");
var sZ = S(function(t15, e, r, n, i, s, o) {
  var _a2;
  const { handDrawnSeed: a } = me();
  let l = e.points, c = false;
  const h10 = i;
  var p = s;
  const m = [];
  for (const F in e.cssCompiledStyles)
    G7(F) || m.push(e.cssCompiledStyles[F]);
  p.intersect && h10.intersect && (l = l.slice(1, e.points.length - 1), l.unshift(h10.intersect(l[0])), ut.debug(
    "Last point APA12",
    e.start,
    "-->",
    e.end,
    l[l.length - 1],
    p,
    p.intersect(l[l.length - 1])
  ), l.push(p.intersect(l[l.length - 1]))), e.toCluster && (ut.info("to cluster abc88", r.get(e.toCluster)), l = J4(e.points, r.get(e.toCluster).node), c = true), e.fromCluster && (ut.debug(
    "from cluster abc88",
    r.get(e.fromCluster),
    JSON.stringify(l, null, 2)
  ), l = J4(l.reverse(), r.get(e.fromCluster).node).reverse(), c = true);
  let g = l.filter((F) => !Number.isNaN(F.y));
  g = iZ(g);
  let y = zh;
  switch (y = Bu, e.curve) {
    case "linear":
      y = Bu;
      break;
    case "basis":
      y = zh;
      break;
    case "cardinal":
      y = Ek;
      break;
    case "bumpX":
      y = Ck;
      break;
    case "bumpY":
      y = Sk;
      break;
    case "catmullRom":
      y = Bk;
      break;
    case "monotoneX":
      y = Ok;
      break;
    case "monotoneY":
      y = zk;
      break;
    case "natural":
      y = Rk;
      break;
    case "step":
      y = Pk;
      break;
    case "stepAfter":
      y = Wk;
      break;
    case "stepBefore":
      y = jk;
      break;
    default:
      y = zh;
  }
  const { x, y: k } = $j(e), C = eV().x(x).y(k).curve(y);
  let _;
  switch (e.thickness) {
    case "normal":
      _ = "edge-thickness-normal";
      break;
    case "thick":
      _ = "edge-thickness-thick";
      break;
    case "invisible":
      _ = "edge-thickness-invisible";
      break;
    default:
      _ = "edge-thickness-normal";
  }
  switch (e.pattern) {
    case "solid":
      _ += " edge-pattern-solid";
      break;
    case "dotted":
      _ += " edge-pattern-dotted";
      break;
    case "dashed":
      _ += " edge-pattern-dashed";
      break;
    default:
      _ += " edge-pattern-solid";
  }
  let $, L = C(g);
  const B = Array.isArray(e.style) ? e.style : e.style ? [e.style] : [];
  let q = B.find((F) => F == null ? void 0 : F.startsWith("stroke:"));
  if (e.look === "handDrawn") {
    const F = Bt.svg(t15);
    Object.assign([], g);
    const W = F.path(L, {
      roughness: 0.3,
      seed: a
    });
    _ += " transition", $ = ae(W).select("path").attr("id", e.id).attr("class", " " + _ + (e.classes ? " " + e.classes : "")).attr("style", B ? B.reduce((J, rt) => J + ";" + rt, "") : "");
    let R = $.attr("d");
    $.attr("d", R), t15.node().appendChild($.node());
  } else {
    const F = m.join(";"), W = B ? B.reduce((rt, I) => rt + I + ";", "") : "";
    let R = "";
    e.animate && (R = " edge-animation-fast"), e.animation && (R = " edge-animation-" + e.animation);
    const J = F ? F + ";" + W + ";" : W;
    $ = t15.append("path").attr("d", L).attr("id", e.id).attr(
      "class",
      " " + _ + (e.classes ? " " + e.classes : "") + (R ?? "")
    ).attr("style", J), q = (_a2 = J.match(/stroke:([^;]+)/)) == null ? void 0 : _a2[1];
  }
  let H = "";
  (me().flowchart.arrowMarkerAbsolute || me().state.arrowMarkerAbsolute) && (H = cw(true)), ut.info("arrowTypeStart", e.arrowTypeStart), ut.info("arrowTypeEnd", e.arrowTypeEnd), QK($, e, H, o, n, q);
  let G = {};
  return c && (G.updatedPath = l), G.originalPath = e.points, G;
}, "insertEdge");
var oZ = S((t15, e, r, n) => {
  e.forEach((i) => {
    vZ[i](t15, r, n);
  });
}, "insertMarkers");
var aZ = S((t15, e, r) => {
  ut.trace("Making markers for ", r), t15.append("defs").append("marker").attr("id", r + "_" + e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension");
var lZ = S((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition");
var cZ = S((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation");
var hZ = S((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency");
var uZ = S((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), t15.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopEnd").attr("class", "marker lollipop " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop");
var dZ = S((t15, e, r) => {
  t15.append("marker").attr("id", r + "_" + e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t15.append("marker").attr("id", r + "_" + e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point");
var pZ = S((t15, e, r) => {
  t15.append("marker").attr("id", r + "_" + e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t15.append("marker").attr("id", r + "_" + e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle");
var fZ = S((t15, e, r) => {
  t15.append("marker").attr("id", r + "_" + e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t15.append("marker").attr("id", r + "_" + e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross");
var mZ = S((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb");
var gZ = S((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-onlyOneStart").attr("class", "marker onlyOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-onlyOneEnd").attr("class", "marker onlyOne " + e).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18");
}, "only_one");
var yZ = S((t15, e, r) => {
  const n = t15.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  n.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), n.append("path").attr("d", "M9,0 L9,18");
  const i = t15.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + e).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), i.append("path").attr("d", "M21,0 L21,18");
}, "zero_or_one");
var bZ = S((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-oneOrMoreStart").attr("class", "marker oneOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + e).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
}, "one_or_more");
var xZ = S((t15, e, r) => {
  const n = t15.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  n.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), n.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
  const i = t15.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + e).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), i.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
}, "zero_or_more");
var wZ = S((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L20,10
      M20,10
      L0,20`
  );
}, "requirement_arrow");
var kZ = S((t15, e, r) => {
  const n = t15.append("defs").append("marker").attr("id", r + "_" + e + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
  n.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none"), n.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10), n.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10);
}, "requirement_contains");
var vZ = {
  extension: aZ,
  composition: lZ,
  aggregation: cZ,
  dependency: hZ,
  lollipop: uZ,
  point: dZ,
  circle: pZ,
  cross: fZ,
  barb: mZ,
  only_one: gZ,
  zero_or_one: yZ,
  one_or_more: bZ,
  zero_or_more: xZ,
  requirement_arrow: wZ,
  requirement_contains: kZ
};
var _Z = oZ;
var CZ = {
  common: ga,
  getConfig: Vr,
  insertCluster: LK,
  insertEdge: sZ,
  insertEdgeLabel: tZ,
  insertMarkers: _Z,
  insertNode: a9,
  interpolateToCurve: lg,
  labelHelper: Gt,
  log: ut,
  positionEdgeLabel: eZ
};
var Yl = {};
var c9 = S((t15) => {
  for (const e of t15)
    Yl[e.name] = e;
}, "registerLayoutLoaders");
var SZ = S(() => {
  c9([
    {
      name: "dagre",
      loader: S(async () => await import("./dagre-JOIXM2OF-CwXgbgpQ-CfRpmQDy-VR7RTSNK.js"), "loader")
    }
  ]);
}, "registerDefaultLayoutLoaders");
SZ();
var vnt = S(async (t15, e) => {
  if (!(t15.layoutAlgorithm in Yl))
    throw new Error(`Unknown layout algorithm: ${t15.layoutAlgorithm}`);
  const r = Yl[t15.layoutAlgorithm];
  return (await r.loader()).render(t15, e, CZ, {
    algorithm: r.algorithm
  });
}, "render");
var _nt = S((t15 = "", { fallback: e = "dagre" } = {}) => {
  if (t15 in Yl)
    return t15;
  if (e in Yl)
    return ut.warn(`Layout algorithm ${t15} is not registered. Using ${e} as fallback.`), e;
  throw new Error(`Both layout algorithms ${t15} and ${e} are not registered.`);
}, "getRegisteredLayoutAlgorithm");
var e5 = {
  name: "mermaid",
  version: "11.9.0",
  description: "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
  type: "module",
  module: "./dist/mermaid.core.mjs",
  types: "./dist/mermaid.d.ts",
  exports: {
    ".": {
      types: "./dist/mermaid.d.ts",
      import: "./dist/mermaid.core.mjs",
      default: "./dist/mermaid.core.mjs"
    },
    "./*": "./*"
  },
  keywords: [
    "diagram",
    "markdown",
    "flowchart",
    "sequence diagram",
    "gantt",
    "class diagram",
    "git graph",
    "mindmap",
    "packet diagram",
    "c4 diagram",
    "er diagram",
    "pie chart",
    "pie diagram",
    "quadrant chart",
    "requirement diagram",
    "graph"
  ],
  scripts: {
    clean: "rimraf dist",
    dev: "pnpm -w dev",
    "docs:code": "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
    "docs:build": "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
    "docs:verify": "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
    "docs:pre:vitepress": "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
    "docs:build:vitepress": "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
    "docs:dev": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:dev:docker": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:serve": "pnpm docs:build:vitepress && vitepress serve src/vitepress",
    "docs:spellcheck": 'cspell "src/docs/**/*.md"',
    "docs:release-version": "tsx scripts/update-release-version.mts",
    "docs:verify-version": "tsx scripts/update-release-version.mts --verify",
    "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
    "types:verify-config": "tsx scripts/create-types-from-json-schema.mts --verify",
    checkCircle: "npx madge --circular ./src",
    prepublishOnly: "pnpm docs:verify-version"
  },
  repository: {
    type: "git",
    url: "https://github.com/mermaid-js/mermaid"
  },
  author: "Knut Sveidqvist",
  license: "MIT",
  standard: {
    ignore: [
      "**/parser/*.js",
      "dist/**/*.js",
      "cypress/**/*.js"
    ],
    globals: [
      "page"
    ]
  },
  dependencies: {
    "@braintree/sanitize-url": "^7.0.4",
    "@iconify/utils": "^2.1.33",
    "@mermaid-js/parser": "workspace:^",
    "@types/d3": "^7.4.3",
    cytoscape: "^3.29.3",
    "cytoscape-cose-bilkent": "^4.1.0",
    "cytoscape-fcose": "^2.2.0",
    d3: "^7.9.0",
    "d3-sankey": "^0.12.3",
    "dagre-d3-es": "7.0.11",
    dayjs: "^1.11.13",
    dompurify: "^3.2.5",
    katex: "^0.16.22",
    khroma: "^2.1.0",
    "lodash-es": "^4.17.21",
    marked: "^16.0.0",
    roughjs: "^4.6.6",
    stylis: "^4.3.6",
    "ts-dedent": "^2.2.0",
    uuid: "^11.1.0"
  },
  devDependencies: {
    "@adobe/jsonschema2md": "^8.0.2",
    "@iconify/types": "^2.0.0",
    "@types/cytoscape": "^3.21.9",
    "@types/cytoscape-fcose": "^2.2.4",
    "@types/d3-sankey": "^0.12.4",
    "@types/d3-scale": "^4.0.9",
    "@types/d3-scale-chromatic": "^3.1.0",
    "@types/d3-selection": "^3.0.11",
    "@types/d3-shape": "^3.1.7",
    "@types/jsdom": "^21.1.7",
    "@types/katex": "^0.16.7",
    "@types/lodash-es": "^4.17.12",
    "@types/micromatch": "^4.0.9",
    "@types/stylis": "^4.2.7",
    "@types/uuid": "^10.0.0",
    ajv: "^8.17.1",
    canvas: "^3.1.0",
    chokidar: "3.6.0",
    concurrently: "^9.1.2",
    "csstree-validator": "^4.0.1",
    globby: "^14.0.2",
    jison: "^0.4.18",
    "js-base64": "^3.7.7",
    jsdom: "^26.1.0",
    "json-schema-to-typescript": "^15.0.4",
    micromatch: "^4.0.8",
    "path-browserify": "^1.0.1",
    prettier: "^3.5.2",
    remark: "^15.0.1",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    rimraf: "^6.0.1",
    "start-server-and-test": "^2.0.10",
    "type-fest": "^4.35.0",
    typedoc: "^0.27.8",
    "typedoc-plugin-markdown": "^4.4.2",
    typescript: "~5.7.3",
    "unist-util-flatmap": "^1.0.0",
    "unist-util-visit": "^5.0.0",
    vitepress: "^1.0.2",
    "vitepress-plugin-search": "1.0.4-alpha.22"
  },
  files: [
    "dist/",
    "README.md"
  ],
  publishConfig: {
    access: "public"
  }
};
var TZ = S((t15) => {
  var _a2;
  const { securityLevel: e } = me();
  let r = ae("body");
  if (e === "sandbox") {
    const n = ((_a2 = ae(`#i${t15}`).node()) == null ? void 0 : _a2.contentDocument) ?? document;
    r = ae(n.body);
  }
  return r.select(`#${t15}`);
}, "selectSvgElement");
var h9 = "comm";
var u9 = "rule";
var d9 = "decl";
var AZ = "@import";
var $Z = "@namespace";
var EZ = "@keyframes";
var MZ = "@layer";
var p9 = Math.abs;
var $g = String.fromCharCode;
function f9(t15) {
  return t15.trim();
}
function jh(t15, e, r) {
  return t15.replace(e, r);
}
function BZ(t15, e, r) {
  return t15.indexOf(e, r);
}
function jo(t15, e) {
  return t15.charCodeAt(e) | 0;
}
function sa(t15, e, r) {
  return t15.slice(e, r);
}
function Wn(t15) {
  return t15.length;
}
function LZ(t15) {
  return t15.length;
}
function mh(t15, e) {
  return e.push(t15), t15;
}
var G0 = 1;
var oa = 1;
var m9 = 0;
var wn = 0;
var Ve = 0;
var ka = "";
function Eg(t15, e, r, n, i, s, o, a) {
  return { value: t15, root: e, parent: r, type: n, props: i, children: s, line: G0, column: oa, length: o, return: "", siblings: a };
}
function DZ() {
  return Ve;
}
function FZ() {
  return Ve = wn > 0 ? jo(ka, --wn) : 0, oa--, Ve === 10 && (oa = 1, G0--), Ve;
}
function $n() {
  return Ve = wn < m9 ? jo(ka, wn++) : 0, oa++, Ve === 10 && (oa = 1, G0++), Ve;
}
function ss() {
  return jo(ka, wn);
}
function Wh() {
  return wn;
}
function X0(t15, e) {
  return sa(ka, t15, e);
}
function Kl(t15) {
  switch (t15) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function NZ(t15) {
  return G0 = oa = 1, m9 = Wn(ka = t15), wn = 0, [];
}
function IZ(t15) {
  return ka = "", t15;
}
function Rp(t15) {
  return f9(X0(wn - 1, k1(t15 === 91 ? t15 + 2 : t15 === 40 ? t15 + 1 : t15)));
}
function OZ(t15) {
  for (; (Ve = ss()) && Ve < 33; )
    $n();
  return Kl(t15) > 2 || Kl(Ve) > 3 ? "" : " ";
}
function zZ(t15, e) {
  for (; --e && $n() && !(Ve < 48 || Ve > 102 || Ve > 57 && Ve < 65 || Ve > 70 && Ve < 97); )
    ;
  return X0(t15, Wh() + (e < 6 && ss() == 32 && $n() == 32));
}
function k1(t15) {
  for (; $n(); )
    switch (Ve) {
      case t15:
        return wn;
      case 34:
      case 39:
        t15 !== 34 && t15 !== 39 && k1(Ve);
        break;
      case 40:
        t15 === 41 && k1(t15);
        break;
      case 92:
        $n();
        break;
    }
  return wn;
}
function qZ(t15, e) {
  for (; $n() && t15 + Ve !== 57 && !(t15 + Ve === 84 && ss() === 47); )
    ;
  return "/*" + X0(e, wn - 1) + "*" + $g(t15 === 47 ? t15 : $n());
}
function RZ(t15) {
  for (; !Kl(ss()); )
    $n();
  return X0(t15, wn);
}
function PZ(t15) {
  return IZ(Hh("", null, null, null, [""], t15 = NZ(t15), 0, [0], t15));
}
function Hh(t15, e, r, n, i, s, o, a, l) {
  for (var c = 0, h10 = 0, p = o, m = 0, g = 0, y = 0, x = 1, k = 1, C = 1, _ = 0, $ = "", L = i, B = s, q = n, H = $; k; )
    switch (y = _, _ = $n()) {
      case 40:
        if (y != 108 && jo(H, p - 1) == 58) {
          BZ(H += jh(Rp(_), "&", "&\f"), "&\f", p9(c ? a[c - 1] : 0)) != -1 && (C = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        H += Rp(_);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        H += OZ(y);
        break;
      case 92:
        H += zZ(Wh() - 1, 7);
        continue;
      case 47:
        switch (ss()) {
          case 42:
          case 47:
            mh(jZ(qZ($n(), Wh()), e, r, l), l), (Kl(y || 1) == 5 || Kl(ss() || 1) == 5) && Wn(H) && sa(H, -1, void 0) !== " " && (H += " ");
            break;
          default:
            H += "/";
        }
        break;
      case 123 * x:
        a[c++] = Wn(H) * C;
      case 125 * x:
      case 59:
      case 0:
        switch (_) {
          case 0:
          case 125:
            k = 0;
          case 59 + h10:
            C == -1 && (H = jh(H, /\f/g, "")), g > 0 && (Wn(H) - p || x === 0 && y === 47) && mh(g > 32 ? n5(H + ";", n, r, p - 1, l) : n5(jh(H, " ", "") + ";", n, r, p - 2, l), l);
            break;
          case 59:
            H += ";";
          default:
            if (mh(q = r5(H, e, r, c, h10, i, a, $, L = [], B = [], p, s), s), _ === 123)
              if (h10 === 0)
                Hh(H, e, q, q, L, s, p, a, B);
              else {
                switch (m) {
                  case 99:
                    if (jo(H, 3) === 110) break;
                  case 108:
                    if (jo(H, 2) === 97) break;
                  default:
                    h10 = 0;
                  case 100:
                  case 109:
                  case 115:
                }
                h10 ? Hh(t15, q, q, n && mh(r5(t15, q, q, 0, 0, i, a, $, i, L = [], p, B), B), i, B, p, a, n ? L : B) : Hh(H, q, q, q, [""], B, 0, a, B);
              }
        }
        c = h10 = g = 0, x = C = 1, $ = H = "", p = o;
        break;
      case 58:
        p = 1 + Wn(H), g = y;
      default:
        if (x < 1) {
          if (_ == 123)
            --x;
          else if (_ == 125 && x++ == 0 && FZ() == 125)
            continue;
        }
        switch (H += $g(_), _ * x) {
          case 38:
            C = h10 > 0 ? 1 : (H += "\f", -1);
            break;
          case 44:
            a[c++] = (Wn(H) - 1) * C, C = 1;
            break;
          case 64:
            ss() === 45 && (H += Rp($n())), m = ss(), h10 = p = Wn($ = H += RZ(Wh())), _++;
            break;
          case 45:
            y === 45 && Wn(H) == 2 && (x = 0);
        }
    }
  return s;
}
function r5(t15, e, r, n, i, s, o, a, l, c, h10, p) {
  for (var m = i - 1, g = i === 0 ? s : [""], y = LZ(g), x = 0, k = 0, C = 0; x < n; ++x)
    for (var _ = 0, $ = sa(t15, m + 1, m = p9(k = o[x])), L = t15; _ < y; ++_)
      (L = f9(k > 0 ? g[_] + " " + $ : jh($, /&\f/g, g[_]))) && (l[C++] = L);
  return Eg(t15, e, r, i === 0 ? u9 : a, l, c, h10, p);
}
function jZ(t15, e, r, n) {
  return Eg(t15, e, r, h9, $g(DZ()), sa(t15, 2, -2), 0, n);
}
function n5(t15, e, r, n, i) {
  return Eg(t15, e, r, d9, sa(t15, 0, n), sa(t15, n + 1, -1), n, i);
}
function v1(t15, e) {
  for (var r = "", n = 0; n < t15.length; n++)
    r += e(t15[n], n, t15, e) || "";
  return r;
}
function WZ(t15, e, r, n) {
  switch (t15.type) {
    case MZ:
      if (t15.children.length) break;
    case AZ:
    case $Z:
    case d9:
      return t15.return = t15.return || t15.value;
    case h9:
      return "";
    case EZ:
      return t15.return = t15.value + "{" + v1(t15.children, n) + "}";
    case u9:
      if (!Wn(t15.value = t15.props.join(","))) return "";
  }
  return Wn(r = v1(t15.children, n)) ? t15.return = t15.value + "{" + r + "}" : "";
}
var HZ = Gk(Object.keys, Object);
var UZ = Object.prototype;
var VZ = UZ.hasOwnProperty;
function GZ(t15) {
  if (!z0(t15))
    return HZ(t15);
  var e = [];
  for (var r in Object(t15))
    VZ.call(t15, r) && r != "constructor" && e.push(r);
  return e;
}
var _1 = uo(li, "DataView");
var C1 = uo(li, "Promise");
var S1 = uo(li, "Set");
var T1 = uo(li, "WeakMap");
var i5 = "[object Map]";
var XZ = "[object Object]";
var s5 = "[object Promise]";
var o5 = "[object Set]";
var a5 = "[object WeakMap]";
var l5 = "[object DataView]";
var YZ = ho(_1);
var KZ = ho(Xl);
var ZZ = ho(C1);
var QZ = ho(S1);
var JZ = ho(T1);
var Is = ba;
(_1 && Is(new _1(new ArrayBuffer(1))) != l5 || Xl && Is(new Xl()) != i5 || C1 && Is(C1.resolve()) != s5 || S1 && Is(new S1()) != o5 || T1 && Is(new T1()) != a5) && (Is = function(t15) {
  var e = ba(t15), r = e == XZ ? t15.constructor : void 0, n = r ? ho(r) : "";
  if (n)
    switch (n) {
      case YZ:
        return l5;
      case KZ:
        return i5;
      case ZZ:
        return s5;
      case QZ:
        return o5;
      case JZ:
        return a5;
    }
  return e;
});
var tQ = "[object Map]";
var eQ = "[object Set]";
var rQ = Object.prototype;
var nQ = rQ.hasOwnProperty;
function c5(t15) {
  if (t15 == null)
    return true;
  if (q0(t15) && (zu(t15) || typeof t15 == "string" || typeof t15.splice == "function" || og(t15) || ag(t15) || Ou(t15)))
    return !t15.length;
  var e = Is(t15);
  if (e == tQ || e == eQ)
    return !t15.size;
  if (z0(t15))
    return !GZ(t15).length;
  for (var r in t15)
    if (nQ.call(t15, r))
      return false;
  return true;
}
var g9 = "c4";
var iQ = S((t15) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(t15), "detector");
var sQ = S(async () => {
  const { diagram: t15 } = await import("./c4Diagram-6F6E4RAY-DObsjlRQ-XtUhiGr7-DLWKRXGA.js");
  return { id: g9, diagram: t15 };
}, "loader");
var oQ = {
  id: g9,
  detector: iQ,
  loader: sQ
};
var aQ = oQ;
var y9 = "flowchart";
var lQ = S((t15, e) => {
  var _a2, _b2;
  return ((_a2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" || ((_b2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _b2.defaultRenderer) === "elk" ? false : /^\s*graph/.test(t15);
}, "detector");
var cQ = S(async () => {
  const { diagram: t15 } = await import("./flowDiagram-KYDEHFYC-0BQiF5Ve-CRUn83GM-OIHSBWBK.js");
  return { id: y9, diagram: t15 };
}, "loader");
var hQ = {
  id: y9,
  detector: lQ,
  loader: cQ
};
var uQ = hQ;
var b9 = "flowchart-v2";
var dQ = S((t15, e) => {
  var _a2, _b2, _c;
  return ((_a2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a2.defaultRenderer) === "dagre-d3" ? false : (((_b2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _b2.defaultRenderer) === "elk" && (e.layout = "elk"), /^\s*graph/.test(t15) && ((_c = e == null ? void 0 : e.flowchart) == null ? void 0 : _c.defaultRenderer) === "dagre-wrapper" ? true : /^\s*flowchart/.test(t15));
}, "detector");
var pQ = S(async () => {
  const { diagram: t15 } = await import("./flowDiagram-KYDEHFYC-0BQiF5Ve-CRUn83GM-OIHSBWBK.js");
  return { id: b9, diagram: t15 };
}, "loader");
var fQ = {
  id: b9,
  detector: dQ,
  loader: pQ
};
var mQ = fQ;
var x9 = "er";
var gQ = S((t15) => /^\s*erDiagram/.test(t15), "detector");
var yQ = S(async () => {
  const { diagram: t15 } = await import("./erDiagram-3M52JZNH-CeM_jzqp-BKOUcBTp-M2AF6FAN.js");
  return { id: x9, diagram: t15 };
}, "loader");
var bQ = {
  id: x9,
  detector: gQ,
  loader: yQ
};
var xQ = bQ;
var w9 = "gitGraph";
var wQ = S((t15) => /^\s*gitGraph/.test(t15), "detector");
var kQ = S(async () => {
  const { diagram: t15 } = await import("./gitGraphDiagram-GW3U2K7C-Bd4St_Qu-DaoKAzXs-4ADSLFE4.js");
  return { id: w9, diagram: t15 };
}, "loader");
var vQ = {
  id: w9,
  detector: wQ,
  loader: kQ
};
var _Q = vQ;
var k9 = "gantt";
var CQ = S((t15) => /^\s*gantt/.test(t15), "detector");
var SQ = S(async () => {
  const { diagram: t15 } = await import("./ganttDiagram-EK5VF46D-Ste5T71w-DbB2gGYT-4BU7JFVH.js");
  return { id: k9, diagram: t15 };
}, "loader");
var TQ = {
  id: k9,
  detector: CQ,
  loader: SQ
};
var AQ = TQ;
var v9 = "info";
var $Q = S((t15) => /^\s*info/.test(t15), "detector");
var EQ = S(async () => {
  const { diagram: t15 } = await import("./infoDiagram-LHK5PUON-r5BtCShk-Bd3nZ_X4-PKQLNEZE.js");
  return { id: v9, diagram: t15 };
}, "loader");
var MQ = {
  id: v9,
  detector: $Q,
  loader: EQ
};
var _9 = "pie";
var BQ = S((t15) => /^\s*pie/.test(t15), "detector");
var LQ = S(async () => {
  const { diagram: t15 } = await import("./pieDiagram-NIOCPIFQ-DWO8ZxGq-CGKGI6es-AJNGIDQA.js");
  return { id: _9, diagram: t15 };
}, "loader");
var DQ = {
  id: _9,
  detector: BQ,
  loader: LQ
};
var C9 = "quadrantChart";
var FQ = S((t15) => /^\s*quadrantChart/.test(t15), "detector");
var NQ = S(async () => {
  const { diagram: t15 } = await import("./quadrantDiagram-2OG54O6I-CETGVUZB-D-yE8Wtf-2OB6AFOL.js");
  return { id: C9, diagram: t15 };
}, "loader");
var IQ = {
  id: C9,
  detector: FQ,
  loader: NQ
};
var OQ = IQ;
var S9 = "xychart";
var zQ = S((t15) => /^\s*xychart-beta/.test(t15), "detector");
var qQ = S(async () => {
  const { diagram: t15 } = await import("./xychartDiagram-H2YORKM3-CG64ebqo-CxP5Tk3X-RU3VBWSH.js");
  return { id: S9, diagram: t15 };
}, "loader");
var RQ = {
  id: S9,
  detector: zQ,
  loader: qQ
};
var PQ = RQ;
var T9 = "requirement";
var jQ = S((t15) => /^\s*requirement(Diagram)?/.test(t15), "detector");
var WQ = S(async () => {
  const { diagram: t15 } = await import("./requirementDiagram-QOLK2EJ7-CWENJGxE-Cy17jL3W-AQSU7FWD.js");
  return { id: T9, diagram: t15 };
}, "loader");
var HQ = {
  id: T9,
  detector: jQ,
  loader: WQ
};
var UQ = HQ;
var A9 = "sequence";
var VQ = S((t15) => /^\s*sequenceDiagram/.test(t15), "detector");
var GQ = S(async () => {
  const { diagram: t15 } = await import("./sequenceDiagram-SKLFT4DO-BXKs8vh--CCYoMN4G-U3NSQGWW.js");
  return { id: A9, diagram: t15 };
}, "loader");
var XQ = {
  id: A9,
  detector: VQ,
  loader: GQ
};
var YQ = XQ;
var $9 = "class";
var KQ = S((t15, e) => {
  var _a2;
  return ((_a2 = e == null ? void 0 : e.class) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" ? false : /^\s*classDiagram/.test(t15);
}, "detector");
var ZQ = S(async () => {
  const { diagram: t15 } = await import("./classDiagram-M3E45YP4-Bs_kHkQk-DMolIgWy-SWM3DYA2.js");
  return { id: $9, diagram: t15 };
}, "loader");
var QQ = {
  id: $9,
  detector: KQ,
  loader: ZQ
};
var JQ = QQ;
var E9 = "classDiagram";
var tJ = S((t15, e) => {
  var _a2;
  return /^\s*classDiagram/.test(t15) && ((_a2 = e == null ? void 0 : e.class) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" ? true : /^\s*classDiagram-v2/.test(t15);
}, "detector");
var eJ = S(async () => {
  const { diagram: t15 } = await import("./classDiagram-v2-YAWTLIQI-Bs_kHkQk-DMolIgWy-PW4W6W47.js");
  return { id: E9, diagram: t15 };
}, "loader");
var rJ = {
  id: E9,
  detector: tJ,
  loader: eJ
};
var nJ = rJ;
var M9 = "state";
var iJ = S((t15, e) => {
  var _a2;
  return ((_a2 = e == null ? void 0 : e.state) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" ? false : /^\s*stateDiagram/.test(t15);
}, "detector");
var sJ = S(async () => {
  const { diagram: t15 } = await import("./stateDiagram-MI5ZYTHO-gWvRaqSn-FJOO-cJj-7G2PEE6U.js");
  return { id: M9, diagram: t15 };
}, "loader");
var oJ = {
  id: M9,
  detector: iJ,
  loader: sJ
};
var aJ = oJ;
var B9 = "stateDiagram";
var lJ = S((t15, e) => {
  var _a2;
  return !!(/^\s*stateDiagram-v2/.test(t15) || /^\s*stateDiagram/.test(t15) && ((_a2 = e == null ? void 0 : e.state) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper");
}, "detector");
var cJ = S(async () => {
  const { diagram: t15 } = await import("./stateDiagram-v2-5AN5P6BG-PEZfhsgY-C0uCqOrH-OHCGMZAI.js");
  return { id: B9, diagram: t15 };
}, "loader");
var hJ = {
  id: B9,
  detector: lJ,
  loader: cJ
};
var uJ = hJ;
var L9 = "journey";
var dJ = S((t15) => /^\s*journey/.test(t15), "detector");
var pJ = S(async () => {
  const { diagram: t15 } = await import("./journeyDiagram-EWQZEKCU-WWIdK_St-Deg5yU4v-CLHXNQ72.js");
  return { id: L9, diagram: t15 };
}, "loader");
var fJ = {
  id: L9,
  detector: dJ,
  loader: pJ
};
var mJ = fJ;
var gJ = S((t15, e, r) => {
  ut.debug(`rendering svg for syntax error
`);
  const n = TZ(e), i = n.append("g");
  n.attr("viewBox", "0 0 2412 512"), hw(n, 100, 512, true), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
  ), i.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text"), i.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${r}`);
}, "draw");
var D9 = { draw: gJ };
var yJ = D9;
var bJ = {
  db: {},
  renderer: D9,
  parser: {
    parse: S(() => {
    }, "parse")
  }
};
var xJ = bJ;
var F9 = "flowchart-elk";
var wJ = S((t15, e = {}) => {
  var _a2;
  return (
    // If diagram explicitly states flowchart-elk
    /^\s*flowchart-elk/.test(t15) || // If a flowchart/graph diagram has their default renderer set to elk
    /^\s*flowchart|graph/.test(t15) && ((_a2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a2.defaultRenderer) === "elk" ? (e.layout = "elk", true) : false
  );
}, "detector");
var kJ = S(async () => {
  const { diagram: t15 } = await import("./flowDiagram-KYDEHFYC-0BQiF5Ve-CRUn83GM-OIHSBWBK.js");
  return { id: F9, diagram: t15 };
}, "loader");
var vJ = {
  id: F9,
  detector: wJ,
  loader: kJ
};
var _J = vJ;
var N9 = "timeline";
var CJ = S((t15) => /^\s*timeline/.test(t15), "detector");
var SJ = S(async () => {
  const { diagram: t15 } = await import("./timeline-definition-MYPXXCX6-BC6DTEXu-Dheq_747-GHWKGYSC.js");
  return { id: N9, diagram: t15 };
}, "loader");
var TJ = {
  id: N9,
  detector: CJ,
  loader: SJ
};
var AJ = TJ;
var I9 = "mindmap";
var $J = S((t15) => /^\s*mindmap/.test(t15), "detector");
var EJ = S(async () => {
  const { diagram: t15 } = await import("./mindmap-definition-6CBA2TL7-CG7XFai2-B-ObmyZG-K73XCAOB.js");
  return { id: I9, diagram: t15 };
}, "loader");
var MJ = {
  id: I9,
  detector: $J,
  loader: EJ
};
var BJ = MJ;
var O9 = "kanban";
var LJ = S((t15) => /^\s*kanban/.test(t15), "detector");
var DJ = S(async () => {
  const { diagram: t15 } = await import("./kanban-definition-ZSS6B67P-BVHDZnu5-BI_alZAK-LWMXBDBV.js");
  return { id: O9, diagram: t15 };
}, "loader");
var FJ = {
  id: O9,
  detector: LJ,
  loader: DJ
};
var NJ = FJ;
var z9 = "sankey";
var IJ = S((t15) => /^\s*sankey-beta/.test(t15), "detector");
var OJ = S(async () => {
  const { diagram: t15 } = await import("./sankeyDiagram-4UZDY2LN-DoTjtl8i-VvmUl99R-5LH6KIFB.js");
  return { id: z9, diagram: t15 };
}, "loader");
var zJ = {
  id: z9,
  detector: IJ,
  loader: OJ
};
var qJ = zJ;
var q9 = "packet";
var RJ = S((t15) => /^\s*packet(-beta)?/.test(t15), "detector");
var PJ = S(async () => {
  const { diagram: t15 } = await import("./diagram-5UYTHUR4-HCM9uTGi-fURArewE-TER4NHL6.js");
  return { id: q9, diagram: t15 };
}, "loader");
var jJ = {
  id: q9,
  detector: RJ,
  loader: PJ
};
var R9 = "radar";
var WJ = S((t15) => /^\s*radar-beta/.test(t15), "detector");
var HJ = S(async () => {
  const { diagram: t15 } = await import("./diagram-ZTM2IBQH-CITBcV_Z-Bg9u3hwa-KSA2PFHZ.js");
  return { id: R9, diagram: t15 };
}, "loader");
var UJ = {
  id: R9,
  detector: WJ,
  loader: HJ
};
var P9 = "block";
var VJ = S((t15) => /^\s*block-beta/.test(t15), "detector");
var GJ = S(async () => {
  const { diagram: t15 } = await import("./blockDiagram-6J76NXCF-CZvpvWjH-DXeRKbxD-7OY6YTHC.js");
  return { id: P9, diagram: t15 };
}, "loader");
var XJ = {
  id: P9,
  detector: VJ,
  loader: GJ
};
var YJ = XJ;
var j9 = "architecture";
var KJ = S((t15) => /^\s*architecture/.test(t15), "detector");
var ZJ = S(async () => {
  const { diagram: t15 } = await import("./architectureDiagram-SUXI7LT5-CpWQYJus-DReApCvq-LNFNVFNZ.js");
  return { id: j9, diagram: t15 };
}, "loader");
var QJ = {
  id: j9,
  detector: KJ,
  loader: ZJ
};
var JJ = QJ;
var W9 = "treemap";
var ttt = S((t15) => /^\s*treemap/.test(t15), "detector");
var ett = S(async () => {
  const { diagram: t15 } = await import("./diagram-VMROVX33-8x1VznwQ-8feEHGmd-ONAK26B3.js");
  return { id: W9, diagram: t15 };
}, "loader");
var rtt = {
  id: W9,
  detector: ttt,
  loader: ett
};
var h5 = false;
var Y0 = S(() => {
  h5 || (h5 = true, bu("error", xJ, (t15) => t15.toLowerCase().trim() === "error"), bu(
    "---",
    // --- diagram type may appear if YAML front-matter is not parsed correctly
    {
      db: {
        clear: S(() => {
        }, "clear")
      },
      styles: {},
      // should never be used
      renderer: {
        draw: S(() => {
        }, "draw")
      },
      parser: {
        parse: S(() => {
          throw new Error(
            "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks"
          );
        }, "parse")
      },
      init: S(() => null, "init")
      // no op
    },
    (t15) => t15.toLowerCase().trimStart().startsWith("---")
  ), Nf(_J, BJ, JJ), Nf(
    aQ,
    NJ,
    nJ,
    JQ,
    xQ,
    AQ,
    MQ,
    DQ,
    UQ,
    YQ,
    mQ,
    uQ,
    AJ,
    _Q,
    uJ,
    aJ,
    mJ,
    OQ,
    qJ,
    jJ,
    PQ,
    YJ,
    UJ,
    rtt
  ));
}, "addDiagrams");
var ntt = S(async () => {
  ut.debug("Loading registered diagrams");
  const t15 = (await Promise.allSettled(
    Object.entries(Js).map(async ([e, { detector: r, loader: n }]) => {
      if (n)
        try {
          qf(e);
        } catch {
          try {
            const { diagram: i, id: s } = await n();
            bu(s, i, r);
          } catch (i) {
            throw ut.error(`Failed to load external diagram with key ${e}. Removing from detectors.`), delete Js[e], i;
          }
        }
    })
  )).filter((e) => e.status === "rejected");
  if (t15.length > 0) {
    ut.error(`Failed to load ${t15.length} external diagrams`);
    for (const e of t15)
      ut.error(e);
    throw new Error(`Failed to load ${t15.length} external diagrams`);
  }
}, "loadRegisteredDiagrams");
var itt = "graphics-document document";
function H9(t15, e) {
  t15.attr("role", itt), e !== "" && t15.attr("aria-roledescription", e);
}
S(H9, "setA11yDiagramInfo");
function U9(t15, e, r, n) {
  if (t15.insert !== void 0) {
    if (r) {
      const i = `chart-desc-${n}`;
      t15.attr("aria-describedby", i), t15.insert("desc", ":first-child").attr("id", i).text(r);
    }
    if (e) {
      const i = `chart-title-${n}`;
      t15.attr("aria-labelledby", i), t15.insert("title", ":first-child").attr("id", i).text(e);
    }
  }
}
S(U9, "addSVGa11yTitleDescription");
var gh;
var A1 = (gh = class {
  constructor(t15, e, r, n, i) {
    this.type = t15, this.text = e, this.db = r, this.parser = n, this.renderer = i;
  }
  static async fromText(t15, e = {}) {
    var _a2, _b2;
    const r = Vr(), n = Lm(t15, r);
    t15 = eY(t15) + `
`;
    try {
      qf(n);
    } catch {
      const l = ER(n);
      if (!l)
        throw new K6(`Diagram ${n} not found.`);
      const { id: c, diagram: h10 } = await l();
      bu(c, h10);
    }
    const { db: i, parser: s, renderer: o, init: a } = qf(n);
    return s.parser && (s.parser.yy = i), (_a2 = i.clear) == null ? void 0 : _a2.call(i), a == null ? void 0 : a(r), e.title && ((_b2 = i.setDiagramTitle) == null ? void 0 : _b2.call(i, e.title)), await s.parse(t15), new gh(n, t15, i, s, o);
  }
  async render(t15, e) {
    await this.renderer.draw(this.text, t15, e, this);
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}, S(gh, "Diagram"), gh);
var u5 = [];
var stt = S(() => {
  u5.forEach((t15) => {
    t15();
  }), u5 = [];
}, "attachFunctions");
var ott = S((t15) => t15.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(), "cleanupComments");
function V9(t15) {
  const e = t15.match(Y6);
  if (!e)
    return {
      text: t15,
      metadata: {}
    };
  let r = Aj(e[1], {
    // To support config, we need JSON schema.
    // https://www.yaml.org/spec/1.2/spec.html#id2803231
    schema: Tj
  }) ?? {};
  r = typeof r == "object" && !Array.isArray(r) ? r : {};
  const n = {};
  return r.displayMode && (n.displayMode = r.displayMode.toString()), r.title && (n.title = r.title.toString()), r.config && (n.config = r.config), {
    text: t15.slice(e[0].length),
    metadata: n
  };
}
S(V9, "extractFrontMatter");
var att = S((t15) => t15.replace(/\r\n?/g, `
`).replace(
  /<(\w+)([^>]*)>/g,
  (e, r, n) => "<" + r + n.replace(/="([^"]*)"/g, "='$1'") + ">"
), "cleanupText");
var ltt = S((t15) => {
  const { text: e, metadata: r } = V9(t15), { displayMode: n, title: i, config: s = {} } = r;
  return n && (s.gantt || (s.gantt = {}), s.gantt.displayMode = n), { title: i, config: s, text: e };
}, "processFrontmatter");
var ctt = S((t15) => {
  const e = Xn.detectInit(t15) ?? {}, r = Xn.detectDirective(t15, "wrap");
  return Array.isArray(r) ? e.wrap = r.some(({ type: n }) => n === "wrap") : (r == null ? void 0 : r.type) === "wrap" && (e.wrap = true), {
    text: jX(t15),
    directive: e
  };
}, "processDirectives");
function Mg(t15) {
  const e = att(t15), r = ltt(e), n = ctt(r.text), i = pg(r.config, n.directive);
  return t15 = ott(n.text), {
    code: t15,
    title: r.title,
    config: i
  };
}
S(Mg, "preprocessDiagram");
function G9(t15) {
  const e = new TextEncoder().encode(t15), r = Array.from(e, (n) => String.fromCodePoint(n)).join("");
  return btoa(r);
}
S(G9, "toBase64");
var htt = 5e4;
var utt = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
var dtt = "sandbox";
var ptt = "loose";
var ftt = "http://www.w3.org/2000/svg";
var mtt = "http://www.w3.org/1999/xlink";
var gtt = "http://www.w3.org/1999/xhtml";
var ytt = "100%";
var btt = "100%";
var xtt = "border:0;margin:0;";
var wtt = "margin:0";
var ktt = "allow-top-navigation-by-user-activation allow-popups";
var vtt = 'The "iframe" tag is not supported by your browser.';
var _tt = ["foreignobject"];
var Ctt = ["dominant-baseline"];
function Bg(t15) {
  const e = Mg(t15);
  return gu(), UR(e.config ?? {}), e;
}
S(Bg, "processAndSetConfigs");
async function X9(t15, e) {
  Y0();
  try {
    const { code: r, config: n } = Bg(t15);
    return { diagramType: (await K9(r)).type, config: n };
  } catch (r) {
    if (e == null ? void 0 : e.suppressErrors)
      return false;
    throw r;
  }
}
S(X9, "parse");
var d5 = S((t15, e, r = []) => `
.${t15} ${e} { ${r.join(" !important; ")} !important; }`, "cssImportantStyles");
var Stt = S((t15, e = /* @__PURE__ */ new Map()) => {
  var _a2;
  let r = "";
  if (t15.themeCSS !== void 0 && (r += `
${t15.themeCSS}`), t15.fontFamily !== void 0 && (r += `
:root { --mermaid-font-family: ${t15.fontFamily}}`), t15.altFontFamily !== void 0 && (r += `
:root { --mermaid-alt-font-family: ${t15.altFontFamily}}`), e instanceof Map) {
    const n = t15.htmlLabels ?? ((_a2 = t15.flowchart) == null ? void 0 : _a2.htmlLabels) ? ["> *", "span"] : ["rect", "polygon", "ellipse", "circle", "path"];
    e.forEach((i) => {
      c5(i.styles) || n.forEach((s) => {
        r += d5(i.id, s, i.styles);
      }), c5(i.textStyles) || (r += d5(
        i.id,
        "tspan",
        ((i == null ? void 0 : i.textStyles) || []).map((s) => s.replace("color", "fill"))
      ));
    });
  }
  return r;
}, "createCssStyles");
var Ttt = S((t15, e, r, n) => {
  const i = Stt(t15, r), s = cP(e, i, t15.themeVariables);
  return v1(PZ(`${n}{${s}}`), WZ);
}, "createUserStyles");
var Att = S((t15 = "", e, r) => {
  let n = t15;
  return !r && !e && (n = n.replace(
    /marker-end="url\([\d+./:=?A-Za-z-]*?#/g,
    'marker-end="url(#'
  )), n = po(n), n = n.replace(/<br>/g, "<br/>"), n;
}, "cleanUpSvgCode");
var $tt = S((t15 = "", e) => {
  var _a2, _b2;
  const r = ((_b2 = (_a2 = e == null ? void 0 : e.viewBox) == null ? void 0 : _a2.baseVal) == null ? void 0 : _b2.height) ? e.viewBox.baseVal.height + "px" : btt, n = G9(`<body style="${wtt}">${t15}</body>`);
  return `<iframe style="width:${ytt};height:${r};${xtt}" src="data:text/html;charset=UTF-8;base64,${n}" sandbox="${ktt}">
  ${vtt}
</iframe>`;
}, "putIntoIFrame");
var p5 = S((t15, e, r, n, i) => {
  const s = t15.append("div");
  s.attr("id", r), n && s.attr("style", n);
  const o = s.append("svg").attr("id", e).attr("width", "100%").attr("xmlns", ftt);
  return i && o.attr("xmlns:xlink", i), o.append("g"), t15;
}, "appendDivSvgG");
function $1(t15, e) {
  return t15.append("iframe").attr("id", e).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
S($1, "sandboxedIframe");
var Ett = S((t15, e, r, n) => {
  var _a2, _b2, _c;
  (_a2 = t15.getElementById(e)) == null ? void 0 : _a2.remove(), (_b2 = t15.getElementById(r)) == null ? void 0 : _b2.remove(), (_c = t15.getElementById(n)) == null ? void 0 : _c.remove();
}, "removeExistingElements");
var Mtt = S(async function(t15, e, r) {
  var _a2, _b2, _c, _d, _e, _f2;
  Y0();
  const n = Bg(e);
  e = n.code;
  const i = Vr();
  ut.debug(i), e.length > ((i == null ? void 0 : i.maxTextSize) ?? htt) && (e = utt);
  const s = "#" + t15, o = "i" + t15, a = "#" + o, l = "d" + t15, c = "#" + l, h10 = S(() => {
    const J = ae(m ? a : c).node();
    J && "remove" in J && J.remove();
  }, "removeTempElements");
  let p = ae("body");
  const m = i.securityLevel === dtt, g = i.securityLevel === ptt, y = i.fontFamily;
  if (r !== void 0) {
    if (r && (r.innerHTML = ""), m) {
      const J = $1(ae(r), o);
      p = ae(J.nodes()[0].contentDocument.body), p.node().style.margin = 0;
    } else
      p = ae(r);
    p5(p, t15, l, `font-family: ${y}`, mtt);
  } else {
    if (Ett(document, t15, l, o), m) {
      const J = $1(ae("body"), o);
      p = ae(J.nodes()[0].contentDocument.body), p.node().style.margin = 0;
    } else
      p = ae("body");
    p5(p, t15, l);
  }
  let x, k;
  try {
    x = await A1.fromText(e, { title: n.title });
  } catch (J) {
    if (i.suppressErrorRendering)
      throw h10(), J;
    x = await A1.fromText("error"), k = J;
  }
  const C = p.select(c).node(), _ = x.type, $ = C.firstChild, L = $.firstChild, B = (_b2 = (_a2 = x.renderer).getClasses) == null ? void 0 : _b2.call(_a2, e, x), q = Ttt(i, _, B, s), H = document.createElement("style");
  H.innerHTML = q, $.insertBefore(H, L);
  try {
    await x.renderer.draw(e, t15, e5.version, x);
  } catch (J) {
    throw i.suppressErrorRendering ? h10() : yJ.draw(e, t15, e5.version), J;
  }
  const G = p.select(`${c} svg`), F = (_d = (_c = x.db).getAccTitle) == null ? void 0 : _d.call(_c), W = (_f2 = (_e = x.db).getAccDescription) == null ? void 0 : _f2.call(_e);
  Z9(_, G, F, W), p.select(`[id="${t15}"]`).selectAll("foreignobject > *").attr("xmlns", gtt);
  let R = p.select(c).node().innerHTML;
  if (ut.debug("config.arrowMarkerAbsolute", i.arrowMarkerAbsolute), R = Att(R, m, Qe(i.arrowMarkerAbsolute)), m) {
    const J = p.select(c + " svg").node();
    R = $tt(R, J);
  } else g || (R = Zo.sanitize(R, {
    ADD_TAGS: _tt,
    ADD_ATTR: Ctt,
    HTML_INTEGRATION_POINTS: { foreignobject: true }
  }));
  if (stt(), k)
    throw k;
  return h10(), {
    diagramType: _,
    svg: R,
    bindFunctions: x.db.bindFunctions
  };
}, "render");
function Y9(t15 = {}) {
  var _a2;
  const e = pr({}, t15);
  (e == null ? void 0 : e.fontFamily) && !((_a2 = e.themeVariables) == null ? void 0 : _a2.fontFamily) && (e.themeVariables || (e.themeVariables = {}), e.themeVariables.fontFamily = e.fontFamily), WR(e), (e == null ? void 0 : e.theme) && e.theme in Li ? e.themeVariables = Li[e.theme].getThemeVariables(
    e.themeVariables
  ) : e && (e.themeVariables = Li.default.getThemeVariables(e.themeVariables));
  const r = typeof e == "object" ? jR(e) : rw();
  Bm(r.logLevel), Y0();
}
S(Y9, "initialize");
var K9 = S((t15, e = {}) => {
  const { code: r } = Mg(t15);
  return A1.fromText(r, e);
}, "getDiagramFromText");
function Z9(t15, e, r, n) {
  H9(e, t15), U9(e, r, n, e.attr("id"));
}
S(Z9, "addA11yInfo");
var so = Object.freeze({
  render: Mtt,
  parse: X9,
  getDiagramFromText: K9,
  initialize: Y9,
  getConfig: Vr,
  setConfig: nw,
  getSiteConfig: rw,
  updateSiteConfig: HR,
  reset: S(() => {
    gu();
  }, "reset"),
  globalReset: S(() => {
    gu(Qo);
  }, "globalReset"),
  defaultConfig: Qo
});
Bm(Vr().logLevel);
gu(Vr());
var Btt = S((t15, e, r) => {
  ut.warn(t15), dg(t15) ? (r && r(t15.str, t15.hash), e.push({ ...t15, message: t15.str, error: t15 })) : (r && r(t15), t15 instanceof Error && e.push({
    str: t15.message,
    message: t15.message,
    hash: t15.name,
    error: t15
  }));
}, "handleError");
var Q9 = S(async function(t15 = {
  querySelector: ".mermaid"
}) {
  try {
    await Ltt(t15);
  } catch (e) {
    if (dg(e) && ut.error(e.str), Oi.parseError && Oi.parseError(e), !t15.suppressErrors)
      throw ut.error("Use the suppressErrors option to suppress these errors"), e;
  }
}, "run");
var Ltt = S(async function({ postRenderCallback: t15, querySelector: e, nodes: r } = {
  querySelector: ".mermaid"
}) {
  const n = so.getConfig();
  ut.debug(`${t15 ? "" : "No "}Callback function found`);
  let i;
  if (r)
    i = r;
  else if (e)
    i = document.querySelectorAll(e);
  else
    throw new Error("Nodes and querySelector are both undefined");
  ut.debug(`Found ${i.length} diagrams`), (n == null ? void 0 : n.startOnLoad) !== void 0 && (ut.debug("Start On Load: " + (n == null ? void 0 : n.startOnLoad)), so.updateSiteConfig({ startOnLoad: n == null ? void 0 : n.startOnLoad }));
  const s = new Xn.InitIDGenerator(n.deterministicIds, n.deterministicIDSeed);
  let o;
  const a = [];
  for (const l of Array.from(i)) {
    if (ut.info("Rendering diagram: " + l.id), l.getAttribute("data-processed"))
      continue;
    l.setAttribute("data-processed", "true");
    const c = `mermaid-${s.next()}`;
    o = l.innerHTML, o = Cv(Xn.entityDecode(o)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const h10 = Xn.detectInit(o);
    h10 && ut.debug("Detected early reinit: ", h10);
    try {
      const { svg: p, bindFunctions: m } = await r_(c, o, l);
      l.innerHTML = p, t15 && await t15(c), m && m(l);
    } catch (p) {
      Btt(p, a, Oi.parseError);
    }
  }
  if (a.length > 0)
    throw a[0];
}, "runThrowsErrors");
var J9 = S(function(t15) {
  so.initialize(t15);
}, "initialize");
var Dtt = S(async function(t15, e, r) {
  ut.warn("mermaid.init is deprecated. Please use run instead."), t15 && J9(t15);
  const n = { postRenderCallback: r, querySelector: ".mermaid" };
  typeof e == "string" ? n.querySelector = e : e && (e instanceof HTMLElement ? n.nodes = [e] : n.nodes = e), await Q9(n);
}, "init");
var Ftt = S(async (t15, {
  lazyLoad: e = true
} = {}) => {
  Y0(), Nf(...t15), e === false && await ntt();
}, "registerExternalDiagrams");
var t_ = S(function() {
  if (Oi.startOnLoad) {
    const { startOnLoad: t15 } = so.getConfig();
    t15 && Oi.run().catch((e) => ut.error("Mermaid failed to initialize", e));
  }
}, "contentLoaded");
typeof document < "u" && window.addEventListener("load", t_, false);
var Ntt = S(function(t15) {
  Oi.parseError = t15;
}, "setParseErrorHandler");
var Yu = [];
var Pp = false;
var e_ = S(async () => {
  if (!Pp) {
    for (Pp = true; Yu.length > 0; ) {
      const t15 = Yu.shift();
      if (t15)
        try {
          await t15();
        } catch (e) {
          ut.error("Error executing queue", e);
        }
    }
    Pp = false;
  }
}, "executeQueue");
var Itt = S(async (t15, e) => new Promise((r, n) => {
  const i = S(() => new Promise((s, o) => {
    so.parse(t15, e).then(
      (a) => {
        s(a), r(a);
      },
      (a) => {
        var _a2;
        ut.error("Error parsing", a), (_a2 = Oi.parseError) == null ? void 0 : _a2.call(Oi, a), o(a), n(a);
      }
    );
  }), "performCall");
  Yu.push(i), e_().catch(n);
}), "parse");
var r_ = S((t15, e, r) => new Promise((n, i) => {
  const s = S(() => new Promise((o, a) => {
    so.render(t15, e, r).then(
      (l) => {
        o(l), n(l);
      },
      (l) => {
        var _a2;
        ut.error("Error parsing", l), (_a2 = Oi.parseError) == null ? void 0 : _a2.call(Oi, l), a(l), i(l);
      }
    );
  }), "performCall");
  Yu.push(s), e_().catch(i);
}), "render");
var Ott = S(() => Object.keys(Js).map((t15) => ({
  id: t15
})), "getRegisteredDiagramsMetadata");
var Oi = {
  startOnLoad: true,
  mermaidAPI: so,
  parse: Itt,
  render: r_,
  init: Dtt,
  run: Q9,
  registerExternalDiagrams: Ftt,
  registerLayoutLoaders: c9,
  initialize: J9,
  parseError: void 0,
  contentLoaded: t_,
  setParseErrorHandler: Ntt,
  detectType: Lm,
  registerIconPacks: sK,
  getRegisteredDiagramsMetadata: Ott
};
var f5 = Oi;
function ztt(t15) {
  navigator.clipboard.writeText(t15);
}
var Bs = /* @__PURE__ */ new Map();
var jp = /* @__PURE__ */ new Map();
var Jr = /* @__PURE__ */ new Map();
var fl = /* @__PURE__ */ new Map();
var Wp = /* @__PURE__ */ new Map();
var m5 = /* @__PURE__ */ new WeakMap();
var ki = /* @__PURE__ */ new Set();
function qtt(t15) {
  if (fl.has(t15))
    return fl.get(t15);
  if ((/* @__PURE__ */ new Set(["script", "style", "meta", "link", "noscript", "template"])).has(t15)) {
    const s = {};
    return fl.set(t15, s), s;
  }
  let e = document.getElementById("snapdom-sandbox");
  e || (e = document.createElement("div"), e.id = "snapdom-sandbox", e.style.position = "absolute", e.style.left = "-9999px", e.style.top = "-9999px", e.style.width = "0", e.style.height = "0", e.style.overflow = "hidden", document.body.appendChild(e));
  const r = document.createElement(t15);
  r.style.all = "initial", e.appendChild(r);
  const n = getComputedStyle(r), i = {};
  for (let s of n)
    i[s] = n.getPropertyValue(s);
  return e.removeChild(r), fl.set(t15, i), i;
}
function E1(t15, e, r = false) {
  const n = [], i = qtt(e);
  for (let [s, o] of Object.entries(t15))
    if (!r)
      o && n.push(`${s}:${o}`);
    else {
      const a = i[s];
      o && o !== a && n.push(`${s}:${o}`);
    }
  return n.sort().join(";");
}
function Rtt(t15) {
  const e = /* @__PURE__ */ new Set();
  return t15.nodeType !== Node.ELEMENT_NODE && t15.nodeType !== Node.DOCUMENT_FRAGMENT_NODE ? [] : (t15.tagName && e.add(t15.tagName.toLowerCase()), typeof t15.querySelectorAll == "function" && t15.querySelectorAll("*").forEach((r) => e.add(r.tagName.toLowerCase())), Array.from(e));
}
function Ptt(t15) {
  const e = /* @__PURE__ */ new Map();
  for (let n of t15) {
    const i = fl.get(n);
    if (!i) continue;
    const s = Object.entries(i).map(([o, a]) => `${o}:${a};`).sort().join("");
    e.has(s) || e.set(s, []), e.get(s).push(n);
  }
  let r = "";
  for (let [n, i] of e.entries())
    r += `${i.join(",")} { ${n} }
`;
  return r;
}
function jtt(t15) {
  const e = new Set(t15.values()), r = /* @__PURE__ */ new Map();
  let n = 1;
  for (const i of e)
    r.set(i, `c${n++}`);
  return r;
}
async function n_(t15, e = {}) {
  var _a2;
  const r = (_a2 = t15.match(/url\(["']?(.*?)["']?\)/)) == null ? void 0 : _a2[1];
  if (r) {
    const n = Fg(r);
    if (jp.has(n))
      return e.skipInline ? void 0 : `url(${jp.get(n)})`;
    {
      const i = await Dg(n, { useProxy: e.useProxy });
      return jp.set(n, i), e.skipInline ? void 0 : `url("${i}")`;
    }
  }
  return t15;
}
function Qa(t15, { fast: e = false } = {}) {
  if (e) return t15();
  "requestIdleCallback" in window ? requestIdleCallback(t15, { timeout: 50 }) : setTimeout(t15, 1);
}
function Lg(t15, e = null) {
  if (!(t15 instanceof Element))
    return window.getComputedStyle(t15, e);
  let r = m5.get(t15);
  if (r || (r = /* @__PURE__ */ new Map(), m5.set(t15, r)), !r.has(e)) {
    const n = window.getComputedStyle(t15, e);
    r.set(e, n);
  }
  return r.get(e);
}
function Wtt(t15) {
  let e = t15.replace(/^['"]|['"]$/g, "");
  if (e.startsWith("\\"))
    try {
      return String.fromCharCode(parseInt(e.replace("\\", ""), 16));
    } catch {
      return e;
    }
  return e;
}
function i_(t15) {
  const e = t15.indexOf("url(");
  if (e === -1) return null;
  let r = t15.slice(e + 4).trim();
  return r.endsWith(")") && (r = r.slice(0, -1).trim()), (r.startsWith('"') && r.endsWith('"') || r.startsWith("'") && r.endsWith("'")) && (r = r.slice(1, -1)), r;
}
function Dg(t15, { timeout: e = 3e3, useProxy: r = "" } = {}) {
  function n(o) {
    try {
      return new URL(o, window.location.href).origin === window.location.origin ? "use-credentials" : "anonymous";
    } catch {
      return "anonymous";
    }
  }
  async function i(o) {
    const a = (l) => fetch(l, {
      mode: "cors",
      credentials: n(l) === "use-credentials" ? "include" : "omit"
    }).then((c) => c.blob()).then((c) => new Promise((h10, p) => {
      const m = new FileReader();
      m.onloadend = () => {
        const g = m.result;
        if (typeof g != "string" || !g.startsWith("data:image/")) {
          p(new Error("Invalid image data URL"));
          return;
        }
        h10(g);
      }, m.onerror = () => p(new Error("FileReader error")), m.readAsDataURL(c);
    }));
    try {
      return await a(o);
    } catch {
      if (r && typeof r == "string") {
        const l = r.replace(/\/$/, "") + Fg(o);
        try {
          return await a(l);
        } catch {
          throw console.error(`[SnapDOM - fetchImage] Proxy fallback failed for: ${o}`), new Error("CORS restrictions prevented image capture (even via proxy)");
        }
      } else
        throw console.error(`[SnapDOM - fetchImage] No valid proxy URL provided for fallback: ${o}`), new Error("Fetch fallback failed and no proxy provided");
    }
  }
  const s = n(t15);
  return console.log(`[SnapDOM - fetchImage] Start loading image: ${t15} with crossOrigin=${s}`), Bs.has(t15) ? (console.log(`[SnapDOM - fetchImage] Cache hit for: ${t15}`), Promise.resolve(Bs.get(t15))) : t15.startsWith("data:image/") ? (Bs.set(t15, t15), Promise.resolve(t15)) : /\.svg(\?.*)?$/i.test(t15) ? (async () => {
    try {
      const o = await (await fetch(t15, {
        mode: "cors",
        credentials: s === "use-credentials" ? "include" : "omit"
      })).text(), a = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(o)}`;
      return Bs.set(t15, a), a;
    } catch {
      return i(t15);
    }
  })() : new Promise((o, a) => {
    const l = setTimeout(() => {
      console.log(`[SnapDOM - fetchImage] Timeout after ${e}ms for image: ${t15}`), a(new Error("Image load timed out"));
    }, e), c = new Image();
    c.crossOrigin = s, c.onload = async () => {
      clearTimeout(l);
      try {
        await c.decode();
        const h10 = document.createElement("canvas");
        h10.width = c.width, h10.height = c.height, h10.getContext("2d").drawImage(c, 0, 0, h10.width, h10.height);
        const p = h10.toDataURL("image/png");
        Bs.set(t15, p), o(p);
      } catch {
        try {
          const h10 = await i(t15);
          Bs.set(t15, h10), o(h10);
        } catch (h10) {
          a(h10);
        }
      }
    }, c.onerror = async () => {
      clearTimeout(l), console.error(`[SnapDOM - fetchImage] Image failed to load: ${t15}`);
      try {
        const h10 = await i(t15);
        Bs.set(t15, h10), o(h10);
      } catch (h10) {
        a(h10);
      }
    }, c.src = t15;
  });
}
function g5(t15) {
  const e = {};
  for (let r of t15)
    e[r] = t15.getPropertyValue(r);
  return e;
}
function s_() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function Htt(t15) {
  if (!t15 || t15 === "none") return "";
  let e = t15.replace(/translate[XY]?\([^)]*\)/g, "");
  return e = e.replace(/matrix\(([^)]+)\)/g, (r, n) => {
    const i = n.split(",").map((s) => s.trim());
    return i.length !== 6 ? `matrix(${n})` : (i[4] = "0", i[5] = "0", `matrix(${i.join(", ")})`);
  }), e = e.replace(/matrix3d\(([^)]+)\)/g, (r, n) => {
    const i = n.split(",").map((s) => s.trim());
    return i.length !== 16 ? `matrix3d(${n})` : (i[12] = "0", i[13] = "0", `matrix3d(${i.join(", ")})`);
  }), e.trim().replace(/\s{2,}/g, " ");
}
function Fg(t15) {
  if (/%[0-9A-Fa-f]{2}/.test(t15)) return t15;
  try {
    return encodeURI(t15);
  } catch {
    return t15;
  }
}
function o_(t15) {
  const e = [];
  let r = 0, n = 0;
  for (let i = 0; i < t15.length; i++) {
    const s = t15[i];
    s === "(" && r++, s === ")" && r--, s === "," && r === 0 && (e.push(t15.slice(n, i).trim()), n = i + 1);
  }
  return e.push(t15.slice(n).trim()), e;
}
var Hp = /* @__PURE__ */ new WeakMap();
var Up = /* @__PURE__ */ new Map();
function Utt(t15) {
  const e = {};
  for (let r = 0; r < t15.length; r++) {
    const n = t15[r];
    let i = t15.getPropertyValue(n);
    (n === "background-image" || n === "content") && i.includes("url(") && !i.includes("data:") && (i = "none"), e[n] = i;
  }
  return e;
}
function y5(t15, e, r, n, i) {
  var _a2;
  if (t15.tagName === "STYLE") return;
  n.has(t15) || n.set(t15, Lg(t15));
  const s = n.get(t15);
  if (!Hp.has(t15)) {
    const h10 = Utt(s);
    Hp.set(t15, h10);
  }
  const o = Hp.get(t15), a = Object.entries(o).sort(([h10], [p]) => h10.localeCompare(p)).map(([h10, p]) => `${h10}:${p}`).join(";");
  if (Up.has(a)) {
    r.set(e, Up.get(a));
    return;
  }
  const l = ((_a2 = t15.tagName) == null ? void 0 : _a2.toLowerCase()) || "div", c = E1(o, l, i);
  Up.set(a, c), r.set(e, c);
}
function Vtt(t15) {
  return t15.nodeType === Node.ELEMENT_NODE && t15.tagName === "SLOT";
}
function Uh(t15, e, r, n, i, s = {}, o) {
  var _a2, _b2;
  if (t15.nodeType === Node.TEXT_NODE || t15.nodeType !== Node.ELEMENT_NODE) return t15.cloneNode(true);
  if (t15.getAttribute("data-capture") === "exclude") {
    const l = document.createElement("div"), c = t15.getBoundingClientRect();
    return l.style.cssText = `display: inline-block; width: ${c.width}px; height: ${c.height}px; visibility: hidden;`, l;
  }
  if (s.exclude && Array.isArray(s.exclude))
    for (const l of s.exclude)
      try {
        if ((_a2 = t15.matches) == null ? void 0 : _a2.call(t15, l)) {
          const c = document.createElement("div"), h10 = t15.getBoundingClientRect();
          return c.style.cssText = `display: inline-block; width: ${h10.width}px; height: ${h10.height}px; visibility: hidden;`, c;
        }
      } catch (c) {
        console.warn(`Invalid selector in exclude option: ${l}`, c);
      }
  if (typeof s.filter == "function")
    try {
      if (!s.filter(t15, o || t15)) {
        const l = document.createElement("div"), c = t15.getBoundingClientRect();
        return l.style.cssText = `display: inline-block; width: ${c.width}px; height: ${c.height}px; visibility: hidden;`, l;
      }
    } catch (l) {
      console.warn("Error in filter function:", l);
    }
  if (t15.tagName === "IFRAME") {
    const l = document.createElement("div");
    return l.textContent = "", l.style.cssText = `width: ${t15.offsetWidth}px; height: ${t15.offsetHeight}px; background-image: repeating-linear-gradient(45deg, #ddd, #ddd 5px, #f9f9f9 5px, #f9f9f9 10px);display: flex;align-items: center;justify-content: center;font-size: 12px;color: #555; border: 1px solid #aaa;`, l;
  }
  if (t15.getAttribute("data-capture") === "placeholder") {
    const l = t15.cloneNode(false);
    n.set(l, t15), y5(t15, l, e, r, i);
    const c = document.createElement("div");
    return c.textContent = t15.getAttribute("data-placeholder-text") || "", c.style.cssText = "color: #666;font-size: 12px;text-align: center;line-height: 1.4;padding: 0.5em;box-sizing: border-box;", l.appendChild(c), l;
  }
  if (t15.tagName === "CANVAS") {
    const l = t15.toDataURL(), c = document.createElement("img");
    return c.src = l, c.width = t15.width, c.height = t15.height, c.style.display = "inline-block", c.style.width = t15.style.width || `${t15.width}px`, c.style.height = t15.style.height || `${t15.height}px`, c;
  }
  const a = t15.cloneNode(false);
  if (n.set(a, t15), t15 instanceof HTMLInputElement)
    a.value = t15.value, a.setAttribute("value", t15.value), t15.checked !== void 0 && (a.checked = t15.checked, t15.checked && a.setAttribute("checked", ""));
  else if (t15 instanceof HTMLTextAreaElement) {
    const l = t15.getBoundingClientRect();
    a.textContent = t15.value, a.style.width = `${l.width}px`, a.style.height = `${l.height}px`;
  } else t15 instanceof HTMLSelectElement && (a.value = t15.value, Array.from(a.options).forEach((l) => {
    l.value === t15.value ? l.setAttribute("selected", "") : l.removeAttribute("selected");
  }));
  if (y5(t15, a, e, r, i), Vtt(t15)) {
    const l = ((_b2 = t15.assignedNodes) == null ? void 0 : _b2.call(t15, { flatten: true })) || [], c = l.length > 0 ? l : Array.from(t15.childNodes), h10 = document.createDocumentFragment();
    for (const p of c) {
      const m = Uh(p, e, r, n, i, s, o || t15);
      m && h10.appendChild(m);
    }
    return h10;
  } else if (!(t15 instanceof HTMLTextAreaElement)) {
    const l = t15.shadowRoot ? t15.shadowRoot.childNodes : t15.childNodes;
    for (const c of l) {
      const h10 = Uh(c, e, r, n, i, s, o || t15);
      h10 && a.appendChild(h10);
    }
    if (t15.shadowRoot && t15.childNodes.length > 0 && !t15.shadowRoot.querySelector("slot")) {
      const c = document.createDocumentFragment();
      for (const h10 of t15.childNodes) {
        const p = Uh(h10, e, r, n, i, s, o || t15);
        p && c.appendChild(p);
      }
      a.appendChild(c);
    }
  }
  return a;
}
var Gtt = [
  // /uicons/i,
  /font\s*awesome/i,
  /material\s*icons/i,
  /ionicons/i,
  /glyphicons/i,
  /feather/i,
  /bootstrap\s*icons/i,
  /remix\s*icons/i,
  /heroicons/i,
  /layui/i,
  /lucide/i
];
var M1 = [];
function Xtt(t15) {
  const e = Array.isArray(t15) ? t15 : [t15];
  for (const r of e)
    r instanceof RegExp ? M1.push(r) : typeof r == "string" ? M1.push(new RegExp(r, "i")) : console.warn("[snapdom] Ignored invalid iconFont value:", r);
}
function Yi(t15) {
  const e = typeof t15 == "string" ? t15 : "", r = [...Gtt, ...M1];
  for (const n of r)
    if (n instanceof RegExp && n.test(e)) return true;
  return !!(/icon/i.test(e) || /glyph/i.test(e) || /symbols/i.test(e) || /feather/i.test(e) || /fontawesome/i.test(e));
}
async function Ytt(t15, e, r, n = 32, i = "#000") {
  e = e.replace(/^['"]+|['"]+$/g, "");
  const s = window.devicePixelRatio || 1, o = document.createElement("canvas").getContext("2d");
  o.font = r ? `${r} ${n}px "${e}"` : `${n}px "${e}"`;
  const a = o.measureText(t15), l = a.actualBoundingBoxAscent || n * 0.8, c = a.actualBoundingBoxDescent || n * 0.2, h10 = l + c, p = a.width, m = document.createElement("canvas");
  m.width = Math.ceil(p * s), m.height = Math.ceil(h10 * s);
  const g = m.getContext("2d");
  return g.scale(s, s), g.font = o.font, g.textAlign = "left", g.textBaseline = "alphabetic", g.fillStyle = i, g.fillText(t15, 0, l), m.toDataURL();
}
function a_(t15) {
  return Array.from(document.styleSheets).some((e) => e.href === t15);
}
function Ktt(t15) {
  return new Promise((e) => {
    if (a_(t15)) return e(null);
    const r = document.createElement("link");
    r.rel = "stylesheet", r.href = t15, r.setAttribute("data-snapdom", "injected-import"), r.onload = () => e(r), r.onerror = () => e(null), document.head.appendChild(r);
  });
}
async function Ztt({ preCached: t15 = false } = {}) {
  if (Jr.has("fonts-embed-css")) {
    if (t15) {
      const s = document.createElement("style");
      s.setAttribute("data-snapdom", "embedFonts"), s.textContent = Jr.get("fonts-embed-css"), document.head.appendChild(s);
    }
    return Jr.get("fonts-embed-css");
  }
  const e = /@import\s+url\(["']?([^"')]+)["']?\)/g, r = [];
  for (const s of document.querySelectorAll("style")) {
    const o = s.textContent || "", a = Array.from(o.matchAll(e));
    for (const l of a) {
      const c = l[1];
      Yi(c) || a_(c) || r.push(c);
    }
  }
  await Promise.all(r.map(Ktt));
  const n = Array.from(document.querySelectorAll('link[rel="stylesheet"]')).filter((s) => s.href);
  let i = "";
  for (const s of n)
    try {
      const o = await (await fetch(s.href)).text();
      if (Yi(s.href) || Yi(o)) continue;
      const a = /url\((["']?)([^"')]+)\1\)/g, l = await Promise.all(
        Array.from(o.matchAll(a)).map(async (h10) => {
          let p = i_(h10[0]);
          if (!p) return null;
          let m = p;
          if (!m.startsWith("http") && !m.startsWith("data:") && (m = new URL(m, s.href).href), Yi(m)) return null;
          if (Jr.has(m))
            return ki.add(m), { original: h10[0], inlined: `url(${Jr.get(m)})` };
          if (ki.has(m)) return null;
          try {
            const g = await (await fetch(m)).blob(), y = await new Promise((x) => {
              const k = new FileReader();
              k.onload = () => x(k.result), k.readAsDataURL(g);
            });
            return Jr.set(m, y), ki.add(m), { original: h10[0], inlined: `url(${y})` };
          } catch {
            return console.warn("[snapdom] Failed to fetch font resource:", m), null;
          }
        })
      );
      let c = o;
      for (const h10 of l)
        h10 && (c = c.replace(h10.original, h10.inlined));
      i += c + `
`;
    } catch {
      console.warn("[snapdom] Failed to fetch CSS:", s.href);
    }
  for (const s of document.styleSheets)
    try {
      if (!s.href || n.every((o) => o.href !== s.href)) {
        for (const o of s.cssRules)
          if (o.type === CSSRule.FONT_FACE_RULE) {
            const a = o.style.getPropertyValue("src"), l = o.style.getPropertyValue("font-family");
            if (!a || Yi(l)) continue;
            const c = /url\((["']?)([^"')]+)\1\)/g;
            let h10 = a;
            const p = Array.from(a.matchAll(c));
            for (const m of p) {
              let g = m[2].trim();
              if (!g) continue;
              let y = g;
              if (!y.startsWith("http") && !y.startsWith("data:") && (y = new URL(y, s.href || location.href).href), !Yi(y)) {
                if (Jr.has(y)) {
                  ki.add(y), h10 = h10.replace(m[0], `url(${Jr.get(y)})`);
                  continue;
                }
                if (!ki.has(y))
                  try {
                    const x = await (await fetch(y)).blob(), k = await new Promise((C) => {
                      const _ = new FileReader();
                      _.onload = () => C(_.result), _.readAsDataURL(x);
                    });
                    Jr.set(y, k), ki.add(y), h10 = h10.replace(m[0], `url(${k})`);
                  } catch {
                    console.warn("[snapdom] Failed to fetch font URL:", y);
                  }
              }
            }
            i += `@font-face {
  font-family: ${l};
  src: ${h10};
  font-style: ${o.style.getPropertyValue("font-style") || "normal"};
  font-weight: ${o.style.getPropertyValue("font-weight") || "normal"};
}
`;
          }
      }
    } catch (o) {
      console.warn("[snapdom] Cannot access stylesheet", s.href, o);
    }
  for (const s of document.fonts)
    if (s.family && s.status === "loaded" && s._snapdomSrc) {
      if (Yi(s.family)) continue;
      let o = s._snapdomSrc;
      if (!o.startsWith("data:")) {
        if (Jr.has(s._snapdomSrc))
          o = Jr.get(s._snapdomSrc), ki.add(s._snapdomSrc);
        else if (!ki.has(s._snapdomSrc))
          try {
            const a = await (await fetch(s._snapdomSrc)).blob();
            o = await new Promise((l) => {
              const c = new FileReader();
              c.onload = () => l(c.result), c.readAsDataURL(a);
            }), Jr.set(s._snapdomSrc, o), ki.add(s._snapdomSrc);
          } catch {
            console.warn("[snapdom] Failed to fetch dynamic font src:", s._snapdomSrc);
            continue;
          }
      }
      i += `@font-face {
  font-family: '${s.family}';
  src: url(${o});
  font-style: ${s.style || "normal"};
  font-weight: ${s.weight || "normal"};
}
`;
    }
  if (i && (Jr.set("fonts-embed-css", i), t15)) {
    const s = document.createElement("style");
    s.setAttribute("data-snapdom", "embedFonts"), s.textContent = i, document.head.appendChild(s);
  }
  return i;
}
async function l_(t15, e, r, n, i, s = false, o) {
  var _a2;
  if (!(t15 instanceof Element) || !(e instanceof Element)) return;
  for (const c of ["::before", "::after", "::first-letter"])
    try {
      const h10 = Lg(t15, c);
      if (!h10 || typeof h10[Symbol.iterator] != "function") continue;
      if (c === "::first-letter") {
        const C = getComputedStyle(t15);
        if (!(h10.color !== C.color || h10.fontSize !== C.fontSize || h10.fontWeight !== C.fontWeight)) continue;
        const _ = Array.from(e.childNodes).find(
          (W) => W.nodeType === Node.TEXT_NODE && W.textContent && W.textContent.trim().length > 0
        );
        if (!_) continue;
        const $ = _.textContent, L = (_a2 = $.match(/^([^\p{L}\p{N}\s]*[\p{L}\p{N}](?:['’])?)/u)) == null ? void 0 : _a2[0], B = $.slice((L == null ? void 0 : L.length) || 0);
        if (!L || /[\uD800-\uDFFF]/.test(L)) continue;
        const q = document.createElement("span");
        q.textContent = L, q.dataset.snapdomPseudo = "::first-letter";
        const H = g5(h10), G = E1(H, "span", i);
        r.set(q, G);
        const F = document.createTextNode(B);
        e.replaceChild(F, _), e.insertBefore(q, F);
        continue;
      }
      const p = h10.getPropertyValue("content"), m = h10.getPropertyValue("background-image"), g = h10.getPropertyValue("background-color"), y = p !== "none", x = m && m !== "none", k = g && g !== "transparent" && g !== "rgba(0, 0, 0, 0)";
      if (y || x || k) {
        const C = h10.getPropertyValue("font-family"), _ = parseInt(h10.getPropertyValue("font-size")) || 32, $ = parseInt(h10.getPropertyValue("font-weight")) || false, L = h10.getPropertyValue("color") || "#000", B = document.createElement("span");
        B.dataset.snapdomPseudo = c;
        const q = g5(h10), H = E1(q, "span", i);
        r.set(B, H);
        const G = Yi(C), F = Wtt(p);
        if (G && F.length === 1) {
          const W = document.createElement("img");
          W.src = await Ytt(F, C, $, _, L), W.style = `width:${_}px;height:auto;object-fit:contain;`, B.appendChild(W);
        } else if (F.startsWith("url(")) {
          const W = i_(F);
          if (W && W.trim() !== "")
            try {
              const R = document.createElement("img"), J = await Dg(Fg(W, { useProxy: o }));
              R.src = J, R.style = `width:${_}px;height:auto;object-fit:contain;`, B.appendChild(R);
            } catch (R) {
              console.error(`[snapdom] Error in pseudo ${c} for`, t15, R);
            }
        } else !G && F && F !== "none" && (B.textContent = F);
        if (x)
          try {
            const W = o_(m), R = await Promise.all(
              W.map((J) => n_(J))
            );
            B.style.backgroundImage = R.join(", ");
          } catch (W) {
            console.warn(`[snapdom] Failed to inline background-image for ${c}`, W);
          }
        if (k && (B.style.backgroundColor = g), !(B.childNodes.length > 0 || B.textContent && B.textContent.trim() !== "" || x || k)) continue;
        c === "::before" ? e.insertBefore(B, e.firstChild) : e.appendChild(B);
      }
    } catch (h10) {
      console.warn(`[snapdom] Failed to capture ${c} for`, t15, h10);
    }
  const a = Array.from(t15.children), l = Array.from(e.children).filter((c) => !c.dataset.snapdomPseudo);
  for (let c = 0; c < Math.min(a.length, l.length); c++)
    await l_(
      a[c],
      l[c],
      r,
      n,
      i,
      s,
      o
    );
}
function Qtt(t15) {
  if (!t15) return;
  const e = document.querySelectorAll("svg > defs");
  e.length && t15.querySelectorAll("svg").forEach((r) => {
    const n = r.querySelectorAll("use");
    if (!n.length) return;
    const i = /* @__PURE__ */ new Set();
    if (n.forEach((o) => {
      const a = o.getAttribute("xlink:href") || o.getAttribute("href");
      a && a.startsWith("#") && i.add(a.slice(1));
    }), !i.size) return;
    const s = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    for (const o of i)
      for (const a of e) {
        const l = a.querySelector(`#${CSS.escape(o)}`);
        if (l) {
          s.appendChild(l.cloneNode(true));
          break;
        }
      }
    s.childNodes.length && r.insertBefore(s, r.firstChild);
  });
}
async function Jtt(t15, e = false, r = false, n = {}) {
  var _a2;
  const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new Map();
  let a;
  try {
    a = Uh(t15, i, s, o, e, n, t15);
  } catch (c) {
    throw console.warn("deepClone failed:", c), c;
  }
  try {
    await l_(t15, a, i, s, e, r, n.useProxy);
  } catch (c) {
    console.warn("inlinePseudoElements failed:", c);
  }
  try {
    Qtt(a);
  } catch (c) {
    console.warn("inlineExternalDef failed:", c);
  }
  let l = "";
  if (e) {
    const c = jtt(i);
    l = Array.from(c.entries()).map(([h10, p]) => `.${p}{${h10}}`).join("");
    for (const [h10, p] of i.entries()) {
      if (h10.tagName === "STYLE") continue;
      const m = c.get(p);
      m && h10.classList.add(m);
      const g = (_a2 = h10.style) == null ? void 0 : _a2.backgroundImage;
      h10.removeAttribute("style"), g && g !== "none" && (h10.style.backgroundImage = g);
    }
  } else
    for (const [c, h10] of i.entries())
      c.tagName !== "STYLE" && c.setAttribute("style", h10.replace(/;/g, "; "));
  for (const [c, h10] of o.entries()) {
    const p = h10.scrollLeft, m = h10.scrollTop;
    if ((p || m) && c instanceof HTMLElement) {
      c.style.overflow = "hidden", c.style.scrollbarWidth = "none", c.style.msOverflowStyle = "none";
      const g = document.createElement("div");
      for (g.style.transform = `translate(${-p}px, ${-m}px)`, g.style.willChange = "transform", g.style.display = "inline-block", g.style.width = "100%"; c.firstChild; )
        g.appendChild(c.firstChild);
      c.appendChild(g);
    }
  }
  if (t15 === o.get(a)) {
    const c = s.get(t15) || window.getComputedStyle(t15);
    s.set(t15, c);
    const h10 = Htt(c.transform);
    a.style.margin = "0", a.style.position = "static", a.style.top = "auto", a.style.left = "auto", a.style.right = "auto", a.style.bottom = "auto", a.style.zIndex = "auto", a.style.float = "none", a.style.clear = "none", a.style.transform = h10 || "";
  }
  for (const [c, h10] of o.entries())
    h10.tagName === "PRE" && (c.style.marginTop = "0", c.style.marginBlockStart = "0");
  return { clone: a, classCSS: l, styleCache: s };
}
async function tet(t15, e = {}) {
  const r = Array.from(t15.querySelectorAll("img")), n = async (i) => {
    const s = i.src;
    try {
      const o = await Dg(s, { useProxy: e.useProxy });
      i.src = o, i.width || (i.width = i.naturalWidth || 100), i.height || (i.height = i.naturalHeight || 100);
    } catch {
      const o = document.createElement("div");
      o.style = `width: ${i.width || 100}px; height: ${i.height || 100}px; background: #ccc; display: inline-block; text-align: center; line-height: ${i.height || 100}px; color: #666; font-size: 12px;`, o.innerText = "img", i.replaceWith(o);
    }
  };
  for (let i = 0; i < r.length; i += 4) {
    const s = r.slice(i, i + 4).map(n);
    await Promise.allSettled(s);
  }
}
async function eet(t15, e, r, n = {}) {
  const i = [[t15, e]], s = [
    "background-image",
    "mask",
    "mask-image",
    "-webkit-mask-image",
    "mask-source",
    "mask-box-image-source",
    "mask-border-source",
    "-webkit-mask-box-image-source"
  ];
  for (; i.length; ) {
    const [o, a] = i.shift(), l = r.get(o) || Lg(o);
    r.has(o) || r.set(o, l);
    for (const m of s) {
      const g = l.getPropertyValue(m);
      if (!g || g === "none") continue;
      const y = o_(g), x = await Promise.all(
        y.map((k) => n_(k, n))
      );
      x.some((k) => k && k !== "none" && !/^url\(undefined/.test(k)) && a.style.setProperty(m, x.join(", "));
    }
    const c = l.getPropertyValue("background-color");
    c && c !== "transparent" && c !== "rgba(0, 0, 0, 0)" && (a.style.backgroundColor = c);
    const h10 = Array.from(o.children), p = Array.from(a.children);
    for (let m = 0; m < Math.min(h10.length, p.length); m++)
      i.push([h10[m], p[m]]);
  }
}
async function ret(t15, e = {}) {
  if (!t15) throw new Error("Element cannot be null or undefined");
  const { compress: r = true, embedFonts: n = false, fast: i = true, scale: s = 1, useProxy: o = "" } = e;
  let a, l, c, h10 = "", p = "", m, g;
  if ({ clone: a, classCSS: l, styleCache: c } = await Jtt(t15, r, n, e), await new Promise((x) => {
    Qa(async () => {
      await tet(a, e), x();
    }, { fast: i });
  }), await new Promise((x) => {
    Qa(async () => {
      await eet(t15, a, c, e), x();
    }, { fast: i });
  }), n && await new Promise((x) => {
    Qa(async () => {
      h10 = await Ztt(), x();
    }, { fast: i });
  }), r) {
    const x = Rtt(a).sort(), k = x.join(",");
    Wp.has(k) ? p = Wp.get(k) : await new Promise((C) => {
      Qa(() => {
        p = Ptt(x), Wp.set(k, p), C();
      }, { fast: i });
    });
  }
  await new Promise((x) => {
    Qa(() => {
      const k = t15.getBoundingClientRect();
      let C = k.width, _ = k.height;
      const $ = Number.isFinite(e.width), L = Number.isFinite(e.height), B = typeof s == "number" && s !== 1;
      if (!B) {
        const W = k.width / k.height;
        $ && L ? (C = e.width, _ = e.height) : $ ? (C = e.width, _ = C / W) : L && (_ = e.height, C = _ * W);
      }
      if (C = Math.ceil(C), _ = Math.ceil(_), a.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), a.style.transformOrigin = "top left", !B && ($ || L)) {
        const W = k.width, R = k.height, J = C / W, rt = _ / R, I = a.style.transform || "", j = `scale(${J}, ${rt})`;
        a.style.transform = `${j} ${I}`.trim();
      } else B && s_() && (a.style.scale = `${s}`);
      const q = "http://www.w3.org/2000/svg", H = document.createElementNS(q, "foreignObject");
      H.setAttribute("width", "100%"), H.setAttribute("height", "100%");
      const G = document.createElement("style");
      G.textContent = p + h10 + "svg{overflow:visible;}" + l, H.appendChild(G), H.appendChild(a);
      const F = new XMLSerializer().serializeToString(H);
      g = `<svg xmlns="${q}" width="${C}" height="${_}" viewBox="0 0 ${C} ${_}">` + F + "</svg>", m = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(g)}`, x();
    }, { fast: i });
  });
  const y = document.getElementById("snapdom-sandbox");
  return y && y.style.position === "absolute" && y.remove(), m;
}
async function net(t15, { dpr: e = 1, scale: r = 1 }) {
  const n = new Image();
  return n.src = t15, await n.decode(), s_ ? (n.width = n.width * r, n.height = n.height * r) : (n.width = n.width / r, n.height = n.height / r), n;
}
async function c_(t15, { dpr: e = 1, scale: r = 1 } = {}) {
  const n = new Image();
  n.src = t15, await n.decode();
  const i = document.createElement("canvas"), s = n.width * r, o = n.height * r;
  i.width = Math.ceil(s * e), i.height = Math.ceil(o * e);
  const a = i.getContext("2d");
  return a.scale(e, e), a.drawImage(n, 0, 0, s, o), i.style.width = `${s}px`, i.style.height = `${o}px`, i;
}
async function h_(t15, {
  type: e = "svg",
  scale: r = 1,
  backgroundColor: n = "#fff",
  quality: i
} = {}) {
  const s = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[e] || "image/png";
  if (e === "svg") {
    const a = decodeURIComponent(t15.split(",")[1]);
    return new Blob([a], { type: "image/svg+xml" });
  }
  const o = await Ng(t15, { dpr: 1, scale: r }, n);
  return new Promise((a) => {
    o.toBlob((l) => a(l), `${s}`, i);
  });
}
async function Ng(t15, { dpr: e = 1, scale: r = 1 }, n) {
  const i = await c_(t15, { dpr: e, scale: r });
  if (!n) return i;
  const s = document.createElement("canvas");
  s.width = i.width, s.height = i.height;
  const o = s.getContext("2d");
  return o.fillStyle = n, o.fillRect(0, 0, s.width, s.height), o.drawImage(i, 0, 0), s;
}
async function Vp(t15, { dpr: e = 1, scale: r = 1, backgroundColor: n = "#fff", quality: i }, s = "png") {
  const o = await Ng(t15, { dpr: e, scale: r }, n), a = new Image();
  return a.src = o.toDataURL(`image/${s}`, i), await a.decode(), a.style.width = `${o.width / e}px`, a.style.height = `${o.height / e}px`, a;
}
async function iet(t15, { dpr: e = 1, scale: r = 1, backgroundColor: n = "#fff", format: i = "png", filename: s = "capture" } = {}) {
  if (i === "svg") {
    const p = await h_(t15), m = URL.createObjectURL(p), g = document.createElement("a");
    g.href = m, g.download = `${s}.svg`, g.click(), URL.revokeObjectURL(m);
    return;
  }
  const o = ["jpg", "jpeg", "webp"].includes(i) ? "#fff" : void 0, a = await Ng(t15, { dpr: e, scale: r }, n ?? o), l = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[i] || "image/png", c = a.toDataURL(l), h10 = document.createElement("a");
  h10.href = c, h10.download = `${s}.${i}`, h10.click();
}
async function Je(t15, e = {}) {
  if (e = { scale: 1, ...e }, !t15) throw new Error("Element cannot be null or undefined");
  return e.iconFonts && Xtt(e.iconFonts), await Je.capture(t15, e);
}
Je.capture = async (t15, e = {}) => {
  const r = await ret(t15, e), n = window.devicePixelRatio || 1, i = e.scale || 1;
  return {
    url: r,
    options: e,
    toRaw: () => r,
    toImg: () => net(r, { dpr: n, scale: i }),
    toCanvas: () => c_(r, { dpr: n, scale: i }),
    toBlob: (s) => h_(r, { scale: i, ...s }),
    toPng: (s) => Vp(r, { dpr: n, scale: i, ...s }, "png"),
    toJpg: (s) => Vp(r, { dpr: n, scale: i, ...s }, "jpeg"),
    toWebp: (s) => Vp(r, { dpr: n, scale: i, ...s }, "webp"),
    download: ({ format: s = "png", filename: o = "capture", backgroundColor: a } = {}) => iet(r, { dpr: n, scale: i, backgroundColor: a, format: s, filename: o })
  };
};
Je.toRaw = async (t15, e) => (await Je.capture(t15, e)).toRaw();
Je.toImg = async (t15, e) => (await Je.capture(t15, e)).toImg();
Je.toCanvas = async (t15, e) => (await Je.capture(t15, e)).toCanvas();
Je.toBlob = async (t15, e) => (await Je.capture(t15, e)).toBlob(e);
Je.toPng = async (t15, e) => (await Je.capture(t15, e)).toPng(e);
Je.toJpg = async (t15, e) => (await Je.capture(t15, e)).toJpg(e);
Je.toWebp = async (t15, e) => (await Je.capture(t15, e)).toWebp(e);
Je.download = async (t15, e = {}) => {
  const {
    format: r = "png",
    filename: n = "capture",
    backgroundColor: i,
    ...s
  } = e;
  return await (await Je.capture(t15, s)).download({ format: r, filename: n, backgroundColor: i });
};
function kc(t15) {
  return getCurrentScope() ? (onScopeDispose(t15), true) : false;
}
var K0 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var set = (t15) => t15 != null;
var oet = Object.prototype.toString;
var u_ = (t15) => oet.call(t15) === "[object Object]";
var aet = () => {
};
var b5 = cet();
function cet() {
  var t15, e;
  return K0 && ((t15 = window == null ? void 0 : window.navigator) == null ? void 0 : t15.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function het(...t15) {
  if (t15.length !== 1)
    return toRef(...t15);
  const e = t15[0];
  return typeof e == "function" ? readonly(customRef(() => ({ get: e, set: aet }))) : ref(e);
}
function Xs(t15) {
  return Array.isArray(t15) ? t15 : [t15];
}
function uet(t15) {
  return getCurrentInstance();
}
function det(t15, e = true, r) {
  uet() ? onMounted(t15, r) : e ? t15() : nextTick(t15);
}
function d_(t15, e, r) {
  return watch(
    t15,
    e,
    {
      ...r,
      immediate: true
    }
  );
}
var p_ = K0 ? window : void 0;
var pet = K0 ? window.document : void 0;
function Ku(t15) {
  var e;
  const r = toValue(t15);
  return (e = r == null ? void 0 : r.$el) != null ? e : r;
}
function x5(...t15) {
  const e = [], r = () => {
    e.forEach((a) => a()), e.length = 0;
  }, n = (a, l, c, h10) => (a.addEventListener(l, c, h10), () => a.removeEventListener(l, c, h10)), i = computed(() => {
    const a = Xs(toValue(t15[0])).filter((l) => l != null);
    return a.every((l) => typeof l != "string") ? a : void 0;
  }), s = d_(
    () => {
      var a, l;
      return [
        (l = (a = i.value) == null ? void 0 : a.map((c) => Ku(c))) != null ? l : [p_].filter((c) => c != null),
        Xs(toValue(i.value ? t15[1] : t15[0])),
        Xs(unref(i.value ? t15[2] : t15[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(i.value ? t15[3] : t15[2])
      ];
    },
    ([a, l, c, h10]) => {
      if (r(), !(a == null ? void 0 : a.length) || !(l == null ? void 0 : l.length) || !(c == null ? void 0 : c.length))
        return;
      const p = u_(h10) ? { ...h10 } : h10;
      e.push(
        ...a.flatMap(
          (m) => l.flatMap(
            (g) => c.map((y) => n(m, g, y, p))
          )
        )
      );
    },
    { flush: "post" }
  ), o = () => {
    s(), r();
  };
  return kc(r), o;
}
function fet() {
  const t15 = shallowRef(false), e = getCurrentInstance();
  return e && onMounted(() => {
    t15.value = true;
  }, e), t15;
}
function f_(t15) {
  const e = fet();
  return computed(() => (e.value, !!t15()));
}
function met(t15, e, r = {}) {
  const { window: n = p_, ...i } = r;
  let s;
  const o = f_(() => n && "MutationObserver" in n), a = () => {
    s && (s.disconnect(), s = void 0);
  }, l = computed(() => {
    const m = toValue(t15), g = Xs(m).map(Ku).filter(set);
    return new Set(g);
  }), c = watch(
    () => l.value,
    (m) => {
      a(), o.value && m.size && (s = new MutationObserver(e), m.forEach((g) => s.observe(g, i)));
    },
    { immediate: true, flush: "post" }
  ), h10 = () => s == null ? void 0 : s.takeRecords(), p = () => {
    c(), a();
  };
  return kc(p), {
    isSupported: o,
    stop: p,
    takeRecords: h10
  };
}
var w5 = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function get(t15, e = {}) {
  const {
    document: r = pet,
    autoExit: n = false
  } = e, i = computed(() => {
    var _;
    return (_ = Ku(t15)) != null ? _ : r == null ? void 0 : r.documentElement;
  }), s = shallowRef(false), o = computed(() => [
    "requestFullscreen",
    "webkitRequestFullscreen",
    "webkitEnterFullscreen",
    "webkitEnterFullScreen",
    "webkitRequestFullScreen",
    "mozRequestFullScreen",
    "msRequestFullscreen"
  ].find((_) => r && _ in r || i.value && _ in i.value)), a = computed(() => [
    "exitFullscreen",
    "webkitExitFullscreen",
    "webkitExitFullScreen",
    "webkitCancelFullScreen",
    "mozCancelFullScreen",
    "msExitFullscreen"
  ].find((_) => r && _ in r || i.value && _ in i.value)), l = computed(() => [
    "fullScreen",
    "webkitIsFullScreen",
    "webkitDisplayingFullscreen",
    "mozFullScreen",
    "msFullscreenElement"
  ].find((_) => r && _ in r || i.value && _ in i.value)), c = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((_) => r && _ in r), h10 = f_(() => i.value && r && o.value !== void 0 && a.value !== void 0 && l.value !== void 0), p = () => c ? (r == null ? void 0 : r[c]) === i.value : false, m = () => {
    if (l.value) {
      if (r && r[l.value] != null)
        return r[l.value];
      {
        const _ = i.value;
        if ((_ == null ? void 0 : _[l.value]) != null)
          return !!_[l.value];
      }
    }
    return false;
  };
  async function g() {
    if (!(!h10.value || !s.value)) {
      if (a.value)
        if ((r == null ? void 0 : r[a.value]) != null)
          await r[a.value]();
        else {
          const _ = i.value;
          (_ == null ? void 0 : _[a.value]) != null && await _[a.value]();
        }
      s.value = false;
    }
  }
  async function y() {
    if (!h10.value || s.value)
      return;
    m() && await g();
    const _ = i.value;
    o.value && (_ == null ? void 0 : _[o.value]) != null && (await _[o.value](), s.value = true);
  }
  async function x() {
    await (s.value ? g() : y());
  }
  const k = () => {
    const _ = m();
    (!_ || _ && p()) && (s.value = _);
  }, C = { capture: false, passive: true };
  return x5(r, w5, k, C), x5(() => Ku(i), w5, k, C), det(k, false), n && kc(g), {
    isSupported: h10,
    isFullscreen: s,
    enter: y,
    exit: g,
    toggle: x
  };
}
var yet = K0 ? window : void 0;
function bet(t15) {
  var e;
  const r = toValue(t15);
  return (e = r == null ? void 0 : r.$el) != null ? e : r;
}
function xet(...t15) {
  const e = [], r = () => {
    e.forEach((a) => a()), e.length = 0;
  }, n = (a, l, c, h10) => (a.addEventListener(l, c, h10), () => a.removeEventListener(l, c, h10)), i = computed(() => {
    const a = Xs(toValue(t15[0])).filter((l) => l != null);
    return a.every((l) => typeof l != "string") ? a : void 0;
  }), s = d_(
    () => {
      var a, l;
      return [
        (l = (a = i.value) == null ? void 0 : a.map((c) => bet(c))) != null ? l : [yet].filter((c) => c != null),
        Xs(toValue(i.value ? t15[1] : t15[0])),
        Xs(unref(i.value ? t15[2] : t15[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(i.value ? t15[3] : t15[2])
      ];
    },
    ([a, l, c, h10]) => {
      if (r(), !(a == null ? void 0 : a.length) || !(l == null ? void 0 : l.length) || !(c == null ? void 0 : c.length))
        return;
      const p = u_(h10) ? { ...h10 } : h10;
      e.push(
        ...a.flatMap(
          (m) => l.flatMap(
            (g) => c.map((y) => n(m, g, y, p))
          )
        )
      );
    },
    { flush: "post" }
  ), o = () => {
    s(), r();
  };
  return kc(r), o;
}
var wet = defineComponent({
  name: "UseFullscreen",
  props: ["as"],
  setup(t15, { slots: e }) {
    const r = shallowRef(), n = reactive(get(r));
    return () => {
      if (e.default)
        return h(t15.as || "div", { ref: r }, e.default(n));
    };
  }
});
function Gp(t15) {
  return typeof Window < "u" && t15 instanceof Window ? t15.document.documentElement : typeof Document < "u" && t15 instanceof Document ? t15.documentElement : t15;
}
function m_(t15) {
  const e = window.getComputedStyle(t15);
  if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t15.clientWidth < t15.scrollWidth || e.overflowY === "auto" && t15.clientHeight < t15.scrollHeight)
    return true;
  {
    const r = t15.parentNode;
    return !r || r.tagName === "BODY" ? false : m_(r);
  }
}
function ket(t15) {
  const e = t15 || window.event, r = e.target;
  return m_(r) ? false : e.touches.length > 1 ? true : (e.preventDefault && e.preventDefault(), false);
}
var Xp = /* @__PURE__ */ new WeakMap();
function vet(t15, e = false) {
  const r = shallowRef(e);
  let n = null, i = "";
  watch(het(t15), (a) => {
    const l = Gp(toValue(a));
    if (l) {
      const c = l;
      if (Xp.get(c) || Xp.set(c, c.style.overflow), c.style.overflow !== "hidden" && (i = c.style.overflow), c.style.overflow === "hidden")
        return r.value = true;
      if (r.value)
        return c.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const s = () => {
    const a = Gp(toValue(t15));
    !a || r.value || (b5 && (n = xet(
      a,
      "touchmove",
      (l) => {
        ket(l);
      },
      { passive: false }
    )), a.style.overflow = "hidden", r.value = true);
  }, o = () => {
    const a = Gp(toValue(t15));
    !a || !r.value || (b5 && (n == null ? void 0 : n()), a.style.overflow = i, Xp.delete(a), r.value = false);
  };
  return kc(o), computed({
    get() {
      return r.value;
    },
    set(a) {
      a ? s() : o();
    }
  });
}
function _et() {
  let t15 = false;
  const e = shallowRef(false);
  return (r, n) => {
    if (e.value = n.value, t15)
      return;
    t15 = true;
    const i = vet(r, n.value);
    watch(e, (s) => i.value = s);
  };
}
_et();
var B1 = 1;
var Cet = class {
  constructor() {
    __publicField(this, "subscribers");
    __publicField(this, "toasts");
    __publicField(this, "dismissedToasts");
    __publicField(this, "subscribe", (t15) => (this.subscribers.push(t15), () => {
      const e = this.subscribers.indexOf(t15);
      this.subscribers.splice(e, 1);
    }));
    __publicField(this, "publish", (t15) => {
      this.subscribers.forEach((e) => e(t15));
    });
    __publicField(this, "addToast", (t15) => {
      this.publish(t15), this.toasts = [...this.toasts, t15];
    });
    __publicField(this, "create", (t15) => {
      var _a2;
      const { message: e, ...r } = t15, n = typeof t15.id == "number" || t15.id && ((_a2 = t15.id) == null ? void 0 : _a2.length) > 0 ? t15.id : B1++, i = this.toasts.find((o) => o.id === n), s = t15.dismissible === void 0 ? true : t15.dismissible;
      return this.dismissedToasts.has(n) && this.dismissedToasts.delete(n), i ? this.toasts = this.toasts.map((o) => o.id === n ? (this.publish({
        ...o,
        ...t15,
        id: n,
        title: e
      }), {
        ...o,
        ...t15,
        id: n,
        dismissible: s,
        title: e
      }) : o) : this.addToast({
        title: e,
        ...r,
        dismissible: s,
        id: n
      }), n;
    });
    __publicField(this, "dismiss", (t15) => (t15 ? (this.dismissedToasts.add(t15), requestAnimationFrame(() => this.subscribers.forEach((e) => e({
      id: t15,
      dismiss: true
    })))) : this.toasts.forEach((e) => {
      this.subscribers.forEach((r) => r({
        id: e.id,
        dismiss: true
      }));
    }), t15));
    __publicField(this, "message", (t15, e) => this.create({
      ...e,
      message: t15,
      type: "default"
    }));
    __publicField(this, "error", (t15, e) => this.create({
      ...e,
      type: "error",
      message: t15
    }));
    __publicField(this, "success", (t15, e) => this.create({
      ...e,
      type: "success",
      message: t15
    }));
    __publicField(this, "info", (t15, e) => this.create({
      ...e,
      type: "info",
      message: t15
    }));
    __publicField(this, "warning", (t15, e) => this.create({
      ...e,
      type: "warning",
      message: t15
    }));
    __publicField(this, "loading", (t15, e) => this.create({
      ...e,
      type: "loading",
      message: t15
    }));
    __publicField(this, "promise", (t15, e) => {
      if (!e) return;
      let r;
      e.loading !== void 0 && (r = this.create({
        ...e,
        promise: t15,
        type: "loading",
        message: e.loading,
        description: typeof e.description != "function" ? e.description : void 0
      }));
      const n = Promise.resolve(t15 instanceof Function ? t15() : t15);
      let i = r !== void 0, s;
      const o = n.then(async (l) => {
        if (s = ["resolve", l], isVNode(l))
          i = false, this.create({
            id: r,
            type: "default",
            message: l
          });
        else if (Aet(l) && !l.ok) {
          i = false;
          const c = typeof e.error == "function" ? await e.error(`HTTP error! status: ${l.status}`) : e.error, h10 = typeof e.description == "function" ? await e.description(`HTTP error! status: ${l.status}`) : e.description, p = typeof c == "object" && !isVNode(c) ? c : {
            message: c || "",
            id: r || ""
          };
          this.create({
            id: r,
            type: "error",
            description: h10,
            ...p
          });
        } else if (l instanceof Error) {
          i = false;
          const c = typeof e.error == "function" ? await e.error(l) : e.error, h10 = typeof e.description == "function" ? await e.description(l) : e.description, p = typeof c == "object" && !isVNode(c) ? c : {
            message: c || "",
            id: r || ""
          };
          this.create({
            id: r,
            type: "error",
            description: h10,
            ...p
          });
        } else if (e.success !== void 0) {
          i = false;
          const c = typeof e.success == "function" ? await e.success(l) : e.success, h10 = typeof e.description == "function" ? await e.description(l) : e.description, p = typeof c == "object" && !isVNode(c) ? c : {
            message: c || "",
            id: r || ""
          };
          this.create({
            id: r,
            type: "success",
            description: h10,
            ...p
          });
        }
      }).catch(async (l) => {
        if (s = ["reject", l], e.error !== void 0) {
          i = false;
          const c = typeof e.error == "function" ? await e.error(l) : e.error, h10 = typeof e.description == "function" ? await e.description(l) : e.description, p = typeof c == "object" && !isVNode(c) ? c : {
            message: c || "",
            id: r || ""
          };
          this.create({
            id: r,
            type: "error",
            description: h10,
            ...p
          });
        }
      }).finally(() => {
        var _a2;
        i && (this.dismiss(r), r = void 0), (_a2 = e.finally) == null ? void 0 : _a2.call(e);
      }), a = () => new Promise((l, c) => o.then(() => s[0] === "reject" ? c(s[1]) : l(s[1])).catch(c));
      return typeof r != "string" && typeof r != "number" ? { unwrap: a } : Object.assign(r, { unwrap: a });
    });
    __publicField(this, "custom", (t15, e) => {
      const r = (e == null ? void 0 : e.id) || B1++;
      return this.publish({
        component: t15,
        id: r,
        ...e
      }), r;
    });
    __publicField(this, "getActiveToasts", () => this.toasts.filter((t15) => !this.dismissedToasts.has(t15.id)));
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
};
var qr = new Cet();
function Tet(t15, e) {
  const r = (e == null ? void 0 : e.id) || B1++;
  return qr.create({
    message: t15,
    id: r,
    type: "default",
    ...e
  }), r;
}
var Aet = (t15) => t15 && typeof t15 == "object" && "ok" in t15 && typeof t15.ok == "boolean" && "status" in t15 && typeof t15.status == "number";
var $et = Tet;
var Eet = () => qr.toasts;
var Met = () => qr.getActiveToasts();
var yh = Object.assign($et, {
  success: qr.success,
  info: qr.info,
  warning: qr.warning,
  error: qr.error,
  custom: qr.custom,
  message: qr.message,
  promise: qr.promise,
  dismiss: qr.dismiss,
  loading: qr.loading
}, {
  getHistory: Eet,
  getToasts: Met
});
function bh(t15) {
  return t15.label !== void 0;
}
var Bet = 3;
var g_ = "24px";
var y_ = "16px";
var k5 = 4e3;
var Let = 356;
var Det = 14;
var Fet = 45;
var b_ = 200;
function Net() {
  const t15 = ref(false);
  return watchEffect(() => {
    const e = () => {
      t15.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", e), () => window.removeEventListener("visibilitychange", e);
  }), { isDocumentHidden: t15 };
}
function Vi(...t15) {
  return t15.filter(Boolean).join(" ");
}
function Iet(t15) {
  const [e, r] = t15.split("-"), n = [];
  return e && n.push(e), r && n.push(r), n;
}
function Oet(t15, e) {
  const r = {};
  return [t15, e].forEach((n, i) => {
    const s = i === 1, o = s ? "--mobile-offset" : "--offset", a = s ? y_ : g_;
    function l(c) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((h10) => {
        r[`${o}-${h10}`] = typeof c == "number" ? `${c}px` : c;
      });
    }
    typeof n == "number" || typeof n == "string" ? l(n) : typeof n == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((c) => {
      n[c] === void 0 ? r[`${o}-${c}`] = a : r[`${o}-${c}`] = typeof n[c] == "number" ? `${n[c]}px` : n[c];
    }) : l(a);
  }), r;
}
var zet = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded"
];
var qet = ["aria-label", "data-disabled"];
var Ret = defineComponent({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(t15, { emit: e }) {
    const r = t15, n = e, i = ref(null), s = ref(null), o = ref(false), a = ref(false), l = ref(false), c = ref(false), h10 = ref(false), p = ref(0), m = ref(0), g = ref(r.toast.duration || r.duration || k5), y = ref(null), x = ref(null), k = computed(() => r.index === 0), C = computed(() => r.index + 1 <= r.visibleToasts), _ = computed(() => r.toast.type), $ = computed(() => r.toast.dismissible !== false), L = computed(() => r.toast.class || ""), B = computed(() => r.descriptionClass || ""), q = computed(() => {
      const U = r.toast.position || r.position, mt = r.heights.filter((wt) => wt.position === U).findIndex((wt) => wt.toastId === r.toast.id);
      return mt >= 0 ? mt : 0;
    }), H = computed(() => {
      const U = r.toast.position || r.position;
      return r.heights.filter((mt) => mt.position === U).reduce((mt, wt, Tt) => Tt >= q.value ? mt : mt + wt.height, 0);
    }), G = computed(() => q.value * r.gap + H.value || 0), F = computed(() => r.toast.closeButton ?? r.closeButton), W = computed(() => r.toast.duration || r.duration || k5), R = ref(0), J = ref(0), rt = ref(null), I = computed(() => r.position.split("-")), j = computed(() => I.value[0]), z = computed(() => I.value[1]), K = computed(() => typeof r.toast.title != "string"), Y = computed(() => typeof r.toast.description != "string"), { isDocumentHidden: at } = Net(), et = computed(() => _.value && _.value === "loading");
    onMounted(() => {
      o.value = true, g.value = W.value;
    }), watchEffect(async () => {
      if (!o.value || !x.value) return;
      await nextTick();
      const U = x.value, mt = U.style.height;
      U.style.height = "auto";
      const wt = U.getBoundingClientRect().height;
      U.style.height = mt, m.value = wt, n("update:height", {
        toastId: r.toast.id,
        height: wt,
        position: r.toast.position || r.position
      });
    });
    function ht() {
      a.value = true, p.value = G.value, setTimeout(() => {
        n("removeToast", r.toast);
      }, b_);
    }
    function X() {
      var _a2, _b2;
      if (et.value || !$.value) return {};
      ht(), (_b2 = (_a2 = r.toast).onDismiss) == null ? void 0 : _b2.call(_a2, r.toast);
    }
    function ct(U) {
      et.value || !$.value || (y.value = /* @__PURE__ */ new Date(), p.value = G.value, U.target.setPointerCapture(U.pointerId), U.target.tagName !== "BUTTON" && (l.value = true, rt.value = {
        x: U.clientX,
        y: U.clientY
      }));
    }
    function gt() {
      var _a2, _b2, _c, _d, _e, _f2, _g2;
      if (c.value || !$.value) return;
      rt.value = null;
      const U = Number(((_a2 = x.value) == null ? void 0 : _a2.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), mt = Number(((_b2 = x.value) == null ? void 0 : _b2.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), wt = (/* @__PURE__ */ new Date()).getTime() - (((_c = y.value) == null ? void 0 : _c.getTime()) || 0), Tt = i.value === "x" ? U : mt, Ut = Math.abs(Tt) / wt;
      if (Math.abs(Tt) >= Fet || Ut > 0.11) {
        p.value = G.value, (_e = (_d = r.toast).onDismiss) == null ? void 0 : _e.call(_d, r.toast), i.value === "x" ? s.value = U > 0 ? "right" : "left" : s.value = mt > 0 ? "down" : "up", ht(), c.value = true;
        return;
      } else
        (_f2 = x.value) == null ? void 0 : _f2.style.setProperty("--swipe-amount-x", "0px"), (_g2 = x.value) == null ? void 0 : _g2.style.setProperty("--swipe-amount-y", "0px");
      h10.value = false, l.value = false, i.value = null;
    }
    function xt(U) {
      var _a2, _b2, _c, _d;
      if (!rt.value || !$.value || (((_b2 = (_a2 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a2.toString()) == null ? void 0 : _b2.length) ?? false)) return;
      const mt = U.clientY - rt.value.y, wt = U.clientX - rt.value.x, Tt = r.swipeDirections ?? Iet(r.position);
      !i.value && (Math.abs(wt) > 1 || Math.abs(mt) > 1) && (i.value = Math.abs(wt) > Math.abs(mt) ? "x" : "y");
      let Ut = {
        x: 0,
        y: 0
      };
      const Ce = (ue) => 1 / (1.5 + Math.abs(ue) / 20);
      if (i.value === "y") {
        if (Tt.includes("top") || Tt.includes("bottom")) if (Tt.includes("top") && mt < 0 || Tt.includes("bottom") && mt > 0) Ut.y = mt;
        else {
          const ue = mt * Ce(mt);
          Ut.y = Math.abs(ue) < Math.abs(mt) ? ue : mt;
        }
      } else if (i.value === "x" && (Tt.includes("left") || Tt.includes("right")))
        if (Tt.includes("left") && wt < 0 || Tt.includes("right") && wt > 0) Ut.x = wt;
        else {
          const ue = wt * Ce(wt);
          Ut.x = Math.abs(ue) < Math.abs(wt) ? ue : wt;
        }
      (Math.abs(Ut.x) > 0 || Math.abs(Ut.y) > 0) && (h10.value = true), (_c = x.value) == null ? void 0 : _c.style.setProperty("--swipe-amount-x", `${Ut.x}px`), (_d = x.value) == null ? void 0 : _d.style.setProperty("--swipe-amount-y", `${Ut.y}px`);
    }
    onMounted(() => {
      if (o.value = true, !x.value) return;
      const U = x.value.getBoundingClientRect().height;
      m.value = U;
      const mt = [{
        toastId: r.toast.id,
        height: U,
        position: r.toast.position
      }, ...r.heights];
      n("update:heights", mt);
    }), onBeforeUnmount(() => {
      x.value && n("removeToast", r.toast);
    }), watchEffect((U) => {
      if (r.toast.promise && _.value === "loading" || r.toast.duration === 1 / 0 || r.toast.type === "loading") return;
      let mt;
      const wt = () => {
        if (J.value < R.value) {
          const Ut = (/* @__PURE__ */ new Date()).getTime() - R.value;
          g.value = g.value - Ut;
        }
        J.value = (/* @__PURE__ */ new Date()).getTime();
      }, Tt = () => {
        g.value !== 1 / 0 && (R.value = (/* @__PURE__ */ new Date()).getTime(), mt = setTimeout(() => {
          var _a2, _b2;
          (_b2 = (_a2 = r.toast).onAutoClose) == null ? void 0 : _b2.call(_a2, r.toast), ht();
        }, g.value));
      };
      r.expanded || r.interacting || at.value ? wt() : Tt(), U(() => {
        clearTimeout(mt);
      });
    }), watch(() => r.toast.delete, (U) => {
      U !== void 0 && U && ht();
    }, { deep: true });
    function Yt() {
      l.value = false, i.value = null, rt.value = null;
    }
    return (U, mt) => {
      var _a2, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r, _s, _t, _u2, _v2, _w2, _x2, _y, _z2, _A2;
      return openBlock(), createElementBlock("li", {
        tabindex: "0",
        ref_key: "toastRef",
        ref: x,
        class: normalizeClass(unref(Vi)(r.class, L.value, (_a2 = U.classes) == null ? void 0 : _a2.toast, (_b2 = U.toast.classes) == null ? void 0 : _b2.toast, (_c = U.classes) == null ? void 0 : _c[_.value], (_e = (_d = U.toast) == null ? void 0 : _d.classes) == null ? void 0 : _e[_.value])),
        "data-sonner-toast": "",
        "data-rich-colors": U.toast.richColors ?? U.defaultRichColors,
        "data-styled": !(U.toast.component || ((_f2 = U.toast) == null ? void 0 : _f2.unstyled) || U.unstyled),
        "data-mounted": o.value,
        "data-promise": !!U.toast.promise,
        "data-swiped": h10.value,
        "data-removed": a.value,
        "data-visible": C.value,
        "data-y-position": j.value,
        "data-x-position": z.value,
        "data-index": U.index,
        "data-front": k.value,
        "data-swiping": l.value,
        "data-dismissible": $.value,
        "data-type": _.value,
        "data-invert": U.toast.invert || U.invert,
        "data-swipe-out": c.value,
        "data-swipe-direction": s.value,
        "data-expanded": !!(U.expanded || U.expandByDefault && o.value),
        style: normalizeStyle({
          "--index": U.index,
          "--toasts-before": U.index,
          "--z-index": U.toasts.length - U.index,
          "--offset": `${a.value ? p.value : G.value}px`,
          "--initial-height": U.expandByDefault ? "auto" : `${m.value}px`,
          ...U.style,
          ...r.toast.style
        }),
        onDragend: Yt,
        onPointerdown: ct,
        onPointerup: gt,
        onPointermove: xt
      }, [F.value && !U.toast.component && _.value !== "loading" ? (openBlock(), createElementBlock("button", {
        key: 0,
        "aria-label": U.closeButtonAriaLabel || "Close toast",
        "data-disabled": et.value,
        "data-close-button": "true",
        class: normalizeClass(unref(Vi)((_g2 = U.classes) == null ? void 0 : _g2.closeButton, (_i2 = (_h2 = U.toast) == null ? void 0 : _h2.classes) == null ? void 0 : _i2.closeButton)),
        onClick: X
      }, [((_j2 = U.icons) == null ? void 0 : _j2.close) ? (openBlock(), createBlock(resolveDynamicComponent((_k2 = U.icons) == null ? void 0 : _k2.close), { key: 0 })) : renderSlot(U.$slots, "close-icon", { key: 1 })], 10, qet)) : createCommentVNode("v-if", true), U.toast.component ? (openBlock(), createBlock(resolveDynamicComponent(U.toast.component), mergeProps({ key: 1 }, U.toast.componentProps, { onCloseToast: X }), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        _.value !== "default" || U.toast.icon || U.toast.promise ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-icon": "",
          class: normalizeClass(unref(Vi)((_l2 = U.classes) == null ? void 0 : _l2.icon, (_n2 = (_m2 = U.toast) == null ? void 0 : _m2.classes) == null ? void 0 : _n2.icon))
        }, [U.toast.icon ? (openBlock(), createBlock(resolveDynamicComponent(U.toast.icon), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [_.value === "loading" ? renderSlot(U.$slots, "loading-icon", { key: 0 }) : _.value === "success" ? renderSlot(U.$slots, "success-icon", { key: 1 }) : _.value === "error" ? renderSlot(U.$slots, "error-icon", { key: 2 }) : _.value === "warning" ? renderSlot(U.$slots, "warning-icon", { key: 3 }) : _.value === "info" ? renderSlot(U.$slots, "info-icon", { key: 4 }) : createCommentVNode("v-if", true)], 64))], 2)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          "data-content": "",
          class: normalizeClass(unref(Vi)((_o2 = U.classes) == null ? void 0 : _o2.content, (_q2 = (_p2 = U.toast) == null ? void 0 : _p2.classes) == null ? void 0 : _q2.content))
        }, [createBaseVNode("div", {
          "data-title": "",
          class: normalizeClass(unref(Vi)((_r = U.classes) == null ? void 0 : _r.title, (_s = U.toast.classes) == null ? void 0 : _s.title))
        }, [K.value ? (openBlock(), createBlock(resolveDynamicComponent(U.toast.title), normalizeProps(mergeProps({ key: 0 }, U.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(U.toast.title), 1)], 64))], 2), U.toast.description ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-description": "",
          class: normalizeClass(unref(Vi)(U.descriptionClass, B.value, (_t = U.classes) == null ? void 0 : _t.description, (_u2 = U.toast.classes) == null ? void 0 : _u2.description))
        }, [Y.value ? (openBlock(), createBlock(resolveDynamicComponent(U.toast.description), normalizeProps(mergeProps({ key: 0 }, U.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(U.toast.description), 1)], 64))], 2)) : createCommentVNode("v-if", true)], 2),
        U.toast.cancel ? (openBlock(), createElementBlock("button", {
          key: 1,
          style: normalizeStyle(U.toast.cancelButtonStyle || U.cancelButtonStyle),
          class: normalizeClass(unref(Vi)((_v2 = U.classes) == null ? void 0 : _v2.cancelButton, (_w2 = U.toast.classes) == null ? void 0 : _w2.cancelButton)),
          "data-button": "",
          "data-cancel": "",
          onClick: mt[0] || (mt[0] = (wt) => {
            var _a3, _b3;
            unref(bh)(U.toast.cancel) && $.value && ((_b3 = (_a3 = U.toast.cancel).onClick) == null ? void 0 : _b3.call(_a3, wt), ht());
          })
        }, toDisplayString(unref(bh)(U.toast.cancel) ? (_x2 = U.toast.cancel) == null ? void 0 : _x2.label : U.toast.cancel), 7)) : createCommentVNode("v-if", true),
        U.toast.action ? (openBlock(), createElementBlock("button", {
          key: 2,
          style: normalizeStyle(U.toast.actionButtonStyle || U.actionButtonStyle),
          class: normalizeClass(unref(Vi)((_y = U.classes) == null ? void 0 : _y.actionButton, (_z2 = U.toast.classes) == null ? void 0 : _z2.actionButton)),
          "data-button": "",
          "data-action": "",
          onClick: mt[1] || (mt[1] = (wt) => {
            var _a3, _b3;
            unref(bh)(U.toast.action) && ((_b3 = (_a3 = U.toast.action).onClick) == null ? void 0 : _b3.call(_a3, wt), !wt.defaultPrevented && ht());
          })
        }, toDisplayString(unref(bh)(U.toast.action) ? (_A2 = U.toast.action) == null ? void 0 : _A2.label : U.toast.action), 7)) : createCommentVNode("v-if", true)
      ], 64))], 46, zet);
    };
  }
});
var Pet = Ret;
var vc = (t15, e) => {
  const r = t15.__vccOpts || t15;
  for (const [n, i] of e) r[n] = i;
  return r;
};
var jet = {};
var Wet = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Het(t15, e) {
  return openBlock(), createElementBlock("svg", Wet, e[0] || (e[0] = [createBaseVNode("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), createBaseVNode("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var Uet = vc(jet, [["render", Het]]);
var Vet = ["data-visible"];
var Get = { class: "sonner-spinner" };
var Xet = defineComponent({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(t15) {
    const e = Array(12).fill(0);
    return (r, n) => (openBlock(), createElementBlock("div", {
      class: "sonner-loading-wrapper",
      "data-visible": r.visible
    }, [createBaseVNode("div", Get, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(e), (i) => (openBlock(), createElementBlock("div", {
      key: `spinner-bar-${i}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, Vet));
  }
});
var Yet = Xet;
var Ket = {};
var Zet = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function Qet(t15, e) {
  return openBlock(), createElementBlock("svg", Zet, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var Jet = vc(Ket, [["render", Qet]]);
var trt = {};
var ert = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function rrt(t15, e) {
  return openBlock(), createElementBlock("svg", ert, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var nrt = vc(trt, [["render", rrt]]);
var irt = {};
var srt = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function ort(t15, e) {
  return openBlock(), createElementBlock("svg", srt, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var art = vc(irt, [["render", ort]]);
var lrt = {};
var crt = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function hrt(t15, e) {
  return openBlock(), createElementBlock("svg", crt, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var urt = vc(lrt, [["render", hrt]]);
var drt = ["aria-label"];
var prt = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position",
  "data-lifted"
];
var frt = typeof window < "u" && typeof document < "u";
function mrt() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const t15 = document.documentElement.getAttribute("dir");
  return t15 === "auto" || !t15 ? window.getComputedStyle(document.documentElement).direction : t15;
}
var grt = defineComponent({
  name: "Toaster",
  inheritAttrs: false,
  __name: "Toaster",
  props: {
    invert: {
      type: Boolean,
      default: false
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: false
    },
    expand: {
      type: Boolean,
      default: false
    },
    duration: {},
    gap: { default: Det },
    visibleToasts: { default: Bet },
    closeButton: {
      type: Boolean,
      default: false
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: g_ },
    mobileOffset: { default: y_ },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(t15) {
    const e = t15, r = useAttrs(), n = ref([]);
    function i(F, W) {
      return n.value.filter((R) => !R.position && W === 0 || R.position === F);
    }
    const s = computed(() => {
      const F = n.value.filter((W) => W.position).map((W) => W.position);
      return F.length > 0 ? Array.from(new Set([e.position].concat(F))) : [e.position];
    }), o = computed(() => {
      const F = {};
      return s.value.forEach((W) => {
        F[W] = n.value.filter((R) => R.position === W);
      }), F;
    }), a = ref([]), l = ref(false), c = ref(false), h10 = ref(e.theme !== "system" ? e.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = ref(null), m = ref(null), g = ref(false), y = e.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function x(F) {
      var _a2;
      ((_a2 = n.value.find((W) => W.id === F.id)) == null ? void 0 : _a2.delete) || qr.dismiss(F.id), n.value = n.value.filter(({ id: W }) => W !== F.id), setTimeout(() => {
        n.value.find((W) => W.id === F.id) || (a.value = a.value.filter((W) => W.toastId !== F.id));
      }, b_ + 50);
    }
    function k(F) {
      var _a2, _b2;
      g.value && !((_b2 = (_a2 = F.currentTarget) == null ? void 0 : _a2.contains) == null ? void 0 : _b2.call(_a2, F.relatedTarget)) && (g.value = false, m.value && (m.value.focus({ preventScroll: true }), m.value = null));
    }
    function C(F) {
      F.target instanceof HTMLElement && F.target.dataset.dismissible === "false" || g.value || (g.value = true, m.value = F.relatedTarget);
    }
    function _(F) {
      F.target && F.target instanceof HTMLElement && F.target.dataset.dismissible === "false" || (c.value = true);
    }
    watchEffect((F) => {
      const W = qr.subscribe((R) => {
        if (R.dismiss) {
          requestAnimationFrame(() => {
            n.value = n.value.map((J) => J.id === R.id ? {
              ...J,
              delete: true
            } : J);
          });
          return;
        }
        nextTick(() => {
          const J = n.value.findIndex((rt) => rt.id === R.id);
          J !== -1 ? n.value = [
            ...n.value.slice(0, J),
            {
              ...n.value[J],
              ...R
            },
            ...n.value.slice(J + 1)
          ] : n.value = [R, ...n.value];
        });
      });
      F(W);
    }), watchEffect((F) => {
      if (typeof window > "u") return;
      if (e.theme !== "system") {
        h10.value = e.theme;
        return;
      }
      const W = window.matchMedia("(prefers-color-scheme: dark)"), R = (rt) => {
        h10.value = rt ? "dark" : "light";
      };
      R(W.matches);
      const J = (rt) => {
        R(rt.matches);
      };
      try {
        W.addEventListener("change", J);
      } catch {
        W.addListener(J);
      }
      F(() => {
        try {
          W.removeEventListener("change", J);
        } catch {
          W.removeListener(J);
        }
      });
    }), watchEffect(() => {
      p.value && m.value && (m.value.focus({ preventScroll: true }), m.value = null, g.value = false);
    }), watchEffect(() => {
      n.value.length <= 1 && (l.value = false);
    }), watchEffect((F) => {
      function W(R) {
        const J = e.hotkey.every((j) => R[j] || R.code === j), rt = Array.isArray(p.value) ? p.value[0] : p.value;
        J && (l.value = true, rt == null ? void 0 : rt.focus());
        const I = document.activeElement === p.value || (rt == null ? void 0 : rt.contains(document.activeElement));
        R.code === "Escape" && I && (l.value = false);
      }
      frt && (document.addEventListener("keydown", W), F(() => {
        document.removeEventListener("keydown", W);
      }));
    });
    function $() {
      l.value = true;
    }
    function L() {
      c.value || (l.value = false);
    }
    function B() {
      l.value = false;
    }
    function q() {
      c.value = false;
    }
    function H(F) {
      a.value = F;
    }
    function G(F) {
      const W = a.value.findIndex((R) => R.toastId === F.toastId);
      if (W !== -1) a.value[W] = F;
      else {
        const R = a.value.findIndex((J) => J.position === F.position);
        R !== -1 ? a.value.splice(R, 0, F) : a.value.unshift(F);
      }
    }
    return (F, W) => (openBlock(), createElementBlock(Fragment, null, [createCommentVNode(" Remove item from normal navigation flow, only available via hotkey "), createBaseVNode("section", {
      "aria-label": `${F.containerAriaLabel} ${unref(y)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (R, J) => {
      var _a2;
      return openBlock(), createElementBlock("ol", mergeProps({
        key: R,
        ref_for: true,
        ref_key: "listRef",
        ref: p,
        "data-sonner-toaster": "",
        "data-sonner-theme": h10.value,
        class: e.class,
        dir: F.dir === "auto" ? mrt() : F.dir,
        tabIndex: -1,
        "data-theme": F.theme,
        "data-rich-colors": F.richColors,
        "data-y-position": R.split("-")[0],
        "data-x-position": R.split("-")[1],
        "data-lifted": l.value && n.value.length > 1 && !F.expand,
        style: {
          "--front-toast-height": `${((_a2 = a.value[0]) == null ? void 0 : _a2.height) || 0}px`,
          "--width": `${unref(Let)}px`,
          "--gap": `${F.gap}px`,
          ...F.style,
          ...unref(r).style,
          ...unref(Oet)(F.offset, F.mobileOffset)
        }
      }, F.$attrs, {
        onBlur: k,
        onFocus: C,
        onMouseenter: $,
        onMousemove: $,
        onMouseleave: L,
        onDragend: B,
        onPointerdown: _,
        onPointerup: q
      }), [(openBlock(true), createElementBlock(Fragment, null, renderList(i(R, J), (rt, I) => {
        var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2;
        return openBlock(), createBlock(Pet, {
          key: rt.id,
          heights: a.value,
          icons: F.icons,
          index: I,
          toast: rt,
          defaultRichColors: F.richColors,
          duration: ((_a3 = F.toastOptions) == null ? void 0 : _a3.duration) ?? F.duration,
          class: normalizeClass(((_b2 = F.toastOptions) == null ? void 0 : _b2.class) ?? ""),
          descriptionClass: (_c = F.toastOptions) == null ? void 0 : _c.descriptionClass,
          invert: F.invert,
          visibleToasts: F.visibleToasts,
          closeButton: ((_d = F.toastOptions) == null ? void 0 : _d.closeButton) ?? F.closeButton,
          interacting: c.value,
          position: R,
          style: normalizeStyle((_e = F.toastOptions) == null ? void 0 : _e.style),
          unstyled: (_f2 = F.toastOptions) == null ? void 0 : _f2.unstyled,
          classes: (_g2 = F.toastOptions) == null ? void 0 : _g2.classes,
          cancelButtonStyle: (_h2 = F.toastOptions) == null ? void 0 : _h2.cancelButtonStyle,
          actionButtonStyle: (_i2 = F.toastOptions) == null ? void 0 : _i2.actionButtonStyle,
          "close-button-aria-label": (_j2 = F.toastOptions) == null ? void 0 : _j2.closeButtonAriaLabel,
          toasts: o.value[R],
          expandByDefault: F.expand,
          gap: F.gap,
          expanded: l.value,
          swipeDirections: e.swipeDirections,
          "onUpdate:heights": H,
          "onUpdate:height": G,
          onRemoveToast: x
        }, {
          "close-icon": withCtx(() => [renderSlot(F.$slots, "close-icon", {}, () => [createVNode(Uet)])]),
          "loading-icon": withCtx(() => [renderSlot(F.$slots, "loading-icon", {}, () => [createVNode(Yet, { visible: rt.type === "loading" }, null, 8, ["visible"])])]),
          "success-icon": withCtx(() => [renderSlot(F.$slots, "success-icon", {}, () => [createVNode(Jet)])]),
          "error-icon": withCtx(() => [renderSlot(F.$slots, "error-icon", {}, () => [createVNode(urt)])]),
          "warning-icon": withCtx(() => [renderSlot(F.$slots, "warning-icon", {}, () => [createVNode(art)])]),
          "info-icon": withCtx(() => [renderSlot(F.$slots, "info-icon", {}, () => [createVNode(nrt)])]),
          _: 2
        }, 1032, [
          "heights",
          "icons",
          "index",
          "toast",
          "defaultRichColors",
          "duration",
          "class",
          "descriptionClass",
          "invert",
          "visibleToasts",
          "closeButton",
          "interacting",
          "position",
          "style",
          "unstyled",
          "classes",
          "cancelButtonStyle",
          "actionButtonStyle",
          "close-button-aria-label",
          "toasts",
          "expandByDefault",
          "gap",
          "expanded",
          "swipeDirections"
        ]);
      }), 128))], 16, prt);
    }), 128))], 8, drt)], 2112));
  }
});
var yrt = grt;
var brt = { class: "mermaid-container" };
var xrt = ["innerHTML"];
var wrt = { class: "mermaid-toolbar" };
var krt = ["onClick"];
var vrt = defineComponent({
  __name: "MermaidChart",
  props: {
    code: { default: "" },
    showToolbar: { default: "0" }
  },
  setup(t15) {
    const e = t15;
    console.log("props:", e);
    const r = computed(() => decodeURIComponent(e.code)), n = ref(), i = ref(), s = ref();
    async function o() {
      if (!i.value) return;
      i.value.innerHTML = "", await f5.initialize({
        startOnLoad: false,
        theme: document.documentElement.classList.contains("dark") ? "dark" : "default",
        securityLevel: "loose"
        // 允许点击交互
      });
      const h10 = Math.random().toString(36).substring(2, 15), { svg: p } = await f5.render(
        `mermaid-${h10}`,
        r.value,
        i.value
      );
      n.value = p;
    }
    async function a() {
      if (s.value)
        try {
          await (await Je(s.value, {
            scale: 2,
            quality: 1,
            backgroundColor: getComputedStyle(
              document.documentElement
            ).getPropertyValue("--vp-c-bg-soft")
          })).download({ format: "png", filename: "mermaid-chart" }), yh.success("图表下载成功！");
        } catch (h10) {
          console.error("下载失败:", h10), yh.error("下载失败，请重试");
        }
    }
    async function l() {
      if (r.value)
        try {
          ztt(r.value), yh.success("代码复制成功！");
        } catch (h10) {
          console.error("复制失败:", h10), yh.error("复制失败，请重试");
        }
    }
    met(
      i,
      () => {
        o();
      },
      {
        attributes: true,
        // 监听属性
        attributeFilter: ["class"]
        // 只关心这几个
      }
    );
    const c = ref();
    return onMounted(() => {
      o(), typeof window < "u" && window.MutationObserver && (c.value = new MutationObserver((h10) => {
        for (const p of h10)
          if (p.attributeName === "class" && p.target === document.documentElement) {
            o();
            break;
          }
      }), c.value.observe(document.documentElement, {
        attributes: true
      })), typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
        o();
      });
    }), (h10, p) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", brt, [
        createVNode(unref(wet), null, {
          default: withCtx(({ toggle: m, isFullscreen: g }) => [
            createBaseVNode("div", {
              ref_key: "mermaidRef",
              ref: i,
              class: normalizeClass(["mermaid", g && "mermaid-fullscreen"]),
              innerHTML: n.value
            }, null, 10, xrt),
            withDirectives(createBaseVNode("div", wrt, [
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "复制代码",
                onClick: l
              }, " 📋 "),
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "下载图表",
                onClick: a
              }, " ⬇️ "),
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "全屏",
                onClick: m
              }, toDisplayString(g ? "🔲" : "🔳"), 9, krt)
            ], 512), [
              [vShow, Number(e.showToolbar) === 1]
            ])
          ]),
          _: 1
        })
      ]),
      createVNode(unref(yrt), {
        position: "top-right",
        "rich-colors": ""
      })
    ], 64));
  }
});
var x_ = (t15, e) => {
  const r = t15.__vccOpts || t15;
  for (const [n, i] of e)
    r[n] = i;
  return r;
};
var w_ = x_(vrt, [["__scopeId", "data-v-e6a16b68"]]);
var _rt = { class: "vitepress-mermaid-preview" };
var Crt = defineComponent({
  __name: "PreviewMermaidPath",
  props: {
    path: {},
    showToolbar: { type: Boolean, default: false }
  },
  setup(t15) {
    const e = t15, r = ref("");
    return (n, i) => {
      const s = resolveComponent("ClientOnly");
      return openBlock(), createElementBlock("div", _rt, [
        createVNode(s, null, {
          default: withCtx(() => [
            r.value ? (openBlock(), createBlock(w_, {
              key: 0,
              code: r.value,
              "show-toolbar": e.showToolbar
            }, null, 8, ["code", "show-toolbar"])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});
var Srt = x_(Crt, [["__scopeId", "data-v-2ea0c3b6"]]);
function Trt(t15) {
  t15.component("MermaidChart", w_), t15.component("PreviewMermaidPath", Srt);
}
function Cnt(t15) {
  Gq(t15), Trt(t15);
}

export {
  Gq,
  Xq,
  Qq,
  Vt,
  ri,
  xl,
  hc,
  At,
  zt,
  S,
  AR,
  ut,
  pr,
  NR,
  tw,
  Vr,
  uc,
  to,
  cw,
  Qe,
  Vb,
  ta,
  rnt,
  Dm,
  ga,
  hw,
  oP,
  uw,
  hP,
  uP,
  dP,
  pP,
  fP,
  mP,
  gP,
  me,
  nnt,
  int,
  bP,
  Tj,
  Aj,
  $j,
  Um,
  G7,
  Nt,
  Dj,
  ae,
  Xm,
  ak,
  fc,
  Ul,
  CH,
  Ur,
  Ym,
  snt,
  hk,
  c4,
  Ji,
  BH,
  To,
  ont,
  ant,
  lnt,
  cnt,
  hnt,
  unt,
  dnt,
  m4,
  Jm,
  g4,
  pnt,
  fnt,
  mnt,
  ZU,
  QU,
  eV,
  zh,
  Nu,
  ba,
  co,
  ig,
  N0,
  gs,
  mc,
  xa,
  sg,
  pG,
  mG,
  T4,
  gG,
  yG,
  bG,
  Xk,
  z0,
  kG,
  gc,
  Ou,
  zu,
  Kk,
  q0,
  TG,
  og,
  aX,
  B4,
  ag,
  uX,
  dX,
  tv,
  bX,
  ev,
  nv,
  TX,
  AX,
  DX,
  FX,
  NX,
  IX,
  OX,
  zX,
  cv,
  VX,
  GX,
  KX,
  uv,
  Ii,
  R0,
  pg,
  Xn,
  po,
  gnt,
  iK,
  sK,
  bc,
  aK,
  Iv,
  ys,
  Ft,
  LK,
  ynt,
  ZK,
  a9,
  bnt,
  xnt,
  wnt,
  knt,
  tZ,
  eZ,
  sZ,
  _Z,
  vnt,
  _nt,
  e5,
  TZ,
  GZ,
  S1,
  Is,
  c5,
  Trt,
  Cnt
};
/*! Bundled license information:

vitepress-plugin-legend/dist/component-B8iEnLsv.js:
  (*! @gera2ld/jsx-dom v2.2.2 | ISC License *)
  (*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE *)
  (*! Bundled license information:
  
  js-yaml/dist/js-yaml.mjs:
    (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
  *)
  (*! Check if previously processed *)
  (*!
   * Wait for document loaded before starting the execution
   *)
*/
//# sourceMappingURL=chunk-G6K7VW2X.js.map
