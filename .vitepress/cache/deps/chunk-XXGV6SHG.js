import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  defineComponent,
  isVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  openBlock,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  unref,
  useAttrs,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives
} from "./chunk-ZNML7WN5.js";
import {
  __publicField
} from "./chunk-EQCVQC35.js";

// node_modules/.pnpm/vitepress-plugin-legend@1.0.2_jiti@1.21.7_markmap-common@0.18.9_typescript@5.4.3_yaml@2.7.0/node_modules/vitepress-plugin-legend/dist/component-Dd_YnWOH.js
var c_ = "npm2url/dist/index.cjs";
var h_ = {
  jsdelivr: (t15) => `https://cdn.jsdelivr.net/npm/${t15}`,
  unpkg: (t15) => `https://unpkg.com/${t15}`
};
async function u_(t15, e) {
  const r = await fetch(t15, {
    signal: e
  });
  if (!r.ok)
    throw r;
  await r.text();
}
var d_ = class {
  constructor() {
    this.providers = { ...h_ }, this.provider = "jsdelivr";
  }
  /**
   * Get the fastest provider name.
   * If none of the providers returns a valid response within `timeout`, an error will be thrown.
   */
  async getFastestProvider(e = 5e3, r = c_) {
    const n = new AbortController();
    let i = 0;
    try {
      return await new Promise((s, a) => {
        Promise.all(
          Object.entries(this.providers).map(async ([o, l]) => {
            try {
              await u_(l(r), n.signal), s(o);
            } catch {
            }
          })
        ).then(() => a(new Error("All providers failed"))), i = setTimeout(a, e, new Error("Timed out"));
      });
    } finally {
      n.abort(), clearTimeout(i);
    }
  }
  /**
   * Set the current provider to the fastest provider found by `getFastestProvider`.
   */
  async findFastestProvider(e, r) {
    return this.provider = await this.getFastestProvider(e, r), this.provider;
  }
  setProvider(e, r) {
    r ? this.providers[e] = r : delete this.providers[e];
  }
  getFullUrl(e, r = this.provider) {
    if (e.includes("://"))
      return e;
    const n = this.providers[r];
    if (!n)
      throw new Error(`Provider ${r} not found`);
    return n(e);
  }
};
var Zo = class {
  constructor() {
    this.listeners = [];
  }
  tap(e) {
    return this.listeners.push(e), () => this.revoke(e);
  }
  revoke(e) {
    const r = this.listeners.indexOf(e);
    r >= 0 && this.listeners.splice(r, 1);
  }
  revokeAll() {
    this.listeners.splice(0);
  }
  call(...e) {
    for (const r of this.listeners)
      r(...e);
  }
};
var p_ = Math.random().toString(36).slice(2, 8);
var Py = 0;
function f_() {
  return Py += 1, `mm-${p_}-${Py}`;
}
function Ta() {
}
function Jo(t15, e) {
  const r = (n, i) => e(
    n,
    () => {
      var s;
      return (s = n.children) == null ? void 0 : s.map((a) => r(a, n));
    },
    i
  );
  return r(t15);
}
function m_(t15, ...e) {
  const r = (t15 || "").split(" ").filter(Boolean);
  return e.forEach((n) => {
    n && r.indexOf(n) < 0 && r.push(n);
  }), r.join(" ");
}
function jy(t15, e) {
  return (...r) => e(t15, ...r);
}
function g_() {
  const t15 = {};
  return t15.promise = new Promise((e, r) => {
    t15.resolve = e, t15.reject = r;
  }), t15;
}
function y_(t15) {
  const e = {};
  return function(...r) {
    const n = `${r[0]}`;
    let i = e[n];
    return i || (i = {
      value: t15(...r)
    }, e[n] = i), i.value;
  };
}
function b_(t15, e) {
  const r = {
    timer: 0
  };
  function n() {
    r.timer && (window.clearTimeout(r.timer), r.timer = 0);
  }
  function i() {
    n(), r.args && (r.result = t15(...r.args));
  }
  return function(...s) {
    return n(), r.args = s, r.timer = window.setTimeout(i, e), r.result;
  };
}
var d5 = 1;
var p5 = 2;
var x_ = "http://www.w3.org/2000/svg";
var Ad = "http://www.w3.org/1999/xlink";
var w_ = {
  show: Ad,
  actuate: Ad,
  href: Ad
};
var k_ = (t15) => typeof t15 == "string" || typeof t15 == "number";
var v_ = (t15) => (t15 == null ? void 0 : t15.vtype) === d5;
var C_ = (t15) => (t15 == null ? void 0 : t15.vtype) === p5;
function __(t15, e, ...r) {
  return e = Object.assign({}, e, {
    children: r.length === 1 ? r[0] : r
  }), S_(t15, e);
}
function S_(t15, e) {
  let r;
  if (typeof t15 == "string") r = d5;
  else if (typeof t15 == "function") r = p5;
  else throw new Error("Invalid VNode type");
  return {
    vtype: r,
    type: t15,
    props: e
  };
}
function A_(t15) {
  return t15.children;
}
var T_ = {
  isSvg: false
};
function Wy(t15, e) {
  Array.isArray(e) || (e = [e]), e = e.filter(Boolean), e.length && t15.append(...e);
}
function $_(t15, e, r) {
  for (const n in e)
    if (!(n === "key" || n === "children" || n === "ref"))
      if (n === "dangerouslySetInnerHTML")
        t15.innerHTML = e[n].__html;
      else if (n === "innerHTML" || n === "textContent" || n === "innerText" || n === "value" && ["textarea", "select"].includes(t15.tagName)) {
        const i = e[n];
        i != null && (t15[n] = i);
      } else n.startsWith("on") ? t15[n.toLowerCase()] = e[n] : M_(t15, n, e[n], r.isSvg);
}
var E_ = {
  className: "class",
  labelFor: "for"
};
function M_(t15, e, r, n) {
  if (e = E_[e] || e, r === true)
    t15.setAttribute(e, "");
  else if (r === false)
    t15.removeAttribute(e);
  else {
    const i = n ? w_[e] : void 0;
    i !== void 0 ? t15.setAttributeNS(i, e, r) : t15.setAttribute(e, r);
  }
}
function B_(t15) {
  return t15.reduce((e, r) => e.concat(r), []);
}
function Rp(t15, e) {
  return Array.isArray(t15) ? B_(t15.map((r) => Rp(r, e))) : _1(t15, e);
}
function _1(t15, e = T_) {
  if (t15 == null || typeof t15 == "boolean")
    return null;
  if (t15 instanceof Node)
    return t15;
  if (C_(t15)) {
    const {
      type: r,
      props: n
    } = t15;
    if (r === A_) {
      const s = document.createDocumentFragment();
      if (n.children) {
        const a = Rp(n.children, e);
        Wy(s, a);
      }
      return s;
    }
    const i = r(n);
    return _1(i, e);
  }
  if (k_(t15))
    return document.createTextNode(`${t15}`);
  if (v_(t15)) {
    let r;
    const {
      type: n,
      props: i
    } = t15;
    if (!e.isSvg && n === "svg" && (e = Object.assign({}, e, {
      isSvg: true
    })), e.isSvg ? r = document.createElementNS(x_, n) : r = document.createElement(n), $_(r, i, e), i.children) {
      let a = e;
      e.isSvg && n === "foreignObject" && (a = Object.assign({}, a, {
        isSvg: false
      }));
      const o = Rp(i.children, a);
      o != null && Wy(r, o);
    }
    const {
      ref: s
    } = i;
    return typeof s == "function" && s(r), r;
  }
  throw new Error("mount: Invalid Vnode!");
}
function L_(t15) {
  return _1(t15);
}
function f5(...t15) {
  return L_(__(...t15));
}
var D_ = y_((t15) => {
  document.head.append(
    f5("link", {
      rel: "preload",
      as: "script",
      href: t15
    })
  );
});
var Hy = {};
async function F_(t15, e) {
  var r;
  const n = t15.type === "script" && ((r = t15.data) == null ? void 0 : r.src) || "";
  if (t15.loaded || (t15.loaded = Hy[n]), !t15.loaded) {
    const i = g_();
    if (t15.loaded = i.promise, t15.type === "script" && (document.head.append(
      f5("script", {
        ...t15.data,
        onLoad: () => i.resolve(),
        onError: i.reject
      })
    ), n ? Hy[n] = t15.loaded : i.resolve()), t15.type === "iife") {
      const { fn: s, getParams: a } = t15.data;
      s(...(a == null ? void 0 : a(e)) || []), i.resolve();
    }
  }
  await t15.loaded;
}
async function m5(t15, e) {
  t15.forEach((r) => {
    var n;
    r.type === "script" && (n = r.data) != null && n.src && D_(r.data.src);
  }), e = {
    getMarkmap: () => window.markmap,
    ...e
  };
  for (const r of t15)
    await F_(r, e);
}
function S1(t15) {
  return {
    type: "script",
    data: {
      src: t15
    }
  };
}
function g5(t15) {
  return {
    type: "stylesheet",
    data: {
      href: t15
    }
  };
}
var N_ = {
  _useHtmlParser2: false
};
function Pp(t15, e) {
  if (!t15)
    return e ?? N_;
  const r = {
    _useHtmlParser2: !!t15.xmlMode,
    ...e,
    ...t15
  };
  return t15.xml ? (r._useHtmlParser2 = true, r.xmlMode = true, t15.xml !== true && Object.assign(r, t15.xml)) : t15.xmlMode && (r._useHtmlParser2 = true), r;
}
var me;
(function(t15) {
  t15.Root = "root", t15.Text = "text", t15.Directive = "directive", t15.Comment = "comment", t15.Script = "script", t15.Style = "style", t15.Tag = "tag", t15.CDATA = "cdata", t15.Doctype = "doctype";
})(me || (me = {}));
function I_(t15) {
  return t15.type === me.Tag || t15.type === me.Script || t15.type === me.Style;
}
var O_ = me.Root;
var z_ = me.Text;
var q_ = me.Directive;
var R_ = me.Comment;
var P_ = me.Script;
var j_ = me.Style;
var W_ = me.Tag;
var H_ = me.CDATA;
var U_ = me.Doctype;
var y5 = class {
  constructor() {
    this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(e) {
    this.parent = e;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(e) {
    this.prev = e;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(e) {
    this.next = e;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(e = false) {
    return Cl(this, e);
  }
};
var A1 = class extends y5 {
  /**
   * @param data The content of the data node
   */
  constructor(e) {
    super(), this.data = e;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(e) {
    this.data = e;
  }
};
var Vh = class extends A1 {
  constructor() {
    super(...arguments), this.type = me.Text;
  }
  get nodeType() {
    return 3;
  }
};
var b5 = class extends A1 {
  constructor() {
    super(...arguments), this.type = me.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var x5 = class extends A1 {
  constructor(e, r) {
    super(r), this.name = e, this.type = me.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var T1 = class extends y5 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(e) {
    super(), this.children = e;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var e;
    return (e = this.children[0]) !== null && e !== void 0 ? e : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(e) {
    this.children = e;
  }
};
var w5 = class extends T1 {
  constructor() {
    super(...arguments), this.type = me.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var vl = class extends T1 {
  constructor() {
    super(...arguments), this.type = me.Root;
  }
  get nodeType() {
    return 9;
  }
};
var k5 = class extends T1 {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(e, r, n = [], i = e === "script" ? me.Script : e === "style" ? me.Style : me.Tag) {
    super(n), this.name = e, this.attribs = r, this.type = i;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(e) {
    this.name = e;
  }
  get attributes() {
    return Object.keys(this.attribs).map((e) => {
      var r, n;
      return {
        name: e,
        value: this.attribs[e],
        namespace: (r = this["x-attribsNamespace"]) === null || r === void 0 ? void 0 : r[e],
        prefix: (n = this["x-attribsPrefix"]) === null || n === void 0 ? void 0 : n[e]
      };
    });
  }
};
function Gt(t15) {
  return I_(t15);
}
function Y0(t15) {
  return t15.type === me.CDATA;
}
function Vs(t15) {
  return t15.type === me.Text;
}
function $1(t15) {
  return t15.type === me.Comment;
}
function V_(t15) {
  return t15.type === me.Directive;
}
function na(t15) {
  return t15.type === me.Root;
}
function ar(t15) {
  return Object.prototype.hasOwnProperty.call(t15, "children");
}
function Cl(t15, e = false) {
  let r;
  if (Vs(t15))
    r = new Vh(t15.data);
  else if ($1(t15))
    r = new b5(t15.data);
  else if (Gt(t15)) {
    const n = e ? Td(t15.children) : [], i = new k5(t15.name, { ...t15.attribs }, n);
    n.forEach((s) => s.parent = i), t15.namespace != null && (i.namespace = t15.namespace), t15["x-attribsNamespace"] && (i["x-attribsNamespace"] = { ...t15["x-attribsNamespace"] }), t15["x-attribsPrefix"] && (i["x-attribsPrefix"] = { ...t15["x-attribsPrefix"] }), r = i;
  } else if (Y0(t15)) {
    const n = e ? Td(t15.children) : [], i = new w5(n);
    n.forEach((s) => s.parent = i), r = i;
  } else if (na(t15)) {
    const n = e ? Td(t15.children) : [], i = new vl(n);
    n.forEach((s) => s.parent = i), t15["x-mode"] && (i["x-mode"] = t15["x-mode"]), r = i;
  } else if (V_(t15)) {
    const n = new x5(t15.name, t15.data);
    t15["x-name"] != null && (n["x-name"] = t15["x-name"], n["x-publicId"] = t15["x-publicId"], n["x-systemId"] = t15["x-systemId"]), r = n;
  } else
    throw new Error(`Not implemented yet: ${t15.type}`);
  return r.startIndex = t15.startIndex, r.endIndex = t15.endIndex, t15.sourceCodeLocation != null && (r.sourceCodeLocation = t15.sourceCodeLocation), r;
}
function Td(t15) {
  const e = t15.map((r) => Cl(r, true));
  for (let r = 1; r < e.length; r++)
    e[r].prev = e[r - 1], e[r - 1].next = e[r];
  return e;
}
var Uy = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var G_ = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(e, r, n) {
    this.dom = [], this.root = new vl(this.dom), this.done = false, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof r == "function" && (n = r, r = Uy), typeof e == "object" && (r = e, e = void 0), this.callback = e ?? null, this.options = r ?? Uy, this.elementCB = n ?? null;
  }
  onparserinit(e) {
    this.parser = e;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [], this.root = new vl(this.dom), this.done = false, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    this.done || (this.done = true, this.parser = null, this.handleCallback(null));
  }
  onerror(e) {
    this.handleCallback(e);
  }
  onclosetag() {
    this.lastNode = null;
    const e = this.tagStack.pop();
    this.options.withEndIndices && (e.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(e);
  }
  onopentag(e, r) {
    const n = this.options.xmlMode ? me.Tag : void 0, i = new k5(e, r, void 0, n);
    this.addNode(i), this.tagStack.push(i);
  }
  ontext(e) {
    const { lastNode: r } = this;
    if (r && r.type === me.Text)
      r.data += e, this.options.withEndIndices && (r.endIndex = this.parser.endIndex);
    else {
      const n = new Vh(e);
      this.addNode(n), this.lastNode = n;
    }
  }
  oncomment(e) {
    if (this.lastNode && this.lastNode.type === me.Comment) {
      this.lastNode.data += e;
      return;
    }
    const r = new b5(e);
    this.addNode(r), this.lastNode = r;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const e = new Vh(""), r = new w5([e]);
    this.addNode(r), e.parent = r, this.lastNode = e;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(e, r) {
    const n = new x5(e, r);
    this.addNode(n);
  }
  handleCallback(e) {
    if (typeof this.callback == "function")
      this.callback(e, this.dom);
    else if (e)
      throw e;
  }
  addNode(e) {
    const r = this.tagStack[this.tagStack.length - 1], n = r.children[r.children.length - 1];
    this.options.withStartIndices && (e.startIndex = this.parser.startIndex), this.options.withEndIndices && (e.endIndex = this.parser.endIndex), r.children.push(e), n && (e.prev = n, n.next = e), e.parent = r, this.lastNode = null;
  }
};
var v5 = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((t15) => t15.charCodeAt(0))
);
var C5 = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((t15) => t15.charCodeAt(0))
);
var $d;
var X_ = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var jp = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  ($d = String.fromCodePoint) !== null && $d !== void 0 ? $d : function(t15) {
    let e = "";
    return t15 > 65535 && (t15 -= 65536, e += String.fromCharCode(t15 >>> 10 & 1023 | 55296), t15 = 56320 | t15 & 1023), e += String.fromCharCode(t15), e;
  }
);
function Y_(t15) {
  var e;
  return t15 >= 55296 && t15 <= 57343 || t15 > 1114111 ? 65533 : (e = X_.get(t15)) !== null && e !== void 0 ? e : t15;
}
var nr;
(function(t15) {
  t15[t15.NUM = 35] = "NUM", t15[t15.SEMI = 59] = "SEMI", t15[t15.EQUALS = 61] = "EQUALS", t15[t15.ZERO = 48] = "ZERO", t15[t15.NINE = 57] = "NINE", t15[t15.LOWER_A = 97] = "LOWER_A", t15[t15.LOWER_F = 102] = "LOWER_F", t15[t15.LOWER_X = 120] = "LOWER_X", t15[t15.LOWER_Z = 122] = "LOWER_Z", t15[t15.UPPER_A = 65] = "UPPER_A", t15[t15.UPPER_F = 70] = "UPPER_F", t15[t15.UPPER_Z = 90] = "UPPER_Z";
})(nr || (nr = {}));
var K_ = 32;
var Qi;
(function(t15) {
  t15[t15.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t15[t15.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t15[t15.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Qi || (Qi = {}));
function Wp(t15) {
  return t15 >= nr.ZERO && t15 <= nr.NINE;
}
function Z_(t15) {
  return t15 >= nr.UPPER_A && t15 <= nr.UPPER_F || t15 >= nr.LOWER_A && t15 <= nr.LOWER_F;
}
function J_(t15) {
  return t15 >= nr.UPPER_A && t15 <= nr.UPPER_Z || t15 >= nr.LOWER_A && t15 <= nr.LOWER_Z || Wp(t15);
}
function Q_(t15) {
  return t15 === nr.EQUALS || J_(t15);
}
var tr;
(function(t15) {
  t15[t15.EntityStart = 0] = "EntityStart", t15[t15.NumericStart = 1] = "NumericStart", t15[t15.NumericDecimal = 2] = "NumericDecimal", t15[t15.NumericHex = 3] = "NumericHex", t15[t15.NamedEntity = 4] = "NamedEntity";
})(tr || (tr = {}));
var Pn;
(function(t15) {
  t15[t15.Legacy = 0] = "Legacy", t15[t15.Strict = 1] = "Strict", t15[t15.Attribute = 2] = "Attribute";
})(Pn || (Pn = {}));
var _5 = class {
  constructor(e, r, n) {
    this.decodeTree = e, this.emitCodePoint = r, this.errors = n, this.state = tr.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Pn.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = tr.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, r) {
    switch (this.state) {
      case tr.EntityStart:
        return e.charCodeAt(r) === nr.NUM ? (this.state = tr.NumericStart, this.consumed += 1, this.stateNumericStart(e, r + 1)) : (this.state = tr.NamedEntity, this.stateNamedEntity(e, r));
      case tr.NumericStart:
        return this.stateNumericStart(e, r);
      case tr.NumericDecimal:
        return this.stateNumericDecimal(e, r);
      case tr.NumericHex:
        return this.stateNumericHex(e, r);
      case tr.NamedEntity:
        return this.stateNamedEntity(e, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, r) {
    return r >= e.length ? -1 : (e.charCodeAt(r) | K_) === nr.LOWER_X ? (this.state = tr.NumericHex, this.consumed += 1, this.stateNumericHex(e, r + 1)) : (this.state = tr.NumericDecimal, this.stateNumericDecimal(e, r));
  }
  addToNumericResult(e, r, n, i) {
    if (r !== n) {
      const s = n - r;
      this.result = this.result * Math.pow(i, s) + parseInt(e.substr(r, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (Wp(i) || Z_(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, n, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (Wp(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, n, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, r) {
    var n;
    if (this.consumed <= r)
      return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === nr.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Pn.Strict)
      return 0;
    return this.emitCodePoint(Y_(this.result), this.consumed), this.errors && (e !== nr.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, r) {
    const { decodeTree: n } = this;
    let i = n[this.treeIndex], s = (i & Qi.VALUE_LENGTH) >> 14;
    for (; r < e.length; r++, this.excess++) {
      const a = e.charCodeAt(r);
      if (this.treeIndex = tS(n, i, this.treeIndex + Math.max(1, s), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Pn.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        Q_(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = n[this.treeIndex], s = (i & Qi.VALUE_LENGTH) >> 14, s !== 0) {
        if (a === nr.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== Pn.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: r, decodeTree: n } = this, i = (n[r] & Qi.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, r, n) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(r === 1 ? i[e] & ~Qi.VALUE_LENGTH : i[e + 1], n), r === 3 && this.emitCodePoint(i[e + 2], n), n;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case tr.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Pn.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case tr.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case tr.NumericHex:
        return this.emitNumericEntity(0, 3);
      case tr.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case tr.EntityStart:
        return 0;
    }
  }
};
function S5(t15) {
  let e = "";
  const r = new _5(t15, (n) => e += jp(n));
  return function(n, i) {
    let s = 0, a = 0;
    for (; (a = n.indexOf("&", a)) >= 0; ) {
      e += n.slice(s, a), r.startEntity(i);
      const l = r.write(
        n,
        // Skip the "&"
        a + 1
      );
      if (l < 0) {
        s = a + r.end();
        break;
      }
      s = a + l, a = l === 0 ? s + 1 : s;
    }
    const o = e + n.slice(s);
    return e = "", o;
  };
}
function tS(t15, e, r, n) {
  const i = (e & Qi.BRANCH_LENGTH) >> 7, s = e & Qi.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && n === s ? r : -1;
  if (s) {
    const l = n - s;
    return l < 0 || l >= i ? -1 : t15[r + l] - 1;
  }
  let a = r, o = a + i - 1;
  for (; a <= o; ) {
    const l = a + o >>> 1, c = t15[l];
    if (c < n)
      a = l + 1;
    else if (c > n)
      o = l - 1;
    else
      return t15[l + i];
  }
  return -1;
}
S5(v5);
S5(C5);
var Vy = /["&'<>$\x80-\uFFFF]/g;
var eS = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var rS = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (t15, e) => t15.codePointAt(e) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (t15, e) => (t15.charCodeAt(e) & 64512) === 55296 ? (t15.charCodeAt(e) - 55296) * 1024 + t15.charCodeAt(e + 1) - 56320 + 65536 : t15.charCodeAt(e)
  )
);
function A5(t15) {
  let e = "", r = 0, n;
  for (; (n = Vy.exec(t15)) !== null; ) {
    const i = n.index, s = t15.charCodeAt(i), a = eS.get(s);
    a !== void 0 ? (e += t15.substring(r, i) + a, r = i + 1) : (e += `${t15.substring(r, i)}&#x${rS(t15, i).toString(16)};`, r = Vy.lastIndex += +((s & 64512) === 55296));
  }
  return e + t15.substr(r);
}
function T5(t15, e) {
  return function(r) {
    let n, i = 0, s = "";
    for (; n = t15.exec(r); )
      i !== n.index && (s += r.substring(i, n.index)), s += e.get(n[0].charCodeAt(0)), i = n.index + 1;
    return s + r.substring(i);
  };
}
var nS = T5(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var iS = T5(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
var sS = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((t15) => [t15.toLowerCase(), t15]));
var aS = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((t15) => [t15.toLowerCase(), t15]));
var oS = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function lS(t15) {
  return t15.replace(/"/g, "&quot;");
}
function cS(t15, e) {
  var r;
  if (!t15)
    return;
  const n = ((r = e.encodeEntities) !== null && r !== void 0 ? r : e.decodeEntities) === false ? lS : e.xmlMode || e.encodeEntities !== "utf8" ? A5 : nS;
  return Object.keys(t15).map((i) => {
    var s, a;
    const o = (s = t15[i]) !== null && s !== void 0 ? s : "";
    return e.xmlMode === "foreign" && (i = (a = aS.get(i)) !== null && a !== void 0 ? a : i), !e.emptyAttrs && !e.xmlMode && o === "" ? i : `${i}="${n(o)}"`;
  }).join(" ");
}
var Gy = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function K0(t15, e = {}) {
  const r = "length" in t15 ? t15 : [t15];
  let n = "";
  for (let i = 0; i < r.length; i++)
    n += hS(r[i], e);
  return n;
}
function hS(t15, e) {
  switch (t15.type) {
    case O_:
      return K0(t15.children, e);
    case U_:
    case q_:
      return fS(t15);
    case R_:
      return yS(t15);
    case H_:
      return gS(t15);
    case P_:
    case j_:
    case W_:
      return pS(t15, e);
    case z_:
      return mS(t15, e);
  }
}
var uS = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var dS = /* @__PURE__ */ new Set(["svg", "math"]);
function pS(t15, e) {
  var r;
  e.xmlMode === "foreign" && (t15.name = (r = sS.get(t15.name)) !== null && r !== void 0 ? r : t15.name, t15.parent && uS.has(t15.parent.name) && (e = { ...e, xmlMode: false })), !e.xmlMode && dS.has(t15.name) && (e = { ...e, xmlMode: "foreign" });
  let n = `<${t15.name}`;
  const i = cS(t15.attribs, e);
  return i && (n += ` ${i}`), t15.children.length === 0 && (e.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    e.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    e.selfClosingTags && Gy.has(t15.name)
  )) ? (e.xmlMode || (n += " "), n += "/>") : (n += ">", t15.children.length > 0 && (n += K0(t15.children, e)), (e.xmlMode || !Gy.has(t15.name)) && (n += `</${t15.name}>`)), n;
}
function fS(t15) {
  return `<${t15.data}>`;
}
function mS(t15, e) {
  var r;
  let n = t15.data || "";
  return ((r = e.encodeEntities) !== null && r !== void 0 ? r : e.decodeEntities) !== false && !(!e.xmlMode && t15.parent && oS.has(t15.parent.name)) && (n = e.xmlMode || e.encodeEntities !== "utf8" ? A5(n) : iS(n)), n;
}
function gS(t15) {
  return `<![CDATA[${t15.children[0].data}]]>`;
}
function yS(t15) {
  return `<!--${t15.data}-->`;
}
function $5(t15, e) {
  return K0(t15, e);
}
function bS(t15, e) {
  return ar(t15) ? t15.children.map((r) => $5(r, e)).join("") : "";
}
function yh(t15) {
  return Array.isArray(t15) ? t15.map(yh).join("") : Gt(t15) ? t15.name === "br" ? `
` : yh(t15.children) : Y0(t15) ? yh(t15.children) : Vs(t15) ? t15.data : "";
}
function ja(t15) {
  return Array.isArray(t15) ? t15.map(ja).join("") : ar(t15) && !$1(t15) ? ja(t15.children) : Vs(t15) ? t15.data : "";
}
function Gh(t15) {
  return Array.isArray(t15) ? t15.map(Gh).join("") : ar(t15) && (t15.type === me.Tag || Y0(t15)) ? Gh(t15.children) : Vs(t15) ? t15.data : "";
}
function Z0(t15) {
  return ar(t15) ? t15.children : [];
}
function E5(t15) {
  return t15.parent || null;
}
function M5(t15) {
  const e = E5(t15);
  if (e != null)
    return Z0(e);
  const r = [t15];
  let { prev: n, next: i } = t15;
  for (; n != null; )
    r.unshift(n), { prev: n } = n;
  for (; i != null; )
    r.push(i), { next: i } = i;
  return r;
}
function xS(t15, e) {
  var r;
  return (r = t15.attribs) === null || r === void 0 ? void 0 : r[e];
}
function wS(t15, e) {
  return t15.attribs != null && Object.prototype.hasOwnProperty.call(t15.attribs, e) && t15.attribs[e] != null;
}
function kS(t15) {
  return t15.name;
}
function E1(t15) {
  let { next: e } = t15;
  for (; e !== null && !Gt(e); )
    ({ next: e } = e);
  return e;
}
function M1(t15) {
  let { prev: e } = t15;
  for (; e !== null && !Gt(e); )
    ({ prev: e } = e);
  return e;
}
function ia(t15) {
  if (t15.prev && (t15.prev.next = t15.next), t15.next && (t15.next.prev = t15.prev), t15.parent) {
    const e = t15.parent.children, r = e.lastIndexOf(t15);
    r >= 0 && e.splice(r, 1);
  }
  t15.next = null, t15.prev = null, t15.parent = null;
}
function vS(t15, e) {
  const r = e.prev = t15.prev;
  r && (r.next = e);
  const n = e.next = t15.next;
  n && (n.prev = e);
  const i = e.parent = t15.parent;
  if (i) {
    const s = i.children;
    s[s.lastIndexOf(t15)] = e, t15.parent = null;
  }
}
function CS(t15, e) {
  if (ia(e), e.next = null, e.parent = t15, t15.children.push(e) > 1) {
    const r = t15.children[t15.children.length - 2];
    r.next = e, e.prev = r;
  } else
    e.prev = null;
}
function _S(t15, e) {
  ia(e);
  const { parent: r } = t15, n = t15.next;
  if (e.next = n, e.prev = t15, t15.next = e, e.parent = r, n) {
    if (n.prev = e, r) {
      const i = r.children;
      i.splice(i.lastIndexOf(n), 0, e);
    }
  } else r && r.children.push(e);
}
function SS(t15, e) {
  if (ia(e), e.parent = t15, e.prev = null, t15.children.unshift(e) !== 1) {
    const r = t15.children[1];
    r.prev = e, e.next = r;
  } else
    e.next = null;
}
function AS(t15, e) {
  ia(e);
  const { parent: r } = t15;
  if (r) {
    const n = r.children;
    n.splice(n.indexOf(t15), 0, e);
  }
  t15.prev && (t15.prev.next = e), e.parent = r, e.prev = t15.prev, e.next = t15, t15.prev = e;
}
function J0(t15, e, r = true, n = 1 / 0) {
  return B1(t15, Array.isArray(e) ? e : [e], r, n);
}
function B1(t15, e, r, n) {
  const i = [], s = [e], a = [0];
  for (; ; ) {
    if (a[0] >= s[0].length) {
      if (a.length === 1)
        return i;
      s.shift(), a.shift();
      continue;
    }
    const o = s[0][a[0]++];
    if (t15(o) && (i.push(o), --n <= 0))
      return i;
    r && ar(o) && o.children.length > 0 && (a.unshift(0), s.unshift(o.children));
  }
}
function TS(t15, e) {
  return e.find(t15);
}
function L1(t15, e, r = true) {
  let n = null;
  for (let i = 0; i < e.length && !n; i++) {
    const s = e[i];
    if (Gt(s))
      t15(s) ? n = s : r && s.children.length > 0 && (n = L1(t15, s.children, true));
    else continue;
  }
  return n;
}
function B5(t15, e) {
  return e.some((r) => Gt(r) && (t15(r) || B5(t15, r.children)));
}
function $S(t15, e) {
  const r = [], n = [e], i = [0];
  for (; ; ) {
    if (i[0] >= n[0].length) {
      if (n.length === 1)
        return r;
      n.shift(), i.shift();
      continue;
    }
    const s = n[0][i[0]++];
    Gt(s) && (t15(s) && r.push(s), s.children.length > 0 && (i.unshift(0), n.unshift(s.children)));
  }
}
var Xh = {
  tag_name(t15) {
    return typeof t15 == "function" ? (e) => Gt(e) && t15(e.name) : t15 === "*" ? Gt : (e) => Gt(e) && e.name === t15;
  },
  tag_type(t15) {
    return typeof t15 == "function" ? (e) => t15(e.type) : (e) => e.type === t15;
  },
  tag_contains(t15) {
    return typeof t15 == "function" ? (e) => Vs(e) && t15(e.data) : (e) => Vs(e) && e.data === t15;
  }
};
function L5(t15, e) {
  return typeof e == "function" ? (r) => Gt(r) && e(r.attribs[t15]) : (r) => Gt(r) && r.attribs[t15] === e;
}
function ES(t15, e) {
  return (r) => t15(r) || e(r);
}
function D5(t15) {
  const e = Object.keys(t15).map((r) => {
    const n = t15[r];
    return Object.prototype.hasOwnProperty.call(Xh, r) ? Xh[r](n) : L5(r, n);
  });
  return e.length === 0 ? null : e.reduce(ES);
}
function MS(t15, e) {
  const r = D5(t15);
  return r ? r(e) : true;
}
function BS(t15, e, r, n = 1 / 0) {
  const i = D5(t15);
  return i ? J0(i, e, r, n) : [];
}
function LS(t15, e, r = true) {
  return Array.isArray(e) || (e = [e]), L1(L5("id", t15), e, r);
}
function so(t15, e, r = true, n = 1 / 0) {
  return J0(Xh.tag_name(t15), e, r, n);
}
function DS(t15, e, r = true, n = 1 / 0) {
  return J0(Xh.tag_type(t15), e, r, n);
}
function FS(t15) {
  let e = t15.length;
  for (; --e >= 0; ) {
    const r = t15[e];
    if (e > 0 && t15.lastIndexOf(r, e - 1) >= 0) {
      t15.splice(e, 1);
      continue;
    }
    for (let n = r.parent; n; n = n.parent)
      if (t15.includes(n)) {
        t15.splice(e, 1);
        break;
      }
  }
  return t15;
}
var dn;
(function(t15) {
  t15[t15.DISCONNECTED = 1] = "DISCONNECTED", t15[t15.PRECEDING = 2] = "PRECEDING", t15[t15.FOLLOWING = 4] = "FOLLOWING", t15[t15.CONTAINS = 8] = "CONTAINS", t15[t15.CONTAINED_BY = 16] = "CONTAINED_BY";
})(dn || (dn = {}));
function F5(t15, e) {
  const r = [], n = [];
  if (t15 === e)
    return 0;
  let i = ar(t15) ? t15 : t15.parent;
  for (; i; )
    r.unshift(i), i = i.parent;
  for (i = ar(e) ? e : e.parent; i; )
    n.unshift(i), i = i.parent;
  const s = Math.min(r.length, n.length);
  let a = 0;
  for (; a < s && r[a] === n[a]; )
    a++;
  if (a === 0)
    return dn.DISCONNECTED;
  const o = r[a - 1], l = o.children, c = r[a], h = n[a];
  return l.indexOf(c) > l.indexOf(h) ? o === e ? dn.FOLLOWING | dn.CONTAINED_BY : dn.FOLLOWING : o === t15 ? dn.PRECEDING | dn.CONTAINS : dn.PRECEDING;
}
function ao(t15) {
  return t15 = t15.filter((e, r, n) => !n.includes(e, r + 1)), t15.sort((e, r) => {
    const n = F5(e, r);
    return n & dn.PRECEDING ? -1 : n & dn.FOLLOWING ? 1 : 0;
  }), t15;
}
function NS(t15) {
  const e = Yh(RS, t15);
  return e ? e.name === "feed" ? IS(e) : OS(e) : null;
}
function IS(t15) {
  var e;
  const r = t15.children, n = {
    type: "atom",
    items: so("entry", r).map((a) => {
      var o;
      const { children: l } = a, c = { media: N5(l) };
      Or(c, "id", "id", l), Or(c, "title", "title", l);
      const h = (o = Yh("link", l)) === null || o === void 0 ? void 0 : o.attribs.href;
      h && (c.link = h);
      const p = ts("summary", l) || ts("content", l);
      p && (c.description = p);
      const m = ts("updated", l);
      return m && (c.pubDate = new Date(m)), c;
    })
  };
  Or(n, "id", "id", r), Or(n, "title", "title", r);
  const i = (e = Yh("link", r)) === null || e === void 0 ? void 0 : e.attribs.href;
  i && (n.link = i), Or(n, "description", "subtitle", r);
  const s = ts("updated", r);
  return s && (n.updated = new Date(s)), Or(n, "author", "email", r, true), n;
}
function OS(t15) {
  var e, r;
  const n = (r = (e = Yh("channel", t15.children)) === null || e === void 0 ? void 0 : e.children) !== null && r !== void 0 ? r : [], i = {
    type: t15.name.substr(0, 3),
    id: "",
    items: so("item", t15.children).map((a) => {
      const { children: o } = a, l = { media: N5(o) };
      Or(l, "id", "guid", o), Or(l, "title", "title", o), Or(l, "link", "link", o), Or(l, "description", "description", o);
      const c = ts("pubDate", o) || ts("dc:date", o);
      return c && (l.pubDate = new Date(c)), l;
    })
  };
  Or(i, "title", "title", n), Or(i, "link", "link", n), Or(i, "description", "description", n);
  const s = ts("lastBuildDate", n);
  return s && (i.updated = new Date(s)), Or(i, "author", "managingEditor", n, true), i;
}
var zS = ["url", "type", "lang"];
var qS = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function N5(t15) {
  return so("media:content", t15).map((e) => {
    const { attribs: r } = e, n = {
      medium: r.medium,
      isDefault: !!r.isDefault
    };
    for (const i of zS)
      r[i] && (n[i] = r[i]);
    for (const i of qS)
      r[i] && (n[i] = parseInt(r[i], 10));
    return r.expression && (n.expression = r.expression), n;
  });
}
function Yh(t15, e) {
  return so(t15, e, true, 1)[0];
}
function ts(t15, e, r = false) {
  return ja(so(t15, e, r, 1)).trim();
}
function Or(t15, e, r, n, i = false) {
  const s = ts(r, n, i);
  s && (t15[e] = s);
}
function RS(t15) {
  return t15 === "rss" || t15 === "feed" || t15 === "rdf:RDF";
}
var Q0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  get DocumentPosition() {
    return dn;
  },
  append: _S,
  appendChild: CS,
  compareDocumentPosition: F5,
  existsOne: B5,
  filter: J0,
  find: B1,
  findAll: $S,
  findOne: L1,
  findOneChild: TS,
  getAttributeValue: xS,
  getChildren: Z0,
  getElementById: LS,
  getElements: BS,
  getElementsByTagName: so,
  getElementsByTagType: DS,
  getFeed: NS,
  getInnerHTML: bS,
  getName: kS,
  getOuterHTML: $5,
  getParent: E5,
  getSiblings: M5,
  getText: yh,
  hasAttrib: wS,
  hasChildren: ar,
  innerText: Gh,
  isCDATA: Y0,
  isComment: $1,
  isDocument: na,
  isTag: Gt,
  isText: Vs,
  nextElementSibling: E1,
  prepend: AS,
  prependChild: SS,
  prevElementSibling: M1,
  removeElement: ia,
  removeSubsets: FS,
  replaceElement: vS,
  testElement: MS,
  textContent: ja,
  uniqueSort: ao
}, Symbol.toStringTag, { value: "Module" }));
function I5(t15, e, r) {
  return t15 ? t15(e ?? t15._root.children, null, void 0, r).toString() : "";
}
function PS(t15, e) {
  return typeof t15 == "object" && t15 != null && !("length" in t15) && !("type" in t15);
}
function jS(t15, e) {
  const r = PS(t15) ? (e = t15, void 0) : t15, n = {
    ...this === null || this === void 0 ? void 0 : this._options,
    ...Pp(e)
  };
  return I5(this, r, n);
}
function WS(t15) {
  const e = { ...this._options, xmlMode: true };
  return I5(this, t15, e);
}
function _l(t15) {
  const e = t15 ?? (this ? this.root() : []);
  let r = "";
  for (let n = 0; n < e.length; n++)
    r += ja(e[n]);
  return r;
}
function HS(t15, e, r = typeof e == "boolean" ? e : false) {
  if (!t15 || typeof t15 != "string")
    return null;
  typeof e == "boolean" && (r = e);
  const n = this.load(t15, this._options, false);
  return r || n("script").remove(), [...n.root()[0].children];
}
function US() {
  return this(this._root);
}
function O5(t15, e) {
  if (e === t15)
    return false;
  let r = e;
  for (; r && r !== r.parent; )
    if (r = r.parent, r === t15)
      return true;
  return false;
}
function VS(t15) {
  return this.root().extract(t15);
}
function GS(t15, e) {
  if (!Xy(t15) || !Xy(e))
    return;
  let r = t15.length;
  const n = +e.length;
  for (let i = 0; i < n; i++)
    t15[r++] = e[i];
  return t15.length = r, t15;
}
function Xy(t15) {
  if (Array.isArray(t15))
    return true;
  if (typeof t15 != "object" || t15 === null || !("length" in t15) || typeof t15.length != "number" || t15.length < 0)
    return false;
  for (let e = 0; e < t15.length; e++)
    if (!(e in t15))
      return false;
  return true;
}
var XS = Object.freeze(Object.defineProperty({
  __proto__: null,
  contains: O5,
  extract: VS,
  html: jS,
  merge: GS,
  parseHTML: HS,
  root: US,
  text: _l,
  xml: WS
}, Symbol.toStringTag, { value: "Module" }));
function Si(t15) {
  return t15.cheerio != null;
}
function YS(t15) {
  return t15.replace(/[._-](\w|$)/g, (e, r) => r.toUpperCase());
}
function KS(t15) {
  return t15.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function Ie(t15, e) {
  const r = t15.length;
  for (let n = 0; n < r; n++)
    e(t15[n], n);
  return t15;
}
var Fs;
(function(t15) {
  t15[t15.LowerA = 97] = "LowerA", t15[t15.LowerZ = 122] = "LowerZ", t15[t15.UpperA = 65] = "UpperA", t15[t15.UpperZ = 90] = "UpperZ", t15[t15.Exclamation = 33] = "Exclamation";
})(Fs || (Fs = {}));
function Hp(t15) {
  const e = t15.indexOf("<");
  if (e < 0 || e > t15.length - 3)
    return false;
  const r = t15.charCodeAt(e + 1);
  return (r >= Fs.LowerA && r <= Fs.LowerZ || r >= Fs.UpperA && r <= Fs.UpperZ || r === Fs.Exclamation) && t15.includes(">", e + 2);
}
var Sl = Object.prototype.hasOwnProperty;
var Al = /\s+/;
var Up = "data-";
var D1 = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
var ZS = /^{[^]*}$|^\[[^]*]$/;
function Kh(t15, e, r) {
  var n;
  if (!(!t15 || !Gt(t15))) {
    if ((n = t15.attribs) !== null && n !== void 0 || (t15.attribs = {}), !e)
      return t15.attribs;
    if (Sl.call(t15.attribs, e))
      return !r && D1.test(e) ? e : t15.attribs[e];
    if (t15.name === "option" && e === "value")
      return _l(t15.children);
    if (t15.name === "input" && (t15.attribs.type === "radio" || t15.attribs.type === "checkbox") && e === "value")
      return "on";
  }
}
function La(t15, e, r) {
  r === null ? q5(t15, e) : t15.attribs[e] = `${r}`;
}
function JS(t15, e) {
  if (typeof t15 == "object" || e !== void 0) {
    if (typeof e == "function") {
      if (typeof t15 != "string")
        throw new Error("Bad combination of arguments.");
      return Ie(this, (r, n) => {
        Gt(r) && La(r, t15, e.call(r, n, r.attribs[t15]));
      });
    }
    return Ie(this, (r) => {
      if (Gt(r))
        if (typeof t15 == "object")
          for (const n of Object.keys(t15)) {
            const i = t15[n];
            La(r, n, i);
          }
        else
          La(r, t15, e);
    });
  }
  return arguments.length > 1 ? this : Kh(this[0], t15, this.options.xmlMode);
}
function Yy(t15, e, r) {
  return e in t15 ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    t15[e]
  ) : !r && D1.test(e) ? Kh(t15, e, false) !== void 0 : Kh(t15, e, r);
}
function Ed(t15, e, r, n) {
  e in t15 ? t15[e] = r : La(t15, e, !n && D1.test(e) ? r ? "" : null : `${r}`);
}
function QS(t15, e) {
  var r;
  if (typeof t15 == "string" && e === void 0) {
    const n = this[0];
    if (!n || !Gt(n))
      return;
    switch (t15) {
      case "style": {
        const i = this.css(), s = Object.keys(i);
        for (let a = 0; a < s.length; a++)
          i[a] = s[a];
        return i.length = s.length, i;
      }
      case "tagName":
      case "nodeName":
        return n.name.toUpperCase();
      case "href":
      case "src": {
        const i = (r = n.attribs) === null || r === void 0 ? void 0 : r[t15];
        return typeof URL < "u" && (t15 === "href" && (n.tagName === "a" || n.tagName === "link") || t15 === "src" && (n.tagName === "img" || n.tagName === "iframe" || n.tagName === "audio" || n.tagName === "video" || n.tagName === "source")) && i !== void 0 && this.options.baseURI ? new URL(i, this.options.baseURI).href : i;
      }
      case "innerText":
        return Gh(n);
      case "textContent":
        return ja(n);
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return Yy(n, t15, this.options.xmlMode);
    }
  }
  if (typeof t15 == "object" || e !== void 0) {
    if (typeof e == "function") {
      if (typeof t15 == "object")
        throw new TypeError("Bad combination of arguments.");
      return Ie(this, (n, i) => {
        Gt(n) && Ed(n, t15, e.call(n, i, Yy(n, t15, this.options.xmlMode)), this.options.xmlMode);
      });
    }
    return Ie(this, (n) => {
      if (Gt(n))
        if (typeof t15 == "object")
          for (const i of Object.keys(t15)) {
            const s = t15[i];
            Ed(n, i, s, this.options.xmlMode);
          }
        else
          Ed(n, t15, e, this.options.xmlMode);
    });
  }
}
function Ky(t15, e, r) {
  var n;
  (n = t15.data) !== null && n !== void 0 || (t15.data = {}), typeof e == "object" ? Object.assign(t15.data, e) : typeof e == "string" && r !== void 0 && (t15.data[e] = r);
}
function tA(t15) {
  for (const e of Object.keys(t15.attribs)) {
    if (!e.startsWith(Up))
      continue;
    const r = YS(e.slice(Up.length));
    Sl.call(t15.data, r) || (t15.data[r] = z5(t15.attribs[e]));
  }
  return t15.data;
}
function eA(t15, e) {
  const r = Up + KS(e), n = t15.data;
  if (Sl.call(n, e))
    return n[e];
  if (Sl.call(t15.attribs, r))
    return n[e] = z5(t15.attribs[r]);
}
function z5(t15) {
  if (t15 === "null")
    return null;
  if (t15 === "true")
    return true;
  if (t15 === "false")
    return false;
  const e = Number(t15);
  if (t15 === String(e))
    return e;
  if (ZS.test(t15))
    try {
      return JSON.parse(t15);
    } catch {
    }
  return t15;
}
function rA(t15, e) {
  var r;
  const n = this[0];
  if (!n || !Gt(n))
    return;
  const i = n;
  return (r = i.data) !== null && r !== void 0 || (i.data = {}), t15 == null ? tA(i) : typeof t15 == "object" || e !== void 0 ? (Ie(this, (s) => {
    Gt(s) && (typeof t15 == "object" ? Ky(s, t15) : Ky(s, t15, e));
  }), this) : eA(i, t15);
}
function nA(t15) {
  const e = arguments.length === 0, r = this[0];
  if (!r || !Gt(r))
    return e ? void 0 : this;
  switch (r.name) {
    case "textarea":
      return this.text(t15);
    case "select": {
      const n = this.find("option:selected");
      if (!e) {
        if (this.attr("multiple") == null && typeof t15 == "object")
          return this;
        this.find("option").removeAttr("selected");
        const i = typeof t15 == "object" ? t15 : [t15];
        for (const s of i)
          this.find(`option[value="${s}"]`).attr("selected", "");
        return this;
      }
      return this.attr("multiple") ? n.toArray().map((i) => _l(i.children)) : n.attr("value");
    }
    case "input":
    case "option":
      return e ? this.attr("value") : this.attr("value", t15);
  }
}
function q5(t15, e) {
  !t15.attribs || !Sl.call(t15.attribs, e) || delete t15.attribs[e];
}
function Zh(t15) {
  return t15 ? t15.trim().split(Al) : [];
}
function iA(t15) {
  const e = Zh(t15);
  for (const r of e)
    Ie(this, (n) => {
      Gt(n) && q5(n, r);
    });
  return this;
}
function sA(t15) {
  return this.toArray().some((e) => {
    const r = Gt(e) && e.attribs.class;
    let n = -1;
    if (r && t15.length > 0)
      for (; (n = r.indexOf(t15, n + 1)) > -1; ) {
        const i = n + t15.length;
        if ((n === 0 || Al.test(r[n - 1])) && (i === r.length || Al.test(r[i])))
          return true;
      }
    return false;
  });
}
function R5(t15) {
  if (typeof t15 == "function")
    return Ie(this, (n, i) => {
      if (Gt(n)) {
        const s = n.attribs.class || "";
        R5.call([n], t15.call(n, i, s));
      }
    });
  if (!t15 || typeof t15 != "string")
    return this;
  const e = t15.split(Al), r = this.length;
  for (let n = 0; n < r; n++) {
    const i = this[n];
    if (!Gt(i))
      continue;
    const s = Kh(i, "class", false);
    if (s) {
      let a = ` ${s} `;
      for (const o of e) {
        const l = `${o} `;
        a.includes(` ${l}`) || (a += l);
      }
      La(i, "class", a.trim());
    } else
      La(i, "class", e.join(" ").trim());
  }
  return this;
}
function P5(t15) {
  if (typeof t15 == "function")
    return Ie(this, (i, s) => {
      Gt(i) && P5.call([i], t15.call(i, s, i.attribs.class || ""));
    });
  const e = Zh(t15), r = e.length, n = arguments.length === 0;
  return Ie(this, (i) => {
    if (Gt(i))
      if (n)
        i.attribs.class = "";
      else {
        const s = Zh(i.attribs.class);
        let a = false;
        for (let o = 0; o < r; o++) {
          const l = s.indexOf(e[o]);
          l >= 0 && (s.splice(l, 1), a = true, o--);
        }
        a && (i.attribs.class = s.join(" "));
      }
  });
}
function j5(t15, e) {
  if (typeof t15 == "function")
    return Ie(this, (a, o) => {
      Gt(a) && j5.call([a], t15.call(a, o, a.attribs.class || "", e), e);
    });
  if (!t15 || typeof t15 != "string")
    return this;
  const r = t15.split(Al), n = r.length, i = typeof e == "boolean" ? e ? 1 : -1 : 0, s = this.length;
  for (let a = 0; a < s; a++) {
    const o = this[a];
    if (!Gt(o))
      continue;
    const l = Zh(o.attribs.class);
    for (let c = 0; c < n; c++) {
      const h = l.indexOf(r[c]);
      i >= 0 && h < 0 ? l.push(r[c]) : i <= 0 && h >= 0 && l.splice(h, 1);
    }
    o.attribs.class = l.join(" ");
  }
  return this;
}
var aA = Object.freeze(Object.defineProperty({
  __proto__: null,
  addClass: R5,
  attr: JS,
  data: rA,
  hasClass: sA,
  prop: QS,
  removeAttr: iA,
  removeClass: P5,
  toggleClass: j5,
  val: nA
}, Symbol.toStringTag, { value: "Module" }));
var qt;
(function(t15) {
  t15.Attribute = "attribute", t15.Pseudo = "pseudo", t15.PseudoElement = "pseudo-element", t15.Tag = "tag", t15.Universal = "universal", t15.Adjacent = "adjacent", t15.Child = "child", t15.Descendant = "descendant", t15.Parent = "parent", t15.Sibling = "sibling", t15.ColumnCombinator = "column-combinator";
})(qt || (qt = {}));
var Ge;
(function(t15) {
  t15.Any = "any", t15.Element = "element", t15.End = "end", t15.Equals = "equals", t15.Exists = "exists", t15.Hyphen = "hyphen", t15.Not = "not", t15.Start = "start";
})(Ge || (Ge = {}));
var Zy = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var oA = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var lA = /* @__PURE__ */ new Map([
  [126, Ge.Element],
  [94, Ge.Start],
  [36, Ge.End],
  [42, Ge.Any],
  [33, Ge.Not],
  [124, Ge.Hyphen]
]);
var cA = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function pl(t15) {
  switch (t15.type) {
    case qt.Adjacent:
    case qt.Child:
    case qt.Descendant:
    case qt.Parent:
    case qt.Sibling:
    case qt.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
var hA = /* @__PURE__ */ new Set(["contains", "icontains"]);
function uA(t15, e, r) {
  const n = parseInt(e, 16) - 65536;
  return n !== n || r ? e : n < 0 ? (
    // BMP codepoint
    String.fromCharCode(n + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(n >> 10 | 55296, n & 1023 | 56320)
  );
}
function Lo(t15) {
  return t15.replace(oA, uA);
}
function Md(t15) {
  return t15 === 39 || t15 === 34;
}
function Jy(t15) {
  return t15 === 32 || t15 === 9 || t15 === 10 || t15 === 12 || t15 === 13;
}
function tu(t15) {
  const e = [], r = W5(e, `${t15}`, 0);
  if (r < t15.length)
    throw new Error(`Unmatched selector: ${t15.slice(r)}`);
  return e;
}
function W5(t15, e, r) {
  let n = [];
  function i(m) {
    const g = e.slice(r + m).match(Zy);
    if (!g)
      throw new Error(`Expected name, found ${e.slice(r)}`);
    const [y] = g;
    return r += m + y.length, Lo(y);
  }
  function s(m) {
    for (r += m; r < e.length && Jy(e.charCodeAt(r)); )
      r++;
  }
  function a() {
    r += 1;
    const m = r;
    let g = 1;
    for (; g > 0 && r < e.length; r++)
      e.charCodeAt(r) === 40 && !o(r) ? g++ : e.charCodeAt(r) === 41 && !o(r) && g--;
    if (g)
      throw new Error("Parenthesis not matched");
    return Lo(e.slice(m, r - 1));
  }
  function o(m) {
    let g = 0;
    for (; e.charCodeAt(--m) === 92; )
      g++;
    return (g & 1) === 1;
  }
  function l() {
    if (n.length > 0 && pl(n[n.length - 1]))
      throw new Error("Did not expect successive traversals.");
  }
  function c(m) {
    if (n.length > 0 && n[n.length - 1].type === qt.Descendant) {
      n[n.length - 1].type = m;
      return;
    }
    l(), n.push({ type: m });
  }
  function h(m, g) {
    n.push({
      type: qt.Attribute,
      name: m,
      action: g,
      value: i(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function p() {
    if (n.length && n[n.length - 1].type === qt.Descendant && n.pop(), n.length === 0)
      throw new Error("Empty sub-selector");
    t15.push(n);
  }
  if (s(0), e.length === r)
    return r;
  t: for (; r < e.length; ) {
    const m = e.charCodeAt(r);
    switch (m) {
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        (n.length === 0 || n[0].type !== qt.Descendant) && (l(), n.push({ type: qt.Descendant })), s(1);
        break;
      }
      case 62: {
        c(qt.Child), s(1);
        break;
      }
      case 60: {
        c(qt.Parent), s(1);
        break;
      }
      case 126: {
        c(qt.Sibling), s(1);
        break;
      }
      case 43: {
        c(qt.Adjacent), s(1);
        break;
      }
      case 46: {
        h("class", Ge.Element);
        break;
      }
      case 35: {
        h("id", Ge.Equals);
        break;
      }
      case 91: {
        s(1);
        let g, y = null;
        e.charCodeAt(r) === 124 ? g = i(1) : e.startsWith("*|", r) ? (y = "*", g = i(2)) : (g = i(0), e.charCodeAt(r) === 124 && e.charCodeAt(r + 1) !== 61 && (y = g, g = i(1))), s(0);
        let x = Ge.Exists;
        const k = lA.get(e.charCodeAt(r));
        if (k) {
          if (x = k, e.charCodeAt(r + 1) !== 61)
            throw new Error("Expected `=`");
          s(2);
        } else e.charCodeAt(r) === 61 && (x = Ge.Equals, s(1));
        let C = "", A = null;
        if (x !== "exists") {
          if (Md(e.charCodeAt(r))) {
            const L = e.charCodeAt(r);
            let q = r + 1;
            for (; q < e.length && (e.charCodeAt(q) !== L || o(q)); )
              q += 1;
            if (e.charCodeAt(q) !== L)
              throw new Error("Attribute value didn't end");
            C = Lo(e.slice(r + 1, q)), r = q + 1;
          } else {
            const L = r;
            for (; r < e.length && (!Jy(e.charCodeAt(r)) && e.charCodeAt(r) !== 93 || o(r)); )
              r += 1;
            C = Lo(e.slice(L, r));
          }
          s(0);
          const B = e.charCodeAt(r) | 32;
          B === 115 ? (A = false, s(1)) : B === 105 && (A = true, s(1));
        }
        if (e.charCodeAt(r) !== 93)
          throw new Error("Attribute selector didn't terminate");
        r += 1;
        const $ = {
          type: qt.Attribute,
          name: g,
          action: x,
          value: C,
          namespace: y,
          ignoreCase: A
        };
        n.push($);
        break;
      }
      case 58: {
        if (e.charCodeAt(r + 1) === 58) {
          n.push({
            type: qt.PseudoElement,
            name: i(2).toLowerCase(),
            data: e.charCodeAt(r) === 40 ? a() : null
          });
          continue;
        }
        const g = i(1).toLowerCase();
        let y = null;
        if (e.charCodeAt(r) === 40)
          if (cA.has(g)) {
            if (Md(e.charCodeAt(r + 1)))
              throw new Error(`Pseudo-selector ${g} cannot be quoted`);
            if (y = [], r = W5(y, e, r + 1), e.charCodeAt(r) !== 41)
              throw new Error(`Missing closing parenthesis in :${g} (${e})`);
            r += 1;
          } else {
            if (y = a(), hA.has(g)) {
              const x = y.charCodeAt(0);
              x === y.charCodeAt(y.length - 1) && Md(x) && (y = y.slice(1, -1));
            }
            y = Lo(y);
          }
        n.push({ type: qt.Pseudo, name: g, data: y });
        break;
      }
      case 44: {
        p(), n = [], s(1);
        break;
      }
      default: {
        if (e.startsWith("/*", r)) {
          const x = e.indexOf("*/", r + 2);
          if (x < 0)
            throw new Error("Comment was not terminated");
          r = x + 2, n.length === 0 && s(0);
          break;
        }
        let g = null, y;
        if (m === 42)
          r += 1, y = "*";
        else if (m === 124) {
          if (y = "", e.charCodeAt(r + 1) === 124) {
            c(qt.ColumnCombinator), s(2);
            break;
          }
        } else if (Zy.test(e.slice(r)))
          y = i(0);
        else
          break t;
        e.charCodeAt(r) === 124 && e.charCodeAt(r + 1) !== 124 && (g = y, e.charCodeAt(r + 1) === 42 ? (y = "*", r += 2) : y = i(1)), n.push(y === "*" ? { type: qt.Universal, namespace: g } : { type: qt.Tag, name: y, namespace: g });
      }
    }
  }
  return p(), r;
}
function dA(t15) {
  return t15 && t15.__esModule && Object.prototype.hasOwnProperty.call(t15, "default") ? t15.default : t15;
}
var Qy;
var t2;
function pA() {
  return t2 || (t2 = 1, Qy = {
    trueFunc: function() {
      return true;
    },
    falseFunc: function() {
      return false;
    }
  }), Qy;
}
var Jh = pA();
var ee = dA(Jh);
var H5 = /* @__PURE__ */ new Map([
  [qt.Universal, 50],
  [qt.Tag, 30],
  [qt.Attribute, 1],
  [qt.Pseudo, 0]
]);
function F1(t15) {
  return !H5.has(t15.type);
}
var fA = /* @__PURE__ */ new Map([
  [Ge.Exists, 10],
  [Ge.Equals, 8],
  [Ge.Not, 7],
  [Ge.Start, 6],
  [Ge.End, 6],
  [Ge.Any, 5]
]);
function mA(t15) {
  const e = t15.map(U5);
  for (let r = 1; r < t15.length; r++) {
    const n = e[r];
    if (!(n < 0))
      for (let i = r - 1; i >= 0 && n < e[i]; i--) {
        const s = t15[i + 1];
        t15[i + 1] = t15[i], t15[i] = s, e[i + 1] = e[i], e[i] = n;
      }
  }
}
function U5(t15) {
  var e, r;
  let n = (e = H5.get(t15.type)) !== null && e !== void 0 ? e : -1;
  return t15.type === qt.Attribute ? (n = (r = fA.get(t15.action)) !== null && r !== void 0 ? r : 4, t15.action === Ge.Equals && t15.name === "id" && (n = 9), t15.ignoreCase && (n >>= 1)) : t15.type === qt.Pseudo && (t15.data ? t15.name === "has" || t15.name === "contains" ? n = 0 : Array.isArray(t15.data) ? (n = Math.min(...t15.data.map((i) => Math.min(...i.map(U5)))), n < 0 && (n = 0)) : n = 2 : n = 3), n;
}
var gA = /[-[\]{}()*+?.,\\^$|#\s]/g;
function e2(t15) {
  return t15.replace(gA, "\\$&");
}
var yA = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function _s(t15, e) {
  return typeof t15.ignoreCase == "boolean" ? t15.ignoreCase : t15.ignoreCase === "quirks" ? !!e.quirksMode : !e.xmlMode && yA.has(t15.name);
}
var bA = {
  equals(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    return _s(e, r) ? (s = s.toLowerCase(), (a) => {
      const o = n.getAttributeValue(a, i);
      return o != null && o.length === s.length && o.toLowerCase() === s && t15(a);
    }) : (a) => n.getAttributeValue(a, i) === s && t15(a);
  },
  hyphen(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    const a = s.length;
    return _s(e, r) ? (s = s.toLowerCase(), function(o) {
      const l = n.getAttributeValue(o, i);
      return l != null && (l.length === a || l.charAt(a) === "-") && l.substr(0, a).toLowerCase() === s && t15(o);
    }) : function(o) {
      const l = n.getAttributeValue(o, i);
      return l != null && (l.length === a || l.charAt(a) === "-") && l.substr(0, a) === s && t15(o);
    };
  },
  element(t15, e, r) {
    const { adapter: n } = r, { name: i, value: s } = e;
    if (/\s/.test(s))
      return ee.falseFunc;
    const a = new RegExp(`(?:^|\\s)${e2(s)}(?:$|\\s)`, _s(e, r) ? "i" : "");
    return function(o) {
      const l = n.getAttributeValue(o, i);
      return l != null && l.length >= s.length && a.test(l) && t15(o);
    };
  },
  exists(t15, { name: e }, { adapter: r }) {
    return (n) => r.hasAttrib(n, e) && t15(n);
  },
  start(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    const a = s.length;
    return a === 0 ? ee.falseFunc : _s(e, r) ? (s = s.toLowerCase(), (o) => {
      const l = n.getAttributeValue(o, i);
      return l != null && l.length >= a && l.substr(0, a).toLowerCase() === s && t15(o);
    }) : (o) => {
      var l;
      return !!(!((l = n.getAttributeValue(o, i)) === null || l === void 0) && l.startsWith(s)) && t15(o);
    };
  },
  end(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    const a = -s.length;
    return a === 0 ? ee.falseFunc : _s(e, r) ? (s = s.toLowerCase(), (o) => {
      var l;
      return ((l = n.getAttributeValue(o, i)) === null || l === void 0 ? void 0 : l.substr(a).toLowerCase()) === s && t15(o);
    }) : (o) => {
      var l;
      return !!(!((l = n.getAttributeValue(o, i)) === null || l === void 0) && l.endsWith(s)) && t15(o);
    };
  },
  any(t15, e, r) {
    const { adapter: n } = r, { name: i, value: s } = e;
    if (s === "")
      return ee.falseFunc;
    if (_s(e, r)) {
      const a = new RegExp(e2(s), "i");
      return function(o) {
        const l = n.getAttributeValue(o, i);
        return l != null && l.length >= s.length && a.test(l) && t15(o);
      };
    }
    return (a) => {
      var o;
      return !!(!((o = n.getAttributeValue(a, i)) === null || o === void 0) && o.includes(s)) && t15(a);
    };
  },
  not(t15, e, r) {
    const { adapter: n } = r, { name: i } = e;
    let { value: s } = e;
    return s === "" ? (a) => !!n.getAttributeValue(a, i) && t15(a) : _s(e, r) ? (s = s.toLowerCase(), (a) => {
      const o = n.getAttributeValue(a, i);
      return (o == null || o.length !== s.length || o.toLowerCase() !== s) && t15(a);
    }) : (a) => n.getAttributeValue(a, i) !== s && t15(a);
  }
};
var xA = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var r2 = 48;
var wA = 57;
function kA(t15) {
  if (t15 = t15.trim().toLowerCase(), t15 === "even")
    return [2, 0];
  if (t15 === "odd")
    return [2, 1];
  let e = 0, r = 0, n = s(), i = a();
  if (e < t15.length && t15.charAt(e) === "n" && (e++, r = n * (i ?? 1), o(), e < t15.length ? (n = s(), o(), i = a()) : n = i = 0), i === null || e < t15.length)
    throw new Error(`n-th rule couldn't be parsed ('${t15}')`);
  return [r, n * i];
  function s() {
    return t15.charAt(e) === "-" ? (e++, -1) : (t15.charAt(e) === "+" && e++, 1);
  }
  function a() {
    const l = e;
    let c = 0;
    for (; e < t15.length && t15.charCodeAt(e) >= r2 && t15.charCodeAt(e) <= wA; )
      c = c * 10 + (t15.charCodeAt(e) - r2), e++;
    return e === l ? null : c;
  }
  function o() {
    for (; e < t15.length && xA.has(t15.charCodeAt(e)); )
      e++;
  }
}
function vA(t15) {
  const e = t15[0], r = t15[1] - 1;
  if (r < 0 && e <= 0)
    return ee.falseFunc;
  if (e === -1)
    return (s) => s <= r;
  if (e === 0)
    return (s) => s === r;
  if (e === 1)
    return r < 0 ? ee.trueFunc : (s) => s >= r;
  const n = Math.abs(e), i = (r % n + n) % n;
  return e > 1 ? (s) => s >= r && s % n === i : (s) => s <= r && s % n === i;
}
function Pc(t15) {
  return vA(kA(t15));
}
function jc(t15, e) {
  return (r) => {
    const n = e.getParent(r);
    return n != null && e.isTag(n) && t15(r);
  };
}
var Vp = {
  contains(t15, e, { adapter: r }) {
    return function(n) {
      return t15(n) && r.getText(n).includes(e);
    };
  },
  icontains(t15, e, { adapter: r }) {
    const n = e.toLowerCase();
    return function(i) {
      return t15(i) && r.getText(i).toLowerCase().includes(n);
    };
  },
  // Location specific methods
  "nth-child"(t15, e, { adapter: r, equals: n }) {
    const i = Pc(e);
    return i === ee.falseFunc ? ee.falseFunc : i === ee.trueFunc ? jc(t15, r) : function(s) {
      const a = r.getSiblings(s);
      let o = 0;
      for (let l = 0; l < a.length && !n(s, a[l]); l++)
        r.isTag(a[l]) && o++;
      return i(o) && t15(s);
    };
  },
  "nth-last-child"(t15, e, { adapter: r, equals: n }) {
    const i = Pc(e);
    return i === ee.falseFunc ? ee.falseFunc : i === ee.trueFunc ? jc(t15, r) : function(s) {
      const a = r.getSiblings(s);
      let o = 0;
      for (let l = a.length - 1; l >= 0 && !n(s, a[l]); l--)
        r.isTag(a[l]) && o++;
      return i(o) && t15(s);
    };
  },
  "nth-of-type"(t15, e, { adapter: r, equals: n }) {
    const i = Pc(e);
    return i === ee.falseFunc ? ee.falseFunc : i === ee.trueFunc ? jc(t15, r) : function(s) {
      const a = r.getSiblings(s);
      let o = 0;
      for (let l = 0; l < a.length; l++) {
        const c = a[l];
        if (n(s, c))
          break;
        r.isTag(c) && r.getName(c) === r.getName(s) && o++;
      }
      return i(o) && t15(s);
    };
  },
  "nth-last-of-type"(t15, e, { adapter: r, equals: n }) {
    const i = Pc(e);
    return i === ee.falseFunc ? ee.falseFunc : i === ee.trueFunc ? jc(t15, r) : function(s) {
      const a = r.getSiblings(s);
      let o = 0;
      for (let l = a.length - 1; l >= 0; l--) {
        const c = a[l];
        if (n(s, c))
          break;
        r.isTag(c) && r.getName(c) === r.getName(s) && o++;
      }
      return i(o) && t15(s);
    };
  },
  // TODO determine the actual root element
  root(t15, e, { adapter: r }) {
    return (n) => {
      const i = r.getParent(n);
      return (i == null || !r.isTag(i)) && t15(n);
    };
  },
  scope(t15, e, r, n) {
    const { equals: i } = r;
    return !n || n.length === 0 ? Vp.root(t15, e, r) : n.length === 1 ? (s) => i(n[0], s) && t15(s) : (s) => n.includes(s) && t15(s);
  },
  hover: Bd("isHovered"),
  visited: Bd("isVisited"),
  active: Bd("isActive")
};
function Bd(t15) {
  return function(e, r, { adapter: n }) {
    const i = n[t15];
    return typeof i != "function" ? ee.falseFunc : function(s) {
      return i(s) && e(s);
    };
  };
}
var n2 = {
  empty(t15, { adapter: e }) {
    return !e.getChildren(t15).some((r) => (
      // FIXME: `getText` call is potentially expensive.
      e.isTag(r) || e.getText(r) !== ""
    ));
  },
  "first-child"(t15, { adapter: e, equals: r }) {
    if (e.prevElementSibling)
      return e.prevElementSibling(t15) == null;
    const n = e.getSiblings(t15).find((i) => e.isTag(i));
    return n != null && r(t15, n);
  },
  "last-child"(t15, { adapter: e, equals: r }) {
    const n = e.getSiblings(t15);
    for (let i = n.length - 1; i >= 0; i--) {
      if (r(t15, n[i]))
        return true;
      if (e.isTag(n[i]))
        break;
    }
    return false;
  },
  "first-of-type"(t15, { adapter: e, equals: r }) {
    const n = e.getSiblings(t15), i = e.getName(t15);
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      if (r(t15, a))
        return true;
      if (e.isTag(a) && e.getName(a) === i)
        break;
    }
    return false;
  },
  "last-of-type"(t15, { adapter: e, equals: r }) {
    const n = e.getSiblings(t15), i = e.getName(t15);
    for (let s = n.length - 1; s >= 0; s--) {
      const a = n[s];
      if (r(t15, a))
        return true;
      if (e.isTag(a) && e.getName(a) === i)
        break;
    }
    return false;
  },
  "only-of-type"(t15, { adapter: e, equals: r }) {
    const n = e.getName(t15);
    return e.getSiblings(t15).every((i) => r(t15, i) || !e.isTag(i) || e.getName(i) !== n);
  },
  "only-child"(t15, { adapter: e, equals: r }) {
    return e.getSiblings(t15).every((n) => r(t15, n) || !e.isTag(n));
  }
};
function i2(t15, e, r, n) {
  if (r === null) {
    if (t15.length > n)
      throw new Error(`Pseudo-class :${e} requires an argument`);
  } else if (t15.length === n)
    throw new Error(`Pseudo-class :${e} doesn't have any arguments`);
}
var CA = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
var V5 = {};
function _A(t15, e) {
  return t15 === ee.falseFunc ? ee.falseFunc : (r) => e.isTag(r) && t15(r);
}
function G5(t15, e) {
  const r = e.getSiblings(t15);
  if (r.length <= 1)
    return [];
  const n = r.indexOf(t15);
  return n < 0 || n === r.length - 1 ? [] : r.slice(n + 1).filter(e.isTag);
}
function Gp(t15) {
  return {
    xmlMode: !!t15.xmlMode,
    lowerCaseAttributeNames: !!t15.lowerCaseAttributeNames,
    lowerCaseTags: !!t15.lowerCaseTags,
    quirksMode: !!t15.quirksMode,
    cacheResults: !!t15.cacheResults,
    pseudos: t15.pseudos,
    adapter: t15.adapter,
    equals: t15.equals
  };
}
var Ld = (t15, e, r, n, i) => {
  const s = i(e, Gp(r), n);
  return s === ee.trueFunc ? t15 : s === ee.falseFunc ? ee.falseFunc : (a) => s(a) && t15(a);
};
var Dd = {
  is: Ld,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: Ld,
  where: Ld,
  not(t15, e, r, n, i) {
    const s = i(e, Gp(r), n);
    return s === ee.falseFunc ? t15 : s === ee.trueFunc ? ee.falseFunc : (a) => !s(a) && t15(a);
  },
  has(t15, e, r, n, i) {
    const { adapter: s } = r, a = Gp(r);
    a.relativeSelector = true;
    const o = e.some((h) => h.some(F1)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [V5]
    ) : void 0, l = i(e, a, o);
    if (l === ee.falseFunc)
      return ee.falseFunc;
    const c = _A(l, s);
    if (o && l !== ee.trueFunc) {
      const { shouldTestNextSiblings: h = false } = l;
      return (p) => {
        if (!t15(p))
          return false;
        o[0] = p;
        const m = s.getChildren(p), g = h ? [...m, ...G5(p, s)] : m;
        return s.existsOne(c, g);
      };
    }
    return (h) => t15(h) && s.existsOne(c, s.getChildren(h));
  }
};
function SA(t15, e, r, n, i) {
  var s;
  const { name: a, data: o } = e;
  if (Array.isArray(o)) {
    if (!(a in Dd))
      throw new Error(`Unknown pseudo-class :${a}(${o})`);
    return Dd[a](t15, o, r, n, i);
  }
  const l = (s = r.pseudos) === null || s === void 0 ? void 0 : s[a], c = typeof l == "string" ? l : CA[a];
  if (typeof c == "string") {
    if (o != null)
      throw new Error(`Pseudo ${a} doesn't have any arguments`);
    const h = tu(c);
    return Dd.is(t15, h, r, n, i);
  }
  if (typeof l == "function")
    return i2(l, a, o, 1), (h) => l(h, o) && t15(h);
  if (a in Vp)
    return Vp[a](t15, o, r, n);
  if (a in n2) {
    const h = n2[a];
    return i2(h, a, o, 2), (p) => h(p, r, o) && t15(p);
  }
  throw new Error(`Unknown pseudo-class :${a}`);
}
function Fd(t15, e) {
  const r = e.getParent(t15);
  return r && e.isTag(r) ? r : null;
}
function AA(t15, e, r, n, i) {
  const { adapter: s, equals: a } = r;
  switch (e.type) {
    case qt.PseudoElement:
      throw new Error("Pseudo-elements are not supported by css-select");
    case qt.ColumnCombinator:
      throw new Error("Column combinators are not yet supported by css-select");
    case qt.Attribute: {
      if (e.namespace != null)
        throw new Error("Namespaced attributes are not yet supported by css-select");
      return (!r.xmlMode || r.lowerCaseAttributeNames) && (e.name = e.name.toLowerCase()), bA[e.action](t15, e, r);
    }
    case qt.Pseudo:
      return SA(t15, e, r, n, i);
    case qt.Tag: {
      if (e.namespace != null)
        throw new Error("Namespaced tag names are not yet supported by css-select");
      let { name: o } = e;
      return (!r.xmlMode || r.lowerCaseTags) && (o = o.toLowerCase()), function(l) {
        return s.getName(l) === o && t15(l);
      };
    }
    case qt.Descendant: {
      if (r.cacheResults === false || typeof WeakSet > "u")
        return function(l) {
          let c = l;
          for (; c = Fd(c, s); )
            if (t15(c))
              return true;
          return false;
        };
      const o = /* @__PURE__ */ new WeakSet();
      return function(l) {
        let c = l;
        for (; c = Fd(c, s); )
          if (!o.has(c)) {
            if (s.isTag(c) && t15(c))
              return true;
            o.add(c);
          }
        return false;
      };
    }
    case "_flexibleDescendant":
      return function(o) {
        let l = o;
        do
          if (t15(l))
            return true;
        while (l = Fd(l, s));
        return false;
      };
    case qt.Parent:
      return function(o) {
        return s.getChildren(o).some((l) => s.isTag(l) && t15(l));
      };
    case qt.Child:
      return function(o) {
        const l = s.getParent(o);
        return l != null && s.isTag(l) && t15(l);
      };
    case qt.Sibling:
      return function(o) {
        const l = s.getSiblings(o);
        for (let c = 0; c < l.length; c++) {
          const h = l[c];
          if (a(o, h))
            break;
          if (s.isTag(h) && t15(h))
            return true;
        }
        return false;
      };
    case qt.Adjacent:
      return s.prevElementSibling ? function(o) {
        const l = s.prevElementSibling(o);
        return l != null && t15(l);
      } : function(o) {
        const l = s.getSiblings(o);
        let c;
        for (let h = 0; h < l.length; h++) {
          const p = l[h];
          if (a(o, p))
            break;
          s.isTag(p) && (c = p);
        }
        return !!c && t15(c);
      };
    case qt.Universal: {
      if (e.namespace != null && e.namespace !== "*")
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      return t15;
    }
  }
}
function X5(t15) {
  return t15.type === qt.Pseudo && (t15.name === "scope" || Array.isArray(t15.data) && t15.data.some((e) => e.some(X5)));
}
var TA = { type: qt.Descendant };
var $A = {
  type: "_flexibleDescendant"
};
var EA = {
  type: qt.Pseudo,
  name: "scope",
  data: null
};
function MA(t15, { adapter: e }, r) {
  const n = !!(r == null ? void 0 : r.every((i) => {
    const s = e.isTag(i) && e.getParent(i);
    return i === V5 || s && e.isTag(s);
  }));
  for (const i of t15) {
    if (!(i.length > 0 && F1(i[0]) && i[0].type !== qt.Descendant)) if (n && !i.some(X5))
      i.unshift(TA);
    else
      continue;
    i.unshift(EA);
  }
}
function Y5(t15, e, r) {
  var n;
  t15.forEach(mA), r = (n = e.context) !== null && n !== void 0 ? n : r;
  const i = Array.isArray(r), s = r && (Array.isArray(r) ? r : [r]);
  if (e.relativeSelector !== false)
    MA(t15, e, s);
  else if (t15.some((l) => l.length > 0 && F1(l[0])))
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  let a = false;
  const o = t15.map((l) => {
    if (l.length >= 2) {
      const [c, h] = l;
      c.type !== qt.Pseudo || c.name !== "scope" || (i && h.type === qt.Descendant ? l[1] = $A : (h.type === qt.Adjacent || h.type === qt.Sibling) && (a = true));
    }
    return BA(l, e, s);
  }).reduce(LA, ee.falseFunc);
  return o.shouldTestNextSiblings = a, o;
}
function BA(t15, e, r) {
  var n;
  return t15.reduce((i, s) => i === ee.falseFunc ? ee.falseFunc : AA(i, s, e, r, Y5), (n = e.rootFunc) !== null && n !== void 0 ? n : ee.trueFunc);
}
function LA(t15, e) {
  return e === ee.falseFunc || t15 === ee.trueFunc ? t15 : t15 === ee.falseFunc || e === ee.trueFunc ? e : function(r) {
    return t15(r) || e(r);
  };
}
var K5 = (t15, e) => t15 === e;
var DA = {
  adapter: Q0,
  equals: K5
};
function FA(t15) {
  var e, r, n, i;
  const s = t15 ?? DA;
  return (e = s.adapter) !== null && e !== void 0 || (s.adapter = Q0), (r = s.equals) !== null && r !== void 0 || (s.equals = (i = (n = s.adapter) === null || n === void 0 ? void 0 : n.equals) !== null && i !== void 0 ? i : K5), s;
}
function NA(t15) {
  return function(e, r, n) {
    const i = FA(r);
    return t15(e, i, n);
  };
}
var N1 = NA(Y5);
function Z5(t15, e, r = false) {
  return r && (t15 = IA(t15, e)), Array.isArray(t15) ? e.removeSubsets(t15) : e.getChildren(t15);
}
function IA(t15, e) {
  const r = Array.isArray(t15) ? t15.slice(0) : [t15], n = r.length;
  for (let i = 0; i < n; i++) {
    const s = G5(r[i], e);
    r.push(...s);
  }
  return r;
}
var OA = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function Qh(t15) {
  return t15.type !== "pseudo" ? false : OA.has(t15.name) ? true : t15.name === "not" && Array.isArray(t15.data) ? t15.data.some((e) => e.some(Qh)) : false;
}
function zA(t15, e, r) {
  const n = e != null ? parseInt(e, 10) : NaN;
  switch (t15) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(n) ? n >= 0 ? n + 1 : 1 / 0 : 0;
    case "lt":
      return isFinite(n) ? n >= 0 ? Math.min(n, r) : 1 / 0 : 0;
    case "gt":
      return isFinite(n) ? 1 / 0 : 0;
    case "odd":
      return 2 * r;
    case "even":
      return 2 * r - 1;
    case "last":
    case "not":
      return 1 / 0;
  }
}
function qA(t15) {
  for (; t15.parent; )
    t15 = t15.parent;
  return t15;
}
function I1(t15) {
  const e = [], r = [];
  for (const n of t15)
    n.some(Qh) ? e.push(n) : r.push(n);
  return [r, e];
}
var RA = {
  type: qt.Universal,
  namespace: null
};
var PA = {
  type: qt.Pseudo,
  name: "scope",
  data: null
};
function J5(t15, e, r = {}) {
  return Q5([t15], e, r);
}
function Q5(t15, e, r = {}) {
  if (typeof e == "function")
    return t15.some(e);
  const [n, i] = I1(tu(e));
  return n.length > 0 && t15.some(N1(n, r)) || i.some((s) => rx(s, t15, r).length > 0);
}
function jA(t15, e, r, n) {
  const i = typeof r == "string" ? parseInt(r, 10) : NaN;
  switch (t15) {
    case "first":
    case "lt":
      return e;
    case "last":
      return e.length > 0 ? [e[e.length - 1]] : e;
    case "nth":
    case "eq":
      return isFinite(i) && Math.abs(i) < e.length ? [i < 0 ? e[e.length + i] : e[i]] : [];
    case "gt":
      return isFinite(i) ? e.slice(i + 1) : [];
    case "even":
      return e.filter((s, a) => a % 2 === 0);
    case "odd":
      return e.filter((s, a) => a % 2 === 1);
    case "not": {
      const s = new Set(ex(r, e, n));
      return e.filter((a) => !s.has(a));
    }
  }
}
function tx(t15, e, r = {}) {
  return ex(tu(t15), e, r);
}
function ex(t15, e, r) {
  if (e.length === 0)
    return [];
  const [n, i] = I1(t15);
  let s;
  if (n.length) {
    const a = Yp(e, n, r);
    if (i.length === 0)
      return a;
    a.length && (s = new Set(a));
  }
  for (let a = 0; a < i.length && (s == null ? void 0 : s.size) !== e.length; a++) {
    const o = i[a];
    if ((s ? e.filter((c) => Gt(c) && !s.has(c)) : e).length === 0)
      break;
    const l = rx(o, e, r);
    if (l.length)
      if (s)
        l.forEach((c) => s.add(c));
      else {
        if (a === i.length - 1)
          return l;
        s = new Set(l);
      }
  }
  return typeof s < "u" ? s.size === e.length ? e : (
    // Filter elements to preserve order
    e.filter((a) => s.has(a))
  ) : [];
}
function rx(t15, e, r) {
  var n;
  if (t15.some(pl)) {
    const i = (n = r.root) !== null && n !== void 0 ? n : qA(e[0]), s = { ...r, context: e, relativeSelector: false };
    return t15.push(PA), t0(i, t15, s, true, e.length);
  }
  return t0(e, t15, r, false, e.length);
}
function WA(t15, e, r = {}, n = 1 / 0) {
  if (typeof t15 == "function")
    return nx(e, t15);
  const [i, s] = I1(tu(t15)), a = s.map((o) => t0(e, o, r, true, n));
  return i.length && a.push(Xp(e, i, r, n)), a.length === 0 ? [] : a.length === 1 ? a[0] : ao(a.reduce((o, l) => [...o, ...l]));
}
function t0(t15, e, r, n, i) {
  const s = e.findIndex(Qh), a = e.slice(0, s), o = e[s], l = e.length - 1 === s ? i : 1 / 0, c = zA(o.name, o.data, l);
  if (c === 0)
    return [];
  const h = (a.length === 0 && !Array.isArray(t15) ? Z0(t15).filter(Gt) : a.length === 0 ? (Array.isArray(t15) ? t15 : [t15]).filter(Gt) : n || a.some(pl) ? Xp(t15, [a], r, c) : Yp(t15, [a], r)).slice(0, c);
  let p = jA(o.name, h, o.data, r);
  if (p.length === 0 || e.length === s + 1)
    return p;
  const m = e.slice(s + 1), g = m.some(pl);
  if (g) {
    if (pl(m[0])) {
      const { type: y } = m[0];
      (y === qt.Sibling || y === qt.Adjacent) && (p = Z5(p, Q0, true)), m.unshift(RA);
    }
    r = {
      ...r,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (y) => p.includes(y)
    };
  } else r.rootFunc && r.rootFunc !== Jh.trueFunc && (r = { ...r, rootFunc: Jh.trueFunc });
  return m.some(Qh) ? t0(p, m, r, false, i) : g ? (
    // Query existing elements to resolve traversal.
    Xp(p, [m], r, i)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    Yp(p, [m], r)
  );
}
function Xp(t15, e, r, n) {
  const i = N1(e, r, t15);
  return nx(t15, i, n);
}
function nx(t15, e, r = 1 / 0) {
  const n = Z5(t15, Q0, e.shouldTestNextSiblings);
  return B1((i) => Gt(i) && e(i), n, true, r);
}
function Yp(t15, e, r) {
  const n = (Array.isArray(t15) ? t15 : [t15]).filter(Gt);
  if (n.length === 0)
    return n;
  const i = N1(e, r);
  return i === Jh.trueFunc ? n : n.filter(i);
}
var HA = /^\s*[+~]/;
function UA(t15) {
  if (!t15)
    return this._make([]);
  if (typeof t15 != "string") {
    const e = Si(t15) ? t15.toArray() : [t15], r = this.toArray();
    return this._make(e.filter((n) => r.some((i) => O5(i, n))));
  }
  return this._findBySelector(t15, Number.POSITIVE_INFINITY);
}
function VA(t15, e) {
  var r;
  const n = this.toArray(), i = HA.test(t15) ? n : this.children().toArray(), s = {
    context: n,
    root: (r = this._root) === null || r === void 0 ? void 0 : r[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(WA(t15, i, s, e));
}
function O1(t15) {
  return function(e, ...r) {
    return function(n) {
      var i;
      let s = t15(e, this);
      return n && (s = R1(s, n, this.options.xmlMode, (i = this._root) === null || i === void 0 ? void 0 : i[0])), this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && s.length > 1 ? r.reduce((a, o) => o(a), s) : s
      );
    };
  };
}
var Yl = O1((t15, e) => {
  let r = [];
  for (let n = 0; n < e.length; n++) {
    const i = t15(e[n]);
    i.length > 0 && (r = r.concat(i));
  }
  return r;
});
var z1 = O1((t15, e) => {
  const r = [];
  for (let n = 0; n < e.length; n++) {
    const i = t15(e[n]);
    i !== null && r.push(i);
  }
  return r;
});
function q1(t15, ...e) {
  let r = null;
  const n = O1((i, s) => {
    const a = [];
    return Ie(s, (o) => {
      for (let l; (l = i(o)) && !(r == null ? void 0 : r(l, a.length)); o = l)
        a.push(l);
    }), a;
  })(t15, ...e);
  return function(i, s) {
    r = typeof i == "string" ? (o) => J5(o, i, this.options) : i ? Kl(i) : null;
    const a = n.call(this, s);
    return r = null, a;
  };
}
function oo(t15) {
  return t15.length > 1 ? Array.from(new Set(t15)) : t15;
}
var GA = z1(({ parent: t15 }) => t15 && !na(t15) ? t15 : null, oo);
var XA = Yl((t15) => {
  const e = [];
  for (; t15.parent && !na(t15.parent); )
    e.push(t15.parent), t15 = t15.parent;
  return e;
}, ao, (t15) => t15.reverse());
var YA = q1(({ parent: t15 }) => t15 && !na(t15) ? t15 : null, ao, (t15) => t15.reverse());
function KA(t15) {
  var e;
  const r = [];
  if (!t15)
    return this._make(r);
  const n = {
    xmlMode: this.options.xmlMode,
    root: (e = this._root) === null || e === void 0 ? void 0 : e[0]
  }, i = typeof t15 == "string" ? (s) => J5(s, t15, n) : Kl(t15);
  return Ie(this, (s) => {
    for (s && !na(s) && !Gt(s) && (s = s.parent); s && Gt(s); ) {
      if (i(s, 0)) {
        r.includes(s) || r.push(s);
        break;
      }
      s = s.parent;
    }
  }), this._make(r);
}
var ZA = z1((t15) => E1(t15));
var JA = Yl((t15) => {
  const e = [];
  for (; t15.next; )
    t15 = t15.next, Gt(t15) && e.push(t15);
  return e;
}, oo);
var QA = q1((t15) => E1(t15), oo);
var tT = z1((t15) => M1(t15));
var eT = Yl((t15) => {
  const e = [];
  for (; t15.prev; )
    t15 = t15.prev, Gt(t15) && e.push(t15);
  return e;
}, oo);
var rT = q1((t15) => M1(t15), oo);
var nT = Yl((t15) => M5(t15).filter((e) => Gt(e) && e !== t15), ao);
var iT = Yl((t15) => Z0(t15).filter(Gt), oo);
function sT() {
  const t15 = this.toArray().reduce((e, r) => ar(r) ? e.concat(r.children) : e, []);
  return this._make(t15);
}
function aT(t15) {
  let e = 0;
  const r = this.length;
  for (; e < r && t15.call(this[e], e, this[e]) !== false; )
    ++e;
  return this;
}
function oT(t15) {
  let e = [];
  for (let r = 0; r < this.length; r++) {
    const n = this[r], i = t15.call(n, r, n);
    i != null && (e = e.concat(i));
  }
  return this._make(e);
}
function Kl(t15) {
  return typeof t15 == "function" ? (e, r) => t15.call(e, r, e) : Si(t15) ? (e) => Array.prototype.includes.call(t15, e) : function(e) {
    return t15 === e;
  };
}
function lT(t15) {
  var e;
  return this._make(R1(this.toArray(), t15, this.options.xmlMode, (e = this._root) === null || e === void 0 ? void 0 : e[0]));
}
function R1(t15, e, r, n) {
  return typeof e == "string" ? tx(e, t15, { xmlMode: r, root: n }) : t15.filter(Kl(e));
}
function cT(t15) {
  const e = this.toArray();
  return typeof t15 == "string" ? Q5(e.filter(Gt), t15, this.options) : t15 ? e.some(Kl(t15)) : false;
}
function hT(t15) {
  let e = this.toArray();
  if (typeof t15 == "string") {
    const r = new Set(tx(t15, e, this.options));
    e = e.filter((n) => !r.has(n));
  } else {
    const r = Kl(t15);
    e = e.filter((n, i) => !r(n, i));
  }
  return this._make(e);
}
function uT(t15) {
  return this.filter(typeof t15 == "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${t15})`
  ) : (e, r) => this._make(r).find(t15).length > 0);
}
function dT() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function pT() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function fT(t15) {
  var e;
  return t15 = +t15, t15 === 0 && this.length <= 1 ? this : (t15 < 0 && (t15 = this.length + t15), this._make((e = this[t15]) !== null && e !== void 0 ? e : []));
}
function mT(t15) {
  return t15 == null ? this.toArray() : this[t15 < 0 ? this.length + t15 : t15];
}
function gT() {
  return Array.prototype.slice.call(this);
}
function yT(t15) {
  let e, r;
  return t15 == null ? (e = this.parent().children(), r = this[0]) : typeof t15 == "string" ? (e = this._make(t15), r = this[0]) : (e = this, r = Si(t15) ? t15[0] : t15), Array.prototype.indexOf.call(e, r);
}
function bT(t15, e) {
  return this._make(Array.prototype.slice.call(this, t15, e));
}
function xT() {
  var t15;
  return (t15 = this.prevObject) !== null && t15 !== void 0 ? t15 : this._make([]);
}
function wT(t15, e) {
  const r = this._make(t15, e), n = ao([...this.get(), ...r.get()]);
  return this._make(n);
}
function kT(t15) {
  return this.prevObject ? this.add(t15 ? this.prevObject.filter(t15) : this.prevObject) : this;
}
var vT = Object.freeze(Object.defineProperty({
  __proto__: null,
  _findBySelector: VA,
  add: wT,
  addBack: kT,
  children: iT,
  closest: KA,
  contents: sT,
  each: aT,
  end: xT,
  eq: fT,
  filter: lT,
  filterArray: R1,
  find: UA,
  first: dT,
  get: mT,
  has: uT,
  index: yT,
  is: cT,
  last: pT,
  map: oT,
  next: ZA,
  nextAll: JA,
  nextUntil: QA,
  not: hT,
  parent: GA,
  parents: XA,
  parentsUntil: YA,
  prev: tT,
  prevAll: eT,
  prevUntil: rT,
  siblings: nT,
  slice: bT,
  toArray: gT
}, Symbol.toStringTag, { value: "Module" }));
function CT(t15) {
  return function(e, r, n, i) {
    if (typeof Buffer < "u" && Buffer.isBuffer(e) && (e = e.toString()), typeof e == "string")
      return t15(e, r, n, i);
    const s = e;
    if (!Array.isArray(s) && na(s))
      return s;
    const a = new vl([]);
    return Gs(s, a), a;
  };
}
function Gs(t15, e) {
  const r = Array.isArray(t15) ? t15 : [t15];
  e ? e.children = r : e = null;
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    i.parent && i.parent.children !== r && ia(i), e ? (i.prev = r[n - 1] || null, i.next = r[n + 1] || null) : i.prev = i.next = null, i.parent = e;
  }
  return e;
}
function _T(t15, e) {
  if (t15 == null)
    return [];
  if (typeof t15 == "string")
    return this._parse(t15, this.options, false, null).children.slice(0);
  if ("length" in t15) {
    if (t15.length === 1)
      return this._makeDomArray(t15[0], e);
    const r = [];
    for (let n = 0; n < t15.length; n++) {
      const i = t15[n];
      if (typeof i == "object") {
        if (i == null)
          continue;
        if (!("length" in i)) {
          r.push(e ? Cl(i, true) : i);
          continue;
        }
      }
      r.push(...this._makeDomArray(i, e));
    }
    return r;
  }
  return [e ? Cl(t15, true) : t15];
}
function ix(t15) {
  return function(...e) {
    const r = this.length - 1;
    return Ie(this, (n, i) => {
      if (!ar(n))
        return;
      const s = typeof e[0] == "function" ? e[0].call(n, i, this._render(n.children)) : e, a = this._makeDomArray(s, i < r);
      t15(a, n.children, n);
    });
  };
}
function ds(t15, e, r, n, i) {
  var s, a;
  const o = [
    e,
    r,
    ...n
  ], l = e === 0 ? null : t15[e - 1], c = e + r >= t15.length ? null : t15[e + r];
  for (let h = 0; h < n.length; ++h) {
    const p = n[h], m = p.parent;
    if (m) {
      const g = m.children.indexOf(p);
      g > -1 && (m.children.splice(g, 1), i === m && e > g && o[0]--);
    }
    p.parent = i, p.prev && (p.prev.next = (s = p.next) !== null && s !== void 0 ? s : null), p.next && (p.next.prev = (a = p.prev) !== null && a !== void 0 ? a : null), p.prev = h === 0 ? l : n[h - 1], p.next = h === n.length - 1 ? c : n[h + 1];
  }
  return l && (l.next = n[0]), c && (c.prev = n[n.length - 1]), t15.splice(...o);
}
function ST(t15) {
  return (Si(t15) ? t15 : this._make(t15)).append(this), this;
}
function AT(t15) {
  return (Si(t15) ? t15 : this._make(t15)).prepend(this), this;
}
var TT = ix((t15, e, r) => {
  ds(e, e.length, 0, t15, r);
});
var $T = ix((t15, e, r) => {
  ds(e, 0, 0, t15, r);
});
function sx(t15) {
  return function(e) {
    const r = this.length - 1, n = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const s = this[i], a = typeof e == "function" ? e.call(s, i, s) : typeof e == "string" && !Hp(e) ? n.find(e).clone() : e, [o] = this._makeDomArray(a, i < r);
      if (!o || !ar(o))
        continue;
      let l = o, c = 0;
      for (; c < l.children.length; ) {
        const h = l.children[c];
        Gt(h) ? (l = h, c = 0) : c++;
      }
      t15(s, l, [o]);
    }
    return this;
  };
}
var ET = sx((t15, e, r) => {
  const { parent: n } = t15;
  if (!n)
    return;
  const i = n.children, s = i.indexOf(t15);
  Gs([t15], e), ds(i, s, 0, r, n);
});
var MT = sx((t15, e, r) => {
  ar(t15) && (Gs(t15.children, e), Gs(r, t15));
});
function BT(t15) {
  return this.parent(t15).not("body").each((e, r) => {
    this._make(r).replaceWith(r.children);
  }), this;
}
function LT(t15) {
  const e = this[0];
  if (e) {
    const r = this._make(typeof t15 == "function" ? t15.call(e, 0, e) : t15).insertBefore(e);
    let n;
    for (let s = 0; s < r.length; s++)
      r[s].type === "tag" && (n = r[s]);
    let i = 0;
    for (; n && i < n.children.length; ) {
      const s = n.children[i];
      s.type === "tag" ? (n = s, i = 0) : i++;
    }
    n && this._make(n).append(this);
  }
  return this;
}
function DT(...t15) {
  const e = this.length - 1;
  return Ie(this, (r, n) => {
    if (!ar(r) || !r.parent)
      return;
    const i = r.parent.children, s = i.indexOf(r);
    if (s < 0)
      return;
    const a = typeof t15[0] == "function" ? t15[0].call(r, n, this._render(r.children)) : t15, o = this._makeDomArray(a, n < e);
    ds(i, s + 1, 0, o, r.parent);
  });
}
function FT(t15) {
  typeof t15 == "string" && (t15 = this._make(t15)), this.remove();
  const e = [];
  for (const r of this._makeDomArray(t15)) {
    const n = this.clone().toArray(), { parent: i } = r;
    if (!i)
      continue;
    const s = i.children, a = s.indexOf(r);
    a < 0 || (ds(s, a + 1, 0, n, i), e.push(...n));
  }
  return this._make(e);
}
function NT(...t15) {
  const e = this.length - 1;
  return Ie(this, (r, n) => {
    if (!ar(r) || !r.parent)
      return;
    const i = r.parent.children, s = i.indexOf(r);
    if (s < 0)
      return;
    const a = typeof t15[0] == "function" ? t15[0].call(r, n, this._render(r.children)) : t15, o = this._makeDomArray(a, n < e);
    ds(i, s, 0, o, r.parent);
  });
}
function IT(t15) {
  const e = this._make(t15);
  this.remove();
  const r = [];
  return Ie(e, (n) => {
    const i = this.clone().toArray(), { parent: s } = n;
    if (!s)
      return;
    const a = s.children, o = a.indexOf(n);
    o < 0 || (ds(a, o, 0, i, s), r.push(...i));
  }), this._make(r);
}
function OT(t15) {
  const e = t15 ? this.filter(t15) : this;
  return Ie(e, (r) => {
    ia(r), r.prev = r.next = r.parent = null;
  }), this;
}
function zT(t15) {
  return Ie(this, (e, r) => {
    const { parent: n } = e;
    if (!n)
      return;
    const i = n.children, s = typeof t15 == "function" ? t15.call(e, r, e) : t15, a = this._makeDomArray(s);
    Gs(a, null);
    const o = i.indexOf(e);
    ds(i, o, 1, a, n), a.includes(e) || (e.parent = e.prev = e.next = null);
  });
}
function qT() {
  return Ie(this, (t15) => {
    if (ar(t15)) {
      for (const e of t15.children)
        e.next = e.prev = e.parent = null;
      t15.children.length = 0;
    }
  });
}
function RT(t15) {
  if (t15 === void 0) {
    const e = this[0];
    return !e || !ar(e) ? null : this._render(e.children);
  }
  return Ie(this, (e) => {
    if (!ar(e))
      return;
    for (const n of e.children)
      n.next = n.prev = n.parent = null;
    const r = Si(t15) ? t15.toArray() : this._parse(`${t15}`, this.options, false, e).children;
    Gs(r, e);
  });
}
function PT() {
  return this._render(this);
}
function jT(t15) {
  return t15 === void 0 ? _l(this) : typeof t15 == "function" ? Ie(this, (e, r) => this._make(e).text(t15.call(e, r, _l([e])))) : Ie(this, (e) => {
    if (!ar(e))
      return;
    for (const n of e.children)
      n.next = n.prev = n.parent = null;
    const r = new Vh(`${t15}`);
    Gs(r, e);
  });
}
function WT() {
  const t15 = Array.prototype.map.call(this.get(), (r) => Cl(r, true)), e = new vl(t15);
  for (const r of t15)
    r.parent = e;
  return this._make(t15);
}
var HT = Object.freeze(Object.defineProperty({
  __proto__: null,
  _makeDomArray: _T,
  after: DT,
  append: TT,
  appendTo: ST,
  before: NT,
  clone: WT,
  empty: qT,
  html: RT,
  insertAfter: FT,
  insertBefore: IT,
  prepend: $T,
  prependTo: AT,
  remove: OT,
  replaceWith: zT,
  text: jT,
  toString: PT,
  unwrap: BT,
  wrap: ET,
  wrapAll: LT,
  wrapInner: MT
}, Symbol.toStringTag, { value: "Module" }));
function UT(t15, e) {
  if (t15 != null && e != null || // When `prop` is a "plain" object
  typeof t15 == "object" && !Array.isArray(t15))
    return Ie(this, (r, n) => {
      Gt(r) && ax(r, t15, e, n);
    });
  if (this.length !== 0)
    return ox(this[0], t15);
}
function ax(t15, e, r, n) {
  if (typeof e == "string") {
    const i = ox(t15), s = typeof r == "function" ? r.call(t15, n, i[e]) : r;
    s === "" ? delete i[e] : s != null && (i[e] = s), t15.attribs.style = VT(i);
  } else if (typeof e == "object") {
    const i = Object.keys(e);
    for (let s = 0; s < i.length; s++) {
      const a = i[s];
      ax(t15, a, e[a], s);
    }
  }
}
function ox(t15, e) {
  if (!t15 || !Gt(t15))
    return;
  const r = GT(t15.attribs.style);
  if (typeof e == "string")
    return r[e];
  if (Array.isArray(e)) {
    const n = {};
    for (const i of e)
      r[i] != null && (n[i] = r[i]);
    return n;
  }
  return r;
}
function VT(t15) {
  return Object.keys(t15).reduce((e, r) => `${e}${e ? " " : ""}${r}: ${t15[r]};`, "");
}
function GT(t15) {
  if (t15 = (t15 || "").trim(), !t15)
    return {};
  const e = {};
  let r;
  for (const n of t15.split(";")) {
    const i = n.indexOf(":");
    if (i < 1 || i === n.length - 1) {
      const s = n.trimEnd();
      s.length > 0 && r !== void 0 && (e[r] += `;${s}`);
    } else
      r = n.slice(0, i).trim(), e[r] = n.slice(i + 1).trim();
  }
  return e;
}
var XT = Object.freeze(Object.defineProperty({
  __proto__: null,
  css: UT
}, Symbol.toStringTag, { value: "Module" }));
var s2 = "input,select,textarea,keygen";
var YT = /%20/g;
var a2 = /\r?\n/g;
function KT() {
  return this.serializeArray().map((t15) => `${encodeURIComponent(t15.name)}=${encodeURIComponent(t15.value)}`).join("&").replace(YT, "+");
}
function ZT() {
  return this.map((t15, e) => {
    const r = this._make(e);
    return Gt(e) && e.name === "form" ? r.find(s2).toArray() : r.filter(s2).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
  ).map((t15, e) => {
    var r;
    const n = this._make(e), i = n.attr("name"), s = (r = n.val()) !== null && r !== void 0 ? r : "";
    return Array.isArray(s) ? s.map((a) => (
      /*
       * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
       * These can occur inside of `<textarea>'s`
       */
      { name: i, value: a.replace(a2, `\r
`) }
    )) : { name: i, value: s.replace(a2, `\r
`) };
  }).toArray();
}
var JT = Object.freeze(Object.defineProperty({
  __proto__: null,
  serialize: KT,
  serializeArray: ZT
}, Symbol.toStringTag, { value: "Module" }));
function QT(t15) {
  var e;
  return typeof t15 == "string" ? { selector: t15, value: "textContent" } : {
    selector: t15.selector,
    value: (e = t15.value) !== null && e !== void 0 ? e : "textContent"
  };
}
function t$(t15) {
  const e = {};
  for (const r in t15) {
    const n = t15[r], i = Array.isArray(n), { selector: s, value: a } = QT(i ? n[0] : n), o = typeof a == "function" ? a : typeof a == "string" ? (l) => this._make(l).prop(a) : (l) => this._make(l).extract(a);
    if (i)
      e[r] = this._findBySelector(s, Number.POSITIVE_INFINITY).map((l, c) => o(c, r, e)).get();
    else {
      const l = this._findBySelector(s, 1);
      e[r] = l.length > 0 ? o(l[0], r, e) : void 0;
    }
  }
  return e;
}
var e$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  extract: t$
}, Symbol.toStringTag, { value: "Module" }));
var Zl = class {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(e, r, n) {
    if (this.length = 0, this.options = n, this._root = r, e) {
      for (let i = 0; i < e.length; i++)
        this[i] = e[i];
      this.length = e.length;
    }
  }
};
Zl.prototype.cheerio = "[cheerio object]";
Zl.prototype.splice = Array.prototype.splice;
Zl.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Zl.prototype, aA, vT, HT, XT, JT, e$);
function r$(t15, e) {
  return function r(n, i, s = true) {
    if (n == null)
      throw new Error("cheerio.load() expects a string");
    const a = Pp(i), o = t15(n, a, s, null);
    class l extends Zl {
      _make(p, m) {
        const g = c(p, m);
        return g.prevObject = this, g;
      }
      _parse(p, m, g, y) {
        return t15(p, m, g, y);
      }
      _render(p) {
        return e(p, this.options);
      }
    }
    function c(h, p, m = o, g) {
      if (h && Si(h))
        return h;
      const y = Pp(g, a), x = typeof m == "string" ? [t15(m, y, false, null)] : "length" in m ? m : [m], k = Si(x) ? x : new l(x, null, y);
      if (k._root = k, !h)
        return new l(void 0, k, y);
      const C = typeof h == "string" && Hp(h) ? (
        // $(<html>)
        t15(h, y, false, null).children
      ) : n$(h) ? (
        // $(dom)
        [h]
      ) : Array.isArray(h) ? (
        // $([dom])
        h
      ) : void 0, A = new l(C, k, y);
      if (C)
        return A;
      if (typeof h != "string")
        throw new TypeError("Unexpected type of selector");
      let $ = h;
      const B = p ? (
        // If we don't have a context, maybe we have a root, from loading
        typeof p == "string" ? Hp(p) ? (
          // $('li', '<ul>...</ul>')
          new l([t15(p, y, false, null)], k, y)
        ) : (
          // $('li', 'ul')
          ($ = `${p} ${$}`, k)
        ) : Si(p) ? (
          // $('li', $)
          p
        ) : (
          // $('li', node), $('li', [nodes])
          new l(Array.isArray(p) ? p : [p], k, y)
        )
      ) : k;
      return B ? B.find($) : A;
    }
    return Object.assign(c, XS, {
      load: r,
      // `_root` and `_options` are used in static methods.
      _root: o,
      _options: a,
      // Add `fn` for plugins
      fn: l.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: l.prototype
    }), c;
  };
}
function n$(t15) {
  return !!t15.name || t15.type === "root" || t15.type === "text" || t15.type === "comment";
}
var Rt;
(function(t15) {
  t15[t15.Tab = 9] = "Tab", t15[t15.NewLine = 10] = "NewLine", t15[t15.FormFeed = 12] = "FormFeed", t15[t15.CarriageReturn = 13] = "CarriageReturn", t15[t15.Space = 32] = "Space", t15[t15.ExclamationMark = 33] = "ExclamationMark", t15[t15.Number = 35] = "Number", t15[t15.Amp = 38] = "Amp", t15[t15.SingleQuote = 39] = "SingleQuote", t15[t15.DoubleQuote = 34] = "DoubleQuote", t15[t15.Dash = 45] = "Dash", t15[t15.Slash = 47] = "Slash", t15[t15.Zero = 48] = "Zero", t15[t15.Nine = 57] = "Nine", t15[t15.Semi = 59] = "Semi", t15[t15.Lt = 60] = "Lt", t15[t15.Eq = 61] = "Eq", t15[t15.Gt = 62] = "Gt", t15[t15.Questionmark = 63] = "Questionmark", t15[t15.UpperA = 65] = "UpperA", t15[t15.LowerA = 97] = "LowerA", t15[t15.UpperF = 70] = "UpperF", t15[t15.LowerF = 102] = "LowerF", t15[t15.UpperZ = 90] = "UpperZ", t15[t15.LowerZ = 122] = "LowerZ", t15[t15.LowerX = 120] = "LowerX", t15[t15.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(Rt || (Rt = {}));
var pt;
(function(t15) {
  t15[t15.Text = 1] = "Text", t15[t15.BeforeTagName = 2] = "BeforeTagName", t15[t15.InTagName = 3] = "InTagName", t15[t15.InSelfClosingTag = 4] = "InSelfClosingTag", t15[t15.BeforeClosingTagName = 5] = "BeforeClosingTagName", t15[t15.InClosingTagName = 6] = "InClosingTagName", t15[t15.AfterClosingTagName = 7] = "AfterClosingTagName", t15[t15.BeforeAttributeName = 8] = "BeforeAttributeName", t15[t15.InAttributeName = 9] = "InAttributeName", t15[t15.AfterAttributeName = 10] = "AfterAttributeName", t15[t15.BeforeAttributeValue = 11] = "BeforeAttributeValue", t15[t15.InAttributeValueDq = 12] = "InAttributeValueDq", t15[t15.InAttributeValueSq = 13] = "InAttributeValueSq", t15[t15.InAttributeValueNq = 14] = "InAttributeValueNq", t15[t15.BeforeDeclaration = 15] = "BeforeDeclaration", t15[t15.InDeclaration = 16] = "InDeclaration", t15[t15.InProcessingInstruction = 17] = "InProcessingInstruction", t15[t15.BeforeComment = 18] = "BeforeComment", t15[t15.CDATASequence = 19] = "CDATASequence", t15[t15.InSpecialComment = 20] = "InSpecialComment", t15[t15.InCommentLike = 21] = "InCommentLike", t15[t15.BeforeSpecialS = 22] = "BeforeSpecialS", t15[t15.BeforeSpecialT = 23] = "BeforeSpecialT", t15[t15.SpecialStartSequence = 24] = "SpecialStartSequence", t15[t15.InSpecialTag = 25] = "InSpecialTag", t15[t15.InEntity = 26] = "InEntity";
})(pt || (pt = {}));
function gi(t15) {
  return t15 === Rt.Space || t15 === Rt.NewLine || t15 === Rt.Tab || t15 === Rt.FormFeed || t15 === Rt.CarriageReturn;
}
function Wc(t15) {
  return t15 === Rt.Slash || t15 === Rt.Gt || gi(t15);
}
function i$(t15) {
  return t15 >= Rt.LowerA && t15 <= Rt.LowerZ || t15 >= Rt.UpperA && t15 <= Rt.UpperZ;
}
var jn;
(function(t15) {
  t15[t15.NoValue = 0] = "NoValue", t15[t15.Unquoted = 1] = "Unquoted", t15[t15.Single = 2] = "Single", t15[t15.Double = 3] = "Double";
})(jn || (jn = {}));
var lr = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea`
};
var s$ = class {
  constructor({ xmlMode: e = false, decodeEntities: r = true }, n) {
    this.cbs = n, this.state = pt.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = pt.Text, this.isSpecial = false, this.running = true, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = e, this.decodeEntities = r, this.entityDecoder = new _5(e ? C5 : v5, (i, s) => this.emitCodePoint(i, s));
  }
  reset() {
    this.state = pt.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = pt.Text, this.currentSequence = void 0, this.running = true, this.offset = 0;
  }
  write(e) {
    this.offset += this.buffer.length, this.buffer = e, this.parse();
  }
  end() {
    this.running && this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true, this.index < this.buffer.length + this.offset && this.parse();
  }
  stateText(e) {
    e === Rt.Lt || !this.decodeEntities && this.fastForwardTo(Rt.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = pt.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && e === Rt.Amp && this.startEntity();
  }
  stateSpecialStartSequence(e) {
    const r = this.sequenceIndex === this.currentSequence.length;
    if (!(r ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      Wc(e)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (e | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.isSpecial = false;
    else if (!r) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = pt.InTagName, this.stateInTagName(e);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === Rt.Gt || gi(e)) {
        const r = this.index - this.currentSequence.length;
        if (this.sectionStart < r) {
          const n = this.index;
          this.index = r, this.cbs.ontext(this.sectionStart, r), this.index = n;
        }
        this.isSpecial = false, this.sectionStart = r + 2, this.stateInClosingTagName(e);
        return;
      }
      this.sequenceIndex = 0;
    }
    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === lr.TitleEnd ? this.decodeEntities && e === Rt.Amp && this.startEntity() : this.fastForwardTo(Rt.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === Rt.Lt);
  }
  stateCDATASequence(e) {
    e === lr.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === lr.Cdata.length && (this.state = pt.InCommentLike, this.currentSequence = lr.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = pt.InDeclaration, this.stateInDeclaration(e));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length + this.offset; )
      if (this.buffer.charCodeAt(this.index - this.offset) === e)
        return true;
    return this.index = this.buffer.length + this.offset - 1, false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === lr.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = pt.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(e) {
    return this.xmlMode ? !Wc(e) : i$(e);
  }
  startSpecial(e, r) {
    this.isSpecial = true, this.currentSequence = e, this.sequenceIndex = r, this.state = pt.SpecialStartSequence;
  }
  stateBeforeTagName(e) {
    if (e === Rt.ExclamationMark)
      this.state = pt.BeforeDeclaration, this.sectionStart = this.index + 1;
    else if (e === Rt.Questionmark)
      this.state = pt.InProcessingInstruction, this.sectionStart = this.index + 1;
    else if (this.isTagStartChar(e)) {
      const r = e | 32;
      this.sectionStart = this.index, this.xmlMode ? this.state = pt.InTagName : r === lr.ScriptEnd[2] ? this.state = pt.BeforeSpecialS : r === lr.TitleEnd[2] ? this.state = pt.BeforeSpecialT : this.state = pt.InTagName;
    } else e === Rt.Slash ? this.state = pt.BeforeClosingTagName : (this.state = pt.Text, this.stateText(e));
  }
  stateInTagName(e) {
    Wc(e) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = pt.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateBeforeClosingTagName(e) {
    gi(e) || (e === Rt.Gt ? this.state = pt.Text : (this.state = this.isTagStartChar(e) ? pt.InClosingTagName : pt.InSpecialComment, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === Rt.Gt || gi(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = pt.AfterClosingTagName, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    (e === Rt.Gt || this.fastForwardTo(Rt.Gt)) && (this.state = pt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeAttributeName(e) {
    e === Rt.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = pt.InSpecialTag, this.sequenceIndex = 0) : this.state = pt.Text, this.sectionStart = this.index + 1) : e === Rt.Slash ? this.state = pt.InSelfClosingTag : gi(e) || (this.state = pt.InAttributeName, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === Rt.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = pt.Text, this.sectionStart = this.index + 1, this.isSpecial = false) : gi(e) || (this.state = pt.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateInAttributeName(e) {
    (e === Rt.Eq || Wc(e)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = this.index, this.state = pt.AfterAttributeName, this.stateAfterAttributeName(e));
  }
  stateAfterAttributeName(e) {
    e === Rt.Eq ? this.state = pt.BeforeAttributeValue : e === Rt.Slash || e === Rt.Gt ? (this.cbs.onattribend(jn.NoValue, this.sectionStart), this.sectionStart = -1, this.state = pt.BeforeAttributeName, this.stateBeforeAttributeName(e)) : gi(e) || (this.cbs.onattribend(jn.NoValue, this.sectionStart), this.state = pt.InAttributeName, this.sectionStart = this.index);
  }
  stateBeforeAttributeValue(e) {
    e === Rt.DoubleQuote ? (this.state = pt.InAttributeValueDq, this.sectionStart = this.index + 1) : e === Rt.SingleQuote ? (this.state = pt.InAttributeValueSq, this.sectionStart = this.index + 1) : gi(e) || (this.sectionStart = this.index, this.state = pt.InAttributeValueNq, this.stateInAttributeValueNoQuotes(e));
  }
  handleInAttributeValue(e, r) {
    e === r || !this.decodeEntities && this.fastForwardTo(r) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(r === Rt.DoubleQuote ? jn.Double : jn.Single, this.index + 1), this.state = pt.BeforeAttributeName) : this.decodeEntities && e === Rt.Amp && this.startEntity();
  }
  stateInAttributeValueDoubleQuotes(e) {
    this.handleInAttributeValue(e, Rt.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(e) {
    this.handleInAttributeValue(e, Rt.SingleQuote);
  }
  stateInAttributeValueNoQuotes(e) {
    gi(e) || e === Rt.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(jn.Unquoted, this.index), this.state = pt.BeforeAttributeName, this.stateBeforeAttributeName(e)) : this.decodeEntities && e === Rt.Amp && this.startEntity();
  }
  stateBeforeDeclaration(e) {
    e === Rt.OpeningSquareBracket ? (this.state = pt.CDATASequence, this.sequenceIndex = 0) : this.state = e === Rt.Dash ? pt.BeforeComment : pt.InDeclaration;
  }
  stateInDeclaration(e) {
    (e === Rt.Gt || this.fastForwardTo(Rt.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = pt.Text, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === Rt.Gt || this.fastForwardTo(Rt.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = pt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === Rt.Dash ? (this.state = pt.InCommentLike, this.currentSequence = lr.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = pt.InDeclaration;
  }
  stateInSpecialComment(e) {
    (e === Rt.Gt || this.fastForwardTo(Rt.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = pt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    const r = e | 32;
    r === lr.ScriptEnd[3] ? this.startSpecial(lr.ScriptEnd, 4) : r === lr.StyleEnd[3] ? this.startSpecial(lr.StyleEnd, 4) : (this.state = pt.InTagName, this.stateInTagName(e));
  }
  stateBeforeSpecialT(e) {
    const r = e | 32;
    r === lr.TitleEnd[3] ? this.startSpecial(lr.TitleEnd, 4) : r === lr.TextareaEnd[3] ? this.startSpecial(lr.TextareaEnd, 4) : (this.state = pt.InTagName, this.stateInTagName(e));
  }
  startEntity() {
    this.baseState = this.state, this.state = pt.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? Pn.Strict : this.baseState === pt.Text || this.baseState === pt.InSpecialTag ? Pn.Legacy : Pn.Attribute);
  }
  stateInEntity() {
    const e = this.entityDecoder.write(this.buffer, this.index - this.offset);
    e >= 0 ? (this.state = this.baseState, e === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.running && this.sectionStart !== this.index && (this.state === pt.Text || this.state === pt.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === pt.InAttributeValueDq || this.state === pt.InAttributeValueSq || this.state === pt.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    for (; this.shouldContinue(); ) {
      const e = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case pt.Text: {
          this.stateText(e);
          break;
        }
        case pt.SpecialStartSequence: {
          this.stateSpecialStartSequence(e);
          break;
        }
        case pt.InSpecialTag: {
          this.stateInSpecialTag(e);
          break;
        }
        case pt.CDATASequence: {
          this.stateCDATASequence(e);
          break;
        }
        case pt.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(e);
          break;
        }
        case pt.InAttributeName: {
          this.stateInAttributeName(e);
          break;
        }
        case pt.InCommentLike: {
          this.stateInCommentLike(e);
          break;
        }
        case pt.InSpecialComment: {
          this.stateInSpecialComment(e);
          break;
        }
        case pt.BeforeAttributeName: {
          this.stateBeforeAttributeName(e);
          break;
        }
        case pt.InTagName: {
          this.stateInTagName(e);
          break;
        }
        case pt.InClosingTagName: {
          this.stateInClosingTagName(e);
          break;
        }
        case pt.BeforeTagName: {
          this.stateBeforeTagName(e);
          break;
        }
        case pt.AfterAttributeName: {
          this.stateAfterAttributeName(e);
          break;
        }
        case pt.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(e);
          break;
        }
        case pt.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(e);
          break;
        }
        case pt.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(e);
          break;
        }
        case pt.AfterClosingTagName: {
          this.stateAfterClosingTagName(e);
          break;
        }
        case pt.BeforeSpecialS: {
          this.stateBeforeSpecialS(e);
          break;
        }
        case pt.BeforeSpecialT: {
          this.stateBeforeSpecialT(e);
          break;
        }
        case pt.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(e);
          break;
        }
        case pt.InSelfClosingTag: {
          this.stateInSelfClosingTag(e);
          break;
        }
        case pt.InDeclaration: {
          this.stateInDeclaration(e);
          break;
        }
        case pt.BeforeDeclaration: {
          this.stateBeforeDeclaration(e);
          break;
        }
        case pt.BeforeComment: {
          this.stateBeforeComment(e);
          break;
        }
        case pt.InProcessingInstruction: {
          this.stateInProcessingInstruction(e);
          break;
        }
        case pt.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    this.state === pt.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const e = this.buffer.length + this.offset;
    this.sectionStart >= e || (this.state === pt.InCommentLike ? this.currentSequence === lr.CdataEnd ? this.cbs.oncdata(this.sectionStart, e, 0) : this.cbs.oncomment(this.sectionStart, e, 0) : this.state === pt.InTagName || this.state === pt.BeforeAttributeName || this.state === pt.BeforeAttributeValue || this.state === pt.AfterAttributeName || this.state === pt.InAttributeName || this.state === pt.InAttributeValueSq || this.state === pt.InAttributeValueDq || this.state === pt.InAttributeValueNq || this.state === pt.InClosingTagName || this.cbs.ontext(this.sectionStart, e));
  }
  emitCodePoint(e, r) {
    this.baseState !== pt.Text && this.baseState !== pt.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.onattribentity(e)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.ontextentity(e, this.sectionStart));
  }
};
var ya = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var ke = /* @__PURE__ */ new Set(["p"]);
var o2 = /* @__PURE__ */ new Set(["thead", "tbody"]);
var l2 = /* @__PURE__ */ new Set(["dd", "dt"]);
var c2 = /* @__PURE__ */ new Set(["rt", "rp"]);
var a$ = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", ke],
  ["h1", ke],
  ["h2", ke],
  ["h3", ke],
  ["h4", ke],
  ["h5", ke],
  ["h6", ke],
  ["select", ya],
  ["input", ya],
  ["output", ya],
  ["button", ya],
  ["datalist", ya],
  ["textarea", ya],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", l2],
  ["dt", l2],
  ["address", ke],
  ["article", ke],
  ["aside", ke],
  ["blockquote", ke],
  ["details", ke],
  ["div", ke],
  ["dl", ke],
  ["fieldset", ke],
  ["figcaption", ke],
  ["figure", ke],
  ["footer", ke],
  ["form", ke],
  ["header", ke],
  ["hr", ke],
  ["main", ke],
  ["nav", ke],
  ["ol", ke],
  ["pre", ke],
  ["section", ke],
  ["table", ke],
  ["ul", ke],
  ["rt", c2],
  ["rp", c2],
  ["tbody", o2],
  ["tfoot", o2]
]);
var o$ = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var h2 = /* @__PURE__ */ new Set(["math", "svg"]);
var u2 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var l$ = /\s|\//;
var c$ = class {
  constructor(t15, e = {}) {
    var r, n, i, s, a, o;
    this.options = e, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = false, this.cbs = t15 ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (r = e.lowerCaseTags) !== null && r !== void 0 ? r : this.htmlMode, this.lowerCaseAttributeNames = (n = e.lowerCaseAttributeNames) !== null && n !== void 0 ? n : this.htmlMode, this.recognizeSelfClosing = (i = e.recognizeSelfClosing) !== null && i !== void 0 ? i : !this.htmlMode, this.tokenizer = new ((s = e.Tokenizer) !== null && s !== void 0 ? s : s$)(this.options, this), this.foreignContext = [!this.htmlMode], (o = (a = this.cbs).onparserinit) === null || o === void 0 || o.call(a, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(t15, e) {
    var r, n;
    const i = this.getSlice(t15, e);
    this.endIndex = e - 1, (n = (r = this.cbs).ontext) === null || n === void 0 || n.call(r, i), this.startIndex = e;
  }
  /** @internal */
  ontextentity(t15, e) {
    var r, n;
    this.endIndex = e - 1, (n = (r = this.cbs).ontext) === null || n === void 0 || n.call(r, jp(t15)), this.startIndex = e;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(t15) {
    return this.htmlMode && o$.has(t15);
  }
  /** @internal */
  onopentagname(t15, e) {
    this.endIndex = e;
    let r = this.getSlice(t15, e);
    this.lowerCaseTagNames && (r = r.toLowerCase()), this.emitOpenTag(r);
  }
  emitOpenTag(t15) {
    var e, r, n, i;
    this.openTagStart = this.startIndex, this.tagname = t15;
    const s = this.htmlMode && a$.get(t15);
    if (s)
      for (; this.stack.length > 0 && s.has(this.stack[0]); ) {
        const a = this.stack.shift();
        (r = (e = this.cbs).onclosetag) === null || r === void 0 || r.call(e, a, true);
      }
    this.isVoidElement(t15) || (this.stack.unshift(t15), this.htmlMode && (h2.has(t15) ? this.foreignContext.unshift(true) : u2.has(t15) && this.foreignContext.unshift(false))), (i = (n = this.cbs).onopentagname) === null || i === void 0 || i.call(n, t15), this.cbs.onopentag && (this.attribs = {});
  }
  endOpenTag(t15) {
    var e, r;
    this.startIndex = this.openTagStart, this.attribs && ((r = (e = this.cbs).onopentag) === null || r === void 0 || r.call(e, this.tagname, this.attribs, t15), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, true), this.tagname = "";
  }
  /** @internal */
  onopentagend(t15) {
    this.endIndex = t15, this.endOpenTag(false), this.startIndex = t15 + 1;
  }
  /** @internal */
  onclosetag(t15, e) {
    var r, n, i, s, a, o, l, c;
    this.endIndex = e;
    let h = this.getSlice(t15, e);
    if (this.lowerCaseTagNames && (h = h.toLowerCase()), this.htmlMode && (h2.has(h) || u2.has(h)) && this.foreignContext.shift(), this.isVoidElement(h))
      this.htmlMode && h === "br" && ((s = (i = this.cbs).onopentagname) === null || s === void 0 || s.call(i, "br"), (o = (a = this.cbs).onopentag) === null || o === void 0 || o.call(a, "br", {}, true), (c = (l = this.cbs).onclosetag) === null || c === void 0 || c.call(l, "br", false));
    else {
      const p = this.stack.indexOf(h);
      if (p !== -1)
        for (let m = 0; m <= p; m++) {
          const g = this.stack.shift();
          (n = (r = this.cbs).onclosetag) === null || n === void 0 || n.call(r, g, m !== p);
        }
      else this.htmlMode && h === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(true));
    }
    this.startIndex = e + 1;
  }
  /** @internal */
  onselfclosingtag(t15) {
    this.endIndex = t15, this.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(false), this.startIndex = t15 + 1) : this.onopentagend(t15);
  }
  closeCurrentTag(t15) {
    var e, r;
    const n = this.tagname;
    this.endOpenTag(t15), this.stack[0] === n && ((r = (e = this.cbs).onclosetag) === null || r === void 0 || r.call(e, n, !t15), this.stack.shift());
  }
  /** @internal */
  onattribname(t15, e) {
    this.startIndex = t15;
    const r = this.getSlice(t15, e);
    this.attribname = this.lowerCaseAttributeNames ? r.toLowerCase() : r;
  }
  /** @internal */
  onattribdata(t15, e) {
    this.attribvalue += this.getSlice(t15, e);
  }
  /** @internal */
  onattribentity(t15) {
    this.attribvalue += jp(t15);
  }
  /** @internal */
  onattribend(t15, e) {
    var r, n;
    this.endIndex = e, (n = (r = this.cbs).onattribute) === null || n === void 0 || n.call(r, this.attribname, this.attribvalue, t15 === jn.Double ? '"' : t15 === jn.Single ? "'" : t15 === jn.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
  }
  getInstructionName(t15) {
    const e = t15.search(l$);
    let r = e < 0 ? t15 : t15.substr(0, e);
    return this.lowerCaseTagNames && (r = r.toLowerCase()), r;
  }
  /** @internal */
  ondeclaration(t15, e) {
    this.endIndex = e;
    const r = this.getSlice(t15, e);
    if (this.cbs.onprocessinginstruction) {
      const n = this.getInstructionName(r);
      this.cbs.onprocessinginstruction(`!${n}`, `!${r}`);
    }
    this.startIndex = e + 1;
  }
  /** @internal */
  onprocessinginstruction(t15, e) {
    this.endIndex = e;
    const r = this.getSlice(t15, e);
    if (this.cbs.onprocessinginstruction) {
      const n = this.getInstructionName(r);
      this.cbs.onprocessinginstruction(`?${n}`, `?${r}`);
    }
    this.startIndex = e + 1;
  }
  /** @internal */
  oncomment(t15, e, r) {
    var n, i, s, a;
    this.endIndex = e, (i = (n = this.cbs).oncomment) === null || i === void 0 || i.call(n, this.getSlice(t15, e - r)), (a = (s = this.cbs).oncommentend) === null || a === void 0 || a.call(s), this.startIndex = e + 1;
  }
  /** @internal */
  oncdata(t15, e, r) {
    var n, i, s, a, o, l, c, h, p, m;
    this.endIndex = e;
    const g = this.getSlice(t15, e - r);
    !this.htmlMode || this.options.recognizeCDATA ? ((i = (n = this.cbs).oncdatastart) === null || i === void 0 || i.call(n), (a = (s = this.cbs).ontext) === null || a === void 0 || a.call(s, g), (l = (o = this.cbs).oncdataend) === null || l === void 0 || l.call(o)) : ((h = (c = this.cbs).oncomment) === null || h === void 0 || h.call(c, `[CDATA[${g}]]`), (m = (p = this.cbs).oncommentend) === null || m === void 0 || m.call(p)), this.startIndex = e + 1;
  }
  /** @internal */
  onend() {
    var t15, e;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let r = 0; r < this.stack.length; r++)
        this.cbs.onclosetag(this.stack[r], true);
    }
    (e = (t15 = this.cbs).onend) === null || e === void 0 || e.call(t15);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var t15, e, r, n;
    (e = (t15 = this.cbs).onreset) === null || e === void 0 || e.call(t15), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (n = (r = this.cbs).onparserinit) === null || n === void 0 || n.call(r, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(t15) {
    this.reset(), this.end(t15);
  }
  getSlice(t15, e) {
    for (; t15 - this.bufferOffset >= this.buffers[0].length; )
      this.shiftBuffer();
    let r = this.buffers[0].slice(t15 - this.bufferOffset, e - this.bufferOffset);
    for (; e - this.bufferOffset > this.buffers[0].length; )
      this.shiftBuffer(), r += this.buffers[0].slice(0, e - this.bufferOffset);
    return r;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(t15) {
    var e, r;
    if (this.ended) {
      (r = (e = this.cbs).onerror) === null || r === void 0 || r.call(e, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(t15), this.tokenizer.running && (this.tokenizer.write(t15), this.writeIndex++);
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(t15) {
    var e, r;
    if (this.ended) {
      (r = (e = this.cbs).onerror) === null || r === void 0 || r.call(e, new Error(".end() after done!"));
      return;
    }
    t15 && this.write(t15), this.ended = true, this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    this.ended && this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(t15) {
    this.write(t15);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(t15) {
    this.end(t15);
  }
};
function h$(t15, e) {
  const r = new G_(void 0, e);
  return new c$(r, e).end(t15), r.root;
}
var u$ = r$(CT(h$), K0);
var d$ = {
  "div,p": ({ $node: t15 }) => ({
    queue: t15.children()
  }),
  "h1,h2,h3,h4,h5,h6": ({ $node: t15, getContent: e }) => ({
    ...e(t15.contents())
  }),
  "ul,ol": ({ $node: t15 }) => ({
    queue: t15.children(),
    nesting: true
  }),
  li: ({ $node: t15, getContent: e }) => {
    const r = t15.children().filter("ul,ol");
    let n;
    if (t15.contents().first().is("div,p"))
      n = e(t15.children().first());
    else {
      let i = t15.contents();
      const s = i.index(r);
      s >= 0 && (i = i.slice(0, s)), n = e(i);
    }
    return {
      queue: r,
      nesting: true,
      ...n
    };
  },
  "table,pre,p>img:only-child": ({ $node: t15, getContent: e }) => ({
    ...e(t15)
  })
};
var p$ = {
  selector: "h1,h2,h3,h4,h5,h6,ul,ol,li,table,pre,p>img:only-child",
  selectorRules: d$
};
var d2 = "markmap: ";
var f$ = /^h[1-6]$/;
var m$ = /^[uo]l$/;
var g$ = /^li$/;
function y$(t15) {
  return f$.test(t15) ? +t15[1] : m$.test(t15) ? 8 : g$.test(t15) ? 9 : 7;
}
function b$(t15, e) {
  const r = {
    ...p$,
    ...e
  }, n = u$(t15);
  let i = n("body");
  i.length || (i = n.root());
  let s = 0;
  const a = {
    id: s,
    tag: "",
    html: "",
    level: 0,
    parent: 0,
    childrenLevel: 0,
    children: []
  }, o = [];
  let l = 0;
  return g(i.children()), a;
  function c(y) {
    var x;
    const { parent: k } = y, C = {
      id: ++s,
      tag: y.tagName,
      level: y.level,
      html: y.html,
      childrenLevel: 0,
      children: y.nesting ? [] : void 0,
      parent: k.id
    };
    return (x = y.comments) != null && x.length && (C.comments = y.comments), Object.keys(y.data || {}).length && (C.data = y.data), k.children && ((k.childrenLevel === 0 || k.childrenLevel > C.level) && (k.children = [], k.childrenLevel = C.level), k.childrenLevel === C.level && k.children.push(C)), C;
  }
  function h(y) {
    let x;
    for (; (x = o[o.length - 1]) && x.level >= y; )
      o.pop();
    return x || a;
  }
  function p(y) {
    var x;
    const k = m(y), C = (x = n.html(k.$node)) == null ? void 0 : x.trimEnd();
    return { comments: k.comments, html: C };
  }
  function m(y) {
    const x = [];
    return y = y.filter((k, C) => {
      if (C.type === "comment") {
        const A = C.data.trim();
        if (A.startsWith(d2))
          return x.push(A.slice(d2.length).trim()), false;
      }
      return true;
    }), { $node: y, comments: x };
  }
  function g(y, x) {
    y.each((k, C) => {
      var A;
      const $ = n(C), B = (A = Object.entries(r.selectorRules).find(
        ([R]) => $.is(R)
      )) == null ? void 0 : A[1], L = B == null ? void 0 : B({ $node: $, $: n, getContent: p });
      if ((L == null ? void 0 : L.queue) && !L.nesting) {
        g(L.queue, x);
        return;
      }
      const q = y$(C.tagName);
      if (!L) {
        q <= 6 && (l = q);
        return;
      }
      if (l > 0 && q > l || !$.is(r.selector)) return;
      l = 0;
      const U = q <= 6;
      let G = {
        // If the child is an inline element and expected to be a separate node,
        // data from the closest `<p>` should be included, e.g. `<p data-lines><img /></p>`
        ...$.closest("p").data(),
        ...$.data()
      }, F = L.html || "";
      if ($.is("ol>li") && (x == null ? void 0 : x.children)) {
        const R = +($.parent().attr("start") || 1) + x.children.length;
        F = `${R}. ${F}`, G = {
          ...G,
          listIndex: R
        };
      }
      const W = c({
        parent: x || h(q),
        nesting: !!L.queue || U,
        tagName: C.tagName,
        level: q,
        html: F,
        comments: L.comments,
        data: G
      });
      U && o.push(W), L.queue && g(L.queue, W);
    });
  }
}
function x$(t15) {
  return Jo(t15, (e, r) => {
    const n = {
      content: e.html,
      children: r() || []
    };
    return e.data && (n.payload = {
      tag: e.tag,
      ...e.data
    }), e.comments && (e.comments.includes("foldAll") ? n.payload = { ...n.payload, fold: 2 } : e.comments.includes("fold") && (n.payload = { ...n.payload, fold: 1 })), n;
  });
}
function w$(t15, e) {
  const r = b$(t15, e);
  return x$(r);
}
var p2 = {};
function k$(t15) {
  let e = p2[t15];
  if (e)
    return e;
  e = p2[t15] = [];
  for (let r = 0; r < 128; r++) {
    const n = String.fromCharCode(r);
    e.push(n);
  }
  for (let r = 0; r < t15.length; r++) {
    const n = t15.charCodeAt(r);
    e[n] = "%" + ("0" + n.toString(16).toUpperCase()).slice(-2);
  }
  return e;
}
function Wa(t15, e) {
  typeof e != "string" && (e = Wa.defaultChars);
  const r = k$(e);
  return t15.replace(/(%[a-f0-9]{2})+/gi, function(n) {
    let i = "";
    for (let s = 0, a = n.length; s < a; s += 3) {
      const o = parseInt(n.slice(s + 1, s + 3), 16);
      if (o < 128) {
        i += r[o];
        continue;
      }
      if ((o & 224) === 192 && s + 3 < a) {
        const l = parseInt(n.slice(s + 4, s + 6), 16);
        if ((l & 192) === 128) {
          const c = o << 6 & 1984 | l & 63;
          c < 128 ? i += "��" : i += String.fromCharCode(c), s += 3;
          continue;
        }
      }
      if ((o & 240) === 224 && s + 6 < a) {
        const l = parseInt(n.slice(s + 4, s + 6), 16), c = parseInt(n.slice(s + 7, s + 9), 16);
        if ((l & 192) === 128 && (c & 192) === 128) {
          const h = o << 12 & 61440 | l << 6 & 4032 | c & 63;
          h < 2048 || h >= 55296 && h <= 57343 ? i += "���" : i += String.fromCharCode(h), s += 6;
          continue;
        }
      }
      if ((o & 248) === 240 && s + 9 < a) {
        const l = parseInt(n.slice(s + 4, s + 6), 16), c = parseInt(n.slice(s + 7, s + 9), 16), h = parseInt(n.slice(s + 10, s + 12), 16);
        if ((l & 192) === 128 && (c & 192) === 128 && (h & 192) === 128) {
          let p = o << 18 & 1835008 | l << 12 & 258048 | c << 6 & 4032 | h & 63;
          p < 65536 || p > 1114111 ? i += "����" : (p -= 65536, i += String.fromCharCode(55296 + (p >> 10), 56320 + (p & 1023))), s += 9;
          continue;
        }
      }
      i += "�";
    }
    return i;
  });
}
Wa.defaultChars = ";/?:@&=+$,#";
Wa.componentChars = "";
var f2 = {};
function v$(t15) {
  let e = f2[t15];
  if (e)
    return e;
  e = f2[t15] = [];
  for (let r = 0; r < 128; r++) {
    const n = String.fromCharCode(r);
    /^[0-9a-z]$/i.test(n) ? e.push(n) : e.push("%" + ("0" + r.toString(16).toUpperCase()).slice(-2));
  }
  for (let r = 0; r < t15.length; r++)
    e[t15.charCodeAt(r)] = t15[r];
  return e;
}
function Jl(t15, e, r) {
  typeof e != "string" && (r = e, e = Jl.defaultChars), typeof r > "u" && (r = true);
  const n = v$(e);
  let i = "";
  for (let s = 0, a = t15.length; s < a; s++) {
    const o = t15.charCodeAt(s);
    if (r && o === 37 && s + 2 < a && /^[0-9a-f]{2}$/i.test(t15.slice(s + 1, s + 3))) {
      i += t15.slice(s, s + 3), s += 2;
      continue;
    }
    if (o < 128) {
      i += n[o];
      continue;
    }
    if (o >= 55296 && o <= 57343) {
      if (o >= 55296 && o <= 56319 && s + 1 < a) {
        const l = t15.charCodeAt(s + 1);
        if (l >= 56320 && l <= 57343) {
          i += encodeURIComponent(t15[s] + t15[s + 1]), s++;
          continue;
        }
      }
      i += "%EF%BF%BD";
      continue;
    }
    i += encodeURIComponent(t15[s]);
  }
  return i;
}
Jl.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Jl.componentChars = "-_.!~*'()";
function P1(t15) {
  let e = "";
  return e += t15.protocol || "", e += t15.slashes ? "//" : "", e += t15.auth ? t15.auth + "@" : "", t15.hostname && t15.hostname.indexOf(":") !== -1 ? e += "[" + t15.hostname + "]" : e += t15.hostname || "", e += t15.port ? ":" + t15.port : "", e += t15.pathname || "", e += t15.search || "", e += t15.hash || "", e;
}
function e0() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var C$ = /^([a-z0-9.+-]+:)/i;
var _$ = /:[0-9]*$/;
var S$ = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var A$ = ["<", ">", '"', "`", " ", "\r", `
`, "	"];
var T$ = ["{", "}", "|", "\\", "^", "`"].concat(A$);
var $$ = ["'"].concat(T$);
var m2 = ["%", "/", "?", ";", "#"].concat($$);
var g2 = ["/", "?", "#"];
var E$ = 255;
var y2 = /^[+a-z0-9A-Z_-]{0,63}$/;
var M$ = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var b2 = {
  javascript: true,
  "javascript:": true
};
var x2 = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function j1(t15, e) {
  if (t15 && t15 instanceof e0) return t15;
  const r = new e0();
  return r.parse(t15, e), r;
}
e0.prototype.parse = function(t15, e) {
  let r, n, i, s = t15;
  if (s = s.trim(), !e && t15.split("#").length === 1) {
    const c = S$.exec(s);
    if (c)
      return this.pathname = c[1], c[2] && (this.search = c[2]), this;
  }
  let a = C$.exec(s);
  if (a && (a = a[0], r = a.toLowerCase(), this.protocol = a, s = s.substr(a.length)), (e || a || s.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = s.substr(0, 2) === "//", i && !(a && b2[a]) && (s = s.substr(2), this.slashes = true)), !b2[a] && (i || a && !x2[a])) {
    let c = -1;
    for (let y = 0; y < g2.length; y++)
      n = s.indexOf(g2[y]), n !== -1 && (c === -1 || n < c) && (c = n);
    let h, p;
    c === -1 ? p = s.lastIndexOf("@") : p = s.lastIndexOf("@", c), p !== -1 && (h = s.slice(0, p), s = s.slice(p + 1), this.auth = h), c = -1;
    for (let y = 0; y < m2.length; y++)
      n = s.indexOf(m2[y]), n !== -1 && (c === -1 || n < c) && (c = n);
    c === -1 && (c = s.length), s[c - 1] === ":" && c--;
    const m = s.slice(0, c);
    s = s.slice(c), this.parseHost(m), this.hostname = this.hostname || "";
    const g = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!g) {
      const y = this.hostname.split(/\./);
      for (let x = 0, k = y.length; x < k; x++) {
        const C = y[x];
        if (C && !C.match(y2)) {
          let A = "";
          for (let $ = 0, B = C.length; $ < B; $++)
            C.charCodeAt($) > 127 ? A += "x" : A += C[$];
          if (!A.match(y2)) {
            const $ = y.slice(0, x), B = y.slice(x + 1), L = C.match(M$);
            L && ($.push(L[1]), B.unshift(L[2])), B.length && (s = B.join(".") + s), this.hostname = $.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > E$ && (this.hostname = ""), g && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const o = s.indexOf("#");
  o !== -1 && (this.hash = s.substr(o), s = s.slice(0, o));
  const l = s.indexOf("?");
  return l !== -1 && (this.search = s.substr(l), s = s.slice(0, l)), s && (this.pathname = s), x2[r] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
e0.prototype.parseHost = function(t15) {
  let e = _$.exec(t15);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t15 = t15.substr(0, t15.length - e.length)), t15 && (this.hostname = t15);
};
var B$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: Wa,
  encode: Jl,
  format: P1,
  parse: j1
}, Symbol.toStringTag, { value: "Module" }));
var lx = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var cx = /[\0-\x1F\x7F-\x9F]/;
var L$ = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
var W1 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var hx = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
var ux = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
var D$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  Any: lx,
  Cc: cx,
  Cf: L$,
  P: W1,
  S: hx,
  Z: ux
}, Symbol.toStringTag, { value: "Module" }));
var F$ = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((t15) => t15.charCodeAt(0))
);
var N$ = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((t15) => t15.charCodeAt(0))
);
var Nd;
var I$ = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var O$ = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Nd = String.fromCodePoint) !== null && Nd !== void 0 ? Nd : function(t15) {
    let e = "";
    return t15 > 65535 && (t15 -= 65536, e += String.fromCharCode(t15 >>> 10 & 1023 | 55296), t15 = 56320 | t15 & 1023), e += String.fromCharCode(t15), e;
  }
);
function z$(t15) {
  var e;
  return t15 >= 55296 && t15 <= 57343 || t15 > 1114111 ? 65533 : (e = I$.get(t15)) !== null && e !== void 0 ? e : t15;
}
var ir;
(function(t15) {
  t15[t15.NUM = 35] = "NUM", t15[t15.SEMI = 59] = "SEMI", t15[t15.EQUALS = 61] = "EQUALS", t15[t15.ZERO = 48] = "ZERO", t15[t15.NINE = 57] = "NINE", t15[t15.LOWER_A = 97] = "LOWER_A", t15[t15.LOWER_F = 102] = "LOWER_F", t15[t15.LOWER_X = 120] = "LOWER_X", t15[t15.LOWER_Z = 122] = "LOWER_Z", t15[t15.UPPER_A = 65] = "UPPER_A", t15[t15.UPPER_F = 70] = "UPPER_F", t15[t15.UPPER_Z = 90] = "UPPER_Z";
})(ir || (ir = {}));
var q$ = 32;
var es;
(function(t15) {
  t15[t15.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t15[t15.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t15[t15.JUMP_TABLE = 127] = "JUMP_TABLE";
})(es || (es = {}));
function Kp(t15) {
  return t15 >= ir.ZERO && t15 <= ir.NINE;
}
function R$(t15) {
  return t15 >= ir.UPPER_A && t15 <= ir.UPPER_F || t15 >= ir.LOWER_A && t15 <= ir.LOWER_F;
}
function P$(t15) {
  return t15 >= ir.UPPER_A && t15 <= ir.UPPER_Z || t15 >= ir.LOWER_A && t15 <= ir.LOWER_Z || Kp(t15);
}
function j$(t15) {
  return t15 === ir.EQUALS || P$(t15);
}
var er;
(function(t15) {
  t15[t15.EntityStart = 0] = "EntityStart", t15[t15.NumericStart = 1] = "NumericStart", t15[t15.NumericDecimal = 2] = "NumericDecimal", t15[t15.NumericHex = 3] = "NumericHex", t15[t15.NamedEntity = 4] = "NamedEntity";
})(er || (er = {}));
var Ki;
(function(t15) {
  t15[t15.Legacy = 0] = "Legacy", t15[t15.Strict = 1] = "Strict", t15[t15.Attribute = 2] = "Attribute";
})(Ki || (Ki = {}));
var W$ = class {
  constructor(e, r, n) {
    this.decodeTree = e, this.emitCodePoint = r, this.errors = n, this.state = er.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Ki.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = er.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, r) {
    switch (this.state) {
      case er.EntityStart:
        return e.charCodeAt(r) === ir.NUM ? (this.state = er.NumericStart, this.consumed += 1, this.stateNumericStart(e, r + 1)) : (this.state = er.NamedEntity, this.stateNamedEntity(e, r));
      case er.NumericStart:
        return this.stateNumericStart(e, r);
      case er.NumericDecimal:
        return this.stateNumericDecimal(e, r);
      case er.NumericHex:
        return this.stateNumericHex(e, r);
      case er.NamedEntity:
        return this.stateNamedEntity(e, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, r) {
    return r >= e.length ? -1 : (e.charCodeAt(r) | q$) === ir.LOWER_X ? (this.state = er.NumericHex, this.consumed += 1, this.stateNumericHex(e, r + 1)) : (this.state = er.NumericDecimal, this.stateNumericDecimal(e, r));
  }
  addToNumericResult(e, r, n, i) {
    if (r !== n) {
      const s = n - r;
      this.result = this.result * Math.pow(i, s) + parseInt(e.substr(r, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (Kp(i) || R$(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, n, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, r) {
    const n = r;
    for (; r < e.length; ) {
      const i = e.charCodeAt(r);
      if (Kp(i))
        r += 1;
      else
        return this.addToNumericResult(e, n, r, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, n, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, r) {
    var n;
    if (this.consumed <= r)
      return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === ir.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Ki.Strict)
      return 0;
    return this.emitCodePoint(z$(this.result), this.consumed), this.errors && (e !== ir.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, r) {
    const { decodeTree: n } = this;
    let i = n[this.treeIndex], s = (i & es.VALUE_LENGTH) >> 14;
    for (; r < e.length; r++, this.excess++) {
      const a = e.charCodeAt(r);
      if (this.treeIndex = H$(n, i, this.treeIndex + Math.max(1, s), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Ki.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        j$(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = n[this.treeIndex], s = (i & es.VALUE_LENGTH) >> 14, s !== 0) {
        if (a === ir.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== Ki.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: r, decodeTree: n } = this, i = (n[r] & es.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, r, n) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(r === 1 ? i[e] & ~es.VALUE_LENGTH : i[e + 1], n), r === 3 && this.emitCodePoint(i[e + 2], n), n;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case er.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Ki.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case er.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case er.NumericHex:
        return this.emitNumericEntity(0, 3);
      case er.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case er.EntityStart:
        return 0;
    }
  }
};
function dx(t15) {
  let e = "";
  const r = new W$(t15, (n) => e += O$(n));
  return function(n, i) {
    let s = 0, a = 0;
    for (; (a = n.indexOf("&", a)) >= 0; ) {
      e += n.slice(s, a), r.startEntity(i);
      const l = r.write(
        n,
        // Skip the "&"
        a + 1
      );
      if (l < 0) {
        s = a + r.end();
        break;
      }
      s = a + l, a = l === 0 ? s + 1 : s;
    }
    const o = e + n.slice(s);
    return e = "", o;
  };
}
function H$(t15, e, r, n) {
  const i = (e & es.BRANCH_LENGTH) >> 7, s = e & es.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && n === s ? r : -1;
  if (s) {
    const l = n - s;
    return l < 0 || l >= i ? -1 : t15[r + l] - 1;
  }
  let a = r, o = a + i - 1;
  for (; a <= o; ) {
    const l = a + o >>> 1, c = t15[l];
    if (c < n)
      a = l + 1;
    else if (c > n)
      o = l - 1;
    else
      return t15[l + i];
  }
  return -1;
}
var U$ = dx(F$);
dx(N$);
function px(t15, e = Ki.Legacy) {
  return U$(t15, e);
}
function V$(t15) {
  return Object.prototype.toString.call(t15);
}
function H1(t15) {
  return V$(t15) === "[object String]";
}
var G$ = Object.prototype.hasOwnProperty;
function X$(t15, e) {
  return G$.call(t15, e);
}
function eu(t15) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
    if (e) {
      if (typeof e != "object")
        throw new TypeError(e + "must be object");
      Object.keys(e).forEach(function(r) {
        t15[r] = e[r];
      });
    }
  }), t15;
}
function fx(t15, e, r) {
  return [].concat(t15.slice(0, e), r, t15.slice(e + 1));
}
function U1(t15) {
  return !(t15 >= 55296 && t15 <= 57343 || t15 >= 64976 && t15 <= 65007 || (t15 & 65535) === 65535 || (t15 & 65535) === 65534 || t15 >= 0 && t15 <= 8 || t15 === 11 || t15 >= 14 && t15 <= 31 || t15 >= 127 && t15 <= 159 || t15 > 1114111);
}
function r0(t15) {
  if (t15 > 65535) {
    t15 -= 65536;
    const e = 55296 + (t15 >> 10), r = 56320 + (t15 & 1023);
    return String.fromCharCode(e, r);
  }
  return String.fromCharCode(t15);
}
var mx = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var Y$ = /&([a-z#][a-z0-9]{1,31});/gi;
var K$ = new RegExp(mx.source + "|" + Y$.source, "gi");
var Z$ = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function J$(t15, e) {
  if (e.charCodeAt(0) === 35 && Z$.test(e)) {
    const n = e[1].toLowerCase() === "x" ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10);
    return U1(n) ? r0(n) : t15;
  }
  const r = px(t15);
  return r !== t15 ? r : t15;
}
function Q$(t15) {
  return t15.indexOf("\\") < 0 ? t15 : t15.replace(mx, "$1");
}
function Ha(t15) {
  return t15.indexOf("\\") < 0 && t15.indexOf("&") < 0 ? t15 : t15.replace(K$, function(e, r, n) {
    return r || J$(e, n);
  });
}
var tE = /[&<>"]/;
var eE = /[&<>"]/g;
var rE = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function nE(t15) {
  return rE[t15];
}
function os(t15) {
  return tE.test(t15) ? t15.replace(eE, nE) : t15;
}
var iE = /[.?*+^$[\]\\(){}|-]/g;
function sE(t15) {
  return t15.replace(iE, "\\$&");
}
function Se(t15) {
  switch (t15) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function Tl(t15) {
  if (t15 >= 8192 && t15 <= 8202)
    return true;
  switch (t15) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function $l(t15) {
  return W1.test(t15) || hx.test(t15);
}
function El(t15) {
  switch (t15) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function ru(t15) {
  return t15 = t15.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (t15 = t15.replace(/ẞ/g, "ß")), t15.toLowerCase().toUpperCase();
}
var aE = { mdurl: B$, ucmicro: D$ };
var oE = Object.freeze(Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: fx,
  assign: eu,
  escapeHtml: os,
  escapeRE: sE,
  fromCodePoint: r0,
  has: X$,
  isMdAsciiPunct: El,
  isPunctChar: $l,
  isSpace: Se,
  isString: H1,
  isValidEntityCode: U1,
  isWhiteSpace: Tl,
  lib: aE,
  normalizeReference: ru,
  unescapeAll: Ha,
  unescapeMd: Q$
}, Symbol.toStringTag, { value: "Module" }));
function lE(t15, e, r) {
  let n, i, s, a;
  const o = t15.posMax, l = t15.pos;
  for (t15.pos = e + 1, n = 1; t15.pos < o; ) {
    if (s = t15.src.charCodeAt(t15.pos), s === 93 && (n--, n === 0)) {
      i = true;
      break;
    }
    if (a = t15.pos, t15.md.inline.skipToken(t15), s === 91) {
      if (a === t15.pos - 1)
        n++;
      else if (r)
        return t15.pos = l, -1;
    }
  }
  let c = -1;
  return i && (c = t15.pos), t15.pos = l, c;
}
function cE(t15, e, r) {
  let n, i = e;
  const s = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (t15.charCodeAt(i) === 60) {
    for (i++; i < r; ) {
      if (n = t15.charCodeAt(i), n === 10 || n === 60)
        return s;
      if (n === 62)
        return s.pos = i + 1, s.str = Ha(t15.slice(e + 1, i)), s.ok = true, s;
      if (n === 92 && i + 1 < r) {
        i += 2;
        continue;
      }
      i++;
    }
    return s;
  }
  let a = 0;
  for (; i < r && (n = t15.charCodeAt(i), !(n === 32 || n < 32 || n === 127)); ) {
    if (n === 92 && i + 1 < r) {
      if (t15.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (n === 40 && (a++, a > 32))
      return s;
    if (n === 41) {
      if (a === 0)
        break;
      a--;
    }
    i++;
  }
  return e === i || a !== 0 || (s.str = Ha(t15.slice(e, i)), s.pos = i, s.ok = true), s;
}
function hE(t15, e, r, n) {
  let i, s = e;
  const a = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (n)
    a.str = n.str, a.marker = n.marker;
  else {
    if (s >= r)
      return a;
    let o = t15.charCodeAt(s);
    if (o !== 34 && o !== 39 && o !== 40)
      return a;
    e++, s++, o === 40 && (o = 41), a.marker = o;
  }
  for (; s < r; ) {
    if (i = t15.charCodeAt(s), i === a.marker)
      return a.pos = s + 1, a.str += Ha(t15.slice(e, s)), a.ok = true, a;
    if (i === 40 && a.marker === 41)
      return a;
    i === 92 && s + 1 < r && s++, s++;
  }
  return a.can_continue = true, a.str += Ha(t15.slice(e, s)), a;
}
var uE = Object.freeze(Object.defineProperty({
  __proto__: null,
  parseLinkDestination: cE,
  parseLinkLabel: lE,
  parseLinkTitle: hE
}, Symbol.toStringTag, { value: "Module" }));
var Jn = {};
Jn.code_inline = function(t15, e, r, n, i) {
  const s = t15[e];
  return "<code" + i.renderAttrs(s) + ">" + os(s.content) + "</code>";
};
Jn.code_block = function(t15, e, r, n, i) {
  const s = t15[e];
  return "<pre" + i.renderAttrs(s) + "><code>" + os(t15[e].content) + `</code></pre>
`;
};
Jn.fence = function(t15, e, r, n, i) {
  const s = t15[e], a = s.info ? Ha(s.info).trim() : "";
  let o = "", l = "";
  if (a) {
    const h = a.split(/(\s+)/g);
    o = h[0], l = h.slice(2).join("");
  }
  let c;
  if (r.highlight ? c = r.highlight(s.content, o, l) || os(s.content) : c = os(s.content), c.indexOf("<pre") === 0)
    return c + `
`;
  if (a) {
    const h = s.attrIndex("class"), p = s.attrs ? s.attrs.slice() : [];
    h < 0 ? p.push(["class", r.langPrefix + o]) : (p[h] = p[h].slice(), p[h][1] += " " + r.langPrefix + o);
    const m = {
      attrs: p
    };
    return `<pre><code${i.renderAttrs(m)}>${c}</code></pre>
`;
  }
  return `<pre><code${i.renderAttrs(s)}>${c}</code></pre>
`;
};
Jn.image = function(t15, e, r, n, i) {
  const s = t15[e];
  return s.attrs[s.attrIndex("alt")][1] = i.renderInlineAsText(s.children, r, n), i.renderToken(t15, e, r);
};
Jn.hardbreak = function(t15, e, r) {
  return r.xhtmlOut ? `<br />
` : `<br>
`;
};
Jn.softbreak = function(t15, e, r) {
  return r.breaks ? r.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
Jn.text = function(t15, e) {
  return os(t15[e].content);
};
Jn.html_block = function(t15, e) {
  return t15[e].content;
};
Jn.html_inline = function(t15, e) {
  return t15[e].content;
};
function lo() {
  this.rules = eu({}, Jn);
}
lo.prototype.renderAttrs = function(t15) {
  let e, r, n;
  if (!t15.attrs)
    return "";
  for (n = "", e = 0, r = t15.attrs.length; e < r; e++)
    n += " " + os(t15.attrs[e][0]) + '="' + os(t15.attrs[e][1]) + '"';
  return n;
};
lo.prototype.renderToken = function(t15, e, r) {
  const n = t15[e];
  let i = "";
  if (n.hidden)
    return "";
  n.block && n.nesting !== -1 && e && t15[e - 1].hidden && (i += `
`), i += (n.nesting === -1 ? "</" : "<") + n.tag, i += this.renderAttrs(n), n.nesting === 0 && r.xhtmlOut && (i += " /");
  let s = false;
  if (n.block && (s = true, n.nesting === 1 && e + 1 < t15.length)) {
    const a = t15[e + 1];
    (a.type === "inline" || a.hidden || a.nesting === -1 && a.tag === n.tag) && (s = false);
  }
  return i += s ? `>
` : ">", i;
};
lo.prototype.renderInline = function(t15, e, r) {
  let n = "";
  const i = this.rules;
  for (let s = 0, a = t15.length; s < a; s++) {
    const o = t15[s].type;
    typeof i[o] < "u" ? n += i[o](t15, s, e, r, this) : n += this.renderToken(t15, s, e);
  }
  return n;
};
lo.prototype.renderInlineAsText = function(t15, e, r) {
  let n = "";
  for (let i = 0, s = t15.length; i < s; i++)
    switch (t15[i].type) {
      case "text":
        n += t15[i].content;
        break;
      case "image":
        n += this.renderInlineAsText(t15[i].children, e, r);
        break;
      case "html_inline":
      case "html_block":
        n += t15[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        n += `
`;
        break;
    }
  return n;
};
lo.prototype.render = function(t15, e, r) {
  let n = "";
  const i = this.rules;
  for (let s = 0, a = t15.length; s < a; s++) {
    const o = t15[s].type;
    o === "inline" ? n += this.renderInline(t15[s].children, e, r) : typeof i[o] < "u" ? n += i[o](t15, s, e, r, this) : n += this.renderToken(t15, s, e, r);
  }
  return n;
};
function Ur() {
  this.__rules__ = [], this.__cache__ = null;
}
Ur.prototype.__find__ = function(t15) {
  for (let e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t15)
      return e;
  return -1;
};
Ur.prototype.__compile__ = function() {
  const t15 = this, e = [""];
  t15.__rules__.forEach(function(r) {
    r.enabled && r.alt.forEach(function(n) {
      e.indexOf(n) < 0 && e.push(n);
    });
  }), t15.__cache__ = {}, e.forEach(function(r) {
    t15.__cache__[r] = [], t15.__rules__.forEach(function(n) {
      n.enabled && (r && n.alt.indexOf(r) < 0 || t15.__cache__[r].push(n.fn));
    });
  });
};
Ur.prototype.at = function(t15, e, r) {
  const n = this.__find__(t15), i = r || {};
  if (n === -1)
    throw new Error("Parser rule not found: " + t15);
  this.__rules__[n].fn = e, this.__rules__[n].alt = i.alt || [], this.__cache__ = null;
};
Ur.prototype.before = function(t15, e, r, n) {
  const i = this.__find__(t15), s = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t15);
  this.__rules__.splice(i, 0, {
    name: e,
    enabled: true,
    fn: r,
    alt: s.alt || []
  }), this.__cache__ = null;
};
Ur.prototype.after = function(t15, e, r, n) {
  const i = this.__find__(t15), s = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t15);
  this.__rules__.splice(i + 1, 0, {
    name: e,
    enabled: true,
    fn: r,
    alt: s.alt || []
  }), this.__cache__ = null;
};
Ur.prototype.push = function(t15, e, r) {
  const n = r || {};
  this.__rules__.push({
    name: t15,
    enabled: true,
    fn: e,
    alt: n.alt || []
  }), this.__cache__ = null;
};
Ur.prototype.enable = function(t15, e) {
  Array.isArray(t15) || (t15 = [t15]);
  const r = [];
  return t15.forEach(function(n) {
    const i = this.__find__(n);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + n);
    }
    this.__rules__[i].enabled = true, r.push(n);
  }, this), this.__cache__ = null, r;
};
Ur.prototype.enableOnly = function(t15, e) {
  Array.isArray(t15) || (t15 = [t15]), this.__rules__.forEach(function(r) {
    r.enabled = false;
  }), this.enable(t15, e);
};
Ur.prototype.disable = function(t15, e) {
  Array.isArray(t15) || (t15 = [t15]);
  const r = [];
  return t15.forEach(function(n) {
    const i = this.__find__(n);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + n);
    }
    this.__rules__[i].enabled = false, r.push(n);
  }, this), this.__cache__ = null, r;
};
Ur.prototype.getRules = function(t15) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t15] || [];
};
function An(t15, e, r) {
  this.type = t15, this.tag = e, this.attrs = null, this.map = null, this.nesting = r, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
An.prototype.attrIndex = function(t15) {
  if (!this.attrs)
    return -1;
  const e = this.attrs;
  for (let r = 0, n = e.length; r < n; r++)
    if (e[r][0] === t15)
      return r;
  return -1;
};
An.prototype.attrPush = function(t15) {
  this.attrs ? this.attrs.push(t15) : this.attrs = [t15];
};
An.prototype.attrSet = function(t15, e) {
  const r = this.attrIndex(t15), n = [t15, e];
  r < 0 ? this.attrPush(n) : this.attrs[r] = n;
};
An.prototype.attrGet = function(t15) {
  const e = this.attrIndex(t15);
  let r = null;
  return e >= 0 && (r = this.attrs[e][1]), r;
};
An.prototype.attrJoin = function(t15, e) {
  const r = this.attrIndex(t15);
  r < 0 ? this.attrPush([t15, e]) : this.attrs[r][1] = this.attrs[r][1] + " " + e;
};
function gx(t15, e, r) {
  this.src = t15, this.env = r, this.tokens = [], this.inlineMode = false, this.md = e;
}
gx.prototype.Token = An;
var dE = /\r\n?|\n/g;
var pE = /\0/g;
function fE(t15) {
  let e;
  e = t15.src.replace(dE, `
`), e = e.replace(pE, "�"), t15.src = e;
}
function mE(t15) {
  let e;
  t15.inlineMode ? (e = new t15.Token("inline", "", 0), e.content = t15.src, e.map = [0, 1], e.children = [], t15.tokens.push(e)) : t15.md.block.parse(t15.src, t15.md, t15.env, t15.tokens);
}
function gE(t15) {
  const e = t15.tokens;
  for (let r = 0, n = e.length; r < n; r++) {
    const i = e[r];
    i.type === "inline" && t15.md.inline.parse(i.content, t15.md, t15.env, i.children);
  }
}
function yE(t15) {
  return /^<a[>\s]/i.test(t15);
}
function bE(t15) {
  return /^<\/a\s*>/i.test(t15);
}
function xE(t15) {
  const e = t15.tokens;
  if (t15.md.options.linkify)
    for (let r = 0, n = e.length; r < n; r++) {
      if (e[r].type !== "inline" || !t15.md.linkify.pretest(e[r].content))
        continue;
      let i = e[r].children, s = 0;
      for (let a = i.length - 1; a >= 0; a--) {
        const o = i[a];
        if (o.type === "link_close") {
          for (a--; i[a].level !== o.level && i[a].type !== "link_open"; )
            a--;
          continue;
        }
        if (o.type === "html_inline" && (yE(o.content) && s > 0 && s--, bE(o.content) && s++), !(s > 0) && o.type === "text" && t15.md.linkify.test(o.content)) {
          const l = o.content;
          let c = t15.md.linkify.match(l);
          const h = [];
          let p = o.level, m = 0;
          c.length > 0 && c[0].index === 0 && a > 0 && i[a - 1].type === "text_special" && (c = c.slice(1));
          for (let g = 0; g < c.length; g++) {
            const y = c[g].url, x = t15.md.normalizeLink(y);
            if (!t15.md.validateLink(x))
              continue;
            let k = c[g].text;
            c[g].schema ? c[g].schema === "mailto:" && !/^mailto:/i.test(k) ? k = t15.md.normalizeLinkText("mailto:" + k).replace(/^mailto:/, "") : k = t15.md.normalizeLinkText(k) : k = t15.md.normalizeLinkText("http://" + k).replace(/^http:\/\//, "");
            const C = c[g].index;
            if (C > m) {
              const L = new t15.Token("text", "", 0);
              L.content = l.slice(m, C), L.level = p, h.push(L);
            }
            const A = new t15.Token("link_open", "a", 1);
            A.attrs = [["href", x]], A.level = p++, A.markup = "linkify", A.info = "auto", h.push(A);
            const $ = new t15.Token("text", "", 0);
            $.content = k, $.level = p, h.push($);
            const B = new t15.Token("link_close", "a", -1);
            B.level = --p, B.markup = "linkify", B.info = "auto", h.push(B), m = c[g].lastIndex;
          }
          if (m < l.length) {
            const g = new t15.Token("text", "", 0);
            g.content = l.slice(m), g.level = p, h.push(g);
          }
          e[r].children = i = fx(i, a, h);
        }
      }
    }
}
var yx = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var wE = /\((c|tm|r)\)/i;
var kE = /\((c|tm|r)\)/ig;
var vE = {
  c: "©",
  r: "®",
  tm: "™"
};
function CE(t15, e) {
  return vE[e.toLowerCase()];
}
function _E(t15) {
  let e = 0;
  for (let r = t15.length - 1; r >= 0; r--) {
    const n = t15[r];
    n.type === "text" && !e && (n.content = n.content.replace(kE, CE)), n.type === "link_open" && n.info === "auto" && e--, n.type === "link_close" && n.info === "auto" && e++;
  }
}
function SE(t15) {
  let e = 0;
  for (let r = t15.length - 1; r >= 0; r--) {
    const n = t15[r];
    n.type === "text" && !e && yx.test(n.content) && (n.content = n.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), n.type === "link_open" && n.info === "auto" && e--, n.type === "link_close" && n.info === "auto" && e++;
  }
}
function AE(t15) {
  let e;
  if (t15.md.options.typographer)
    for (e = t15.tokens.length - 1; e >= 0; e--)
      t15.tokens[e].type === "inline" && (wE.test(t15.tokens[e].content) && _E(t15.tokens[e].children), yx.test(t15.tokens[e].content) && SE(t15.tokens[e].children));
}
var TE = /['"]/;
var w2 = /['"]/g;
var k2 = "’";
function Hc(t15, e, r) {
  return t15.slice(0, e) + r + t15.slice(e + 1);
}
function $E(t15, e) {
  let r;
  const n = [];
  for (let i = 0; i < t15.length; i++) {
    const s = t15[i], a = t15[i].level;
    for (r = n.length - 1; r >= 0 && !(n[r].level <= a); r--)
      ;
    if (n.length = r + 1, s.type !== "text")
      continue;
    let o = s.content, l = 0, c = o.length;
    t:
      for (; l < c; ) {
        w2.lastIndex = l;
        const h = w2.exec(o);
        if (!h)
          break;
        let p = true, m = true;
        l = h.index + 1;
        const g = h[0] === "'";
        let y = 32;
        if (h.index - 1 >= 0)
          y = o.charCodeAt(h.index - 1);
        else
          for (r = i - 1; r >= 0 && !(t15[r].type === "softbreak" || t15[r].type === "hardbreak"); r--)
            if (t15[r].content) {
              y = t15[r].content.charCodeAt(t15[r].content.length - 1);
              break;
            }
        let x = 32;
        if (l < c)
          x = o.charCodeAt(l);
        else
          for (r = i + 1; r < t15.length && !(t15[r].type === "softbreak" || t15[r].type === "hardbreak"); r++)
            if (t15[r].content) {
              x = t15[r].content.charCodeAt(0);
              break;
            }
        const k = El(y) || $l(String.fromCharCode(y)), C = El(x) || $l(String.fromCharCode(x)), A = Tl(y), $ = Tl(x);
        if ($ ? p = false : C && (A || k || (p = false)), A ? m = false : k && ($ || C || (m = false)), x === 34 && h[0] === '"' && y >= 48 && y <= 57 && (m = p = false), p && m && (p = k, m = C), !p && !m) {
          g && (s.content = Hc(s.content, h.index, k2));
          continue;
        }
        if (m)
          for (r = n.length - 1; r >= 0; r--) {
            let B = n[r];
            if (n[r].level < a)
              break;
            if (B.single === g && n[r].level === a) {
              B = n[r];
              let L, q;
              g ? (L = e.md.options.quotes[2], q = e.md.options.quotes[3]) : (L = e.md.options.quotes[0], q = e.md.options.quotes[1]), s.content = Hc(s.content, h.index, q), t15[B.token].content = Hc(
                t15[B.token].content,
                B.pos,
                L
              ), l += q.length - 1, B.token === i && (l += L.length - 1), o = s.content, c = o.length, n.length = r;
              continue t;
            }
          }
        p ? n.push({
          token: i,
          pos: h.index,
          single: g,
          level: a
        }) : m && g && (s.content = Hc(s.content, h.index, k2));
      }
  }
}
function EE(t15) {
  if (t15.md.options.typographer)
    for (let e = t15.tokens.length - 1; e >= 0; e--)
      t15.tokens[e].type !== "inline" || !TE.test(t15.tokens[e].content) || $E(t15.tokens[e].children, t15);
}
function ME(t15) {
  let e, r;
  const n = t15.tokens, i = n.length;
  for (let s = 0; s < i; s++) {
    if (n[s].type !== "inline") continue;
    const a = n[s].children, o = a.length;
    for (e = 0; e < o; e++)
      a[e].type === "text_special" && (a[e].type = "text");
    for (e = r = 0; e < o; e++)
      a[e].type === "text" && e + 1 < o && a[e + 1].type === "text" ? a[e + 1].content = a[e].content + a[e + 1].content : (e !== r && (a[r] = a[e]), r++);
    e !== r && (a.length = r);
  }
}
var Id = [
  ["normalize", fE],
  ["block", mE],
  ["inline", gE],
  ["linkify", xE],
  ["replacements", AE],
  ["smartquotes", EE],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", ME]
];
function V1() {
  this.ruler = new Ur();
  for (let t15 = 0; t15 < Id.length; t15++)
    this.ruler.push(Id[t15][0], Id[t15][1]);
}
V1.prototype.process = function(t15) {
  const e = this.ruler.getRules("");
  for (let r = 0, n = e.length; r < n; r++)
    e[r](t15);
};
V1.prototype.State = gx;
function Qn(t15, e, r, n) {
  this.src = t15, this.md = e, this.env = r, this.tokens = n, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const i = this.src;
  for (let s = 0, a = 0, o = 0, l = 0, c = i.length, h = false; a < c; a++) {
    const p = i.charCodeAt(a);
    if (!h)
      if (Se(p)) {
        o++, p === 9 ? l += 4 - l % 4 : l++;
        continue;
      } else
        h = true;
    (p === 10 || a === c - 1) && (p !== 10 && a++, this.bMarks.push(s), this.eMarks.push(a), this.tShift.push(o), this.sCount.push(l), this.bsCount.push(0), h = false, o = 0, l = 0, s = a + 1);
  }
  this.bMarks.push(i.length), this.eMarks.push(i.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
Qn.prototype.push = function(t15, e, r) {
  const n = new An(t15, e, r);
  return n.block = true, r < 0 && this.level--, n.level = this.level, r > 0 && this.level++, this.tokens.push(n), n;
};
Qn.prototype.isEmpty = function(t15) {
  return this.bMarks[t15] + this.tShift[t15] >= this.eMarks[t15];
};
Qn.prototype.skipEmptyLines = function(t15) {
  for (let e = this.lineMax; t15 < e && !(this.bMarks[t15] + this.tShift[t15] < this.eMarks[t15]); t15++)
    ;
  return t15;
};
Qn.prototype.skipSpaces = function(t15) {
  for (let e = this.src.length; t15 < e; t15++) {
    const r = this.src.charCodeAt(t15);
    if (!Se(r))
      break;
  }
  return t15;
};
Qn.prototype.skipSpacesBack = function(t15, e) {
  if (t15 <= e)
    return t15;
  for (; t15 > e; )
    if (!Se(this.src.charCodeAt(--t15)))
      return t15 + 1;
  return t15;
};
Qn.prototype.skipChars = function(t15, e) {
  for (let r = this.src.length; t15 < r && this.src.charCodeAt(t15) === e; t15++)
    ;
  return t15;
};
Qn.prototype.skipCharsBack = function(t15, e, r) {
  if (t15 <= r)
    return t15;
  for (; t15 > r; )
    if (e !== this.src.charCodeAt(--t15))
      return t15 + 1;
  return t15;
};
Qn.prototype.getLines = function(t15, e, r, n) {
  if (t15 >= e)
    return "";
  const i = new Array(e - t15);
  for (let s = 0, a = t15; a < e; a++, s++) {
    let o = 0;
    const l = this.bMarks[a];
    let c = l, h;
    for (a + 1 < e || n ? h = this.eMarks[a] + 1 : h = this.eMarks[a]; c < h && o < r; ) {
      const p = this.src.charCodeAt(c);
      if (Se(p))
        p === 9 ? o += 4 - (o + this.bsCount[a]) % 4 : o++;
      else if (c - l < this.tShift[a])
        o++;
      else
        break;
      c++;
    }
    o > r ? i[s] = new Array(o - r + 1).join(" ") + this.src.slice(c, h) : i[s] = this.src.slice(c, h);
  }
  return i.join("");
};
Qn.prototype.Token = An;
var BE = 65536;
function Od(t15, e) {
  const r = t15.bMarks[e] + t15.tShift[e], n = t15.eMarks[e];
  return t15.src.slice(r, n);
}
function v2(t15) {
  const e = [], r = t15.length;
  let n = 0, i = t15.charCodeAt(n), s = false, a = 0, o = "";
  for (; n < r; )
    i === 124 && (s ? (o += t15.substring(a, n - 1), a = n) : (e.push(o + t15.substring(a, n)), o = "", a = n + 1)), s = i === 92, n++, i = t15.charCodeAt(n);
  return e.push(o + t15.substring(a)), e;
}
function LE(t15, e, r, n) {
  if (e + 2 > r)
    return false;
  let i = e + 1;
  if (t15.sCount[i] < t15.blkIndent || t15.sCount[i] - t15.blkIndent >= 4)
    return false;
  let s = t15.bMarks[i] + t15.tShift[i];
  if (s >= t15.eMarks[i])
    return false;
  const a = t15.src.charCodeAt(s++);
  if (a !== 124 && a !== 45 && a !== 58 || s >= t15.eMarks[i])
    return false;
  const o = t15.src.charCodeAt(s++);
  if (o !== 124 && o !== 45 && o !== 58 && !Se(o) || a === 45 && Se(o))
    return false;
  for (; s < t15.eMarks[i]; ) {
    const B = t15.src.charCodeAt(s);
    if (B !== 124 && B !== 45 && B !== 58 && !Se(B))
      return false;
    s++;
  }
  let l = Od(t15, e + 1), c = l.split("|");
  const h = [];
  for (let B = 0; B < c.length; B++) {
    const L = c[B].trim();
    if (!L) {
      if (B === 0 || B === c.length - 1)
        continue;
      return false;
    }
    if (!/^:?-+:?$/.test(L))
      return false;
    L.charCodeAt(L.length - 1) === 58 ? h.push(L.charCodeAt(0) === 58 ? "center" : "right") : L.charCodeAt(0) === 58 ? h.push("left") : h.push("");
  }
  if (l = Od(t15, e).trim(), l.indexOf("|") === -1 || t15.sCount[e] - t15.blkIndent >= 4)
    return false;
  c = v2(l), c.length && c[0] === "" && c.shift(), c.length && c[c.length - 1] === "" && c.pop();
  const p = c.length;
  if (p === 0 || p !== h.length)
    return false;
  if (n)
    return true;
  const m = t15.parentType;
  t15.parentType = "table";
  const g = t15.md.block.ruler.getRules("blockquote"), y = t15.push("table_open", "table", 1), x = [e, 0];
  y.map = x;
  const k = t15.push("thead_open", "thead", 1);
  k.map = [e, e + 1];
  const C = t15.push("tr_open", "tr", 1);
  C.map = [e, e + 1];
  for (let B = 0; B < c.length; B++) {
    const L = t15.push("th_open", "th", 1);
    h[B] && (L.attrs = [["style", "text-align:" + h[B]]]);
    const q = t15.push("inline", "", 0);
    q.content = c[B].trim(), q.children = [], t15.push("th_close", "th", -1);
  }
  t15.push("tr_close", "tr", -1), t15.push("thead_close", "thead", -1);
  let A, $ = 0;
  for (i = e + 2; i < r && !(t15.sCount[i] < t15.blkIndent); i++) {
    let B = false;
    for (let q = 0, U = g.length; q < U; q++)
      if (g[q](t15, i, r, true)) {
        B = true;
        break;
      }
    if (B || (l = Od(t15, i).trim(), !l) || t15.sCount[i] - t15.blkIndent >= 4 || (c = v2(l), c.length && c[0] === "" && c.shift(), c.length && c[c.length - 1] === "" && c.pop(), $ += p - c.length, $ > BE))
      break;
    if (i === e + 2) {
      const q = t15.push("tbody_open", "tbody", 1);
      q.map = A = [e + 2, 0];
    }
    const L = t15.push("tr_open", "tr", 1);
    L.map = [i, i + 1];
    for (let q = 0; q < p; q++) {
      const U = t15.push("td_open", "td", 1);
      h[q] && (U.attrs = [["style", "text-align:" + h[q]]]);
      const G = t15.push("inline", "", 0);
      G.content = c[q] ? c[q].trim() : "", G.children = [], t15.push("td_close", "td", -1);
    }
    t15.push("tr_close", "tr", -1);
  }
  return A && (t15.push("tbody_close", "tbody", -1), A[1] = i), t15.push("table_close", "table", -1), x[1] = i, t15.parentType = m, t15.line = i, true;
}
function DE(t15, e, r) {
  if (t15.sCount[e] - t15.blkIndent < 4)
    return false;
  let n = e + 1, i = n;
  for (; n < r; ) {
    if (t15.isEmpty(n)) {
      n++;
      continue;
    }
    if (t15.sCount[n] - t15.blkIndent >= 4) {
      n++, i = n;
      continue;
    }
    break;
  }
  t15.line = i;
  const s = t15.push("code_block", "code", 0);
  return s.content = t15.getLines(e, i, 4 + t15.blkIndent, false) + `
`, s.map = [e, t15.line], true;
}
function FE(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e];
  if (t15.sCount[e] - t15.blkIndent >= 4 || i + 3 > s)
    return false;
  const a = t15.src.charCodeAt(i);
  if (a !== 126 && a !== 96)
    return false;
  let o = i;
  i = t15.skipChars(i, a);
  let l = i - o;
  if (l < 3)
    return false;
  const c = t15.src.slice(o, i), h = t15.src.slice(i, s);
  if (a === 96 && h.indexOf(String.fromCharCode(a)) >= 0)
    return false;
  if (n)
    return true;
  let p = e, m = false;
  for (; p++, !(p >= r || (i = o = t15.bMarks[p] + t15.tShift[p], s = t15.eMarks[p], i < s && t15.sCount[p] < t15.blkIndent)); )
    if (t15.src.charCodeAt(i) === a && !(t15.sCount[p] - t15.blkIndent >= 4) && (i = t15.skipChars(i, a), !(i - o < l) && (i = t15.skipSpaces(i), !(i < s)))) {
      m = true;
      break;
    }
  l = t15.sCount[e], t15.line = p + (m ? 1 : 0);
  const g = t15.push("fence", "code", 0);
  return g.info = h, g.content = t15.getLines(e + 1, p, l, true), g.markup = c, g.map = [e, t15.line], true;
}
function NE(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e];
  const a = t15.lineMax;
  if (t15.sCount[e] - t15.blkIndent >= 4 || t15.src.charCodeAt(i) !== 62)
    return false;
  if (n)
    return true;
  const o = [], l = [], c = [], h = [], p = t15.md.block.ruler.getRules("blockquote"), m = t15.parentType;
  t15.parentType = "blockquote";
  let g = false, y;
  for (y = e; y < r; y++) {
    const $ = t15.sCount[y] < t15.blkIndent;
    if (i = t15.bMarks[y] + t15.tShift[y], s = t15.eMarks[y], i >= s)
      break;
    if (t15.src.charCodeAt(i++) === 62 && !$) {
      let L = t15.sCount[y] + 1, q, U;
      t15.src.charCodeAt(i) === 32 ? (i++, L++, U = false, q = true) : t15.src.charCodeAt(i) === 9 ? (q = true, (t15.bsCount[y] + L) % 4 === 3 ? (i++, L++, U = false) : U = true) : q = false;
      let G = L;
      for (o.push(t15.bMarks[y]), t15.bMarks[y] = i; i < s; ) {
        const F = t15.src.charCodeAt(i);
        if (Se(F))
          F === 9 ? G += 4 - (G + t15.bsCount[y] + (U ? 1 : 0)) % 4 : G++;
        else
          break;
        i++;
      }
      g = i >= s, l.push(t15.bsCount[y]), t15.bsCount[y] = t15.sCount[y] + 1 + (q ? 1 : 0), c.push(t15.sCount[y]), t15.sCount[y] = G - L, h.push(t15.tShift[y]), t15.tShift[y] = i - t15.bMarks[y];
      continue;
    }
    if (g)
      break;
    let B = false;
    for (let L = 0, q = p.length; L < q; L++)
      if (p[L](t15, y, r, true)) {
        B = true;
        break;
      }
    if (B) {
      t15.lineMax = y, t15.blkIndent !== 0 && (o.push(t15.bMarks[y]), l.push(t15.bsCount[y]), h.push(t15.tShift[y]), c.push(t15.sCount[y]), t15.sCount[y] -= t15.blkIndent);
      break;
    }
    o.push(t15.bMarks[y]), l.push(t15.bsCount[y]), h.push(t15.tShift[y]), c.push(t15.sCount[y]), t15.sCount[y] = -1;
  }
  const x = t15.blkIndent;
  t15.blkIndent = 0;
  const k = t15.push("blockquote_open", "blockquote", 1);
  k.markup = ">";
  const C = [e, 0];
  k.map = C, t15.md.block.tokenize(t15, e, y);
  const A = t15.push("blockquote_close", "blockquote", -1);
  A.markup = ">", t15.lineMax = a, t15.parentType = m, C[1] = t15.line;
  for (let $ = 0; $ < h.length; $++)
    t15.bMarks[$ + e] = o[$], t15.tShift[$ + e] = h[$], t15.sCount[$ + e] = c[$], t15.bsCount[$ + e] = l[$];
  return t15.blkIndent = x, true;
}
function IE(t15, e, r, n) {
  const i = t15.eMarks[e];
  if (t15.sCount[e] - t15.blkIndent >= 4)
    return false;
  let s = t15.bMarks[e] + t15.tShift[e];
  const a = t15.src.charCodeAt(s++);
  if (a !== 42 && a !== 45 && a !== 95)
    return false;
  let o = 1;
  for (; s < i; ) {
    const c = t15.src.charCodeAt(s++);
    if (c !== a && !Se(c))
      return false;
    c === a && o++;
  }
  if (o < 3)
    return false;
  if (n)
    return true;
  t15.line = e + 1;
  const l = t15.push("hr", "hr", 0);
  return l.map = [e, t15.line], l.markup = Array(o + 1).join(String.fromCharCode(a)), true;
}
function C2(t15, e) {
  const r = t15.eMarks[e];
  let n = t15.bMarks[e] + t15.tShift[e];
  const i = t15.src.charCodeAt(n++);
  if (i !== 42 && i !== 45 && i !== 43)
    return -1;
  if (n < r) {
    const s = t15.src.charCodeAt(n);
    if (!Se(s))
      return -1;
  }
  return n;
}
function _2(t15, e) {
  const r = t15.bMarks[e] + t15.tShift[e], n = t15.eMarks[e];
  let i = r;
  if (i + 1 >= n)
    return -1;
  let s = t15.src.charCodeAt(i++);
  if (s < 48 || s > 57)
    return -1;
  for (; ; ) {
    if (i >= n)
      return -1;
    if (s = t15.src.charCodeAt(i++), s >= 48 && s <= 57) {
      if (i - r >= 10)
        return -1;
      continue;
    }
    if (s === 41 || s === 46)
      break;
    return -1;
  }
  return i < n && (s = t15.src.charCodeAt(i), !Se(s)) ? -1 : i;
}
function OE(t15, e) {
  const r = t15.level + 2;
  for (let n = e + 2, i = t15.tokens.length - 2; n < i; n++)
    t15.tokens[n].level === r && t15.tokens[n].type === "paragraph_open" && (t15.tokens[n + 2].hidden = true, t15.tokens[n].hidden = true, n += 2);
}
function zE(t15, e, r, n) {
  let i, s, a, o, l = e, c = true;
  if (t15.sCount[l] - t15.blkIndent >= 4 || t15.listIndent >= 0 && t15.sCount[l] - t15.listIndent >= 4 && t15.sCount[l] < t15.blkIndent)
    return false;
  let h = false;
  n && t15.parentType === "paragraph" && t15.sCount[l] >= t15.blkIndent && (h = true);
  let p, m, g;
  if ((g = _2(t15, l)) >= 0) {
    if (p = true, a = t15.bMarks[l] + t15.tShift[l], m = Number(t15.src.slice(a, g - 1)), h && m !== 1) return false;
  } else if ((g = C2(t15, l)) >= 0)
    p = false;
  else
    return false;
  if (h && t15.skipSpaces(g) >= t15.eMarks[l])
    return false;
  if (n)
    return true;
  const y = t15.src.charCodeAt(g - 1), x = t15.tokens.length;
  p ? (o = t15.push("ordered_list_open", "ol", 1), m !== 1 && (o.attrs = [["start", m]])) : o = t15.push("bullet_list_open", "ul", 1);
  const k = [l, 0];
  o.map = k, o.markup = String.fromCharCode(y);
  let C = false;
  const A = t15.md.block.ruler.getRules("list"), $ = t15.parentType;
  for (t15.parentType = "list"; l < r; ) {
    s = g, i = t15.eMarks[l];
    const B = t15.sCount[l] + g - (t15.bMarks[l] + t15.tShift[l]);
    let L = B;
    for (; s < i; ) {
      const j = t15.src.charCodeAt(s);
      if (j === 9)
        L += 4 - (L + t15.bsCount[l]) % 4;
      else if (j === 32)
        L++;
      else
        break;
      s++;
    }
    const q = s;
    let U;
    q >= i ? U = 1 : U = L - B, U > 4 && (U = 1);
    const G = B + U;
    o = t15.push("list_item_open", "li", 1), o.markup = String.fromCharCode(y);
    const F = [l, 0];
    o.map = F, p && (o.info = t15.src.slice(a, g - 1));
    const W = t15.tight, R = t15.tShift[l], Q = t15.sCount[l], rt = t15.listIndent;
    if (t15.listIndent = t15.blkIndent, t15.blkIndent = G, t15.tight = true, t15.tShift[l] = q - t15.bMarks[l], t15.sCount[l] = L, q >= i && t15.isEmpty(l + 1) ? t15.line = Math.min(t15.line + 2, r) : t15.md.block.tokenize(t15, l, r, true), (!t15.tight || C) && (c = false), C = t15.line - l > 1 && t15.isEmpty(t15.line - 1), t15.blkIndent = t15.listIndent, t15.listIndent = rt, t15.tShift[l] = R, t15.sCount[l] = Q, t15.tight = W, o = t15.push("list_item_close", "li", -1), o.markup = String.fromCharCode(y), l = t15.line, F[1] = l, l >= r || t15.sCount[l] < t15.blkIndent || t15.sCount[l] - t15.blkIndent >= 4)
      break;
    let I = false;
    for (let j = 0, z = A.length; j < z; j++)
      if (A[j](t15, l, r, true)) {
        I = true;
        break;
      }
    if (I)
      break;
    if (p) {
      if (g = _2(t15, l), g < 0)
        break;
      a = t15.bMarks[l] + t15.tShift[l];
    } else if (g = C2(t15, l), g < 0)
      break;
    if (y !== t15.src.charCodeAt(g - 1))
      break;
  }
  return p ? o = t15.push("ordered_list_close", "ol", -1) : o = t15.push("bullet_list_close", "ul", -1), o.markup = String.fromCharCode(y), k[1] = l, t15.line = l, t15.parentType = $, c && OE(t15, x), true;
}
function qE(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e], a = e + 1;
  if (t15.sCount[e] - t15.blkIndent >= 4 || t15.src.charCodeAt(i) !== 91)
    return false;
  function o(A) {
    const $ = t15.lineMax;
    if (A >= $ || t15.isEmpty(A))
      return null;
    let B = false;
    if (t15.sCount[A] - t15.blkIndent > 3 && (B = true), t15.sCount[A] < 0 && (B = true), !B) {
      const U = t15.md.block.ruler.getRules("reference"), G = t15.parentType;
      t15.parentType = "reference";
      let F = false;
      for (let W = 0, R = U.length; W < R; W++)
        if (U[W](t15, A, $, true)) {
          F = true;
          break;
        }
      if (t15.parentType = G, F)
        return null;
    }
    const L = t15.bMarks[A] + t15.tShift[A], q = t15.eMarks[A];
    return t15.src.slice(L, q + 1);
  }
  let l = t15.src.slice(i, s + 1);
  s = l.length;
  let c = -1;
  for (i = 1; i < s; i++) {
    const A = l.charCodeAt(i);
    if (A === 91)
      return false;
    if (A === 93) {
      c = i;
      break;
    } else if (A === 10) {
      const $ = o(a);
      $ !== null && (l += $, s = l.length, a++);
    } else if (A === 92 && (i++, i < s && l.charCodeAt(i) === 10)) {
      const $ = o(a);
      $ !== null && (l += $, s = l.length, a++);
    }
  }
  if (c < 0 || l.charCodeAt(c + 1) !== 58)
    return false;
  for (i = c + 2; i < s; i++) {
    const A = l.charCodeAt(i);
    if (A === 10) {
      const $ = o(a);
      $ !== null && (l += $, s = l.length, a++);
    } else if (!Se(A)) break;
  }
  const h = t15.md.helpers.parseLinkDestination(l, i, s);
  if (!h.ok)
    return false;
  const p = t15.md.normalizeLink(h.str);
  if (!t15.md.validateLink(p))
    return false;
  i = h.pos;
  const m = i, g = a, y = i;
  for (; i < s; i++) {
    const A = l.charCodeAt(i);
    if (A === 10) {
      const $ = o(a);
      $ !== null && (l += $, s = l.length, a++);
    } else if (!Se(A)) break;
  }
  let x = t15.md.helpers.parseLinkTitle(l, i, s);
  for (; x.can_continue; ) {
    const A = o(a);
    if (A === null) break;
    l += A, i = s, s = l.length, a++, x = t15.md.helpers.parseLinkTitle(l, i, s, x);
  }
  let k;
  for (i < s && y !== i && x.ok ? (k = x.str, i = x.pos) : (k = "", i = m, a = g); i < s; ) {
    const A = l.charCodeAt(i);
    if (!Se(A))
      break;
    i++;
  }
  if (i < s && l.charCodeAt(i) !== 10 && k)
    for (k = "", i = m, a = g; i < s; ) {
      const A = l.charCodeAt(i);
      if (!Se(A))
        break;
      i++;
    }
  if (i < s && l.charCodeAt(i) !== 10)
    return false;
  const C = ru(l.slice(1, c));
  return C ? (n || (typeof t15.env.references > "u" && (t15.env.references = {}), typeof t15.env.references[C] > "u" && (t15.env.references[C] = { title: k, href: p }), t15.line = a), true) : false;
}
var RE = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var PE = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var jE = "[^\"'=<>`\\x00-\\x20]+";
var WE = "'[^']*'";
var HE = '"[^"]*"';
var UE = "(?:" + jE + "|" + WE + "|" + HE + ")";
var VE = "(?:\\s+" + PE + "(?:\\s*=\\s*" + UE + ")?)";
var bx = "<[A-Za-z][A-Za-z0-9\\-]*" + VE + "*\\s*\\/?>";
var xx = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var GE = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var XE = "<[?][\\s\\S]*?[?]>";
var YE = "<![A-Za-z][^>]*>";
var KE = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var ZE = new RegExp("^(?:" + bx + "|" + xx + "|" + GE + "|" + XE + "|" + YE + "|" + KE + ")");
var JE = new RegExp("^(?:" + bx + "|" + xx + ")");
var ba = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + RE.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(JE.source + "\\s*$"), /^$/, false]
];
function QE(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e];
  if (t15.sCount[e] - t15.blkIndent >= 4 || !t15.md.options.html || t15.src.charCodeAt(i) !== 60)
    return false;
  let a = t15.src.slice(i, s), o = 0;
  for (; o < ba.length && !ba[o][0].test(a); o++)
    ;
  if (o === ba.length)
    return false;
  if (n)
    return ba[o][2];
  let l = e + 1;
  if (!ba[o][1].test(a)) {
    for (; l < r && !(t15.sCount[l] < t15.blkIndent); l++)
      if (i = t15.bMarks[l] + t15.tShift[l], s = t15.eMarks[l], a = t15.src.slice(i, s), ba[o][1].test(a)) {
        a.length !== 0 && l++;
        break;
      }
  }
  t15.line = l;
  const c = t15.push("html_block", "", 0);
  return c.map = [e, l], c.content = t15.getLines(e, l, t15.blkIndent, true), true;
}
function tM(t15, e, r, n) {
  let i = t15.bMarks[e] + t15.tShift[e], s = t15.eMarks[e];
  if (t15.sCount[e] - t15.blkIndent >= 4)
    return false;
  let a = t15.src.charCodeAt(i);
  if (a !== 35 || i >= s)
    return false;
  let o = 1;
  for (a = t15.src.charCodeAt(++i); a === 35 && i < s && o <= 6; )
    o++, a = t15.src.charCodeAt(++i);
  if (o > 6 || i < s && !Se(a))
    return false;
  if (n)
    return true;
  s = t15.skipSpacesBack(s, i);
  const l = t15.skipCharsBack(s, 35, i);
  l > i && Se(t15.src.charCodeAt(l - 1)) && (s = l), t15.line = e + 1;
  const c = t15.push("heading_open", "h" + String(o), 1);
  c.markup = "########".slice(0, o), c.map = [e, t15.line];
  const h = t15.push("inline", "", 0);
  h.content = t15.src.slice(i, s).trim(), h.map = [e, t15.line], h.children = [];
  const p = t15.push("heading_close", "h" + String(o), -1);
  return p.markup = "########".slice(0, o), true;
}
function eM(t15, e, r) {
  const n = t15.md.block.ruler.getRules("paragraph");
  if (t15.sCount[e] - t15.blkIndent >= 4)
    return false;
  const i = t15.parentType;
  t15.parentType = "paragraph";
  let s = 0, a, o = e + 1;
  for (; o < r && !t15.isEmpty(o); o++) {
    if (t15.sCount[o] - t15.blkIndent > 3)
      continue;
    if (t15.sCount[o] >= t15.blkIndent) {
      let g = t15.bMarks[o] + t15.tShift[o];
      const y = t15.eMarks[o];
      if (g < y && (a = t15.src.charCodeAt(g), (a === 45 || a === 61) && (g = t15.skipChars(g, a), g = t15.skipSpaces(g), g >= y))) {
        s = a === 61 ? 1 : 2;
        break;
      }
    }
    if (t15.sCount[o] < 0)
      continue;
    let m = false;
    for (let g = 0, y = n.length; g < y; g++)
      if (n[g](t15, o, r, true)) {
        m = true;
        break;
      }
    if (m)
      break;
  }
  if (!s)
    return false;
  const l = t15.getLines(e, o, t15.blkIndent, false).trim();
  t15.line = o + 1;
  const c = t15.push("heading_open", "h" + String(s), 1);
  c.markup = String.fromCharCode(a), c.map = [e, t15.line];
  const h = t15.push("inline", "", 0);
  h.content = l, h.map = [e, t15.line - 1], h.children = [];
  const p = t15.push("heading_close", "h" + String(s), -1);
  return p.markup = String.fromCharCode(a), t15.parentType = i, true;
}
function rM(t15, e, r) {
  const n = t15.md.block.ruler.getRules("paragraph"), i = t15.parentType;
  let s = e + 1;
  for (t15.parentType = "paragraph"; s < r && !t15.isEmpty(s); s++) {
    if (t15.sCount[s] - t15.blkIndent > 3 || t15.sCount[s] < 0)
      continue;
    let c = false;
    for (let h = 0, p = n.length; h < p; h++)
      if (n[h](t15, s, r, true)) {
        c = true;
        break;
      }
    if (c)
      break;
  }
  const a = t15.getLines(e, s, t15.blkIndent, false).trim();
  t15.line = s;
  const o = t15.push("paragraph_open", "p", 1);
  o.map = [e, t15.line];
  const l = t15.push("inline", "", 0);
  return l.content = a, l.map = [e, t15.line], l.children = [], t15.push("paragraph_close", "p", -1), t15.parentType = i, true;
}
var Uc = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", LE, ["paragraph", "reference"]],
  ["code", DE],
  ["fence", FE, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", NE, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", IE, ["paragraph", "reference", "blockquote", "list"]],
  ["list", zE, ["paragraph", "reference", "blockquote"]],
  ["reference", qE],
  ["html_block", QE, ["paragraph", "reference", "blockquote"]],
  ["heading", tM, ["paragraph", "reference", "blockquote"]],
  ["lheading", eM],
  ["paragraph", rM]
];
function nu() {
  this.ruler = new Ur();
  for (let t15 = 0; t15 < Uc.length; t15++)
    this.ruler.push(Uc[t15][0], Uc[t15][1], { alt: (Uc[t15][2] || []).slice() });
}
nu.prototype.tokenize = function(t15, e, r) {
  const n = this.ruler.getRules(""), i = n.length, s = t15.md.options.maxNesting;
  let a = e, o = false;
  for (; a < r && (t15.line = a = t15.skipEmptyLines(a), !(a >= r || t15.sCount[a] < t15.blkIndent)); ) {
    if (t15.level >= s) {
      t15.line = r;
      break;
    }
    const l = t15.line;
    let c = false;
    for (let h = 0; h < i; h++)
      if (c = n[h](t15, a, r, false), c) {
        if (l >= t15.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!c) throw new Error("none of the block rules matched");
    t15.tight = !o, t15.isEmpty(t15.line - 1) && (o = true), a = t15.line, a < r && t15.isEmpty(a) && (o = true, a++, t15.line = a);
  }
};
nu.prototype.parse = function(t15, e, r, n) {
  if (!t15)
    return;
  const i = new this.State(t15, e, r, n);
  this.tokenize(i, i.line, i.lineMax);
};
nu.prototype.State = Qn;
function Ql(t15, e, r, n) {
  this.src = t15, this.env = r, this.md = e, this.tokens = n, this.tokens_meta = Array(n.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
Ql.prototype.pushPending = function() {
  const t15 = new An("text", "", 0);
  return t15.content = this.pending, t15.level = this.pendingLevel, this.tokens.push(t15), this.pending = "", t15;
};
Ql.prototype.push = function(t15, e, r) {
  this.pending && this.pushPending();
  const n = new An(t15, e, r);
  let i = null;
  return r < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), n.level = this.level, r > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(n), this.tokens_meta.push(i), n;
};
Ql.prototype.scanDelims = function(t15, e) {
  const r = this.posMax, n = this.src.charCodeAt(t15), i = t15 > 0 ? this.src.charCodeAt(t15 - 1) : 32;
  let s = t15;
  for (; s < r && this.src.charCodeAt(s) === n; )
    s++;
  const a = s - t15, o = s < r ? this.src.charCodeAt(s) : 32, l = El(i) || $l(String.fromCharCode(i)), c = El(o) || $l(String.fromCharCode(o)), h = Tl(i), p = Tl(o), m = !p && (!c || h || l), g = !h && (!l || p || c);
  return { can_open: m && (e || !g || l), can_close: g && (e || !m || c), length: a };
};
Ql.prototype.Token = An;
function nM(t15) {
  switch (t15) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function iM(t15, e) {
  let r = t15.pos;
  for (; r < t15.posMax && !nM(t15.src.charCodeAt(r)); )
    r++;
  return r === t15.pos ? false : (e || (t15.pending += t15.src.slice(t15.pos, r)), t15.pos = r, true);
}
var sM = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function aM(t15, e) {
  if (!t15.md.options.linkify || t15.linkLevel > 0) return false;
  const r = t15.pos, n = t15.posMax;
  if (r + 3 > n || t15.src.charCodeAt(r) !== 58 || t15.src.charCodeAt(r + 1) !== 47 || t15.src.charCodeAt(r + 2) !== 47) return false;
  const i = t15.pending.match(sM);
  if (!i) return false;
  const s = i[1], a = t15.md.linkify.matchAtStart(t15.src.slice(r - s.length));
  if (!a) return false;
  let o = a.url;
  if (o.length <= s.length) return false;
  o = o.replace(/\*+$/, "");
  const l = t15.md.normalizeLink(o);
  if (!t15.md.validateLink(l)) return false;
  if (!e) {
    t15.pending = t15.pending.slice(0, -s.length);
    const c = t15.push("link_open", "a", 1);
    c.attrs = [["href", l]], c.markup = "linkify", c.info = "auto";
    const h = t15.push("text", "", 0);
    h.content = t15.md.normalizeLinkText(o);
    const p = t15.push("link_close", "a", -1);
    p.markup = "linkify", p.info = "auto";
  }
  return t15.pos += o.length - s.length, true;
}
function oM(t15, e) {
  let r = t15.pos;
  if (t15.src.charCodeAt(r) !== 10)
    return false;
  const n = t15.pending.length - 1, i = t15.posMax;
  if (!e)
    if (n >= 0 && t15.pending.charCodeAt(n) === 32)
      if (n >= 1 && t15.pending.charCodeAt(n - 1) === 32) {
        let s = n - 1;
        for (; s >= 1 && t15.pending.charCodeAt(s - 1) === 32; ) s--;
        t15.pending = t15.pending.slice(0, s), t15.push("hardbreak", "br", 0);
      } else
        t15.pending = t15.pending.slice(0, -1), t15.push("softbreak", "br", 0);
    else
      t15.push("softbreak", "br", 0);
  for (r++; r < i && Se(t15.src.charCodeAt(r)); )
    r++;
  return t15.pos = r, true;
}
var G1 = [];
for (let t15 = 0; t15 < 256; t15++)
  G1.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(t15) {
  G1[t15.charCodeAt(0)] = 1;
});
function lM(t15, e) {
  let r = t15.pos;
  const n = t15.posMax;
  if (t15.src.charCodeAt(r) !== 92 || (r++, r >= n)) return false;
  let i = t15.src.charCodeAt(r);
  if (i === 10) {
    for (e || t15.push("hardbreak", "br", 0), r++; r < n && (i = t15.src.charCodeAt(r), !!Se(i)); )
      r++;
    return t15.pos = r, true;
  }
  let s = t15.src[r];
  if (i >= 55296 && i <= 56319 && r + 1 < n) {
    const o = t15.src.charCodeAt(r + 1);
    o >= 56320 && o <= 57343 && (s += t15.src[r + 1], r++);
  }
  const a = "\\" + s;
  if (!e) {
    const o = t15.push("text_special", "", 0);
    i < 256 && G1[i] !== 0 ? o.content = s : o.content = a, o.markup = a, o.info = "escape";
  }
  return t15.pos = r + 1, true;
}
function cM(t15, e) {
  let r = t15.pos;
  if (t15.src.charCodeAt(r) !== 96)
    return false;
  const n = r;
  r++;
  const i = t15.posMax;
  for (; r < i && t15.src.charCodeAt(r) === 96; )
    r++;
  const s = t15.src.slice(n, r), a = s.length;
  if (t15.backticksScanned && (t15.backticks[a] || 0) <= n)
    return e || (t15.pending += s), t15.pos += a, true;
  let o = r, l;
  for (; (l = t15.src.indexOf("`", o)) !== -1; ) {
    for (o = l + 1; o < i && t15.src.charCodeAt(o) === 96; )
      o++;
    const c = o - l;
    if (c === a) {
      if (!e) {
        const h = t15.push("code_inline", "code", 0);
        h.markup = s, h.content = t15.src.slice(r, l).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return t15.pos = o, true;
    }
    t15.backticks[c] = l;
  }
  return t15.backticksScanned = true, e || (t15.pending += s), t15.pos += a, true;
}
function hM(t15, e) {
  const r = t15.pos, n = t15.src.charCodeAt(r);
  if (e || n !== 126)
    return false;
  const i = t15.scanDelims(t15.pos, true);
  let s = i.length;
  const a = String.fromCharCode(n);
  if (s < 2)
    return false;
  let o;
  s % 2 && (o = t15.push("text", "", 0), o.content = a, s--);
  for (let l = 0; l < s; l += 2)
    o = t15.push("text", "", 0), o.content = a + a, t15.delimiters.push({
      marker: n,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: t15.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return t15.pos += i.length, true;
}
function S2(t15, e) {
  let r;
  const n = [], i = e.length;
  for (let s = 0; s < i; s++) {
    const a = e[s];
    if (a.marker !== 126 || a.end === -1)
      continue;
    const o = e[a.end];
    r = t15.tokens[a.token], r.type = "s_open", r.tag = "s", r.nesting = 1, r.markup = "~~", r.content = "", r = t15.tokens[o.token], r.type = "s_close", r.tag = "s", r.nesting = -1, r.markup = "~~", r.content = "", t15.tokens[o.token - 1].type === "text" && t15.tokens[o.token - 1].content === "~" && n.push(o.token - 1);
  }
  for (; n.length; ) {
    const s = n.pop();
    let a = s + 1;
    for (; a < t15.tokens.length && t15.tokens[a].type === "s_close"; )
      a++;
    a--, s !== a && (r = t15.tokens[a], t15.tokens[a] = t15.tokens[s], t15.tokens[s] = r);
  }
}
function uM(t15) {
  const e = t15.tokens_meta, r = t15.tokens_meta.length;
  S2(t15, t15.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && S2(t15, e[n].delimiters);
}
var wx = {
  tokenize: hM,
  postProcess: uM
};
function dM(t15, e) {
  const r = t15.pos, n = t15.src.charCodeAt(r);
  if (e || n !== 95 && n !== 42)
    return false;
  const i = t15.scanDelims(t15.pos, n === 42);
  for (let s = 0; s < i.length; s++) {
    const a = t15.push("text", "", 0);
    a.content = String.fromCharCode(n), t15.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: n,
      // Total length of these series of delimiters.
      //
      length: i.length,
      // A position of the token this delimiter corresponds to.
      //
      token: t15.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: i.can_open,
      close: i.can_close
    });
  }
  return t15.pos += i.length, true;
}
function A2(t15, e) {
  const r = e.length;
  for (let n = r - 1; n >= 0; n--) {
    const i = e[n];
    if (i.marker !== 95 && i.marker !== 42 || i.end === -1)
      continue;
    const s = e[i.end], a = n > 0 && e[n - 1].end === i.end + 1 && // check that first two markers match and adjacent
    e[n - 1].marker === i.marker && e[n - 1].token === i.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[i.end + 1].token === s.token + 1, o = String.fromCharCode(i.marker), l = t15.tokens[i.token];
    l.type = a ? "strong_open" : "em_open", l.tag = a ? "strong" : "em", l.nesting = 1, l.markup = a ? o + o : o, l.content = "";
    const c = t15.tokens[s.token];
    c.type = a ? "strong_close" : "em_close", c.tag = a ? "strong" : "em", c.nesting = -1, c.markup = a ? o + o : o, c.content = "", a && (t15.tokens[e[n - 1].token].content = "", t15.tokens[e[i.end + 1].token].content = "", n--);
  }
}
function pM(t15) {
  const e = t15.tokens_meta, r = t15.tokens_meta.length;
  A2(t15, t15.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && A2(t15, e[n].delimiters);
}
var kx = {
  tokenize: dM,
  postProcess: pM
};
function fM(t15, e) {
  let r, n, i, s, a = "", o = "", l = t15.pos, c = true;
  if (t15.src.charCodeAt(t15.pos) !== 91)
    return false;
  const h = t15.pos, p = t15.posMax, m = t15.pos + 1, g = t15.md.helpers.parseLinkLabel(t15, t15.pos, true);
  if (g < 0)
    return false;
  let y = g + 1;
  if (y < p && t15.src.charCodeAt(y) === 40) {
    for (c = false, y++; y < p && (r = t15.src.charCodeAt(y), !(!Se(r) && r !== 10)); y++)
      ;
    if (y >= p)
      return false;
    if (l = y, i = t15.md.helpers.parseLinkDestination(t15.src, y, t15.posMax), i.ok) {
      for (a = t15.md.normalizeLink(i.str), t15.md.validateLink(a) ? y = i.pos : a = "", l = y; y < p && (r = t15.src.charCodeAt(y), !(!Se(r) && r !== 10)); y++)
        ;
      if (i = t15.md.helpers.parseLinkTitle(t15.src, y, t15.posMax), y < p && l !== y && i.ok)
        for (o = i.str, y = i.pos; y < p && (r = t15.src.charCodeAt(y), !(!Se(r) && r !== 10)); y++)
          ;
    }
    (y >= p || t15.src.charCodeAt(y) !== 41) && (c = true), y++;
  }
  if (c) {
    if (typeof t15.env.references > "u")
      return false;
    if (y < p && t15.src.charCodeAt(y) === 91 ? (l = y + 1, y = t15.md.helpers.parseLinkLabel(t15, y), y >= 0 ? n = t15.src.slice(l, y++) : y = g + 1) : y = g + 1, n || (n = t15.src.slice(m, g)), s = t15.env.references[ru(n)], !s)
      return t15.pos = h, false;
    a = s.href, o = s.title;
  }
  if (!e) {
    t15.pos = m, t15.posMax = g;
    const x = t15.push("link_open", "a", 1), k = [["href", a]];
    x.attrs = k, o && k.push(["title", o]), t15.linkLevel++, t15.md.inline.tokenize(t15), t15.linkLevel--, t15.push("link_close", "a", -1);
  }
  return t15.pos = y, t15.posMax = p, true;
}
function mM(t15, e) {
  let r, n, i, s, a, o, l, c, h = "";
  const p = t15.pos, m = t15.posMax;
  if (t15.src.charCodeAt(t15.pos) !== 33 || t15.src.charCodeAt(t15.pos + 1) !== 91)
    return false;
  const g = t15.pos + 2, y = t15.md.helpers.parseLinkLabel(t15, t15.pos + 1, false);
  if (y < 0)
    return false;
  if (s = y + 1, s < m && t15.src.charCodeAt(s) === 40) {
    for (s++; s < m && (r = t15.src.charCodeAt(s), !(!Se(r) && r !== 10)); s++)
      ;
    if (s >= m)
      return false;
    for (c = s, o = t15.md.helpers.parseLinkDestination(t15.src, s, t15.posMax), o.ok && (h = t15.md.normalizeLink(o.str), t15.md.validateLink(h) ? s = o.pos : h = ""), c = s; s < m && (r = t15.src.charCodeAt(s), !(!Se(r) && r !== 10)); s++)
      ;
    if (o = t15.md.helpers.parseLinkTitle(t15.src, s, t15.posMax), s < m && c !== s && o.ok)
      for (l = o.str, s = o.pos; s < m && (r = t15.src.charCodeAt(s), !(!Se(r) && r !== 10)); s++)
        ;
    else
      l = "";
    if (s >= m || t15.src.charCodeAt(s) !== 41)
      return t15.pos = p, false;
    s++;
  } else {
    if (typeof t15.env.references > "u")
      return false;
    if (s < m && t15.src.charCodeAt(s) === 91 ? (c = s + 1, s = t15.md.helpers.parseLinkLabel(t15, s), s >= 0 ? i = t15.src.slice(c, s++) : s = y + 1) : s = y + 1, i || (i = t15.src.slice(g, y)), a = t15.env.references[ru(i)], !a)
      return t15.pos = p, false;
    h = a.href, l = a.title;
  }
  if (!e) {
    n = t15.src.slice(g, y);
    const x = [];
    t15.md.inline.parse(
      n,
      t15.md,
      t15.env,
      x
    );
    const k = t15.push("image", "img", 0), C = [["src", h], ["alt", ""]];
    k.attrs = C, k.children = x, k.content = n, l && C.push(["title", l]);
  }
  return t15.pos = s, t15.posMax = m, true;
}
var gM = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var yM = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function bM(t15, e) {
  let r = t15.pos;
  if (t15.src.charCodeAt(r) !== 60)
    return false;
  const n = t15.pos, i = t15.posMax;
  for (; ; ) {
    if (++r >= i) return false;
    const a = t15.src.charCodeAt(r);
    if (a === 60) return false;
    if (a === 62) break;
  }
  const s = t15.src.slice(n + 1, r);
  if (yM.test(s)) {
    const a = t15.md.normalizeLink(s);
    if (!t15.md.validateLink(a))
      return false;
    if (!e) {
      const o = t15.push("link_open", "a", 1);
      o.attrs = [["href", a]], o.markup = "autolink", o.info = "auto";
      const l = t15.push("text", "", 0);
      l.content = t15.md.normalizeLinkText(s);
      const c = t15.push("link_close", "a", -1);
      c.markup = "autolink", c.info = "auto";
    }
    return t15.pos += s.length + 2, true;
  }
  if (gM.test(s)) {
    const a = t15.md.normalizeLink("mailto:" + s);
    if (!t15.md.validateLink(a))
      return false;
    if (!e) {
      const o = t15.push("link_open", "a", 1);
      o.attrs = [["href", a]], o.markup = "autolink", o.info = "auto";
      const l = t15.push("text", "", 0);
      l.content = t15.md.normalizeLinkText(s);
      const c = t15.push("link_close", "a", -1);
      c.markup = "autolink", c.info = "auto";
    }
    return t15.pos += s.length + 2, true;
  }
  return false;
}
function xM(t15) {
  return /^<a[>\s]/i.test(t15);
}
function wM(t15) {
  return /^<\/a\s*>/i.test(t15);
}
function kM(t15) {
  const e = t15 | 32;
  return e >= 97 && e <= 122;
}
function vM(t15, e) {
  if (!t15.md.options.html)
    return false;
  const r = t15.posMax, n = t15.pos;
  if (t15.src.charCodeAt(n) !== 60 || n + 2 >= r)
    return false;
  const i = t15.src.charCodeAt(n + 1);
  if (i !== 33 && i !== 63 && i !== 47 && !kM(i))
    return false;
  const s = t15.src.slice(n).match(ZE);
  if (!s)
    return false;
  if (!e) {
    const a = t15.push("html_inline", "", 0);
    a.content = s[0], xM(a.content) && t15.linkLevel++, wM(a.content) && t15.linkLevel--;
  }
  return t15.pos += s[0].length, true;
}
var CM = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var _M = /^&([a-z][a-z0-9]{1,31});/i;
function SM(t15, e) {
  const r = t15.pos, n = t15.posMax;
  if (t15.src.charCodeAt(r) !== 38 || r + 1 >= n) return false;
  if (t15.src.charCodeAt(r + 1) === 35) {
    const i = t15.src.slice(r).match(CM);
    if (i) {
      if (!e) {
        const s = i[1][0].toLowerCase() === "x" ? parseInt(i[1].slice(1), 16) : parseInt(i[1], 10), a = t15.push("text_special", "", 0);
        a.content = U1(s) ? r0(s) : r0(65533), a.markup = i[0], a.info = "entity";
      }
      return t15.pos += i[0].length, true;
    }
  } else {
    const i = t15.src.slice(r).match(_M);
    if (i) {
      const s = px(i[0]);
      if (s !== i[0]) {
        if (!e) {
          const a = t15.push("text_special", "", 0);
          a.content = s, a.markup = i[0], a.info = "entity";
        }
        return t15.pos += i[0].length, true;
      }
    }
  }
  return false;
}
function T2(t15) {
  const e = {}, r = t15.length;
  if (!r) return;
  let n = 0, i = -2;
  const s = [];
  for (let a = 0; a < r; a++) {
    const o = t15[a];
    if (s.push(0), (t15[n].marker !== o.marker || i !== o.token - 1) && (n = a), i = o.token, o.length = o.length || 0, !o.close) continue;
    e.hasOwnProperty(o.marker) || (e[o.marker] = [-1, -1, -1, -1, -1, -1]);
    const l = e[o.marker][(o.open ? 3 : 0) + o.length % 3];
    let c = n - s[n] - 1, h = c;
    for (; c > l; c -= s[c] + 1) {
      const p = t15[c];
      if (p.marker === o.marker && p.open && p.end < 0) {
        let m = false;
        if ((p.close || o.open) && (p.length + o.length) % 3 === 0 && (p.length % 3 !== 0 || o.length % 3 !== 0) && (m = true), !m) {
          const g = c > 0 && !t15[c - 1].open ? s[c - 1] + 1 : 0;
          s[a] = a - c + g, s[c] = g, o.open = false, p.end = a, p.close = false, h = -1, i = -2;
          break;
        }
      }
    }
    h !== -1 && (e[o.marker][(o.open ? 3 : 0) + (o.length || 0) % 3] = h);
  }
}
function AM(t15) {
  const e = t15.tokens_meta, r = t15.tokens_meta.length;
  T2(t15.delimiters);
  for (let n = 0; n < r; n++)
    e[n] && e[n].delimiters && T2(e[n].delimiters);
}
function TM(t15) {
  let e, r, n = 0;
  const i = t15.tokens, s = t15.tokens.length;
  for (e = r = 0; e < s; e++)
    i[e].nesting < 0 && n--, i[e].level = n, i[e].nesting > 0 && n++, i[e].type === "text" && e + 1 < s && i[e + 1].type === "text" ? i[e + 1].content = i[e].content + i[e + 1].content : (e !== r && (i[r] = i[e]), r++);
  e !== r && (i.length = r);
}
var zd = [
  ["text", iM],
  ["linkify", aM],
  ["newline", oM],
  ["escape", lM],
  ["backticks", cM],
  ["strikethrough", wx.tokenize],
  ["emphasis", kx.tokenize],
  ["link", fM],
  ["image", mM],
  ["autolink", bM],
  ["html_inline", vM],
  ["entity", SM]
];
var qd = [
  ["balance_pairs", AM],
  ["strikethrough", wx.postProcess],
  ["emphasis", kx.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", TM]
];
function tc() {
  this.ruler = new Ur();
  for (let t15 = 0; t15 < zd.length; t15++)
    this.ruler.push(zd[t15][0], zd[t15][1]);
  this.ruler2 = new Ur();
  for (let t15 = 0; t15 < qd.length; t15++)
    this.ruler2.push(qd[t15][0], qd[t15][1]);
}
tc.prototype.skipToken = function(t15) {
  const e = t15.pos, r = this.ruler.getRules(""), n = r.length, i = t15.md.options.maxNesting, s = t15.cache;
  if (typeof s[e] < "u") {
    t15.pos = s[e];
    return;
  }
  let a = false;
  if (t15.level < i) {
    for (let o = 0; o < n; o++)
      if (t15.level++, a = r[o](t15, true), t15.level--, a) {
        if (e >= t15.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    t15.pos = t15.posMax;
  a || t15.pos++, s[e] = t15.pos;
};
tc.prototype.tokenize = function(t15) {
  const e = this.ruler.getRules(""), r = e.length, n = t15.posMax, i = t15.md.options.maxNesting;
  for (; t15.pos < n; ) {
    const s = t15.pos;
    let a = false;
    if (t15.level < i) {
      for (let o = 0; o < r; o++)
        if (a = e[o](t15, false), a) {
          if (s >= t15.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (a) {
      if (t15.pos >= n)
        break;
      continue;
    }
    t15.pending += t15.src[t15.pos++];
  }
  t15.pending && t15.pushPending();
};
tc.prototype.parse = function(t15, e, r, n) {
  const i = new this.State(t15, e, r, n);
  this.tokenize(i);
  const s = this.ruler2.getRules(""), a = s.length;
  for (let o = 0; o < a; o++)
    s[o](i);
};
tc.prototype.State = Ql;
function $M(t15) {
  const e = {};
  t15 = t15 || {}, e.src_Any = lx.source, e.src_Cc = cx.source, e.src_Z = ux.source, e.src_P = W1.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
  const r = "[><｜]";
  return e.src_pseudo_letter = "(?:(?!" + r + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + r + "|" + e.src_ZPCc + ")(?!" + (t15["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + r + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (t15["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + r + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
}
function Zp(t15) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
    e && Object.keys(e).forEach(function(r) {
      t15[r] = e[r];
    });
  }), t15;
}
function iu(t15) {
  return Object.prototype.toString.call(t15);
}
function EM(t15) {
  return iu(t15) === "[object String]";
}
function MM(t15) {
  return iu(t15) === "[object Object]";
}
function BM(t15) {
  return iu(t15) === "[object RegExp]";
}
function $2(t15) {
  return iu(t15) === "[object Function]";
}
function LM(t15) {
  return t15.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var vx = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function DM(t15) {
  return Object.keys(t15 || {}).reduce(function(e, r) {
    return e || vx.hasOwnProperty(r);
  }, false);
}
var FM = {
  "http:": {
    validate: function(t15, e, r) {
      const n = t15.slice(e);
      return r.re.http || (r.re.http = new RegExp(
        "^\\/\\/" + r.re.src_auth + r.re.src_host_port_strict + r.re.src_path,
        "i"
      )), r.re.http.test(n) ? n.match(r.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(t15, e, r) {
      const n = t15.slice(e);
      return r.re.no_http || (r.re.no_http = new RegExp(
        "^" + r.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + r.re.src_domain + ")\\.)+" + r.re.src_domain_root + ")" + r.re.src_port + r.re.src_host_terminator + r.re.src_path,
        "i"
      )), r.re.no_http.test(n) ? e >= 3 && t15[e - 3] === ":" || e >= 3 && t15[e - 3] === "/" ? 0 : n.match(r.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(t15, e, r) {
      const n = t15.slice(e);
      return r.re.mailto || (r.re.mailto = new RegExp(
        "^" + r.re.src_email_name + "@" + r.re.src_host_strict,
        "i"
      )), r.re.mailto.test(n) ? n.match(r.re.mailto)[0].length : 0;
    }
  }
};
var NM = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var IM = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function OM(t15) {
  t15.__index__ = -1, t15.__text_cache__ = "";
}
function zM(t15) {
  return function(e, r) {
    const n = e.slice(r);
    return t15.test(n) ? n.match(t15)[0].length : 0;
  };
}
function E2() {
  return function(t15, e) {
    e.normalize(t15);
  };
}
function n0(t15) {
  const e = t15.re = $M(t15.__opts__), r = t15.__tlds__.slice();
  t15.onCompile(), t15.__tlds_replaced__ || r.push(NM), r.push(e.src_xn), e.src_tlds = r.join("|");
  function n(o) {
    return o.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(n(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(n(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(n(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(n(e.tpl_host_fuzzy_test), "i");
  const i = [];
  t15.__compiled__ = {};
  function s(o, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + o + '": ' + l);
  }
  Object.keys(t15.__schemas__).forEach(function(o) {
    const l = t15.__schemas__[o];
    if (l === null)
      return;
    const c = { validate: null, link: null };
    if (t15.__compiled__[o] = c, MM(l)) {
      BM(l.validate) ? c.validate = zM(l.validate) : $2(l.validate) ? c.validate = l.validate : s(o, l), $2(l.normalize) ? c.normalize = l.normalize : l.normalize ? s(o, l) : c.normalize = E2();
      return;
    }
    if (EM(l)) {
      i.push(o);
      return;
    }
    s(o, l);
  }), i.forEach(function(o) {
    t15.__compiled__[t15.__schemas__[o]] && (t15.__compiled__[o].validate = t15.__compiled__[t15.__schemas__[o]].validate, t15.__compiled__[o].normalize = t15.__compiled__[t15.__schemas__[o]].normalize);
  }), t15.__compiled__[""] = { validate: null, normalize: E2() };
  const a = Object.keys(t15.__compiled__).filter(function(o) {
    return o.length > 0 && t15.__compiled__[o];
  }).map(LM).join("|");
  t15.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + a + ")", "i"), t15.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + a + ")", "ig"), t15.re.schema_at_start = RegExp("^" + t15.re.schema_search.source, "i"), t15.re.pretest = RegExp(
    "(" + t15.re.schema_test.source + ")|(" + t15.re.host_fuzzy_test.source + ")|@",
    "i"
  ), OM(t15);
}
function qM(t15, e) {
  const r = t15.__index__, n = t15.__last_index__, i = t15.__text_cache__.slice(r, n);
  this.schema = t15.__schema__.toLowerCase(), this.index = r + e, this.lastIndex = n + e, this.raw = i, this.text = i, this.url = i;
}
function Jp(t15, e) {
  const r = new qM(t15, e);
  return t15.__compiled__[r.schema].normalize(r, t15), r;
}
function Qr(t15, e) {
  if (!(this instanceof Qr))
    return new Qr(t15, e);
  e || DM(t15) && (e = t15, t15 = {}), this.__opts__ = Zp({}, vx, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Zp({}, FM, t15), this.__compiled__ = {}, this.__tlds__ = IM, this.__tlds_replaced__ = false, this.re = {}, n0(this);
}
Qr.prototype.add = function(t15, e) {
  return this.__schemas__[t15] = e, n0(this), this;
};
Qr.prototype.set = function(t15) {
  return this.__opts__ = Zp(this.__opts__, t15), this;
};
Qr.prototype.test = function(t15) {
  if (this.__text_cache__ = t15, this.__index__ = -1, !t15.length)
    return false;
  let e, r, n, i, s, a, o, l, c;
  if (this.re.schema_test.test(t15)) {
    for (o = this.re.schema_search, o.lastIndex = 0; (e = o.exec(t15)) !== null; )
      if (i = this.testSchemaAt(t15, e[2], o.lastIndex), i) {
        this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + i;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = t15.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = t15.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (s = r.index + r[1].length, (this.__index__ < 0 || s < this.__index__) && (this.__schema__ = "", this.__index__ = s, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (c = t15.indexOf("@"), c >= 0 && (n = t15.match(this.re.email_fuzzy)) !== null && (s = n.index + n[1].length, a = n.index + n[0].length, (this.__index__ < 0 || s < this.__index__ || s === this.__index__ && a > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = s, this.__last_index__ = a))), this.__index__ >= 0;
};
Qr.prototype.pretest = function(t15) {
  return this.re.pretest.test(t15);
};
Qr.prototype.testSchemaAt = function(t15, e, r) {
  return this.__compiled__[e.toLowerCase()] ? this.__compiled__[e.toLowerCase()].validate(t15, r, this) : 0;
};
Qr.prototype.match = function(t15) {
  const e = [];
  let r = 0;
  this.__index__ >= 0 && this.__text_cache__ === t15 && (e.push(Jp(this, r)), r = this.__last_index__);
  let n = r ? t15.slice(r) : t15;
  for (; this.test(n); )
    e.push(Jp(this, r)), n = n.slice(this.__last_index__), r += this.__last_index__;
  return e.length ? e : null;
};
Qr.prototype.matchAtStart = function(t15) {
  if (this.__text_cache__ = t15, this.__index__ = -1, !t15.length) return null;
  const e = this.re.schema_at_start.exec(t15);
  if (!e) return null;
  const r = this.testSchemaAt(t15, e[2], e[0].length);
  return r ? (this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + r, Jp(this, 0)) : null;
};
Qr.prototype.tlds = function(t15, e) {
  return t15 = Array.isArray(t15) ? t15 : [t15], e ? (this.__tlds__ = this.__tlds__.concat(t15).sort().filter(function(r, n, i) {
    return r !== i[n - 1];
  }).reverse(), n0(this), this) : (this.__tlds__ = t15.slice(), this.__tlds_replaced__ = true, n0(this), this);
};
Qr.prototype.normalize = function(t15) {
  t15.schema || (t15.url = "http://" + t15.url), t15.schema === "mailto:" && !/^mailto:/i.test(t15.url) && (t15.url = "mailto:" + t15.url);
};
Qr.prototype.onCompile = function() {
};
var Da = 2147483647;
var Hn = 36;
var X1 = 1;
var Ml = 26;
var RM = 38;
var PM = 700;
var Cx = 72;
var _x = 128;
var Sx = "-";
var jM = /^xn--/;
var WM = /[^\0-\x7F]/;
var HM = /[\x2E\u3002\uFF0E\uFF61]/g;
var UM = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var Rd = Hn - X1;
var Un = Math.floor;
var Pd = String.fromCharCode;
function Vi(t15) {
  throw new RangeError(UM[t15]);
}
function VM(t15, e) {
  const r = [];
  let n = t15.length;
  for (; n--; )
    r[n] = e(t15[n]);
  return r;
}
function Ax(t15, e) {
  const r = t15.split("@");
  let n = "";
  r.length > 1 && (n = r[0] + "@", t15 = r[1]), t15 = t15.replace(HM, ".");
  const i = t15.split("."), s = VM(i, e).join(".");
  return n + s;
}
function Tx(t15) {
  const e = [];
  let r = 0;
  const n = t15.length;
  for (; r < n; ) {
    const i = t15.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      const s = t15.charCodeAt(r++);
      (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), r--);
    } else
      e.push(i);
  }
  return e;
}
var GM = (t15) => String.fromCodePoint(...t15);
var XM = function(t15) {
  return t15 >= 48 && t15 < 58 ? 26 + (t15 - 48) : t15 >= 65 && t15 < 91 ? t15 - 65 : t15 >= 97 && t15 < 123 ? t15 - 97 : Hn;
};
var M2 = function(t15, e) {
  return t15 + 22 + 75 * (t15 < 26) - ((e != 0) << 5);
};
var $x = function(t15, e, r) {
  let n = 0;
  for (t15 = r ? Un(t15 / PM) : t15 >> 1, t15 += Un(t15 / e); t15 > Rd * Ml >> 1; n += Hn)
    t15 = Un(t15 / Rd);
  return Un(n + (Rd + 1) * t15 / (t15 + RM));
};
var Ex = function(t15) {
  const e = [], r = t15.length;
  let n = 0, i = _x, s = Cx, a = t15.lastIndexOf(Sx);
  a < 0 && (a = 0);
  for (let o = 0; o < a; ++o)
    t15.charCodeAt(o) >= 128 && Vi("not-basic"), e.push(t15.charCodeAt(o));
  for (let o = a > 0 ? a + 1 : 0; o < r; ) {
    const l = n;
    for (let h = 1, p = Hn; ; p += Hn) {
      o >= r && Vi("invalid-input");
      const m = XM(t15.charCodeAt(o++));
      m >= Hn && Vi("invalid-input"), m > Un((Da - n) / h) && Vi("overflow"), n += m * h;
      const g = p <= s ? X1 : p >= s + Ml ? Ml : p - s;
      if (m < g)
        break;
      const y = Hn - g;
      h > Un(Da / y) && Vi("overflow"), h *= y;
    }
    const c = e.length + 1;
    s = $x(n - l, c, l == 0), Un(n / c) > Da - i && Vi("overflow"), i += Un(n / c), n %= c, e.splice(n++, 0, i);
  }
  return String.fromCodePoint(...e);
};
var Mx = function(t15) {
  const e = [];
  t15 = Tx(t15);
  const r = t15.length;
  let n = _x, i = 0, s = Cx;
  for (const l of t15)
    l < 128 && e.push(Pd(l));
  const a = e.length;
  let o = a;
  for (a && e.push(Sx); o < r; ) {
    let l = Da;
    for (const h of t15)
      h >= n && h < l && (l = h);
    const c = o + 1;
    l - n > Un((Da - i) / c) && Vi("overflow"), i += (l - n) * c, n = l;
    for (const h of t15)
      if (h < n && ++i > Da && Vi("overflow"), h === n) {
        let p = i;
        for (let m = Hn; ; m += Hn) {
          const g = m <= s ? X1 : m >= s + Ml ? Ml : m - s;
          if (p < g)
            break;
          const y = p - g, x = Hn - g;
          e.push(
            Pd(M2(g + y % x, 0))
          ), p = Un(y / x);
        }
        e.push(Pd(M2(p, 0))), s = $x(i, c, o === a), i = 0, ++o;
      }
    ++i, ++n;
  }
  return e.join("");
};
var YM = function(t15) {
  return Ax(t15, function(e) {
    return jM.test(e) ? Ex(e.slice(4).toLowerCase()) : e;
  });
};
var KM = function(t15) {
  return Ax(t15, function(e) {
    return WM.test(e) ? "xn--" + Mx(e) : e;
  });
};
var Bx = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: Tx,
    encode: GM
  },
  decode: Ex,
  encode: Mx,
  toASCII: KM,
  toUnicode: YM
};
var ZM = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var JM = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
var QM = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
var tB = {
  default: ZM,
  zero: JM,
  commonmark: QM
};
var eB = /^(vbscript|javascript|file|data):/;
var rB = /^data:image\/(gif|png|jpeg|webp);/;
function nB(t15) {
  const e = t15.trim().toLowerCase();
  return eB.test(e) ? rB.test(e) : true;
}
var Lx = ["http:", "https:", "mailto:"];
function iB(t15) {
  const e = j1(t15, true);
  if (e.hostname && (!e.protocol || Lx.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Bx.toASCII(e.hostname);
    } catch {
    }
  return Jl(P1(e));
}
function sB(t15) {
  const e = j1(t15, true);
  if (e.hostname && (!e.protocol || Lx.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Bx.toUnicode(e.hostname);
    } catch {
    }
  return Wa(P1(e), Wa.defaultChars + "%");
}
function mn(t15, e) {
  if (!(this instanceof mn))
    return new mn(t15, e);
  e || H1(t15) || (e = t15 || {}, t15 = "default"), this.inline = new tc(), this.block = new nu(), this.core = new V1(), this.renderer = new lo(), this.linkify = new Qr(), this.validateLink = nB, this.normalizeLink = iB, this.normalizeLinkText = sB, this.utils = oE, this.helpers = eu({}, uE), this.options = {}, this.configure(t15), e && this.set(e);
}
mn.prototype.set = function(t15) {
  return eu(this.options, t15), this;
};
mn.prototype.configure = function(t15) {
  const e = this;
  if (H1(t15)) {
    const r = t15;
    if (t15 = tB[r], !t15)
      throw new Error('Wrong `markdown-it` preset "' + r + '", check name');
  }
  if (!t15)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return t15.options && e.set(t15.options), t15.components && Object.keys(t15.components).forEach(function(r) {
    t15.components[r].rules && e[r].ruler.enableOnly(t15.components[r].rules), t15.components[r].rules2 && e[r].ruler2.enableOnly(t15.components[r].rules2);
  }), this;
};
mn.prototype.enable = function(t15, e) {
  let r = [];
  Array.isArray(t15) || (t15 = [t15]), ["core", "block", "inline"].forEach(function(i) {
    r = r.concat(this[i].ruler.enable(t15, true));
  }, this), r = r.concat(this.inline.ruler2.enable(t15, true));
  const n = t15.filter(function(i) {
    return r.indexOf(i) < 0;
  });
  if (n.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + n);
  return this;
};
mn.prototype.disable = function(t15, e) {
  let r = [];
  Array.isArray(t15) || (t15 = [t15]), ["core", "block", "inline"].forEach(function(i) {
    r = r.concat(this[i].ruler.disable(t15, true));
  }, this), r = r.concat(this.inline.ruler2.disable(t15, true));
  const n = t15.filter(function(i) {
    return r.indexOf(i) < 0;
  });
  if (n.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + n);
  return this;
};
mn.prototype.use = function(t15) {
  const e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t15.apply(t15, e), this;
};
mn.prototype.parse = function(t15, e) {
  if (typeof t15 != "string")
    throw new Error("Input data should be a String");
  const r = new this.core.State(t15, this, e);
  return this.core.process(r), r.tokens;
};
mn.prototype.render = function(t15, e) {
  return e = e || {}, this.renderer.render(this.parse(t15, e), this.options, e);
};
mn.prototype.parseInline = function(t15, e) {
  const r = new this.core.State(t15, this, e);
  return r.inlineMode = true, this.core.process(r), r.tokens;
};
mn.prototype.renderInline = function(t15, e) {
  return e = e || {}, this.renderer.render(this.parseInline(t15, e), this.options, e);
};
function aB(t15) {
  function e(n, i) {
    const s = n.pos, a = n.src.charCodeAt(s);
    if (i || a !== 43)
      return false;
    const o = n.scanDelims(n.pos, true);
    let l = o.length;
    const c = String.fromCharCode(a);
    if (l < 2)
      return false;
    if (l % 2) {
      const h = n.push("text", "", 0);
      h.content = c, l--;
    }
    for (let h = 0; h < l; h += 2) {
      const p = n.push("text", "", 0);
      p.content = c + c, !(!o.can_open && !o.can_close) && n.delimiters.push({
        marker: a,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: h / 2,
        // 1 delimiter = 2 characters
        token: n.tokens.length - 1,
        end: -1,
        open: o.can_open,
        close: o.can_close
      });
    }
    return n.pos += o.length, true;
  }
  function r(n, i) {
    let s;
    const a = [], o = i.length;
    for (let l = 0; l < o; l++) {
      const c = i[l];
      if (c.marker !== 43 || c.end === -1)
        continue;
      const h = i[c.end];
      s = n.tokens[c.token], s.type = "ins_open", s.tag = "ins", s.nesting = 1, s.markup = "++", s.content = "", s = n.tokens[h.token], s.type = "ins_close", s.tag = "ins", s.nesting = -1, s.markup = "++", s.content = "", n.tokens[h.token - 1].type === "text" && n.tokens[h.token - 1].content === "+" && a.push(h.token - 1);
    }
    for (; a.length; ) {
      const l = a.pop();
      let c = l + 1;
      for (; c < n.tokens.length && n.tokens[c].type === "ins_close"; )
        c++;
      c--, l !== c && (s = n.tokens[c], n.tokens[c] = n.tokens[l], n.tokens[l] = s);
    }
  }
  t15.inline.ruler.before("emphasis", "ins", e), t15.inline.ruler2.before("emphasis", "ins", function(n) {
    const i = n.tokens_meta, s = (n.tokens_meta || []).length;
    r(n, n.delimiters);
    for (let a = 0; a < s; a++)
      i[a] && i[a].delimiters && r(n, i[a].delimiters);
  });
}
function oB(t15) {
  function e(n, i) {
    const s = n.pos, a = n.src.charCodeAt(s);
    if (i || a !== 61)
      return false;
    const o = n.scanDelims(n.pos, true);
    let l = o.length;
    const c = String.fromCharCode(a);
    if (l < 2)
      return false;
    if (l % 2) {
      const h = n.push("text", "", 0);
      h.content = c, l--;
    }
    for (let h = 0; h < l; h += 2) {
      const p = n.push("text", "", 0);
      p.content = c + c, !(!o.can_open && !o.can_close) && n.delimiters.push({
        marker: a,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: h / 2,
        // 1 delimiter = 2 characters
        token: n.tokens.length - 1,
        end: -1,
        open: o.can_open,
        close: o.can_close
      });
    }
    return n.pos += o.length, true;
  }
  function r(n, i) {
    const s = [], a = i.length;
    for (let o = 0; o < a; o++) {
      const l = i[o];
      if (l.marker !== 61 || l.end === -1)
        continue;
      const c = i[l.end], h = n.tokens[l.token];
      h.type = "mark_open", h.tag = "mark", h.nesting = 1, h.markup = "==", h.content = "";
      const p = n.tokens[c.token];
      p.type = "mark_close", p.tag = "mark", p.nesting = -1, p.markup = "==", p.content = "", n.tokens[c.token - 1].type === "text" && n.tokens[c.token - 1].content === "=" && s.push(c.token - 1);
    }
    for (; s.length; ) {
      const o = s.pop();
      let l = o + 1;
      for (; l < n.tokens.length && n.tokens[l].type === "mark_close"; )
        l++;
      if (l--, o !== l) {
        const c = n.tokens[l];
        n.tokens[l] = n.tokens[o], n.tokens[o] = c;
      }
    }
  }
  t15.inline.ruler.before("emphasis", "mark", e), t15.inline.ruler2.before("emphasis", "mark", function(n) {
    let i;
    const s = n.tokens_meta, a = (n.tokens_meta || []).length;
    for (r(n, n.delimiters), i = 0; i < a; i++)
      s[i] && s[i].delimiters && r(n, s[i].delimiters);
  });
}
var lB = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function cB(t15, e) {
  const r = t15.posMax, n = t15.pos;
  if (t15.src.charCodeAt(n) !== 126 || e || n + 2 >= r)
    return false;
  t15.pos = n + 1;
  let i = false;
  for (; t15.pos < r; ) {
    if (t15.src.charCodeAt(t15.pos) === 126) {
      i = true;
      break;
    }
    t15.md.inline.skipToken(t15);
  }
  if (!i || n + 1 === t15.pos)
    return t15.pos = n, false;
  const s = t15.src.slice(n + 1, t15.pos);
  if (s.match(/(^|[^\\])(\\\\)*\s/))
    return t15.pos = n, false;
  t15.posMax = t15.pos, t15.pos = n + 1;
  const a = t15.push("sub_open", "sub", 1);
  a.markup = "~";
  const o = t15.push("text", "", 0);
  o.content = s.replace(lB, "$1");
  const l = t15.push("sub_close", "sub", -1);
  return l.markup = "~", t15.pos = t15.posMax + 1, t15.posMax = r, true;
}
function hB(t15) {
  t15.inline.ruler.after("emphasis", "sub", cB);
}
var uB = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function dB(t15, e) {
  const r = t15.posMax, n = t15.pos;
  if (t15.src.charCodeAt(n) !== 94 || e || n + 2 >= r)
    return false;
  t15.pos = n + 1;
  let i = false;
  for (; t15.pos < r; ) {
    if (t15.src.charCodeAt(t15.pos) === 94) {
      i = true;
      break;
    }
    t15.md.inline.skipToken(t15);
  }
  if (!i || n + 1 === t15.pos)
    return t15.pos = n, false;
  const s = t15.src.slice(n + 1, t15.pos);
  if (s.match(/(^|[^\\])(\\\\)*\s/))
    return t15.pos = n, false;
  t15.posMax = t15.pos, t15.pos = n + 1;
  const a = t15.push("sup_open", "sup", 1);
  a.markup = "^";
  const o = t15.push("text", "", 0);
  o.content = s.replace(uB, "$1");
  const l = t15.push("sup_close", "sup", -1);
  return l.markup = "^", t15.pos = t15.posMax + 1, t15.posMax = r, true;
}
function pB(t15) {
  t15.inline.ruler.after("emphasis", "sup", dB);
}
var Y1 = Symbol.for("yaml.alias");
var Qp = Symbol.for("yaml.document");
var ss = Symbol.for("yaml.map");
var Dx = Symbol.for("yaml.pair");
var Xn = Symbol.for("yaml.scalar");
var co = Symbol.for("yaml.seq");
var gn = Symbol.for("yaml.node.type");
var sa = (t15) => !!t15 && typeof t15 == "object" && t15[gn] === Y1;
var su = (t15) => !!t15 && typeof t15 == "object" && t15[gn] === Qp;
var ec = (t15) => !!t15 && typeof t15 == "object" && t15[gn] === ss;
var We = (t15) => !!t15 && typeof t15 == "object" && t15[gn] === Dx;
var Ae = (t15) => !!t15 && typeof t15 == "object" && t15[gn] === Xn;
var rc = (t15) => !!t15 && typeof t15 == "object" && t15[gn] === co;
function Re(t15) {
  if (t15 && typeof t15 == "object")
    switch (t15[gn]) {
      case ss:
      case co:
        return true;
    }
  return false;
}
function je(t15) {
  if (t15 && typeof t15 == "object")
    switch (t15[gn]) {
      case Y1:
      case ss:
      case Xn:
      case co:
        return true;
    }
  return false;
}
var Fx = (t15) => (Ae(t15) || Re(t15)) && !!t15.anchor;
var Es = Symbol("break visit");
var fB = Symbol("skip children");
var fl = Symbol("remove node");
function ho(t15, e) {
  const r = mB(e);
  su(t15) ? $a(null, t15.contents, r, Object.freeze([t15])) === fl && (t15.contents = null) : $a(null, t15, r, Object.freeze([]));
}
ho.BREAK = Es;
ho.SKIP = fB;
ho.REMOVE = fl;
function $a(t15, e, r, n) {
  const i = gB(t15, e, r, n);
  if (je(i) || We(i))
    return yB(t15, n, i), $a(t15, i, r, n);
  if (typeof i != "symbol") {
    if (Re(e)) {
      n = Object.freeze(n.concat(e));
      for (let s = 0; s < e.items.length; ++s) {
        const a = $a(s, e.items[s], r, n);
        if (typeof a == "number")
          s = a - 1;
        else {
          if (a === Es)
            return Es;
          a === fl && (e.items.splice(s, 1), s -= 1);
        }
      }
    } else if (We(e)) {
      n = Object.freeze(n.concat(e));
      const s = $a("key", e.key, r, n);
      if (s === Es)
        return Es;
      s === fl && (e.key = null);
      const a = $a("value", e.value, r, n);
      if (a === Es)
        return Es;
      a === fl && (e.value = null);
    }
  }
  return i;
}
function mB(t15) {
  return typeof t15 == "object" && (t15.Collection || t15.Node || t15.Value) ? Object.assign({
    Alias: t15.Node,
    Map: t15.Node,
    Scalar: t15.Node,
    Seq: t15.Node
  }, t15.Value && {
    Map: t15.Value,
    Scalar: t15.Value,
    Seq: t15.Value
  }, t15.Collection && {
    Map: t15.Collection,
    Seq: t15.Collection
  }, t15) : t15;
}
function gB(t15, e, r, n) {
  var _a3, _b2, _c, _d, _e;
  if (typeof r == "function")
    return r(t15, e, n);
  if (ec(e))
    return (_a3 = r.Map) == null ? void 0 : _a3.call(r, t15, e, n);
  if (rc(e))
    return (_b2 = r.Seq) == null ? void 0 : _b2.call(r, t15, e, n);
  if (We(e))
    return (_c = r.Pair) == null ? void 0 : _c.call(r, t15, e, n);
  if (Ae(e))
    return (_d = r.Scalar) == null ? void 0 : _d.call(r, t15, e, n);
  if (sa(e))
    return (_e = r.Alias) == null ? void 0 : _e.call(r, t15, e, n);
}
function yB(t15, e, r) {
  const n = e[e.length - 1];
  if (Re(n))
    n.items[t15] = r;
  else if (We(n))
    t15 === "key" ? n.key = r : n.value = r;
  else if (su(n))
    n.contents = r;
  else {
    const i = sa(n) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${i} parent`);
  }
}
var bB = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var xB = (t15) => t15.replace(/[!,[\]{}]/g, (e) => bB[e]);
var Fa = class yi {
  constructor(e, r) {
    this.docStart = null, this.docEnd = false, this.yaml = Object.assign({}, yi.defaultYaml, e), this.tags = Object.assign({}, yi.defaultTags, r);
  }
  clone() {
    const e = new yi(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new yi(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false, this.yaml = {
          explicit: yi.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, yi.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, r) {
    this.atNextDocument && (this.yaml = { explicit: yi.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, yi.defaultTags), this.atNextDocument = false);
    const n = e.trim().split(/[ \t]+/), i = n.shift();
    switch (i) {
      case "%TAG": {
        if (n.length !== 2 && (r(0, "%TAG directive should contain exactly two parts"), n.length < 2))
          return false;
        const [s, a] = n;
        return this.tags[s] = a, true;
      }
      case "%YAML": {
        if (this.yaml.explicit = true, n.length !== 1)
          return r(0, "%YAML directive should contain exactly one part"), false;
        const [s] = n;
        if (s === "1.1" || s === "1.2")
          return this.yaml.version = s, true;
        {
          const a = /^\d+\.\d+$/.test(s);
          return r(6, `Unsupported YAML version ${s}`, a), false;
        }
      }
      default:
        return r(0, `Unknown directive ${i}`, true), false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, r) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return r(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const a = e.slice(2, -1);
      return a === "!" || a === "!!" ? (r(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && r("Verbatim tags must end with a >"), a);
    }
    const [, n, i] = e.match(/^(.*!)([^!]*)$/s);
    i || r(`The ${e} tag has no suffix`);
    const s = this.tags[n];
    if (s)
      try {
        return s + decodeURIComponent(i);
      } catch (a) {
        return r(String(a)), null;
      }
    return n === "!" ? e : (r(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [r, n] of Object.entries(this.tags))
      if (e.startsWith(n))
        return r + xB(e.substring(n.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const r = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n = Object.entries(this.tags);
    let i;
    if (e && n.length > 0 && je(e.contents)) {
      const s = {};
      ho(e.contents, (a, o) => {
        je(o) && o.tag && (s[o.tag] = true);
      }), i = Object.keys(s);
    } else
      i = [];
    for (const [s, a] of n)
      s === "!!" && a === "tag:yaml.org,2002:" || (!e || i.some((o) => o.startsWith(a))) && r.push(`%TAG ${s} ${a}`);
    return r.join(`
`);
  }
};
Fa.defaultYaml = { explicit: false, version: "1.2" };
Fa.defaultTags = { "!!": "tag:yaml.org,2002:" };
function Nx(t15) {
  if (/[\x00-\x19\s,[\]{}]/.test(t15)) {
    const e = `Anchor must not contain whitespace or control characters: ${JSON.stringify(t15)}`;
    throw new Error(e);
  }
  return true;
}
function Ix(t15) {
  const e = /* @__PURE__ */ new Set();
  return ho(t15, {
    Value(r, n) {
      n.anchor && e.add(n.anchor);
    }
  }), e;
}
function Ox(t15, e) {
  for (let r = 1; ; ++r) {
    const n = `${t15}${r}`;
    if (!e.has(n))
      return n;
  }
}
function wB(t15, e) {
  const r = [], n = /* @__PURE__ */ new Map();
  let i = null;
  return {
    onAnchor: (s) => {
      r.push(s), i ?? (i = Ix(t15));
      const a = Ox(e, i);
      return i.add(a), a;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const s of r) {
        const a = n.get(s);
        if (typeof a == "object" && a.anchor && (Ae(a.node) || Re(a.node)))
          a.node.anchor = a.anchor;
        else {
          const o = new Error("Failed to resolve repeated object (this should not happen)");
          throw o.source = s, o;
        }
      }
    },
    sourceObjects: n
  };
}
function Ea(t15, e, r, n) {
  if (n && typeof n == "object")
    if (Array.isArray(n))
      for (let i = 0, s = n.length; i < s; ++i) {
        const a = n[i], o = Ea(t15, n, String(i), a);
        o === void 0 ? delete n[i] : o !== a && (n[i] = o);
      }
    else if (n instanceof Map)
      for (const i of Array.from(n.keys())) {
        const s = n.get(i), a = Ea(t15, n, i, s);
        a === void 0 ? n.delete(i) : a !== s && n.set(i, a);
      }
    else if (n instanceof Set)
      for (const i of Array.from(n)) {
        const s = Ea(t15, n, i, i);
        s === void 0 ? n.delete(i) : s !== i && (n.delete(i), n.add(s));
      }
    else
      for (const [i, s] of Object.entries(n)) {
        const a = Ea(t15, n, i, s);
        a === void 0 ? delete n[i] : a !== s && (n[i] = a);
      }
  return t15.call(e, r, n);
}
function fn(t15, e, r) {
  if (Array.isArray(t15))
    return t15.map((n, i) => fn(n, String(i), r));
  if (t15 && typeof t15.toJSON == "function") {
    if (!r || !Fx(t15))
      return t15.toJSON(e, r);
    const n = { aliasCount: 0, count: 1, res: void 0 };
    r.anchors.set(t15, n), r.onCreate = (s) => {
      n.res = s, delete r.onCreate;
    };
    const i = t15.toJSON(e, r);
    return r.onCreate && r.onCreate(i), i;
  }
  return typeof t15 == "bigint" && !(r == null ? void 0 : r.keep) ? Number(t15) : t15;
}
var K1 = class {
  constructor(e) {
    Object.defineProperty(this, gn, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: r, maxAliasCount: n, onAnchor: i, reviver: s } = {}) {
    if (!su(e))
      throw new TypeError("A document argument is required");
    const a = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: true,
      mapAsMap: r === true,
      mapKeyWarned: false,
      maxAliasCount: typeof n == "number" ? n : 100
    }, o = fn(this, "", a);
    if (typeof i == "function")
      for (const { count: l, res: c } of a.anchors.values())
        i(c, l);
    return typeof s == "function" ? Ea(s, { "": o }, "", o) : o;
  }
};
var Z1 = class extends K1 {
  constructor(e) {
    super(Y1), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e, r) {
    let n;
    (r == null ? void 0 : r.aliasResolveCache) ? n = r.aliasResolveCache : (n = [], ho(e, {
      Node: (s, a) => {
        (sa(a) || Fx(a)) && n.push(a);
      }
    }), r && (r.aliasResolveCache = n));
    let i;
    for (const s of n) {
      if (s === this)
        break;
      s.anchor === this.source && (i = s);
    }
    return i;
  }
  toJSON(e, r) {
    if (!r)
      return { source: this.source };
    const { anchors: n, doc: i, maxAliasCount: s } = r, a = this.resolve(i, r);
    if (!a) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let o = n.get(a);
    if (o || (fn(a, null, r), o = n.get(a)), !o || o.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (s >= 0 && (o.count += 1, o.aliasCount === 0 && (o.aliasCount = bh(i, a, n)), o.count * o.aliasCount > s)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return o.res;
  }
  toString(e, r, n) {
    const i = `*${this.source}`;
    if (e) {
      if (Nx(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const s = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(s);
      }
      if (e.implicitKey)
        return `${i} `;
    }
    return i;
  }
};
function bh(t15, e, r) {
  if (sa(e)) {
    const n = e.resolve(t15), i = r && n && r.get(n);
    return i ? i.count * i.aliasCount : 0;
  } else if (Re(e)) {
    let n = 0;
    for (const i of e.items) {
      const s = bh(t15, i, r);
      s > n && (n = s);
    }
    return n;
  } else if (We(e)) {
    const n = bh(t15, e.key, r), i = bh(t15, e.value, r);
    return Math.max(n, i);
  }
  return 1;
}
var zx = (t15) => !t15 || typeof t15 != "function" && typeof t15 != "object";
var Kt = class extends K1 {
  constructor(e) {
    super(Xn), this.value = e;
  }
  toJSON(e, r) {
    return (r == null ? void 0 : r.keep) ? this.value : fn(this.value, e, r);
  }
  toString() {
    return String(this.value);
  }
};
Kt.BLOCK_FOLDED = "BLOCK_FOLDED";
Kt.BLOCK_LITERAL = "BLOCK_LITERAL";
Kt.PLAIN = "PLAIN";
Kt.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Kt.QUOTE_SINGLE = "QUOTE_SINGLE";
var kB = "tag:yaml.org,2002:";
function vB(t15, e, r) {
  if (e) {
    const n = r.filter((s) => s.tag === e), i = n.find((s) => !s.format) ?? n[0];
    if (!i)
      throw new Error(`Tag ${e} not found`);
    return i;
  }
  return r.find((n) => {
    var _a3;
    return ((_a3 = n.identify) == null ? void 0 : _a3.call(n, t15)) && !n.format;
  });
}
function Bl(t15, e, r) {
  var _a3, _b2, _c;
  if (su(t15) && (t15 = t15.contents), je(t15))
    return t15;
  if (We(t15)) {
    const p = (_b2 = (_a3 = r.schema[ss]).createNode) == null ? void 0 : _b2.call(_a3, r.schema, null, r);
    return p.items.push(t15), p;
  }
  (t15 instanceof String || t15 instanceof Number || t15 instanceof Boolean || typeof BigInt < "u" && t15 instanceof BigInt) && (t15 = t15.valueOf());
  const { aliasDuplicateObjects: n, onAnchor: i, onTagObj: s, schema: a, sourceObjects: o } = r;
  let l;
  if (n && t15 && typeof t15 == "object") {
    if (l = o.get(t15), l)
      return l.anchor ?? (l.anchor = i(t15)), new Z1(l.anchor);
    l = { anchor: null, node: null }, o.set(t15, l);
  }
  (e == null ? void 0 : e.startsWith("!!")) && (e = kB + e.slice(2));
  let c = vB(t15, e, a.tags);
  if (!c) {
    if (t15 && typeof t15.toJSON == "function" && (t15 = t15.toJSON()), !t15 || typeof t15 != "object") {
      const p = new Kt(t15);
      return l && (l.node = p), p;
    }
    c = t15 instanceof Map ? a[ss] : Symbol.iterator in Object(t15) ? a[co] : a[ss];
  }
  s && (s(c), delete r.onTagObj);
  const h = (c == null ? void 0 : c.createNode) ? c.createNode(r.schema, t15, r) : typeof ((_c = c == null ? void 0 : c.nodeClass) == null ? void 0 : _c.from) == "function" ? c.nodeClass.from(r.schema, t15, r) : new Kt(t15);
  return e ? h.tag = e : c.default || (h.tag = c.tag), l && (l.node = h), h;
}
function i0(t15, e, r) {
  let n = r;
  for (let i = e.length - 1; i >= 0; --i) {
    const s = e[i];
    if (typeof s == "number" && Number.isInteger(s) && s >= 0) {
      const a = [];
      a[s] = n, n = a;
    } else
      n = /* @__PURE__ */ new Map([[s, n]]);
  }
  return Bl(n, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: t15,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var Qo = (t15) => t15 == null || typeof t15 == "object" && !!t15[Symbol.iterator]().next().done;
var qx = class extends K1 {
  constructor(e, r) {
    super(e), Object.defineProperty(this, "schema", {
      value: r,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const r = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (r.schema = e), r.items = r.items.map((n) => je(n) || We(n) ? n.clone(e) : n), this.range && (r.range = this.range.slice()), r;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, r) {
    if (Qo(e))
      this.add(r);
    else {
      const [n, ...i] = e, s = this.get(n, true);
      if (Re(s))
        s.addIn(i, r);
      else if (s === void 0 && this.schema)
        this.set(n, i0(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.delete(r);
    const i = this.get(r, true);
    if (Re(i))
      return i.deleteIn(n);
    throw new Error(`Expected YAML collection at ${r}. Remaining path: ${n}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    const [n, ...i] = e, s = this.get(n, true);
    return i.length === 0 ? !r && Ae(s) ? s.value : s : Re(s) ? s.getIn(i, r) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((r) => {
      if (!We(r))
        return false;
      const n = r.value;
      return n == null || e && Ae(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.has(r);
    const i = this.get(r, true);
    return Re(i) ? i.hasIn(n) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    const [n, ...i] = e;
    if (i.length === 0)
      this.set(n, r);
    else {
      const s = this.get(n, true);
      if (Re(s))
        s.setIn(i, r);
      else if (s === void 0 && this.schema)
        this.set(n, i0(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
};
var CB = (t15) => t15.replace(/^(?!$)(?: $)?/gm, "#");
function ki(t15, e) {
  return /^\n+$/.test(t15) ? t15.substring(1) : e ? t15.replace(/^(?! *$)/gm, e) : t15;
}
var Ns = (t15, e, r) => t15.endsWith(`
`) ? ki(r, e) : r.includes(`
`) ? `
` + ki(r, e) : (t15.endsWith(" ") ? "" : " ") + r;
var Rx = "flow";
var tf = "block";
var xh = "quoted";
function au(t15, e, r = "flow", { indentAtStart: n, lineWidth: i = 80, minContentWidth: s = 20, onFold: a, onOverflow: o } = {}) {
  if (!i || i < 0)
    return t15;
  i < s && (s = 0);
  const l = Math.max(1 + s, 1 + i - e.length);
  if (t15.length <= l)
    return t15;
  const c = [], h = {};
  let p = i - e.length;
  typeof n == "number" && (n > i - Math.max(2, s) ? c.push(0) : p = i - n);
  let m, g, y = false, x = -1, k = -1, C = -1;
  r === tf && (x = B2(t15, x, e.length), x !== -1 && (p = x + l));
  for (let $; $ = t15[x += 1]; ) {
    if (r === xh && $ === "\\") {
      switch (k = x, t15[x + 1]) {
        case "x":
          x += 3;
          break;
        case "u":
          x += 5;
          break;
        case "U":
          x += 9;
          break;
        default:
          x += 1;
      }
      C = x;
    }
    if ($ === `
`)
      r === tf && (x = B2(t15, x, e.length)), p = x + e.length + l, m = void 0;
    else {
      if ($ === " " && g && g !== " " && g !== `
` && g !== "	") {
        const B = t15[x + 1];
        B && B !== " " && B !== `
` && B !== "	" && (m = x);
      }
      if (x >= p)
        if (m)
          c.push(m), p = m + l, m = void 0;
        else if (r === xh) {
          for (; g === " " || g === "	"; )
            g = $, $ = t15[x += 1], y = true;
          const B = x > C + 1 ? x - 2 : k - 1;
          if (h[B])
            return t15;
          c.push(B), h[B] = true, p = B + l, m = void 0;
        } else
          y = true;
    }
    g = $;
  }
  if (y && o && o(), c.length === 0)
    return t15;
  a && a();
  let A = t15.slice(0, c[0]);
  for (let $ = 0; $ < c.length; ++$) {
    const B = c[$], L = c[$ + 1] || t15.length;
    B === 0 ? A = `
${e}${t15.slice(0, L)}` : (r === xh && h[B] && (A += `${t15[B]}\\`), A += `
${e}${t15.slice(B + 1, L)}`);
  }
  return A;
}
function B2(t15, e, r) {
  let n = e, i = e + 1, s = t15[i];
  for (; s === " " || s === "	"; )
    if (e < i + r)
      s = t15[++e];
    else {
      do
        s = t15[++e];
      while (s && s !== `
`);
      n = e, i = e + 1, s = t15[i];
    }
  return n;
}
var ou = (t15, e) => ({
  indentAtStart: e ? t15.indent.length : t15.indentAtStart,
  lineWidth: t15.options.lineWidth,
  minContentWidth: t15.options.minContentWidth
});
var lu = (t15) => /^(%|---|\.\.\.)/m.test(t15);
function _B(t15, e, r) {
  if (!e || e < 0)
    return false;
  const n = e - r, i = t15.length;
  if (i <= n)
    return false;
  for (let s = 0, a = 0; s < i; ++s)
    if (t15[s] === `
`) {
      if (s - a > n)
        return true;
      if (a = s + 1, i - a <= n)
        return false;
    }
  return true;
}
function ml(t15, e) {
  const r = JSON.stringify(t15);
  if (e.options.doubleQuotedAsJSON)
    return r;
  const { implicitKey: n } = e, i = e.options.doubleQuotedMinMultiLineLength, s = e.indent || (lu(t15) ? "  " : "");
  let a = "", o = 0;
  for (let l = 0, c = r[l]; c; c = r[++l])
    if (c === " " && r[l + 1] === "\\" && r[l + 2] === "n" && (a += r.slice(o, l) + "\\ ", l += 1, o = l, c = "\\"), c === "\\")
      switch (r[l + 1]) {
        case "u":
          {
            a += r.slice(o, l);
            const h = r.substr(l + 2, 4);
            switch (h) {
              case "0000":
                a += "\\0";
                break;
              case "0007":
                a += "\\a";
                break;
              case "000b":
                a += "\\v";
                break;
              case "001b":
                a += "\\e";
                break;
              case "0085":
                a += "\\N";
                break;
              case "00a0":
                a += "\\_";
                break;
              case "2028":
                a += "\\L";
                break;
              case "2029":
                a += "\\P";
                break;
              default:
                h.substr(0, 2) === "00" ? a += "\\x" + h.substr(2) : a += r.substr(l, 6);
            }
            l += 5, o = l + 1;
          }
          break;
        case "n":
          if (n || r[l + 2] === '"' || r.length < i)
            l += 1;
          else {
            for (a += r.slice(o, l) + `

`; r[l + 2] === "\\" && r[l + 3] === "n" && r[l + 4] !== '"'; )
              a += `
`, l += 2;
            a += s, r[l + 2] === " " && (a += "\\"), l += 1, o = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return a = o ? a + r.slice(o) : r, n ? a : au(a, s, xh, ou(e, false));
}
function ef(t15, e) {
  if (e.options.singleQuote === false || e.implicitKey && t15.includes(`
`) || /[ \t]\n|\n[ \t]/.test(t15))
    return ml(t15, e);
  const r = e.indent || (lu(t15) ? "  " : ""), n = "'" + t15.replace(/'/g, "''").replace(/\n+/g, `$&
${r}`) + "'";
  return e.implicitKey ? n : au(n, r, Rx, ou(e, false));
}
function Ma(t15, e) {
  const { singleQuote: r } = e.options;
  let n;
  if (r === false)
    n = ml;
  else {
    const i = t15.includes('"'), s = t15.includes("'");
    i && !s ? n = ef : s && !i ? n = ml : n = r ? ef : ml;
  }
  return n(t15, e);
}
var rf;
try {
  rf = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  rf = /\n+(?!\n|$)/g;
}
function wh({ comment: t15, type: e, value: r }, n, i, s) {
  const { blockQuote: a, commentString: o, lineWidth: l } = n.options;
  if (!a || /\n[\t ]+$/.test(r) || /^\s*$/.test(r))
    return Ma(r, n);
  const c = n.indent || (n.forceBlockIndent || lu(r) ? "  " : ""), h = a === "literal" ? true : a === "folded" || e === Kt.BLOCK_FOLDED ? false : e === Kt.BLOCK_LITERAL ? true : !_B(r, l, c.length);
  if (!r)
    return h ? `|
` : `>
`;
  let p, m;
  for (m = r.length; m > 0; --m) {
    const B = r[m - 1];
    if (B !== `
` && B !== "	" && B !== " ")
      break;
  }
  let g = r.substring(m);
  const y = g.indexOf(`
`);
  y === -1 ? p = "-" : r === g || y !== g.length - 1 ? (p = "+", s && s()) : p = "", g && (r = r.slice(0, -g.length), g[g.length - 1] === `
` && (g = g.slice(0, -1)), g = g.replace(rf, `$&${c}`));
  let x = false, k, C = -1;
  for (k = 0; k < r.length; ++k) {
    const B = r[k];
    if (B === " ")
      x = true;
    else if (B === `
`)
      C = k;
    else
      break;
  }
  let A = r.substring(0, C < k ? C + 1 : k);
  A && (r = r.substring(A.length), A = A.replace(/\n+/g, `$&${c}`));
  let $ = (x ? c ? "2" : "1" : "") + p;
  if (t15 && ($ += " " + o(t15.replace(/ ?[\r\n]+/g, " ")), i && i()), !h) {
    const B = r.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`);
    let L = false;
    const q = ou(n, true);
    a !== "folded" && e !== Kt.BLOCK_FOLDED && (q.onOverflow = () => {
      L = true;
    });
    const U = au(`${A}${B}${g}`, c, tf, q);
    if (!L)
      return `>${$}
${c}${U}`;
  }
  return r = r.replace(/\n+/g, `$&${c}`), `|${$}
${c}${A}${r}${g}`;
}
function SB(t15, e, r, n) {
  const { type: i, value: s } = t15, { actualString: a, implicitKey: o, indent: l, indentStep: c, inFlow: h } = e;
  if (o && s.includes(`
`) || h && /[[\]{},]/.test(s))
    return Ma(s, e);
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(s))
    return o || h || !s.includes(`
`) ? Ma(s, e) : wh(t15, e, r, n);
  if (!o && !h && i !== Kt.PLAIN && s.includes(`
`))
    return wh(t15, e, r, n);
  if (lu(s)) {
    if (l === "")
      return e.forceBlockIndent = true, wh(t15, e, r, n);
    if (o && l === c)
      return Ma(s, e);
  }
  const p = s.replace(/\n+/g, `$&
${l}`);
  if (a) {
    const m = (x) => {
      var _a3;
      return x.default && x.tag !== "tag:yaml.org,2002:str" && ((_a3 = x.test) == null ? void 0 : _a3.test(p));
    }, { compat: g, tags: y } = e.doc.schema;
    if (y.some(m) || (g == null ? void 0 : g.some(m)))
      return Ma(s, e);
  }
  return o ? p : au(p, l, Rx, ou(e, false));
}
function J1(t15, e, r, n) {
  const { implicitKey: i, inFlow: s } = e, a = typeof t15.value == "string" ? t15 : Object.assign({}, t15, { value: String(t15.value) });
  let { type: o } = t15;
  o !== Kt.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(a.value) && (o = Kt.QUOTE_DOUBLE);
  const l = (h) => {
    switch (h) {
      case Kt.BLOCK_FOLDED:
      case Kt.BLOCK_LITERAL:
        return i || s ? Ma(a.value, e) : wh(a, e, r, n);
      case Kt.QUOTE_DOUBLE:
        return ml(a.value, e);
      case Kt.QUOTE_SINGLE:
        return ef(a.value, e);
      case Kt.PLAIN:
        return SB(a, e, r, n);
      default:
        return null;
    }
  };
  let c = l(o);
  if (c === null) {
    const { defaultKeyType: h, defaultStringType: p } = e.options, m = i && h || p;
    if (c = l(m), c === null)
      throw new Error(`Unsupported default string type ${m}`);
  }
  return c;
}
function Px(t15, e) {
  const r = Object.assign({
    blockQuote: true,
    commentString: CB,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, t15.schema.toStringOptions, e);
  let n;
  switch (r.collectionStyle) {
    case "block":
      n = false;
      break;
    case "flow":
      n = true;
      break;
    default:
      n = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: t15,
    flowCollectionPadding: r.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof r.indent == "number" ? " ".repeat(r.indent) : "  ",
    inFlow: n,
    options: r
  };
}
function AB(t15, e) {
  var _a3;
  if (e.tag) {
    const i = t15.filter((s) => s.tag === e.tag);
    if (i.length > 0)
      return i.find((s) => s.format === e.format) ?? i[0];
  }
  let r, n;
  if (Ae(e)) {
    n = e.value;
    let i = t15.filter((s) => {
      var _a4;
      return (_a4 = s.identify) == null ? void 0 : _a4.call(s, n);
    });
    if (i.length > 1) {
      const s = i.filter((a) => a.test);
      s.length > 0 && (i = s);
    }
    r = i.find((s) => s.format === e.format) ?? i.find((s) => !s.format);
  } else
    n = e, r = t15.find((i) => i.nodeClass && n instanceof i.nodeClass);
  if (!r) {
    const i = ((_a3 = n == null ? void 0 : n.constructor) == null ? void 0 : _a3.name) ?? (n === null ? "null" : typeof n);
    throw new Error(`Tag not resolved for ${i} value`);
  }
  return r;
}
function TB(t15, e, { anchors: r, doc: n }) {
  if (!n.directives)
    return "";
  const i = [], s = (Ae(t15) || Re(t15)) && t15.anchor;
  s && Nx(s) && (r.add(s), i.push(`&${s}`));
  const a = t15.tag ?? (e.default ? null : e.tag);
  return a && i.push(n.directives.tagString(a)), i.join(" ");
}
function Ua(t15, e, r, n) {
  var _a3;
  if (We(t15))
    return t15.toString(e, r, n);
  if (sa(t15)) {
    if (e.doc.directives)
      return t15.toString(e);
    if ((_a3 = e.resolvedAliases) == null ? void 0 : _a3.has(t15))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(t15) : e.resolvedAliases = /* @__PURE__ */ new Set([t15]), t15 = t15.resolve(e.doc);
  }
  let i;
  const s = je(t15) ? t15 : e.doc.createNode(t15, { onTagObj: (l) => i = l });
  i ?? (i = AB(e.doc.schema.tags, s));
  const a = TB(s, i, e);
  a.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + a.length + 1);
  const o = typeof i.stringify == "function" ? i.stringify(s, e, r, n) : Ae(s) ? J1(s, e, r, n) : s.toString(e, r, n);
  return a ? Ae(s) || o[0] === "{" || o[0] === "[" ? `${a} ${o}` : `${a}
${e.indent}${o}` : o;
}
function $B({ key: t15, value: e }, r, n, i) {
  const { allNullValues: s, doc: a, indent: o, indentStep: l, options: { commentString: c, indentSeq: h, simpleKeys: p } } = r;
  let m = je(t15) && t15.comment || null;
  if (p) {
    if (m)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (Re(t15) || !je(t15) && typeof t15 == "object") {
      const U = "With simple keys, collection cannot be used as a key value";
      throw new Error(U);
    }
  }
  let g = !p && (!t15 || m && e == null && !r.inFlow || Re(t15) || (Ae(t15) ? t15.type === Kt.BLOCK_FOLDED || t15.type === Kt.BLOCK_LITERAL : typeof t15 == "object"));
  r = Object.assign({}, r, {
    allNullValues: false,
    implicitKey: !g && (p || !s),
    indent: o + l
  });
  let y = false, x = false, k = Ua(t15, r, () => y = true, () => x = true);
  if (!g && !r.inFlow && k.length > 1024) {
    if (p)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    g = true;
  }
  if (r.inFlow) {
    if (s || e == null)
      return y && n && n(), k === "" ? "?" : g ? `? ${k}` : k;
  } else if (s && !p || e == null && g)
    return k = `? ${k}`, m && !y ? k += Ns(k, r.indent, c(m)) : x && i && i(), k;
  y && (m = null), g ? (m && (k += Ns(k, r.indent, c(m))), k = `? ${k}
${o}:`) : (k = `${k}:`, m && (k += Ns(k, r.indent, c(m))));
  let C, A, $;
  je(e) ? (C = !!e.spaceBefore, A = e.commentBefore, $ = e.comment) : (C = false, A = null, $ = null, e && typeof e == "object" && (e = a.createNode(e))), r.implicitKey = false, !g && !m && Ae(e) && (r.indentAtStart = k.length + 1), x = false, !h && l.length >= 2 && !r.inFlow && !g && rc(e) && !e.flow && !e.tag && !e.anchor && (r.indent = r.indent.substring(2));
  let B = false;
  const L = Ua(e, r, () => B = true, () => x = true);
  let q = " ";
  if (m || C || A) {
    if (q = C ? `
` : "", A) {
      const U = c(A);
      q += `
${ki(U, r.indent)}`;
    }
    L === "" && !r.inFlow ? q === `
` && (q = `

`) : q += `
${r.indent}`;
  } else if (!g && Re(e)) {
    const U = L[0], G = L.indexOf(`
`), F = G !== -1, W = r.inFlow ?? e.flow ?? e.items.length === 0;
    if (F || !W) {
      let R = false;
      if (F && (U === "&" || U === "!")) {
        let Q = L.indexOf(" ");
        U === "&" && Q !== -1 && Q < G && L[Q + 1] === "!" && (Q = L.indexOf(" ", Q + 1)), (Q === -1 || G < Q) && (R = true);
      }
      R || (q = `
${r.indent}`);
    }
  } else (L === "" || L[0] === `
`) && (q = "");
  return k += q + L, r.inFlow ? B && n && n() : $ && !B ? k += Ns(k, r.indent, c($)) : x && i && i(), k;
}
function jx(t15, e) {
  (t15 === "debug" || t15 === "warn") && console.warn(e);
}
var Vc = "<<";
var Ai = {
  identify: (t15) => t15 === Vc || typeof t15 == "symbol" && t15.description === Vc,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Kt(Symbol(Vc)), {
    addToJSMap: Wx
  }),
  stringify: () => Vc
};
var EB = (t15, e) => (Ai.identify(e) || Ae(e) && (!e.type || e.type === Kt.PLAIN) && Ai.identify(e.value)) && (t15 == null ? void 0 : t15.doc.schema.tags.some((r) => r.tag === Ai.tag && r.default));
function Wx(t15, e, r) {
  if (r = t15 && sa(r) ? r.resolve(t15.doc) : r, rc(r))
    for (const n of r.items)
      jd(t15, e, n);
  else if (Array.isArray(r))
    for (const n of r)
      jd(t15, e, n);
  else
    jd(t15, e, r);
}
function jd(t15, e, r) {
  const n = t15 && sa(r) ? r.resolve(t15.doc) : r;
  if (!ec(n))
    throw new Error("Merge sources must be maps or map aliases");
  const i = n.toJSON(null, t15, Map);
  for (const [s, a] of i)
    e instanceof Map ? e.has(s) || e.set(s, a) : e instanceof Set ? e.add(s) : Object.prototype.hasOwnProperty.call(e, s) || Object.defineProperty(e, s, {
      value: a,
      writable: true,
      enumerable: true,
      configurable: true
    });
  return e;
}
function Hx(t15, e, { key: r, value: n }) {
  if (je(r) && r.addToJSMap)
    r.addToJSMap(t15, e, n);
  else if (EB(t15, r))
    Wx(t15, e, n);
  else {
    const i = fn(r, "", t15);
    if (e instanceof Map)
      e.set(i, fn(n, i, t15));
    else if (e instanceof Set)
      e.add(i);
    else {
      const s = MB(r, i, t15), a = fn(n, s, t15);
      s in e ? Object.defineProperty(e, s, {
        value: a,
        writable: true,
        enumerable: true,
        configurable: true
      }) : e[s] = a;
    }
  }
  return e;
}
function MB(t15, e, r) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (je(t15) && (r == null ? void 0 : r.doc)) {
    const n = Px(r.doc, {});
    n.anchors = /* @__PURE__ */ new Set();
    for (const s of r.anchors.keys())
      n.anchors.add(s.anchor);
    n.inFlow = true, n.inStringifyKey = true;
    const i = t15.toString(n);
    if (!r.mapKeyWarned) {
      let s = JSON.stringify(i);
      s.length > 40 && (s = s.substring(0, 36) + '..."'), jx(r.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${s}. Set mapAsMap: true to use object keys.`), r.mapKeyWarned = true;
    }
    return i;
  }
  return JSON.stringify(e);
}
function Q1(t15, e, r) {
  const n = Bl(t15, void 0, r), i = Bl(e, void 0, r);
  return new Jr(n, i);
}
var Jr = class Ux {
  constructor(e, r = null) {
    Object.defineProperty(this, gn, { value: Dx }), this.key = e, this.value = r;
  }
  clone(e) {
    let { key: r, value: n } = this;
    return je(r) && (r = r.clone(e)), je(n) && (n = n.clone(e)), new Ux(r, n);
  }
  toJSON(e, r) {
    const n = (r == null ? void 0 : r.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return Hx(r, n, this);
  }
  toString(e, r, n) {
    return (e == null ? void 0 : e.doc) ? $B(this, e, r, n) : JSON.stringify(this);
  }
};
function Vx(t15, e, r) {
  return (e.inFlow ?? t15.flow ? LB : BB)(t15, e, r);
}
function BB({ comment: t15, items: e }, r, { blockItemPrefix: n, flowChars: i, itemIndent: s, onChompKeep: a, onComment: o }) {
  const { indent: l, options: { commentString: c } } = r, h = Object.assign({}, r, { indent: s, type: null });
  let p = false;
  const m = [];
  for (let y = 0; y < e.length; ++y) {
    const x = e[y];
    let k = null;
    if (je(x))
      !p && x.spaceBefore && m.push(""), s0(r, m, x.commentBefore, p), x.comment && (k = x.comment);
    else if (We(x)) {
      const A = je(x.key) ? x.key : null;
      A && (!p && A.spaceBefore && m.push(""), s0(r, m, A.commentBefore, p));
    }
    p = false;
    let C = Ua(x, h, () => k = null, () => p = true);
    k && (C += Ns(C, s, c(k))), p && k && (p = false), m.push(n + C);
  }
  let g;
  if (m.length === 0)
    g = i.start + i.end;
  else {
    g = m[0];
    for (let y = 1; y < m.length; ++y) {
      const x = m[y];
      g += x ? `
${l}${x}` : `
`;
    }
  }
  return t15 ? (g += `
` + ki(c(t15), l), o && o()) : p && a && a(), g;
}
function LB({ items: t15 }, e, { flowChars: r, itemIndent: n }) {
  const { indent: i, indentStep: s, flowCollectionPadding: a, options: { commentString: o } } = e;
  n += s;
  const l = Object.assign({}, e, {
    indent: n,
    inFlow: true,
    type: null
  });
  let c = false, h = 0;
  const p = [];
  for (let y = 0; y < t15.length; ++y) {
    const x = t15[y];
    let k = null;
    if (je(x))
      x.spaceBefore && p.push(""), s0(e, p, x.commentBefore, false), x.comment && (k = x.comment);
    else if (We(x)) {
      const A = je(x.key) ? x.key : null;
      A && (A.spaceBefore && p.push(""), s0(e, p, A.commentBefore, false), A.comment && (c = true));
      const $ = je(x.value) ? x.value : null;
      $ ? ($.comment && (k = $.comment), $.commentBefore && (c = true)) : x.value == null && (A == null ? void 0 : A.comment) && (k = A.comment);
    }
    k && (c = true);
    let C = Ua(x, l, () => k = null);
    y < t15.length - 1 && (C += ","), k && (C += Ns(C, n, o(k))), !c && (p.length > h || C.includes(`
`)) && (c = true), p.push(C), h = p.length;
  }
  const { start: m, end: g } = r;
  if (p.length === 0)
    return m + g;
  if (!c) {
    const y = p.reduce((x, k) => x + k.length + 2, 2);
    c = e.options.lineWidth > 0 && y > e.options.lineWidth;
  }
  if (c) {
    let y = m;
    for (const x of p)
      y += x ? `
${s}${i}${x}` : `
`;
    return `${y}
${i}${g}`;
  } else
    return `${m}${a}${p.join(" ")}${a}${g}`;
}
function s0({ indent: t15, options: { commentString: e } }, r, n, i) {
  if (n && i && (n = n.replace(/^\n+/, "")), n) {
    const s = ki(e(n), t15);
    r.push(s.trimStart());
  }
}
function Is(t15, e) {
  const r = Ae(e) ? e.value : e;
  for (const n of t15)
    if (We(n) && (n.key === e || n.key === r || Ae(n.key) && n.key.value === r))
      return n;
}
var pn = class extends qx {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(ss, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, r, n) {
    const { keepUndefined: i, replacer: s } = n, a = new this(e), o = (l, c) => {
      if (typeof s == "function")
        c = s.call(r, l, c);
      else if (Array.isArray(s) && !s.includes(l))
        return;
      (c !== void 0 || i) && a.items.push(Q1(l, c, n));
    };
    if (r instanceof Map)
      for (const [l, c] of r)
        o(l, c);
    else if (r && typeof r == "object")
      for (const l of Object.keys(r))
        o(l, r[l]);
    return typeof e.sortMapEntries == "function" && a.items.sort(e.sortMapEntries), a;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, r) {
    var _a3;
    let n;
    We(e) ? n = e : !e || typeof e != "object" || !("key" in e) ? n = new Jr(e, e == null ? void 0 : e.value) : n = new Jr(e.key, e.value);
    const i = Is(this.items, n.key), s = (_a3 = this.schema) == null ? void 0 : _a3.sortMapEntries;
    if (i) {
      if (!r)
        throw new Error(`Key ${n.key} already set`);
      Ae(i.value) && zx(n.value) ? i.value.value = n.value : i.value = n.value;
    } else if (s) {
      const a = this.items.findIndex((o) => s(n, o) < 0);
      a === -1 ? this.items.push(n) : this.items.splice(a, 0, n);
    } else
      this.items.push(n);
  }
  delete(e) {
    const r = Is(this.items, e);
    return r ? this.items.splice(this.items.indexOf(r), 1).length > 0 : false;
  }
  get(e, r) {
    var _a3;
    const n = (_a3 = Is(this.items, e)) == null ? void 0 : _a3.value;
    return (!r && Ae(n) ? n.value : n) ?? void 0;
  }
  has(e) {
    return !!Is(this.items, e);
  }
  set(e, r) {
    this.add(new Jr(e, r), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, r, n) {
    const i = n ? new n() : (r == null ? void 0 : r.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    (r == null ? void 0 : r.onCreate) && r.onCreate(i);
    for (const s of this.items)
      Hx(r, i, s);
    return i;
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    for (const i of this.items)
      if (!We(i))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);
    return !e.allNullValues && this.hasAllNullValues(false) && (e = Object.assign({}, e, { allNullValues: true })), Vx(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: n,
      onComment: r
    });
  }
};
var uo = {
  collection: "map",
  default: true,
  nodeClass: pn,
  tag: "tag:yaml.org,2002:map",
  resolve(t15, e) {
    return ec(t15) || e("Expected a mapping for this tag"), t15;
  },
  createNode: (t15, e, r) => pn.from(t15, e, r)
};
var Xs = class extends qx {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(co, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const r = Gc(e);
    return typeof r != "number" ? false : this.items.splice(r, 1).length > 0;
  }
  get(e, r) {
    const n = Gc(e);
    if (typeof n != "number")
      return;
    const i = this.items[n];
    return !r && Ae(i) ? i.value : i;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const r = Gc(e);
    return typeof r == "number" && r < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, r) {
    const n = Gc(e);
    if (typeof n != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const i = this.items[n];
    Ae(i) && zx(r) ? i.value = r : this.items[n] = r;
  }
  toJSON(e, r) {
    const n = [];
    (r == null ? void 0 : r.onCreate) && r.onCreate(n);
    let i = 0;
    for (const s of this.items)
      n.push(fn(s, String(i++), r));
    return n;
  }
  toString(e, r, n) {
    return e ? Vx(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: n,
      onComment: r
    }) : JSON.stringify(this);
  }
  static from(e, r, n) {
    const { replacer: i } = n, s = new this(e);
    if (r && Symbol.iterator in Object(r)) {
      let a = 0;
      for (let o of r) {
        if (typeof i == "function") {
          const l = r instanceof Set ? o : String(a++);
          o = i.call(r, l, o);
        }
        s.items.push(Bl(o, void 0, n));
      }
    }
    return s;
  }
};
function Gc(t15) {
  let e = Ae(t15) ? t15.value : t15;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
var po = {
  collection: "seq",
  default: true,
  nodeClass: Xs,
  tag: "tag:yaml.org,2002:seq",
  resolve(t15, e) {
    return rc(t15) || e("Expected a sequence for this tag"), t15;
  },
  createNode: (t15, e, r) => Xs.from(t15, e, r)
};
var cu = {
  identify: (t15) => typeof t15 == "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (t15) => t15,
  stringify(t15, e, r, n) {
    return e = Object.assign({ actualString: true }, e), J1(t15, e, r, n);
  }
};
var hu = {
  identify: (t15) => t15 == null,
  createNode: () => new Kt(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Kt(null),
  stringify: ({ source: t15 }, e) => typeof t15 == "string" && hu.test.test(t15) ? t15 : e.options.nullStr
};
var tm = {
  identify: (t15) => typeof t15 == "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (t15) => new Kt(t15[0] === "t" || t15[0] === "T"),
  stringify({ source: t15, value: e }, r) {
    if (t15 && tm.test.test(t15)) {
      const n = t15[0] === "t" || t15[0] === "T";
      if (e === n)
        return t15;
    }
    return e ? r.options.trueStr : r.options.falseStr;
  }
};
function Tn({ format: t15, minFractionDigits: e, tag: r, value: n }) {
  if (typeof n == "bigint")
    return String(n);
  const i = typeof n == "number" ? n : Number(n);
  if (!isFinite(i))
    return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  let s = JSON.stringify(n);
  if (!t15 && e && (!r || r === "tag:yaml.org,2002:float") && /^\d/.test(s)) {
    let a = s.indexOf(".");
    a < 0 && (a = s.length, s += ".");
    let o = e - (s.length - a - 1);
    for (; o-- > 0; )
      s += "0";
  }
  return s;
}
var Gx = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t15) => t15.slice(-3).toLowerCase() === "nan" ? NaN : t15[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Tn
};
var Xx = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (t15) => parseFloat(t15),
  stringify(t15) {
    const e = Number(t15.value);
    return isFinite(e) ? e.toExponential() : Tn(t15);
  }
};
var Yx = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(t15) {
    const e = new Kt(parseFloat(t15)), r = t15.indexOf(".");
    return r !== -1 && t15[t15.length - 1] === "0" && (e.minFractionDigits = t15.length - r - 1), e;
  },
  stringify: Tn
};
var uu = (t15) => typeof t15 == "bigint" || Number.isInteger(t15);
var em = (t15, e, r, { intAsBigInt: n }) => n ? BigInt(t15) : parseInt(t15.substring(e), r);
function Kx(t15, e, r) {
  const { value: n } = t15;
  return uu(n) && n >= 0 ? r + n.toString(e) : Tn(t15);
}
var Zx = {
  identify: (t15) => uu(t15) && t15 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (t15, e, r) => em(t15, 2, 8, r),
  stringify: (t15) => Kx(t15, 8, "0o")
};
var Jx = {
  identify: uu,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (t15, e, r) => em(t15, 0, 10, r),
  stringify: Tn
};
var Qx = {
  identify: (t15) => uu(t15) && t15 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (t15, e, r) => em(t15, 2, 16, r),
  stringify: (t15) => Kx(t15, 16, "0x")
};
var DB = [
  uo,
  po,
  cu,
  hu,
  tm,
  Zx,
  Jx,
  Qx,
  Gx,
  Xx,
  Yx
];
function L2(t15) {
  return typeof t15 == "bigint" || Number.isInteger(t15);
}
var Xc = ({ value: t15 }) => JSON.stringify(t15);
var FB = [
  {
    identify: (t15) => typeof t15 == "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (t15) => t15,
    stringify: Xc
  },
  {
    identify: (t15) => t15 == null,
    createNode: () => new Kt(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: Xc
  },
  {
    identify: (t15) => typeof t15 == "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (t15) => t15 === "true",
    stringify: Xc
  },
  {
    identify: L2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (t15, e, { intAsBigInt: r }) => r ? BigInt(t15) : parseInt(t15, 10),
    stringify: ({ value: t15 }) => L2(t15) ? t15.toString() : JSON.stringify(t15)
  },
  {
    identify: (t15) => typeof t15 == "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (t15) => parseFloat(t15),
    stringify: Xc
  }
];
var NB = {
  default: true,
  tag: "",
  test: /^/,
  resolve(t15, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(t15)}`), t15;
  }
};
var IB = [uo, po].concat(FB, NB);
var rm = {
  identify: (t15) => t15 instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(t15, e) {
    if (typeof atob == "function") {
      const r = atob(t15.replace(/[\n\r]/g, "")), n = new Uint8Array(r.length);
      for (let i = 0; i < r.length; ++i)
        n[i] = r.charCodeAt(i);
      return n;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), t15;
  },
  stringify({ comment: t15, type: e, value: r }, n, i, s) {
    if (!r)
      return "";
    const a = r;
    let o;
    if (typeof btoa == "function") {
      let l = "";
      for (let c = 0; c < a.length; ++c)
        l += String.fromCharCode(a[c]);
      o = btoa(l);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e ?? (e = Kt.BLOCK_LITERAL), e !== Kt.QUOTE_DOUBLE) {
      const l = Math.max(n.options.lineWidth - n.indent.length, n.options.minContentWidth), c = Math.ceil(o.length / l), h = new Array(c);
      for (let p = 0, m = 0; p < c; ++p, m += l)
        h[p] = o.substr(m, l);
      o = h.join(e === Kt.BLOCK_LITERAL ? `
` : " ");
    }
    return J1({ comment: t15, type: e, value: o }, n, i, s);
  }
};
function t3(t15, e) {
  if (rc(t15))
    for (let r = 0; r < t15.items.length; ++r) {
      let n = t15.items[r];
      if (!We(n)) {
        if (ec(n)) {
          n.items.length > 1 && e("Each pair must have its own sequence indicator");
          const i = n.items[0] || new Jr(new Kt(null));
          if (n.commentBefore && (i.key.commentBefore = i.key.commentBefore ? `${n.commentBefore}
${i.key.commentBefore}` : n.commentBefore), n.comment) {
            const s = i.value ?? i.key;
            s.comment = s.comment ? `${n.comment}
${s.comment}` : n.comment;
          }
          n = i;
        }
        t15.items[r] = We(n) ? n : new Jr(n);
      }
    }
  else
    e("Expected a sequence for this tag");
  return t15;
}
function e3(t15, e, r) {
  const { replacer: n } = r, i = new Xs(t15);
  i.tag = "tag:yaml.org,2002:pairs";
  let s = 0;
  if (e && Symbol.iterator in Object(e))
    for (let a of e) {
      typeof n == "function" && (a = n.call(e, String(s++), a));
      let o, l;
      if (Array.isArray(a))
        if (a.length === 2)
          o = a[0], l = a[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${a}`);
      else if (a && a instanceof Object) {
        const c = Object.keys(a);
        if (c.length === 1)
          o = c[0], l = a[o];
        else
          throw new TypeError(`Expected tuple with one key, not ${c.length} keys`);
      } else
        o = a;
      i.items.push(Q1(o, l, r));
    }
  return i;
}
var nm = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: t3,
  createNode: e3
};
var kh = class r3 extends Xs {
  constructor() {
    super(), this.add = pn.prototype.add.bind(this), this.delete = pn.prototype.delete.bind(this), this.get = pn.prototype.get.bind(this), this.has = pn.prototype.has.bind(this), this.set = pn.prototype.set.bind(this), this.tag = r3.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, r) {
    if (!r)
      return super.toJSON(e);
    const n = /* @__PURE__ */ new Map();
    (r == null ? void 0 : r.onCreate) && r.onCreate(n);
    for (const i of this.items) {
      let s, a;
      if (We(i) ? (s = fn(i.key, "", r), a = fn(i.value, s, r)) : s = fn(i, "", r), n.has(s))
        throw new Error("Ordered maps must not include duplicate keys");
      n.set(s, a);
    }
    return n;
  }
  static from(e, r, n) {
    const i = e3(e, r, n), s = new this();
    return s.items = i.items, s;
  }
};
kh.tag = "tag:yaml.org,2002:omap";
var im = {
  collection: "seq",
  identify: (t15) => t15 instanceof Map,
  nodeClass: kh,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(t15, e) {
    const r = t3(t15, e), n = [];
    for (const { key: i } of r.items)
      Ae(i) && (n.includes(i.value) ? e(`Ordered maps must not include duplicate keys: ${i.value}`) : n.push(i.value));
    return Object.assign(new kh(), r);
  },
  createNode: (t15, e, r) => kh.from(t15, e, r)
};
function n3({ value: t15, source: e }, r) {
  return e && (t15 ? i3 : s3).test.test(e) ? e : t15 ? r.options.trueStr : r.options.falseStr;
}
var i3 = {
  identify: (t15) => t15 === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Kt(true),
  stringify: n3
};
var s3 = {
  identify: (t15) => t15 === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Kt(false),
  stringify: n3
};
var OB = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (t15) => t15.slice(-3).toLowerCase() === "nan" ? NaN : t15[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Tn
};
var zB = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (t15) => parseFloat(t15.replace(/_/g, "")),
  stringify(t15) {
    const e = Number(t15.value);
    return isFinite(e) ? e.toExponential() : Tn(t15);
  }
};
var qB = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(t15) {
    const e = new Kt(parseFloat(t15.replace(/_/g, ""))), r = t15.indexOf(".");
    if (r !== -1) {
      const n = t15.substring(r + 1).replace(/_/g, "");
      n[n.length - 1] === "0" && (e.minFractionDigits = n.length);
    }
    return e;
  },
  stringify: Tn
};
var nc = (t15) => typeof t15 == "bigint" || Number.isInteger(t15);
function du(t15, e, r, { intAsBigInt: n }) {
  const i = t15[0];
  if ((i === "-" || i === "+") && (e += 1), t15 = t15.substring(e).replace(/_/g, ""), n) {
    switch (r) {
      case 2:
        t15 = `0b${t15}`;
        break;
      case 8:
        t15 = `0o${t15}`;
        break;
      case 16:
        t15 = `0x${t15}`;
        break;
    }
    const a = BigInt(t15);
    return i === "-" ? BigInt(-1) * a : a;
  }
  const s = parseInt(t15, r);
  return i === "-" ? -1 * s : s;
}
function sm(t15, e, r) {
  const { value: n } = t15;
  if (nc(n)) {
    const i = n.toString(e);
    return n < 0 ? "-" + r + i.substr(1) : r + i;
  }
  return Tn(t15);
}
var RB = {
  identify: nc,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (t15, e, r) => du(t15, 2, 2, r),
  stringify: (t15) => sm(t15, 2, "0b")
};
var PB = {
  identify: nc,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (t15, e, r) => du(t15, 1, 8, r),
  stringify: (t15) => sm(t15, 8, "0")
};
var jB = {
  identify: nc,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (t15, e, r) => du(t15, 0, 10, r),
  stringify: Tn
};
var WB = {
  identify: nc,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (t15, e, r) => du(t15, 2, 16, r),
  stringify: (t15) => sm(t15, 16, "0x")
};
var Na = class _Na extends pn {
  constructor(e) {
    super(e), this.tag = _Na.tag;
  }
  add(e) {
    let r;
    We(e) ? r = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? r = new Jr(e.key, null) : r = new Jr(e, null), Is(this.items, r.key) || this.items.push(r);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, r) {
    const n = Is(this.items, e);
    return !r && We(n) ? Ae(n.key) ? n.key.value : n.key : n;
  }
  set(e, r) {
    if (typeof r != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof r}`);
    const n = Is(this.items, e);
    n && !r ? this.items.splice(this.items.indexOf(n), 1) : !n && r && this.items.push(new Jr(e));
  }
  toJSON(e, r) {
    return super.toJSON(e, r, Set);
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, e, { allNullValues: true }), r, n);
    throw new Error("Set items must all have null values");
  }
  static from(e, r, n) {
    const { replacer: i } = n, s = new this(e);
    if (r && Symbol.iterator in Object(r))
      for (let a of r)
        typeof i == "function" && (a = i.call(r, a, a)), s.items.push(Q1(a, null, n));
    return s;
  }
};
Na.tag = "tag:yaml.org,2002:set";
var am = {
  collection: "map",
  identify: (t15) => t15 instanceof Set,
  nodeClass: Na,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (t15, e, r) => Na.from(t15, e, r),
  resolve(t15, e) {
    if (ec(t15)) {
      if (t15.hasAllNullValues(true))
        return Object.assign(new Na(), t15);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return t15;
  }
};
function om(t15, e) {
  const r = t15[0], n = r === "-" || r === "+" ? t15.substring(1) : t15, i = (a) => e ? BigInt(a) : Number(a), s = n.replace(/_/g, "").split(":").reduce((a, o) => a * i(60) + i(o), i(0));
  return r === "-" ? i(-1) * s : s;
}
function a3(t15) {
  let { value: e } = t15, r = (a) => a;
  if (typeof e == "bigint")
    r = (a) => BigInt(a);
  else if (isNaN(e) || !isFinite(e))
    return Tn(t15);
  let n = "";
  e < 0 && (n = "-", e *= r(-1));
  const i = r(60), s = [e % i];
  return e < 60 ? s.unshift(0) : (e = (e - s[0]) / i, s.unshift(e % i), e >= 60 && (e = (e - s[0]) / i, s.unshift(e))), n + s.map((a) => String(a).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var o3 = {
  identify: (t15) => typeof t15 == "bigint" || Number.isInteger(t15),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (t15, e, { intAsBigInt: r }) => om(t15, r),
  stringify: a3
};
var l3 = {
  identify: (t15) => typeof t15 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (t15) => om(t15, false),
  stringify: a3
};
var pu = {
  identify: (t15) => t15 instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(t15) {
    const e = t15.match(pu.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, r, n, i, s, a, o] = e.map(Number), l = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let c = Date.UTC(r, n - 1, i, s || 0, a || 0, o || 0, l);
    const h = e[8];
    if (h && h !== "Z") {
      let p = om(h, false);
      Math.abs(p) < 30 && (p *= 60), c -= 6e4 * p;
    }
    return new Date(c);
  },
  stringify: ({ value: t15 }) => (t15 == null ? void 0 : t15.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) ?? ""
};
var D2 = [
  uo,
  po,
  cu,
  hu,
  i3,
  s3,
  RB,
  PB,
  jB,
  WB,
  OB,
  zB,
  qB,
  rm,
  Ai,
  im,
  nm,
  am,
  o3,
  l3,
  pu
];
var F2 = /* @__PURE__ */ new Map([
  ["core", DB],
  ["failsafe", [uo, po, cu]],
  ["json", IB],
  ["yaml11", D2],
  ["yaml-1.1", D2]
]);
var N2 = {
  binary: rm,
  bool: tm,
  float: Yx,
  floatExp: Xx,
  floatNaN: Gx,
  floatTime: l3,
  int: Jx,
  intHex: Qx,
  intOct: Zx,
  intTime: o3,
  map: uo,
  merge: Ai,
  null: hu,
  omap: im,
  pairs: nm,
  seq: po,
  set: am,
  timestamp: pu
};
var HB = {
  "tag:yaml.org,2002:binary": rm,
  "tag:yaml.org,2002:merge": Ai,
  "tag:yaml.org,2002:omap": im,
  "tag:yaml.org,2002:pairs": nm,
  "tag:yaml.org,2002:set": am,
  "tag:yaml.org,2002:timestamp": pu
};
function Wd(t15, e, r) {
  const n = F2.get(e);
  if (n && !t15)
    return r && !n.includes(Ai) ? n.concat(Ai) : n.slice();
  let i = n;
  if (!i)
    if (Array.isArray(t15))
      i = [];
    else {
      const s = Array.from(F2.keys()).filter((a) => a !== "yaml11").map((a) => JSON.stringify(a)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${s} or define customTags array`);
    }
  if (Array.isArray(t15))
    for (const s of t15)
      i = i.concat(s);
  else typeof t15 == "function" && (i = t15(i.slice()));
  return r && (i = i.concat(Ai)), i.reduce((s, a) => {
    const o = typeof a == "string" ? N2[a] : a;
    if (!o) {
      const l = JSON.stringify(a), c = Object.keys(N2).map((h) => JSON.stringify(h)).join(", ");
      throw new Error(`Unknown custom tag ${l}; use one of ${c}`);
    }
    return s.includes(o) || s.push(o), s;
  }, []);
}
var UB = (t15, e) => t15.key < e.key ? -1 : t15.key > e.key ? 1 : 0;
var VB = class c3 {
  constructor({ compat: e, customTags: r, merge: n, resolveKnownTags: i, schema: s, sortMapEntries: a, toStringDefaults: o }) {
    this.compat = Array.isArray(e) ? Wd(e, "compat") : e ? Wd(null, e) : null, this.name = typeof s == "string" && s || "core", this.knownTags = i ? HB : {}, this.tags = Wd(r, this.name, n), this.toStringOptions = o ?? null, Object.defineProperty(this, ss, { value: uo }), Object.defineProperty(this, Xn, { value: cu }), Object.defineProperty(this, co, { value: po }), this.sortMapEntries = typeof a == "function" ? a : a === true ? UB : null;
  }
  clone() {
    const e = Object.create(c3.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
};
function GB(t15, e) {
  var _a3;
  const r = [];
  let n = e.directives === true;
  if (e.directives !== false && t15.directives) {
    const l = t15.directives.toString(t15);
    l ? (r.push(l), n = true) : t15.directives.docStart && (n = true);
  }
  n && r.push("---");
  const i = Px(t15, e), { commentString: s } = i.options;
  if (t15.commentBefore) {
    r.length !== 1 && r.unshift("");
    const l = s(t15.commentBefore);
    r.unshift(ki(l, ""));
  }
  let a = false, o = null;
  if (t15.contents) {
    if (je(t15.contents)) {
      if (t15.contents.spaceBefore && n && r.push(""), t15.contents.commentBefore) {
        const h = s(t15.contents.commentBefore);
        r.push(ki(h, ""));
      }
      i.forceBlockIndent = !!t15.comment, o = t15.contents.comment;
    }
    const l = o ? void 0 : () => a = true;
    let c = Ua(t15.contents, i, () => o = null, l);
    o && (c += Ns(c, "", s(o))), (c[0] === "|" || c[0] === ">") && r[r.length - 1] === "---" ? r[r.length - 1] = `--- ${c}` : r.push(c);
  } else
    r.push(Ua(t15.contents, i));
  if ((_a3 = t15.directives) == null ? void 0 : _a3.docEnd)
    if (t15.comment) {
      const l = s(t15.comment);
      l.includes(`
`) ? (r.push("..."), r.push(ki(l, ""))) : r.push(`... ${l}`);
    } else
      r.push("...");
  else {
    let l = t15.comment;
    l && a && (l = l.replace(/^\n+/, "")), l && ((!a || o) && r[r.length - 1] !== "" && r.push(""), r.push(ki(s(l), "")));
  }
  return r.join(`
`) + `
`;
}
var h3 = class u3 {
  constructor(e, r, n) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, gn, { value: Qp });
    let i = null;
    typeof r == "function" || Array.isArray(r) ? i = r : n === void 0 && r && (n = r, r = void 0);
    const s = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, n);
    this.options = s;
    let { version: a } = s;
    (n == null ? void 0 : n._directives) ? (this.directives = n._directives.atDocument(), this.directives.yaml.explicit && (a = this.directives.yaml.version)) : this.directives = new Fa({ version: a }), this.setSchema(a, n), this.contents = e === void 0 ? null : this.createNode(e, i, n);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(u3.prototype, {
      [gn]: { value: Qp }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = je(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    xa(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, r) {
    xa(this.contents) && this.contents.addIn(e, r);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, r) {
    if (!e.anchor) {
      const n = Ix(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !r || n.has(r) ? Ox(r || "a", n) : r;
    }
    return new Z1(e.anchor);
  }
  createNode(e, r, n) {
    let i;
    if (typeof r == "function")
      e = r.call({ "": e }, "", e), i = r;
    else if (Array.isArray(r)) {
      const k = (A) => typeof A == "number" || A instanceof String || A instanceof Number, C = r.filter(k).map(String);
      C.length > 0 && (r = r.concat(C)), i = r;
    } else n === void 0 && r && (n = r, r = void 0);
    const { aliasDuplicateObjects: s, anchorPrefix: a, flow: o, keepUndefined: l, onTagObj: c, tag: h } = n ?? {}, { onAnchor: p, setAnchors: m, sourceObjects: g } = wB(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      a || "a"
    ), y = {
      aliasDuplicateObjects: s ?? true,
      keepUndefined: l ?? false,
      onAnchor: p,
      onTagObj: c,
      replacer: i,
      schema: this.schema,
      sourceObjects: g
    }, x = Bl(e, h, y);
    return o && Re(x) && (x.flow = true), m(), x;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, r, n = {}) {
    const i = this.createNode(e, null, n), s = this.createNode(r, null, n);
    return new Jr(i, s);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return xa(this.contents) ? this.contents.delete(e) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return Qo(e) ? this.contents == null ? false : (this.contents = null, true) : xa(this.contents) ? this.contents.deleteIn(e) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, r) {
    return Re(this.contents) ? this.contents.get(e, r) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    return Qo(e) ? !r && Ae(this.contents) ? this.contents.value : this.contents : Re(this.contents) ? this.contents.getIn(e, r) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return Re(this.contents) ? this.contents.has(e) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return Qo(e) ? this.contents !== void 0 : Re(this.contents) ? this.contents.hasIn(e) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, r) {
    this.contents == null ? this.contents = i0(this.schema, [e], r) : xa(this.contents) && this.contents.set(e, r);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    Qo(e) ? this.contents = r : this.contents == null ? this.contents = i0(this.schema, Array.from(e), r) : xa(this.contents) && this.contents.setIn(e, r);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, r = {}) {
    typeof e == "number" && (e = String(e));
    let n;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Fa({ version: "1.1" }), n = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Fa({ version: e }), n = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, n = null;
        break;
      default: {
        const i = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i}`);
      }
    }
    if (r.schema instanceof Object)
      this.schema = r.schema;
    else if (n)
      this.schema = new VB(Object.assign(n, r));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: r, mapAsMap: n, maxAliasCount: i, onAnchor: s, reviver: a } = {}) {
    const o = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: n === true,
      mapKeyWarned: false,
      maxAliasCount: typeof i == "number" ? i : 100
    }, l = fn(this.contents, r ?? "", o);
    if (typeof s == "function")
      for (const { count: c, res: h } of o.anchors.values())
        s(h, c);
    return typeof a == "function" ? Ea(a, { "": l }, "", l) : l;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, r) {
    return this.toJS({ json: true, jsonArg: e, mapAsMap: false, onAnchor: r });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const r = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${r}`);
    }
    return GB(this, e);
  }
};
function xa(t15) {
  if (Re(t15))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var d3 = class extends Error {
  constructor(e, r, n, i) {
    super(), this.name = e, this.code = n, this.message = i, this.pos = r;
  }
};
var tl = class extends d3 {
  constructor(e, r, n) {
    super("YAMLParseError", e, r, n);
  }
};
var XB = class extends d3 {
  constructor(e, r, n) {
    super("YAMLWarning", e, r, n);
  }
};
var I2 = (t15, e) => (r) => {
  if (r.pos[0] === -1)
    return;
  r.linePos = r.pos.map((o) => e.linePos(o));
  const { line: n, col: i } = r.linePos[0];
  r.message += ` at line ${n}, column ${i}`;
  let s = i - 1, a = t15.substring(e.lineStarts[n - 1], e.lineStarts[n]).replace(/[\n\r]+$/, "");
  if (s >= 60 && a.length > 80) {
    const o = Math.min(s - 39, a.length - 79);
    a = "…" + a.substring(o), s -= o - 1;
  }
  if (a.length > 80 && (a = a.substring(0, 79) + "…"), n > 1 && /^ *$/.test(a.substring(0, s))) {
    let o = t15.substring(e.lineStarts[n - 2], e.lineStarts[n - 1]);
    o.length > 80 && (o = o.substring(0, 79) + `…
`), a = o + a;
  }
  if (/[^ ]/.test(a)) {
    let o = 1;
    const l = r.linePos[1];
    l && l.line === n && l.col > i && (o = Math.max(1, Math.min(l.col - i, 80 - s)));
    const c = " ".repeat(s) + "^".repeat(o);
    r.message += `:

${a}
${c}
`;
  }
};
function Va(t15, { flow: e, indicator: r, next: n, offset: i, onError: s, parentIndent: a, startOnNewline: o }) {
  let l = false, c = o, h = o, p = "", m = "", g = false, y = false, x = null, k = null, C = null, A = null, $ = null, B = null, L = null;
  for (const G of t15)
    switch (y && (G.type !== "space" && G.type !== "newline" && G.type !== "comma" && s(G.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), y = false), x && (c && G.type !== "comment" && G.type !== "newline" && s(x, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), x = null), G.type) {
      case "space":
        !e && (r !== "doc-start" || (n == null ? void 0 : n.type) !== "flow-collection") && G.source.includes("	") && (x = G), h = true;
        break;
      case "comment": {
        h || s(G, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const F = G.source.substring(1) || " ";
        p ? p += m + F : p = F, m = "", c = false;
        break;
      }
      case "newline":
        c ? p ? p += G.source : (!B || r !== "seq-item-ind") && (l = true) : m += G.source, c = true, g = true, (k || C) && (A = G), h = true;
        break;
      case "anchor":
        k && s(G, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), G.source.endsWith(":") && s(G.offset + G.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true), k = G, L ?? (L = G.offset), c = false, h = false, y = true;
        break;
      case "tag": {
        C && s(G, "MULTIPLE_TAGS", "A node can have at most one tag"), C = G, L ?? (L = G.offset), c = false, h = false, y = true;
        break;
      }
      case r:
        (k || C) && s(G, "BAD_PROP_ORDER", `Anchors and tags must be after the ${G.source} indicator`), B && s(G, "UNEXPECTED_TOKEN", `Unexpected ${G.source} in ${e ?? "collection"}`), B = G, c = r === "seq-item-ind" || r === "explicit-key-ind", h = false;
        break;
      case "comma":
        if (e) {
          $ && s(G, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), $ = G, c = false, h = false;
          break;
        }
      default:
        s(G, "UNEXPECTED_TOKEN", `Unexpected ${G.type} token`), c = false, h = false;
    }
  const q = t15[t15.length - 1], U = q ? q.offset + q.source.length : i;
  return y && n && n.type !== "space" && n.type !== "newline" && n.type !== "comma" && (n.type !== "scalar" || n.source !== "") && s(n.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), x && (c && x.indent <= a || (n == null ? void 0 : n.type) === "block-map" || (n == null ? void 0 : n.type) === "block-seq") && s(x, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: $,
    found: B,
    spaceBefore: l,
    comment: p,
    hasNewline: g,
    anchor: k,
    tag: C,
    newlineAfterProp: A,
    end: U,
    start: L ?? U
  };
}
function Ll(t15) {
  if (!t15)
    return null;
  switch (t15.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (t15.source.includes(`
`))
        return true;
      if (t15.end) {
        for (const e of t15.end)
          if (e.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const e of t15.items) {
        for (const r of e.start)
          if (r.type === "newline")
            return true;
        if (e.sep) {
          for (const r of e.sep)
            if (r.type === "newline")
              return true;
        }
        if (Ll(e.key) || Ll(e.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function nf(t15, e, r) {
  if ((e == null ? void 0 : e.type) === "flow-collection") {
    const n = e.end[0];
    n.indent === t15 && (n.source === "]" || n.source === "}") && Ll(e) && r(n, "BAD_INDENT", "Flow end indicator should be more indented than parent", true);
  }
}
function p3(t15, e, r) {
  const { uniqueKeys: n } = t15.options;
  if (n === false)
    return false;
  const i = typeof n == "function" ? n : (s, a) => s === a || Ae(s) && Ae(a) && s.value === a.value;
  return e.some((s) => i(s.key, r));
}
var O2 = "All mapping items must start at the same column";
function YB({ composeNode: t15, composeEmptyNode: e }, r, n, i, s) {
  var _a3;
  const a = (s == null ? void 0 : s.nodeClass) ?? pn, o = new a(r.schema);
  r.atRoot && (r.atRoot = false);
  let l = n.offset, c = null;
  for (const h of n.items) {
    const { start: p, key: m, sep: g, value: y } = h, x = Va(p, {
      indicator: "explicit-key-ind",
      next: m ?? (g == null ? void 0 : g[0]),
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: true
    }), k = !x.found;
    if (k) {
      if (m && (m.type === "block-seq" ? i(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in m && m.indent !== n.indent && i(l, "BAD_INDENT", O2)), !x.anchor && !x.tag && !g) {
        c = x.end, x.comment && (o.comment ? o.comment += `
` + x.comment : o.comment = x.comment);
        continue;
      }
      (x.newlineAfterProp || Ll(m)) && i(m ?? p[p.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else ((_a3 = x.found) == null ? void 0 : _a3.indent) !== n.indent && i(l, "BAD_INDENT", O2);
    r.atKey = true;
    const C = x.end, A = m ? t15(r, m, x, i) : e(r, C, p, null, x, i);
    r.schema.compat && nf(n.indent, m, i), r.atKey = false, p3(r, o.items, A) && i(C, "DUPLICATE_KEY", "Map keys must be unique");
    const $ = Va(g ?? [], {
      indicator: "map-value-ind",
      next: y,
      offset: A.range[2],
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !m || m.type === "block-scalar"
    });
    if (l = $.end, $.found) {
      k && ((y == null ? void 0 : y.type) === "block-map" && !$.hasNewline && i(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), r.options.strict && x.start < $.found.offset - 1024 && i(A.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const B = y ? t15(r, y, $, i) : e(r, l, g, null, $, i);
      r.schema.compat && nf(n.indent, y, i), l = B.range[2];
      const L = new Jr(A, B);
      r.options.keepSourceTokens && (L.srcToken = h), o.items.push(L);
    } else {
      k && i(A.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), $.comment && (A.comment ? A.comment += `
` + $.comment : A.comment = $.comment);
      const B = new Jr(A);
      r.options.keepSourceTokens && (B.srcToken = h), o.items.push(B);
    }
  }
  return c && c < l && i(c, "IMPOSSIBLE", "Map comment with trailing content"), o.range = [n.offset, l, c ?? l], o;
}
function KB({ composeNode: t15, composeEmptyNode: e }, r, n, i, s) {
  const a = (s == null ? void 0 : s.nodeClass) ?? Xs, o = new a(r.schema);
  r.atRoot && (r.atRoot = false), r.atKey && (r.atKey = false);
  let l = n.offset, c = null;
  for (const { start: h, value: p } of n.items) {
    const m = Va(h, {
      indicator: "seq-item-ind",
      next: p,
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: true
    });
    if (!m.found)
      if (m.anchor || m.tag || p)
        p && p.type === "block-seq" ? i(m.end, "BAD_INDENT", "All sequence items must start at the same column") : i(l, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        c = m.end, m.comment && (o.comment = m.comment);
        continue;
      }
    const g = p ? t15(r, p, m, i) : e(r, m.end, h, null, m, i);
    r.schema.compat && nf(n.indent, p, i), l = g.range[2], o.items.push(g);
  }
  return o.range = [n.offset, l, c ?? l], o;
}
function ic(t15, e, r, n) {
  let i = "";
  if (t15) {
    let s = false, a = "";
    for (const o of t15) {
      const { source: l, type: c } = o;
      switch (c) {
        case "space":
          s = true;
          break;
        case "comment": {
          r && !s && n(o, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const h = l.substring(1) || " ";
          i ? i += a + h : i = h, a = "";
          break;
        }
        case "newline":
          i && (a += l), s = true;
          break;
        default:
          n(o, "UNEXPECTED_TOKEN", `Unexpected ${c} at node end`);
      }
      e += l.length;
    }
  }
  return { comment: i, offset: e };
}
var Hd = "Block collections are not allowed within flow collections";
var Ud = (t15) => t15 && (t15.type === "block-map" || t15.type === "block-seq");
function ZB({ composeNode: t15, composeEmptyNode: e }, r, n, i, s) {
  const a = n.start.source === "{", o = a ? "flow map" : "flow sequence", l = (s == null ? void 0 : s.nodeClass) ?? (a ? pn : Xs), c = new l(r.schema);
  c.flow = true;
  const h = r.atRoot;
  h && (r.atRoot = false), r.atKey && (r.atKey = false);
  let p = n.offset + n.start.source.length;
  for (let k = 0; k < n.items.length; ++k) {
    const C = n.items[k], { start: A, key: $, sep: B, value: L } = C, q = Va(A, {
      flow: o,
      indicator: "explicit-key-ind",
      next: $ ?? (B == null ? void 0 : B[0]),
      offset: p,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: false
    });
    if (!q.found) {
      if (!q.anchor && !q.tag && !B && !L) {
        k === 0 && q.comma ? i(q.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${o}`) : k < n.items.length - 1 && i(q.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${o}`), q.comment && (c.comment ? c.comment += `
` + q.comment : c.comment = q.comment), p = q.end;
        continue;
      }
      !a && r.options.strict && Ll($) && i(
        $,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (k === 0)
      q.comma && i(q.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${o}`);
    else if (q.comma || i(q.start, "MISSING_CHAR", `Missing , between ${o} items`), q.comment) {
      let U = "";
      t: for (const G of A)
        switch (G.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            U = G.source.substring(1);
            break t;
          default:
            break t;
        }
      if (U) {
        let G = c.items[c.items.length - 1];
        We(G) && (G = G.value ?? G.key), G.comment ? G.comment += `
` + U : G.comment = U, q.comment = q.comment.substring(U.length + 1);
      }
    }
    if (!a && !B && !q.found) {
      const U = L ? t15(r, L, q, i) : e(r, q.end, B, null, q, i);
      c.items.push(U), p = U.range[2], Ud(L) && i(U.range, "BLOCK_IN_FLOW", Hd);
    } else {
      r.atKey = true;
      const U = q.end, G = $ ? t15(r, $, q, i) : e(r, U, A, null, q, i);
      Ud($) && i(G.range, "BLOCK_IN_FLOW", Hd), r.atKey = false;
      const F = Va(B ?? [], {
        flow: o,
        indicator: "map-value-ind",
        next: L,
        offset: G.range[2],
        onError: i,
        parentIndent: n.indent,
        startOnNewline: false
      });
      if (F.found) {
        if (!a && !q.found && r.options.strict) {
          if (B)
            for (const Q of B) {
              if (Q === F.found)
                break;
              if (Q.type === "newline") {
                i(Q, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          q.start < F.found.offset - 1024 && i(F.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else L && ("source" in L && L.source && L.source[0] === ":" ? i(L, "MISSING_CHAR", `Missing space after : in ${o}`) : i(F.start, "MISSING_CHAR", `Missing , or : between ${o} items`));
      const W = L ? t15(r, L, F, i) : F.found ? e(r, F.end, B, null, F, i) : null;
      W ? Ud(L) && i(W.range, "BLOCK_IN_FLOW", Hd) : F.comment && (G.comment ? G.comment += `
` + F.comment : G.comment = F.comment);
      const R = new Jr(G, W);
      if (r.options.keepSourceTokens && (R.srcToken = C), a) {
        const Q = c;
        p3(r, Q.items, G) && i(U, "DUPLICATE_KEY", "Map keys must be unique"), Q.items.push(R);
      } else {
        const Q = new pn(r.schema);
        Q.flow = true, Q.items.push(R);
        const rt = (W ?? G).range;
        Q.range = [G.range[0], rt[1], rt[2]], c.items.push(Q);
      }
      p = W ? W.range[2] : F.end;
    }
  }
  const m = a ? "}" : "]", [g, ...y] = n.end;
  let x = p;
  if (g && g.source === m)
    x = g.offset + g.source.length;
  else {
    const k = o[0].toUpperCase() + o.substring(1), C = h ? `${k} must end with a ${m}` : `${k} in block collection must be sufficiently indented and end with a ${m}`;
    i(p, h ? "MISSING_CHAR" : "BAD_INDENT", C), g && g.source.length !== 1 && y.unshift(g);
  }
  if (y.length > 0) {
    const k = ic(y, x, r.options.strict, i);
    k.comment && (c.comment ? c.comment += `
` + k.comment : c.comment = k.comment), c.range = [n.offset, x, k.offset];
  } else
    c.range = [n.offset, x, x];
  return c;
}
function Vd(t15, e, r, n, i, s) {
  const a = r.type === "block-map" ? YB(t15, e, r, n, s) : r.type === "block-seq" ? KB(t15, e, r, n, s) : ZB(t15, e, r, n, s), o = a.constructor;
  return i === "!" || i === o.tagName ? (a.tag = o.tagName, a) : (i && (a.tag = i), a);
}
function JB(t15, e, r, n, i) {
  var _a3;
  const s = n.tag, a = s ? e.directives.tagName(s.source, (m) => i(s, "TAG_RESOLVE_FAILED", m)) : null;
  if (r.type === "block-seq") {
    const { anchor: m, newlineAfterProp: g } = n, y = m && s ? m.offset > s.offset ? m : s : m ?? s;
    y && (!g || g.offset < y.offset) && i(y, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const o = r.type === "block-map" ? "map" : r.type === "block-seq" ? "seq" : r.start.source === "{" ? "map" : "seq";
  if (!s || !a || a === "!" || a === pn.tagName && o === "map" || a === Xs.tagName && o === "seq")
    return Vd(t15, e, r, i, a);
  let l = e.schema.tags.find((m) => m.tag === a && m.collection === o);
  if (!l) {
    const m = e.schema.knownTags[a];
    if (m && m.collection === o)
      e.schema.tags.push(Object.assign({}, m, { default: false })), l = m;
    else
      return m ? i(s, "BAD_COLLECTION_TYPE", `${m.tag} used for ${o} collection, but expects ${m.collection ?? "scalar"}`, true) : i(s, "TAG_RESOLVE_FAILED", `Unresolved tag: ${a}`, true), Vd(t15, e, r, i, a);
  }
  const c = Vd(t15, e, r, i, a, l), h = ((_a3 = l.resolve) == null ? void 0 : _a3.call(l, c, (m) => i(s, "TAG_RESOLVE_FAILED", m), e.options)) ?? c, p = je(h) ? h : new Kt(h);
  return p.range = c.range, p.tag = a, (l == null ? void 0 : l.format) && (p.format = l.format), p;
}
function QB(t15, e, r) {
  const n = e.offset, i = tL(e, t15.options.strict, r);
  if (!i)
    return { value: "", type: null, comment: "", range: [n, n, n] };
  const s = i.mode === ">" ? Kt.BLOCK_FOLDED : Kt.BLOCK_LITERAL, a = e.source ? eL(e.source) : [];
  let o = a.length;
  for (let x = a.length - 1; x >= 0; --x) {
    const k = a[x][1];
    if (k === "" || k === "\r")
      o = x;
    else
      break;
  }
  if (o === 0) {
    const x = i.chomp === "+" && a.length > 0 ? `
`.repeat(Math.max(1, a.length - 1)) : "";
    let k = n + i.length;
    return e.source && (k += e.source.length), { value: x, type: s, comment: i.comment, range: [n, k, k] };
  }
  let l = e.indent + i.indent, c = e.offset + i.length, h = 0;
  for (let x = 0; x < o; ++x) {
    const [k, C] = a[x];
    if (C === "" || C === "\r")
      i.indent === 0 && k.length > l && (l = k.length);
    else {
      k.length < l && r(c + k.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i.indent === 0 && (l = k.length), h = x, l === 0 && !t15.atRoot && r(c, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    c += k.length + C.length + 1;
  }
  for (let x = a.length - 1; x >= o; --x)
    a[x][0].length > l && (o = x + 1);
  let p = "", m = "", g = false;
  for (let x = 0; x < h; ++x)
    p += a[x][0].slice(l) + `
`;
  for (let x = h; x < o; ++x) {
    let [k, C] = a[x];
    c += k.length + C.length + 1;
    const A = C[C.length - 1] === "\r";
    if (A && (C = C.slice(0, -1)), C && k.length < l) {
      const $ = `Block scalar lines must not be less indented than their ${i.indent ? "explicit indentation indicator" : "first line"}`;
      r(c - C.length - (A ? 2 : 1), "BAD_INDENT", $), k = "";
    }
    s === Kt.BLOCK_LITERAL ? (p += m + k.slice(l) + C, m = `
`) : k.length > l || C[0] === "	" ? (m === " " ? m = `
` : !g && m === `
` && (m = `

`), p += m + k.slice(l) + C, m = `
`, g = true) : C === "" ? m === `
` ? p += `
` : m = `
` : (p += m + C, m = " ", g = false);
  }
  switch (i.chomp) {
    case "-":
      break;
    case "+":
      for (let x = o; x < a.length; ++x)
        p += `
` + a[x][0].slice(l);
      p[p.length - 1] !== `
` && (p += `
`);
      break;
    default:
      p += `
`;
  }
  const y = n + i.length + e.source.length;
  return { value: p, type: s, comment: i.comment, range: [n, y, y] };
}
function tL({ offset: t15, props: e }, r, n) {
  if (e[0].type !== "block-scalar-header")
    return n(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: i } = e[0], s = i[0];
  let a = 0, o = "", l = -1;
  for (let m = 1; m < i.length; ++m) {
    const g = i[m];
    if (!o && (g === "-" || g === "+"))
      o = g;
    else {
      const y = Number(g);
      !a && y ? a = y : l === -1 && (l = t15 + m);
    }
  }
  l !== -1 && n(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i}`);
  let c = false, h = "", p = i.length;
  for (let m = 1; m < e.length; ++m) {
    const g = e[m];
    switch (g.type) {
      case "space":
        c = true;
      case "newline":
        p += g.source.length;
        break;
      case "comment":
        r && !c && n(g, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), p += g.source.length, h = g.source.substring(1);
        break;
      case "error":
        n(g, "UNEXPECTED_TOKEN", g.message), p += g.source.length;
        break;
      default: {
        const y = `Unexpected token in block scalar header: ${g.type}`;
        n(g, "UNEXPECTED_TOKEN", y);
        const x = g.source;
        x && typeof x == "string" && (p += x.length);
      }
    }
  }
  return { mode: s, indent: a, chomp: o, comment: h, length: p };
}
function eL(t15) {
  const e = t15.split(/\n( *)/), r = e[0], n = r.match(/^( *)/), i = [(n == null ? void 0 : n[1]) ? [n[1], r.slice(n[1].length)] : ["", r]];
  for (let s = 1; s < e.length; s += 2)
    i.push([e[s], e[s + 1]]);
  return i;
}
function rL(t15, e, r) {
  const { offset: n, type: i, source: s, end: a } = t15;
  let o, l;
  const c = (m, g, y) => r(n + m, g, y);
  switch (i) {
    case "scalar":
      o = Kt.PLAIN, l = nL(s, c);
      break;
    case "single-quoted-scalar":
      o = Kt.QUOTE_SINGLE, l = iL(s, c);
      break;
    case "double-quoted-scalar":
      o = Kt.QUOTE_DOUBLE, l = sL(s, c);
      break;
    default:
      return r(t15, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i}`), {
        value: "",
        type: null,
        comment: "",
        range: [n, n + s.length, n + s.length]
      };
  }
  const h = n + s.length, p = ic(a, h, e, r);
  return {
    value: l,
    type: o,
    comment: p.comment,
    range: [n, h, p.offset]
  };
}
function nL(t15, e) {
  let r = "";
  switch (t15[0]) {
    case "	":
      r = "a tab character";
      break;
    case ",":
      r = "flow indicator character ,";
      break;
    case "%":
      r = "directive indicator character %";
      break;
    case "|":
    case ">": {
      r = `block scalar indicator ${t15[0]}`;
      break;
    }
    case "@":
    case "`": {
      r = `reserved character ${t15[0]}`;
      break;
    }
  }
  return r && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${r}`), f3(t15);
}
function iL(t15, e) {
  return (t15[t15.length - 1] !== "'" || t15.length === 1) && e(t15.length, "MISSING_CHAR", "Missing closing 'quote"), f3(t15.slice(1, -1)).replace(/''/g, "'");
}
function f3(t15) {
  let e, r;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), r = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, r = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let n = e.exec(t15);
  if (!n)
    return t15;
  let i = n[1], s = " ", a = e.lastIndex;
  for (r.lastIndex = a; n = r.exec(t15); )
    n[1] === "" ? s === `
` ? i += s : s = `
` : (i += s + n[1], s = " "), a = r.lastIndex;
  const o = /[ \t]*(.*)/sy;
  return o.lastIndex = a, n = o.exec(t15), i + s + ((n == null ? void 0 : n[1]) ?? "");
}
function sL(t15, e) {
  let r = "";
  for (let n = 1; n < t15.length - 1; ++n) {
    const i = t15[n];
    if (!(i === "\r" && t15[n + 1] === `
`))
      if (i === `
`) {
        const { fold: s, offset: a } = aL(t15, n);
        r += s, n = a;
      } else if (i === "\\") {
        let s = t15[++n];
        const a = oL[s];
        if (a)
          r += a;
        else if (s === `
`)
          for (s = t15[n + 1]; s === " " || s === "	"; )
            s = t15[++n + 1];
        else if (s === "\r" && t15[n + 1] === `
`)
          for (s = t15[++n + 1]; s === " " || s === "	"; )
            s = t15[++n + 1];
        else if (s === "x" || s === "u" || s === "U") {
          const o = { x: 2, u: 4, U: 8 }[s];
          r += lL(t15, n + 1, o, e), n += o;
        } else {
          const o = t15.substr(n - 1, 2);
          e(n - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${o}`), r += o;
        }
      } else if (i === " " || i === "	") {
        const s = n;
        let a = t15[n + 1];
        for (; a === " " || a === "	"; )
          a = t15[++n + 1];
        a !== `
` && !(a === "\r" && t15[n + 2] === `
`) && (r += n > s ? t15.slice(s, n + 1) : i);
      } else
        r += i;
  }
  return (t15[t15.length - 1] !== '"' || t15.length === 1) && e(t15.length, "MISSING_CHAR", 'Missing closing "quote'), r;
}
function aL(t15, e) {
  let r = "", n = t15[e + 1];
  for (; (n === " " || n === "	" || n === `
` || n === "\r") && !(n === "\r" && t15[e + 2] !== `
`); )
    n === `
` && (r += `
`), e += 1, n = t15[e + 1];
  return r || (r = " "), { fold: r, offset: e };
}
var oL = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: " ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function lL(t15, e, r, n) {
  const i = t15.substr(e, r), s = i.length === r && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
  if (isNaN(s)) {
    const a = t15.substr(e - 2, r + 2);
    return n(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), a;
  }
  return String.fromCodePoint(s);
}
function m3(t15, e, r, n) {
  const { value: i, type: s, comment: a, range: o } = e.type === "block-scalar" ? QB(t15, e, n) : rL(e, t15.options.strict, n), l = r ? t15.directives.tagName(r.source, (p) => n(r, "TAG_RESOLVE_FAILED", p)) : null;
  let c;
  t15.options.stringKeys && t15.atKey ? c = t15.schema[Xn] : l ? c = cL(t15.schema, i, l, r, n) : e.type === "scalar" ? c = hL(t15, i, e, n) : c = t15.schema[Xn];
  let h;
  try {
    const p = c.resolve(i, (m) => n(r ?? e, "TAG_RESOLVE_FAILED", m), t15.options);
    h = Ae(p) ? p : new Kt(p);
  } catch (p) {
    const m = p instanceof Error ? p.message : String(p);
    n(r ?? e, "TAG_RESOLVE_FAILED", m), h = new Kt(i);
  }
  return h.range = o, h.source = i, s && (h.type = s), l && (h.tag = l), c.format && (h.format = c.format), a && (h.comment = a), h;
}
function cL(t15, e, r, n, i) {
  var _a3;
  if (r === "!")
    return t15[Xn];
  const s = [];
  for (const o of t15.tags)
    if (!o.collection && o.tag === r)
      if (o.default && o.test)
        s.push(o);
      else
        return o;
  for (const o of s)
    if ((_a3 = o.test) == null ? void 0 : _a3.test(e))
      return o;
  const a = t15.knownTags[r];
  return a && !a.collection ? (t15.tags.push(Object.assign({}, a, { default: false, test: void 0 })), a) : (i(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${r}`, r !== "tag:yaml.org,2002:str"), t15[Xn]);
}
function hL({ atKey: t15, directives: e, schema: r }, n, i, s) {
  const a = r.tags.find((o) => {
    var _a3;
    return (o.default === true || t15 && o.default === "key") && ((_a3 = o.test) == null ? void 0 : _a3.test(n));
  }) || r[Xn];
  if (r.compat) {
    const o = r.compat.find((l) => {
      var _a3;
      return l.default && ((_a3 = l.test) == null ? void 0 : _a3.test(n));
    }) ?? r[Xn];
    if (a.tag !== o.tag) {
      const l = e.tagString(a.tag), c = e.tagString(o.tag), h = `Value may be parsed as either ${l} or ${c}`;
      s(i, "TAG_RESOLVE_FAILED", h, true);
    }
  }
  return a;
}
function uL(t15, e, r) {
  if (e) {
    r ?? (r = e.length);
    for (let n = r - 1; n >= 0; --n) {
      let i = e[n];
      switch (i.type) {
        case "space":
        case "comment":
        case "newline":
          t15 -= i.source.length;
          continue;
      }
      for (i = e[++n]; (i == null ? void 0 : i.type) === "space"; )
        t15 += i.source.length, i = e[++n];
      break;
    }
  }
  return t15;
}
var dL = { composeNode: g3, composeEmptyNode: lm };
function g3(t15, e, r, n) {
  const i = t15.atKey, { spaceBefore: s, comment: a, anchor: o, tag: l } = r;
  let c, h = true;
  switch (e.type) {
    case "alias":
      c = pL(t15, e, n), (o || l) && n(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      c = m3(t15, e, l, n), o && (c.anchor = o.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      c = JB(dL, t15, e, r, n), o && (c.anchor = o.source.substring(1));
      break;
    default: {
      const p = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      n(e, "UNEXPECTED_TOKEN", p), c = lm(t15, e.offset, void 0, null, r, n), h = false;
    }
  }
  return o && c.anchor === "" && n(o, "BAD_ALIAS", "Anchor cannot be an empty string"), i && t15.options.stringKeys && (!Ae(c) || typeof c.value != "string" || c.tag && c.tag !== "tag:yaml.org,2002:str") && n(l ?? e, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), s && (c.spaceBefore = true), a && (e.type === "scalar" && e.source === "" ? c.comment = a : c.commentBefore = a), t15.options.keepSourceTokens && h && (c.srcToken = e), c;
}
function lm(t15, e, r, n, { spaceBefore: i, comment: s, anchor: a, tag: o, end: l }, c) {
  const h = {
    type: "scalar",
    offset: uL(e, r, n),
    indent: -1,
    source: ""
  }, p = m3(t15, h, o, c);
  return a && (p.anchor = a.source.substring(1), p.anchor === "" && c(a, "BAD_ALIAS", "Anchor cannot be an empty string")), i && (p.spaceBefore = true), s && (p.comment = s, p.range[2] = l), p;
}
function pL({ options: t15 }, { offset: e, source: r, end: n }, i) {
  const s = new Z1(r.substring(1));
  s.source === "" && i(e, "BAD_ALIAS", "Alias cannot be an empty string"), s.source.endsWith(":") && i(e + r.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const a = e + r.length, o = ic(n, a, t15.strict, i);
  return s.range = [e, a, o.offset], o.comment && (s.comment = o.comment), s;
}
function fL(t15, e, { offset: r, start: n, value: i, end: s }, a) {
  const o = Object.assign({ _directives: e }, t15), l = new h3(void 0, o), c = {
    atKey: false,
    atRoot: true,
    directives: l.directives,
    options: l.options,
    schema: l.schema
  }, h = Va(n, {
    indicator: "doc-start",
    next: i ?? (s == null ? void 0 : s[0]),
    offset: r,
    onError: a,
    parentIndent: 0,
    startOnNewline: true
  });
  h.found && (l.directives.docStart = true, i && (i.type === "block-map" || i.type === "block-seq") && !h.hasNewline && a(h.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l.contents = i ? g3(c, i, h, a) : lm(c, h.end, n, null, h, a);
  const p = l.contents.range[2], m = ic(s, p, false, a);
  return m.comment && (l.comment = m.comment), l.range = [r, p, m.offset], l;
}
function Do(t15) {
  if (typeof t15 == "number")
    return [t15, t15 + 1];
  if (Array.isArray(t15))
    return t15.length === 2 ? t15 : [t15[0], t15[1]];
  const { offset: e, source: r } = t15;
  return [e, e + (typeof r == "string" ? r.length : 1)];
}
function z2(t15) {
  var _a3;
  let e = "", r = false, n = false;
  for (let i = 0; i < t15.length; ++i) {
    const s = t15[i];
    switch (s[0]) {
      case "#":
        e += (e === "" ? "" : n ? `

` : `
`) + (s.substring(1) || " "), r = true, n = false;
        break;
      case "%":
        ((_a3 = t15[i + 1]) == null ? void 0 : _a3[0]) !== "#" && (i += 1), r = false;
        break;
      default:
        r || (n = true), r = false;
    }
  }
  return { comment: e, afterEmptyLine: n };
}
var mL = class {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = false, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (r, n, i, s) => {
      const a = Do(r);
      s ? this.warnings.push(new XB(a, n, i)) : this.errors.push(new tl(a, n, i));
    }, this.directives = new Fa({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, r) {
    const { comment: n, afterEmptyLine: i } = z2(this.prelude);
    if (n) {
      const s = e.contents;
      if (r)
        e.comment = e.comment ? `${e.comment}
${n}` : n;
      else if (i || e.directives.docStart || !s)
        e.commentBefore = n;
      else if (Re(s) && !s.flow && s.items.length > 0) {
        let a = s.items[0];
        We(a) && (a = a.key);
        const o = a.commentBefore;
        a.commentBefore = o ? `${n}
${o}` : n;
      } else {
        const a = s.commentBefore;
        s.commentBefore = a ? `${n}
${a}` : n;
      }
    }
    r ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: z2(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, r = false, n = -1) {
    for (const i of e)
      yield* this.next(i);
    yield* this.end(r, n);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (r, n, i) => {
          const s = Do(e);
          s[0] += r, this.onError(s, "BAD_DIRECTIVE", n, i);
        }), this.prelude.push(e.source), this.atDirectives = true;
        break;
      case "document": {
        const r = fL(this.options, this.directives, e, this.onError);
        this.atDirectives && !r.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(r, false), this.doc && (yield this.doc), this.doc = r, this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const r = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, n = new tl(Do(e), "UNEXPECTED_TOKEN", r);
        this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const n = "Unexpected doc-end without preceding document";
          this.errors.push(new tl(Do(e), "UNEXPECTED_TOKEN", n));
          break;
        }
        this.doc.directives.docEnd = true;
        const r = ic(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, true), r.comment) {
          const n = this.doc.comment;
          this.doc.comment = n ? `${n}
${r.comment}` : r.comment;
        }
        this.doc.range[2] = r.offset;
        break;
      }
      default:
        this.errors.push(new tl(Do(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = false, r = -1) {
    if (this.doc)
      this.decorate(this.doc, true), yield this.doc, this.doc = null;
    else if (e) {
      const n = Object.assign({ _directives: this.directives }, this.options), i = new h3(void 0, n);
      this.atDirectives && this.onError(r, "MISSING_CHAR", "Missing directives-end indicator line"), i.range = [0, r, r], this.decorate(i, false), yield i;
    }
  }
};
var y3 = "\uFEFF";
var b3 = "";
var x3 = "";
var sf = "";
function gL(t15) {
  switch (t15) {
    case y3:
      return "byte-order-mark";
    case b3:
      return "doc-mode";
    case x3:
      return "flow-error-end";
    case sf:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (t15[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function wn(t15) {
  switch (t15) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var q2 = new Set("0123456789ABCDEFabcdef");
var yL = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var Yc = new Set(",[]{}");
var bL = new Set(` ,[]{}
\r	`);
var Gd = (t15) => !t15 || bL.has(t15);
var xL = class {
  constructor() {
    this.atEnd = false, this.blockScalarIndent = -1, this.blockScalarKeep = false, this.buffer = "", this.flowKey = false, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, r = false) {
    if (e) {
      if (typeof e != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null;
    }
    this.atEnd = !r;
    let n = this.next ?? "stream";
    for (; n && (r || this.hasChars(1)); )
      n = yield* this.parseNext(n);
  }
  atLineEnd() {
    let e = this.pos, r = this.buffer[e];
    for (; r === " " || r === "	"; )
      r = this.buffer[++e];
    return !r || r === "#" || r === `
` ? true : r === "\r" ? this.buffer[e + 1] === `
` : false;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let r = this.buffer[e];
    if (this.indentNext > 0) {
      let n = 0;
      for (; r === " "; )
        r = this.buffer[++n + e];
      if (r === "\r") {
        const i = this.buffer[n + e + 1];
        if (i === `
` || !i && !this.atEnd)
          return e + n + 1;
      }
      return r === `
` || n >= this.indentNext || !r && !this.atEnd ? e + n : -1;
    }
    if (r === "-" || r === ".") {
      const n = this.buffer.substr(e, 3);
      if ((n === "---" || n === "...") && wn(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === y3 && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let r = e.length, n = e.indexOf("#");
      for (; n !== -1; ) {
        const s = e[n - 1];
        if (s === " " || s === "	") {
          r = n - 1;
          break;
        } else
          n = e.indexOf("#", n + 1);
      }
      for (; ; ) {
        const s = e[r - 1];
        if (s === " " || s === "	")
          r -= 1;
        else
          break;
      }
      const i = (yield* this.pushCount(r)) + (yield* this.pushSpaces(true));
      return yield* this.pushCount(e.length - i), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const r = yield* this.pushSpaces(true);
      return yield* this.pushCount(e.length - r), yield* this.pushNewline(), "stream";
    }
    return yield b3, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const r = this.peek(3);
      if ((r === "---" || r === "...") && wn(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, r === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(false), this.indentNext > this.indentValue && !wn(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, r] = this.peek(2);
    if (!r && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && wn(r)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let r = yield* this.pushIndicators();
    switch (e[r]) {
      case "#":
        yield* this.pushCount(e.length - r);
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = false, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(Gd), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return r += yield* this.parseBlockScalarHeader(), r += yield* this.pushSpaces(true), yield* this.pushCount(e.length - r), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, r, n = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (r = yield* this.pushSpaces(false), this.indentValue = n = r) : r = 0, r += yield* this.pushSpaces(true);
    while (e + r > 0);
    const i = this.getLine();
    if (i === null)
      return this.setNext("flow");
    if ((n !== -1 && n < this.indentNext && i[0] !== "#" || n === 0 && (i.startsWith("---") || i.startsWith("...")) && wn(i[3])) && !(n === this.indentNext - 1 && this.flowLevel === 1 && (i[0] === "]" || i[0] === "}")))
      return this.flowLevel = 0, yield x3, yield* this.parseLineStart();
    let s = 0;
    for (; i[s] === ","; )
      s += yield* this.pushCount(1), s += yield* this.pushSpaces(true), this.flowKey = false;
    switch (s += yield* this.pushIndicators(), i[s]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(i.length - s), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = false, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = true, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(Gd), "flow";
      case '"':
      case "'":
        return this.flowKey = true, yield* this.parseQuotedScalar();
      case ":": {
        const a = this.charAt(1);
        if (this.flowKey || wn(a) || a === ",")
          return this.flowKey = false, yield* this.pushCount(1), yield* this.pushSpaces(true), "flow";
      }
      default:
        return this.flowKey = false, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let r = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; r !== -1 && this.buffer[r + 1] === "'"; )
        r = this.buffer.indexOf("'", r + 2);
    else
      for (; r !== -1; ) {
        let s = 0;
        for (; this.buffer[r - 1 - s] === "\\"; )
          s += 1;
        if (s % 2 === 0)
          break;
        r = this.buffer.indexOf('"', r + 1);
      }
    const n = this.buffer.substring(0, r);
    let i = n.indexOf(`
`, this.pos);
    if (i !== -1) {
      for (; i !== -1; ) {
        const s = this.continueScalar(i + 1);
        if (s === -1)
          break;
        i = n.indexOf(`
`, s);
      }
      i !== -1 && (r = i - (n[i - 1] === "\r" ? 2 : 1));
    }
    if (r === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      r = this.buffer.length;
    }
    return yield* this.pushToIndex(r + 1, false), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = false;
    let e = this.pos;
    for (; ; ) {
      const r = this.buffer[++e];
      if (r === "+")
        this.blockScalarKeep = true;
      else if (r > "0" && r <= "9")
        this.blockScalarIndent = Number(r) - 1;
      else if (r !== "-")
        break;
    }
    return yield* this.pushUntil((r) => wn(r) || r === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, r = 0, n;
    t: for (let s = this.pos; n = this.buffer[s]; ++s)
      switch (n) {
        case " ":
          r += 1;
          break;
        case `
`:
          e = s, r = 0;
          break;
        case "\r": {
          const a = this.buffer[s + 1];
          if (!a && !this.atEnd)
            return this.setNext("block-scalar");
          if (a === `
`)
            break;
        }
        default:
          break t;
      }
    if (!n && !this.atEnd)
      return this.setNext("block-scalar");
    if (r >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = r : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const s = this.continueScalar(e + 1);
        if (s === -1)
          break;
        e = this.buffer.indexOf(`
`, s);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    let i = e + 1;
    for (n = this.buffer[i]; n === " "; )
      n = this.buffer[++i];
    if (n === "	") {
      for (; n === "	" || n === " " || n === "\r" || n === `
`; )
        n = this.buffer[++i];
      e = i - 1;
    } else if (!this.blockScalarKeep)
      do {
        let s = e - 1, a = this.buffer[s];
        a === "\r" && (a = this.buffer[--s]);
        const o = s;
        for (; a === " "; )
          a = this.buffer[--s];
        if (a === `
` && s >= this.pos && s + 1 + r > o)
          e = s;
        else
          break;
      } while (true);
    return yield sf, yield* this.pushToIndex(e + 1, true), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let r = this.pos - 1, n = this.pos - 1, i;
    for (; i = this.buffer[++n]; )
      if (i === ":") {
        const s = this.buffer[n + 1];
        if (wn(s) || e && Yc.has(s))
          break;
        r = n;
      } else if (wn(i)) {
        let s = this.buffer[n + 1];
        if (i === "\r" && (s === `
` ? (n += 1, i = `
`, s = this.buffer[n + 1]) : r = n), s === "#" || e && Yc.has(s))
          break;
        if (i === `
`) {
          const a = this.continueScalar(n + 1);
          if (a === -1)
            break;
          n = Math.max(n, a - 2);
        }
      } else {
        if (e && Yc.has(i))
          break;
        r = n;
      }
    return !i && !this.atEnd ? this.setNext("plain-scalar") : (yield sf, yield* this.pushToIndex(r + 1, true), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, r) {
    const n = this.buffer.slice(this.pos, e);
    return n ? (yield n, this.pos += n.length, n.length) : (r && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(Gd)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const e = this.flowLevel > 0, r = this.charAt(1);
        if (wn(r) || e && Yc.has(r))
          return e ? this.flowKey && (this.flowKey = false) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, r = this.buffer[e];
      for (; !wn(r) && r !== ">"; )
        r = this.buffer[++e];
      return yield* this.pushToIndex(r === ">" ? e + 1 : e, false);
    } else {
      let e = this.pos + 1, r = this.buffer[e];
      for (; r; )
        if (yL.has(r))
          r = this.buffer[++e];
        else if (r === "%" && q2.has(this.buffer[e + 1]) && q2.has(this.buffer[e + 2]))
          r = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, false);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let r = this.pos - 1, n;
    do
      n = this.buffer[++r];
    while (n === " " || e && n === "	");
    const i = r - this.pos;
    return i > 0 && (yield this.buffer.substr(this.pos, i), this.pos = r), i;
  }
  *pushUntil(e) {
    let r = this.pos, n = this.buffer[r];
    for (; !e(n); )
      n = this.buffer[++r];
    return yield* this.pushToIndex(r, false);
  }
};
var wL = class {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let r = 0, n = this.lineStarts.length;
      for (; r < n; ) {
        const s = r + n >> 1;
        this.lineStarts[s] < e ? r = s + 1 : n = s;
      }
      if (this.lineStarts[r] === e)
        return { line: r + 1, col: 1 };
      if (r === 0)
        return { line: 0, col: e };
      const i = this.lineStarts[r - 1];
      return { line: r, col: e - i + 1 };
    };
  }
};
function Gi(t15, e) {
  for (let r = 0; r < t15.length; ++r)
    if (t15[r].type === e)
      return true;
  return false;
}
function R2(t15) {
  for (let e = 0; e < t15.length; ++e)
    switch (t15[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function w3(t15) {
  switch (t15 == null ? void 0 : t15.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function Kc(t15) {
  switch (t15.type) {
    case "document":
      return t15.start;
    case "block-map": {
      const e = t15.items[t15.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return t15.items[t15.items.length - 1].start;
    default:
      return [];
  }
}
function wa(t15) {
  var _a3;
  if (t15.length === 0)
    return [];
  let e = t15.length;
  t: for (; --e >= 0; )
    switch (t15[e].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break t;
    }
  for (; ((_a3 = t15[++e]) == null ? void 0 : _a3.type) === "space"; )
    ;
  return t15.splice(e, t15.length);
}
function P2(t15) {
  if (t15.start.type === "flow-seq-start")
    for (const e of t15.items)
      e.sep && !e.value && !Gi(e.start, "explicit-key-ind") && !Gi(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, w3(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
var kL = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = true, this.atScalar = false, this.indent = 0, this.offset = 0, this.onKeyLine = false, this.stack = [], this.source = "", this.type = "", this.lexer = new xL(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, r = false) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const n of this.lexer.lex(e, r))
      yield* this.next(n);
    r || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = false, yield* this.step(), this.offset += e.length;
      return;
    }
    const r = gL(e);
    if (r)
      if (r === "scalar")
        this.atNewLine = false, this.atScalar = true, this.type = "scalar";
      else {
        switch (this.type = r, yield* this.step(), r) {
          case "newline":
            this.atNewLine = true, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += e.length;
      }
    else {
      const n = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: n, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const r = e ?? this.stack.pop();
    if (!r)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield r;
    else {
      const n = this.peek(1);
      switch (r.type === "block-scalar" ? r.indent = "indent" in n ? n.indent : 0 : r.type === "flow-collection" && n.type === "document" && (r.indent = 0), r.type === "flow-collection" && P2(r), n.type) {
        case "document":
          n.value = r;
          break;
        case "block-scalar":
          n.props.push(r);
          break;
        case "block-map": {
          const i = n.items[n.items.length - 1];
          if (i.value) {
            n.items.push({ start: [], key: r, sep: [] }), this.onKeyLine = true;
            return;
          } else if (i.sep)
            i.value = r;
          else {
            Object.assign(i, { key: r, sep: [] }), this.onKeyLine = !i.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const i = n.items[n.items.length - 1];
          i.value ? n.items.push({ start: [], value: r }) : i.value = r;
          break;
        }
        case "flow-collection": {
          const i = n.items[n.items.length - 1];
          !i || i.value ? n.items.push({ start: [], key: r, sep: [] }) : i.sep ? i.value = r : Object.assign(i, { key: r, sep: [] });
          return;
        }
        default:
          yield* this.pop(), yield* this.pop(r);
      }
      if ((n.type === "document" || n.type === "block-map" || n.type === "block-seq") && (r.type === "block-map" || r.type === "block-seq")) {
        const i = r.items[r.items.length - 1];
        i && !i.sep && !i.value && i.start.length > 0 && R2(i.start) === -1 && (r.indent === 0 || i.start.every((s) => s.type !== "comment" || s.indent < r.indent)) && (n.type === "document" ? n.end = i.start : n.items.push({ start: i.start }), r.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        R2(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const r = this.startBlockValue(e);
    r ? this.stack.push(r) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const r = Kc(this.peek(2)), n = wa(r);
      let i;
      e.end ? (i = e.end, i.push(this.sourceToken), delete e.end) : i = [this.sourceToken];
      const s = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: n, key: e, sep: i }]
      };
      this.onKeyLine = true, this.stack[this.stack.length - 1] = s;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = true, this.indent = 0, this.onNewLine) {
          let r = this.source.indexOf(`
`) + 1;
          for (; r !== 0; )
            this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    var _a3, _b2, _c;
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = false, r.value) {
          const n = "end" in r.value ? r.value.end : void 0;
          ((_a3 = Array.isArray(n) ? n[n.length - 1] : void 0) == null ? void 0 : _a3.type) === "comment" ? n == null ? void 0 : n.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else if (r.sep)
          r.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const n = (_c = (_b2 = e.items[e.items.length - 2]) == null ? void 0 : _b2.value) == null ? void 0 : _c.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, r.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const n = !this.onKeyLine && this.indent === e.indent, i = n && (r.sep || r.explicitKey) && this.type !== "seq-item-ind";
      let s = [];
      if (i && r.sep && !r.value) {
        const a = [];
        for (let o = 0; o < r.sep.length; ++o) {
          const l = r.sep[o];
          switch (l.type) {
            case "newline":
              a.push(o);
              break;
            case "space":
              break;
            case "comment":
              l.indent > e.indent && (a.length = 0);
              break;
            default:
              a.length = 0;
          }
        }
        a.length >= 2 && (s = r.sep.splice(a[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          i || r.value ? (s.push(this.sourceToken), e.items.push({ start: s }), this.onKeyLine = true) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !r.sep && !r.explicitKey ? (r.start.push(this.sourceToken), r.explicitKey = true) : i || r.value ? (s.push(this.sourceToken), e.items.push({ start: s, explicitKey: true })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: true }]
          }), this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (r.explicitKey)
            if (r.sep)
              if (r.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Gi(r.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: s, key: null, sep: [this.sourceToken] }]
                });
              else if (w3(r.key) && !Gi(r.sep, "newline")) {
                const a = wa(r.start), o = r.key, l = r.sep;
                l.push(this.sourceToken), delete r.key, delete r.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: a, key: o, sep: l }]
                });
              } else s.length > 0 ? r.sep = r.sep.concat(s, this.sourceToken) : r.sep.push(this.sourceToken);
            else if (Gi(r.start, "newline"))
              Object.assign(r, { key: null, sep: [this.sourceToken] });
            else {
              const a = wa(r.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: a, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            r.sep ? r.value || i ? e.items.push({ start: s, key: null, sep: [this.sourceToken] }) : Gi(r.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const a = this.flowScalar(this.type);
          i || r.value ? (e.items.push({ start: s, key: a, sep: [] }), this.onKeyLine = true) : r.sep ? this.stack.push(a) : (Object.assign(r, { key: a, sep: [] }), this.onKeyLine = true);
          return;
        }
        default: {
          const a = this.startBlockValue(e);
          if (a) {
            if (a.type === "block-seq") {
              if (!r.explicitKey && r.sep && !Gi(r.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else n && e.items.push({ start: s });
            this.stack.push(a);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    var _a3, _b2, _c;
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (r.value) {
          const n = "end" in r.value ? r.value.end : void 0;
          ((_a3 = Array.isArray(n) ? n[n.length - 1] : void 0) == null ? void 0 : _a3.type) === "comment" ? n == null ? void 0 : n.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const n = (_c = (_b2 = e.items[e.items.length - 2]) == null ? void 0 : _b2.value) == null ? void 0 : _c.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, r.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (r.value || this.indent <= e.indent)
          break;
        r.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        r.value || Gi(r.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const n = this.startBlockValue(e);
      if (n) {
        this.stack.push(n);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const r = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let n;
      do
        yield* this.pop(), n = this.peek(1);
      while (n && n.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !r || r.sep ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !r || r.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !r || r.value ? e.items.push({ start: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          !r || r.value ? e.items.push({ start: [], key: i, sep: [] }) : r.sep ? this.stack.push(i) : Object.assign(r, { key: i, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const n = this.startBlockValue(e);
      n ? this.stack.push(n) : (yield* this.pop(), yield* this.step());
    } else {
      const n = this.peek(2);
      if (n.type === "block-map" && (this.type === "map-value-ind" && n.indent === e.indent || this.type === "newline" && !n.items[n.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && n.type !== "flow-collection") {
        const i = Kc(n), s = wa(i);
        P2(e);
        const a = e.end.splice(1, e.end.length);
        a.push(this.sourceToken);
        const o = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: s, key: e, sep: a }]
        };
        this.onKeyLine = true, this.stack[this.stack.length - 1] = o;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let r = this.source.indexOf(`
`) + 1;
      for (; r !== 0; )
        this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const r = Kc(e), n = wa(r);
        return n.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const r = Kc(e), n = wa(r);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, r) {
    return this.type !== "comment" || this.indent <= r ? false : e.every((n) => n.type === "newline" || n.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
};
function vL(t15) {
  const e = t15.prettyErrors !== false;
  return { lineCounter: t15.lineCounter || e && new wL() || null, prettyErrors: e };
}
function CL(t15, e = {}) {
  const { lineCounter: r, prettyErrors: n } = vL(e), i = new kL(r == null ? void 0 : r.addNewLine), s = new mL(e);
  let a = null;
  for (const o of s.compose(i.parse(t15), true, t15.length))
    if (!a)
      a = o;
    else if (a.options.logLevel !== "silent") {
      a.errors.push(new tl(o.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return n && r && (a.errors.forEach(I2(t15, r)), a.warnings.forEach(I2(t15, r))), a;
}
function _L(t15, e, r) {
  let n;
  const i = CL(t15, r);
  if (!i)
    return null;
  if (i.warnings.forEach((s) => jx(i.options.logLevel, s)), i.errors.length > 0) {
    if (i.options.logLevel !== "silent")
      throw i.errors[0];
    i.errors = [];
  }
  return i.toJS(Object.assign({ reviver: n }, r));
}
function SL(t15) {
  return t15 && t15.__esModule && Object.prototype.hasOwnProperty.call(t15, "default") ? t15.default : t15;
}
var ka = {};
var af = { exports: {} };
var AL = af.exports;
var j2;
function TL() {
  return j2 || (j2 = 1, function(t15, e) {
    (function(r, n) {
      t15.exports = n();
    })(typeof self < "u" ? self : AL, function() {
      return (
        /******/
        function() {
          var r = {};
          (function() {
            r.d = function(d, u) {
              for (var f in u)
                r.o(u, f) && !r.o(d, f) && Object.defineProperty(d, f, { enumerable: true, get: u[f] });
            };
          })(), function() {
            r.o = function(d, u) {
              return Object.prototype.hasOwnProperty.call(d, u);
            };
          }();
          var n = {};
          r.d(n, {
            default: function() {
              return (
                /* binding */
                n_
              );
            }
          });
          class i {
            // Error start position based on passed-in Token or ParseNode.
            // Length of affected text based on passed-in Token or ParseNode.
            // The underlying error message without any context added.
            constructor(u, f) {
              this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
              let b = "KaTeX parse error: " + u, w, S;
              const E = f && f.loc;
              if (E && E.start <= E.end) {
                const P = E.lexer.input;
                w = E.start, S = E.end, w === P.length ? b += " at end of input: " : b += " at position " + (w + 1) + ": ";
                const J = P.slice(w, S).replace(/[^]/g, "$&̲");
                let nt;
                w > 15 ? nt = "…" + P.slice(w - 15, w) : nt = P.slice(0, w);
                let it;
                S + 15 < P.length ? it = P.slice(S, S + 15) + "…" : it = P.slice(S), b += nt + J + it;
              }
              const D = new Error(b);
              return D.name = "ParseError", D.__proto__ = i.prototype, D.position = w, w != null && S != null && (D.length = S - w), D.rawMessage = u, D;
            }
          }
          i.prototype.__proto__ = Error.prototype;
          var s = i;
          const a = function(d, u) {
            return d.indexOf(u) !== -1;
          }, o = function(d, u) {
            return d === void 0 ? u : d;
          }, l = /([A-Z])/g, c = function(d) {
            return d.replace(l, "-$1").toLowerCase();
          }, h = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;",
            "'": "&#x27;"
          }, p = /[&><"']/g;
          function m(d) {
            return String(d).replace(p, (u) => h[u]);
          }
          const g = function(d) {
            return d.type === "ordgroup" || d.type === "color" ? d.body.length === 1 ? g(d.body[0]) : d : d.type === "font" ? g(d.body) : d;
          }, y = function(d) {
            const u = g(d);
            return u.type === "mathord" || u.type === "textord" || u.type === "atom";
          }, x = function(d) {
            if (!d)
              throw new Error("Expected non-null, but got " + String(d));
            return d;
          };
          var k = {
            contains: a,
            deflt: o,
            escape: m,
            hyphenate: c,
            getBaseElem: g,
            isCharacterBox: y,
            protocolFromUrl: function(d) {
              const u = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(d);
              return u ? u[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(u[1]) ? null : u[1].toLowerCase() : "_relative";
            }
          };
          const C = {
            displayMode: {
              type: "boolean",
              description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
              cli: "-d, --display-mode"
            },
            output: {
              type: {
                enum: ["htmlAndMathml", "html", "mathml"]
              },
              description: "Determines the markup language of the output.",
              cli: "-F, --format <type>"
            },
            leqno: {
              type: "boolean",
              description: "Render display math in leqno style (left-justified tags)."
            },
            fleqn: {
              type: "boolean",
              description: "Render display math flush left."
            },
            throwOnError: {
              type: "boolean",
              default: true,
              cli: "-t, --no-throw-on-error",
              cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
            },
            errorColor: {
              type: "string",
              default: "#cc0000",
              cli: "-c, --error-color <color>",
              cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
              cliProcessor: (d) => "#" + d
            },
            macros: {
              type: "object",
              cli: "-m, --macro <def>",
              cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
              cliDefault: [],
              cliProcessor: (d, u) => (u.push(d), u)
            },
            minRuleThickness: {
              type: "number",
              description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
              processor: (d) => Math.max(0, d),
              cli: "--min-rule-thickness <size>",
              cliProcessor: parseFloat
            },
            colorIsTextColor: {
              type: "boolean",
              description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
              cli: "-b, --color-is-text-color"
            },
            strict: {
              type: [{
                enum: ["warn", "ignore", "error"]
              }, "boolean", "function"],
              description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
              cli: "-S, --strict",
              cliDefault: false
            },
            trust: {
              type: ["boolean", "function"],
              description: "Trust the input, enabling all HTML features such as \\url.",
              cli: "-T, --trust"
            },
            maxSize: {
              type: "number",
              default: 1 / 0,
              description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
              processor: (d) => Math.max(0, d),
              cli: "-s, --max-size <n>",
              cliProcessor: parseInt
            },
            maxExpand: {
              type: "number",
              default: 1e3,
              description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
              processor: (d) => Math.max(0, d),
              cli: "-e, --max-expand <n>",
              cliProcessor: (d) => d === "Infinity" ? 1 / 0 : parseInt(d)
            },
            globalGroup: {
              type: "boolean",
              cli: false
            }
          };
          function A(d) {
            if (d.default)
              return d.default;
            const u = d.type, f = Array.isArray(u) ? u[0] : u;
            if (typeof f != "string")
              return f.enum[0];
            switch (f) {
              case "boolean":
                return false;
              case "string":
                return "";
              case "number":
                return 0;
              case "object":
                return {};
            }
          }
          class $ {
            constructor(u) {
              this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, u = u || {};
              for (const f in C)
                if (C.hasOwnProperty(f)) {
                  const b = C[f];
                  this[f] = u[f] !== void 0 ? b.processor ? b.processor(u[f]) : u[f] : A(b);
                }
            }
            /**
             * Report nonstrict (non-LaTeX-compatible) input.
             * Can safely not be called if `this.strict` is false in JavaScript.
             */
            reportNonstrict(u, f, b) {
              let w = this.strict;
              if (typeof w == "function" && (w = w(u, f, b)), !(!w || w === "ignore")) {
                if (w === true || w === "error")
                  throw new s("LaTeX-incompatible input and strict mode is set to 'error': " + (f + " [" + u + "]"), b);
                w === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (f + " [" + u + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + w + "': " + f + " [" + u + "]"));
              }
            }
            /**
             * Check whether to apply strict (LaTeX-adhering) behavior for unusual
             * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
             * instead, "error" translates to a return value of `true`, while "ignore"
             * translates to a return value of `false`.  May still print a warning:
             * "warn" prints a warning and returns `false`.
             * This is for the second category of `errorCode`s listed in the README.
             */
            useStrictBehavior(u, f, b) {
              let w = this.strict;
              if (typeof w == "function")
                try {
                  w = w(u, f, b);
                } catch {
                  w = "error";
                }
              return !w || w === "ignore" ? false : w === true || w === "error" ? true : w === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (f + " [" + u + "]")), false) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + w + "': " + f + " [" + u + "]")), false);
            }
            /**
             * Check whether to test potentially dangerous input, and return
             * `true` (trusted) or `false` (untrusted).  The sole argument `context`
             * should be an object with `command` field specifying the relevant LaTeX
             * command (as a string starting with `\`), and any other arguments, etc.
             * If `context` has a `url` field, a `protocol` field will automatically
             * get added by this function (changing the specified object).
             */
            isTrusted(u) {
              if (u.url && !u.protocol) {
                const f = k.protocolFromUrl(u.url);
                if (f == null)
                  return false;
                u.protocol = f;
              }
              return !!(typeof this.trust == "function" ? this.trust(u) : this.trust);
            }
          }
          class B {
            constructor(u, f, b) {
              this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = u, this.size = f, this.cramped = b;
            }
            /**
             * Get the style of a superscript given a base in the current style.
             */
            sup() {
              return rt[I[this.id]];
            }
            /**
             * Get the style of a subscript given a base in the current style.
             */
            sub() {
              return rt[j[this.id]];
            }
            /**
             * Get the style of a fraction numerator given the fraction in the current
             * style.
             */
            fracNum() {
              return rt[z[this.id]];
            }
            /**
             * Get the style of a fraction denominator given the fraction in the current
             * style.
             */
            fracDen() {
              return rt[K[this.id]];
            }
            /**
             * Get the cramped version of a style (in particular, cramping a cramped style
             * doesn't change the style).
             */
            cramp() {
              return rt[Y[this.id]];
            }
            /**
             * Get a text or display version of this style.
             */
            text() {
              return rt[ot[this.id]];
            }
            /**
             * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
             */
            isTight() {
              return this.size >= 2;
            }
          }
          const L = 0, q = 1, U = 2, G = 3, F = 4, W = 5, R = 6, Q = 7, rt = [new B(L, 0, false), new B(q, 0, true), new B(U, 1, false), new B(G, 1, true), new B(F, 2, false), new B(W, 2, true), new B(R, 3, false), new B(Q, 3, true)], I = [F, W, F, W, R, Q, R, Q], j = [W, W, W, W, Q, Q, Q, Q], z = [U, G, F, W, R, Q, R, Q], K = [G, G, W, W, Q, Q, Q, Q], Y = [q, q, G, G, W, W, Q, Q], ot = [L, q, U, G, U, G, U, G];
          var et = {
            DISPLAY: rt[L],
            TEXT: rt[U],
            SCRIPT: rt[F],
            SCRIPTSCRIPT: rt[R]
          };
          const ht = [{
            // Latin characters beyond the Latin-1 characters we have metrics for.
            // Needed for Czech, Hungarian and Turkish text, for example.
            name: "latin",
            blocks: [
              [256, 591],
              // Latin Extended-A and Latin Extended-B
              [768, 879]
              // Combining Diacritical marks
            ]
          }, {
            // The Cyrillic script used by Russian and related languages.
            // A Cyrillic subset used to be supported as explicitly defined
            // symbols in symbols.js
            name: "cyrillic",
            blocks: [[1024, 1279]]
          }, {
            // Armenian
            name: "armenian",
            blocks: [[1328, 1423]]
          }, {
            // The Brahmic scripts of South and Southeast Asia
            // Devanagari (0900–097F)
            // Bengali (0980–09FF)
            // Gurmukhi (0A00–0A7F)
            // Gujarati (0A80–0AFF)
            // Oriya (0B00–0B7F)
            // Tamil (0B80–0BFF)
            // Telugu (0C00–0C7F)
            // Kannada (0C80–0CFF)
            // Malayalam (0D00–0D7F)
            // Sinhala (0D80–0DFF)
            // Thai (0E00–0E7F)
            // Lao (0E80–0EFF)
            // Tibetan (0F00–0FFF)
            // Myanmar (1000–109F)
            name: "brahmic",
            blocks: [[2304, 4255]]
          }, {
            name: "georgian",
            blocks: [[4256, 4351]]
          }, {
            // Chinese and Japanese.
            // The "k" in cjk is for Korean, but we've separated Korean out
            name: "cjk",
            blocks: [
              [12288, 12543],
              // CJK symbols and punctuation, Hiragana, Katakana
              [19968, 40879],
              // CJK ideograms
              [65280, 65376]
              // Fullwidth punctuation
              // TODO: add halfwidth Katakana and Romanji glyphs
            ]
          }, {
            // Korean
            name: "hangul",
            blocks: [[44032, 55215]]
          }];
          function X(d) {
            for (let u = 0; u < ht.length; u++) {
              const f = ht[u];
              for (let b = 0; b < f.blocks.length; b++) {
                const w = f.blocks[b];
                if (d >= w[0] && d <= w[1])
                  return f.name;
              }
            }
            return null;
          }
          const ct = [];
          ht.forEach((d) => d.blocks.forEach((u) => ct.push(...u)));
          function gt(d) {
            for (let u = 0; u < ct.length; u += 2)
              if (d >= ct[u] && d <= ct[u + 1])
                return true;
            return false;
          }
          const xt = 80, Xt = function(d, u) {
            return "M95," + (622 + d + u) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + d / 2.075 + " -" + d + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + d) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + d) + " " + u + "h400000v" + (40 + d) + "h-400000z";
          }, H = function(d, u) {
            return "M263," + (601 + d + u) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + d / 2.084 + " -" + d + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + d) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + d) + " " + u + "h400000v" + (40 + d) + "h-400000z";
          }, mt = function(d, u) {
            return "M983 " + (10 + d + u) + `
l` + d / 3.13 + " -" + d + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + d) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + d) + " " + u + "h400000v" + (40 + d) + "h-400000z";
          }, wt = function(d, u) {
            return "M424," + (2398 + d + u) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + d / 4.223 + " -" + d + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + d) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + d) + " " + u + `
h400000v` + (40 + d) + "h-400000z";
          }, At = function(d, u) {
            return "M473," + (2713 + d + u) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + d / 5.298 + " -" + d + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + d) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + d) + " " + u + "h400000v" + (40 + d) + "H1017.7z";
          }, Ht = function(d) {
            const u = d / 2;
            return "M400000 " + d + " H0 L" + u + " 0 l65 45 L145 " + (d - 80) + " H400000z";
          }, Ce = function(d, u, f) {
            const b = f - 54 - u - d;
            return "M702 " + (d + u) + "H400000" + (40 + d) + `
H742v` + b + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + u + "H400000v" + (40 + d) + "H742z";
          }, he = function(d, u, f) {
            u = 1e3 * u;
            let b = "";
            switch (d) {
              case "sqrtMain":
                b = Xt(u, xt);
                break;
              case "sqrtSize1":
                b = H(u, xt);
                break;
              case "sqrtSize2":
                b = mt(u, xt);
                break;
              case "sqrtSize3":
                b = wt(u, xt);
                break;
              case "sqrtSize4":
                b = At(u, xt);
                break;
              case "sqrtTall":
                b = Ce(u, xt, f);
            }
            return b;
          }, ni = function(d, u) {
            switch (d) {
              case "⎜":
                return "M291 0 H417 V" + u + " H291z M291 0 H417 V" + u + " H291z";
              case "∣":
                return "M145 0 H188 V" + u + " H145z M145 0 H188 V" + u + " H145z";
              case "∥":
                return "M145 0 H188 V" + u + " H145z M145 0 H188 V" + u + " H145z" + ("M367 0 H410 V" + u + " H367z M367 0 H410 V" + u + " H367z");
              case "⎟":
                return "M457 0 H583 V" + u + " H457z M457 0 H583 V" + u + " H457z";
              case "⎢":
                return "M319 0 H403 V" + u + " H319z M319 0 H403 V" + u + " H319z";
              case "⎥":
                return "M263 0 H347 V" + u + " H263z M263 0 H347 V" + u + " H263z";
              case "⎪":
                return "M384 0 H504 V" + u + " H384z M384 0 H504 V" + u + " H384z";
              case "⏐":
                return "M312 0 H355 V" + u + " H312z M312 0 H355 V" + u + " H312z";
              case "‖":
                return "M257 0 H300 V" + u + " H257z M257 0 H300 V" + u + " H257z" + ("M478 0 H521 V" + u + " H478z M478 0 H521 V" + u + " H478z");
              default:
                return "";
            }
          }, ua = {
            // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
            doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
            // doublerightarrow is from glyph U+21D2 in font KaTeX Main
            doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
            // leftarrow is from glyph U+2190 in font KaTeX Main
            leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
            // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
            leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
            leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
            // overgroup is from the MnSymbol package (public domain)
            leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
            leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
            // Harpoons are from glyph U+21BD in font KaTeX Main
            leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
            leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
            leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
            leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
            // hook is from glyph U+21A9 in font KaTeX Main
            lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
            leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
            leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
            // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
            leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
            longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
            midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
            midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
            oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
            oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
            oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
            oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
            rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
            rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
            rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
            rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
            rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
            rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
            rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
            rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
            rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
            righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
            rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
            rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
            // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
            twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
            twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
            // tilde1 is a modified version of a glyph from the MnSymbol package
            tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
            // ditto tilde2, tilde3, & tilde4
            tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
            tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
            tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
            // vec is from glyph U+20D7 in font KaTeX Main
            vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
            // widehat1 is a modified version of a glyph from the MnSymbol package
            widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
            // ditto widehat2, widehat3, & widehat4
            widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            // widecheck paths are all inverted versions of widehat
            widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
            widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            // The next ten paths support reaction arrows from the mhchem package.
            // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
            // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
            baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
            // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
            rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
            // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
            // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
            baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
            rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
            shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
            shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
          }, wo = function(d, u) {
            switch (d) {
              case "lbrack":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + u + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + u + " v1759 h84z";
              case "rbrack":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + u + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + u + " v1759 h84z";
              case "vert":
                return "M145 15 v585 v" + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + u + " v585 h43z";
              case "doublevert":
                return "M145 15 v585 v" + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + u + ` v585 h43z
M367 15 v585 v` + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + u + " v585 h43z";
              case "lfloor":
                return "M319 602 V0 H403 V602 v" + u + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + u + " v1715 H319z";
              case "rfloor":
                return "M319 602 V0 H403 V602 v" + u + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + u + " v1715 H319z";
              case "lceil":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + u + ` v602 h84z
M403 1759 V0 H319 V1759 v` + u + " v602 h84z";
              case "rceil":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + u + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + u + " v602 h84z";
              case "lparen":
                return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (u + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (u + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
              case "rparen":
                return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (u + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (u + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
              default:
                throw new Error("Unknown stretchy delimiter.");
            }
          };
          class rn {
            // HtmlDomNode
            // Never used; needed for satisfying interface.
            constructor(u) {
              this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = u, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            /** Convert the fragment into a node. */
            toNode() {
              const u = document.createDocumentFragment();
              for (let f = 0; f < this.children.length; f++)
                u.appendChild(this.children[f].toNode());
              return u;
            }
            /** Convert the fragment into HTML markup. */
            toMarkup() {
              let u = "";
              for (let f = 0; f < this.children.length; f++)
                u += this.children[f].toMarkup();
              return u;
            }
            /**
             * Converts the math node into a string, similar to innerText. Applies to
             * MathDomNode's only.
             */
            toText() {
              const u = (f) => f.toText();
              return this.children.map(u).join("");
            }
          }
          var br = {
            "AMS-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.68889, 0, 0, 0.72222],
              66: [0, 0.68889, 0, 0, 0.66667],
              67: [0, 0.68889, 0, 0, 0.72222],
              68: [0, 0.68889, 0, 0, 0.72222],
              69: [0, 0.68889, 0, 0, 0.66667],
              70: [0, 0.68889, 0, 0, 0.61111],
              71: [0, 0.68889, 0, 0, 0.77778],
              72: [0, 0.68889, 0, 0, 0.77778],
              73: [0, 0.68889, 0, 0, 0.38889],
              74: [0.16667, 0.68889, 0, 0, 0.5],
              75: [0, 0.68889, 0, 0, 0.77778],
              76: [0, 0.68889, 0, 0, 0.66667],
              77: [0, 0.68889, 0, 0, 0.94445],
              78: [0, 0.68889, 0, 0, 0.72222],
              79: [0.16667, 0.68889, 0, 0, 0.77778],
              80: [0, 0.68889, 0, 0, 0.61111],
              81: [0.16667, 0.68889, 0, 0, 0.77778],
              82: [0, 0.68889, 0, 0, 0.72222],
              83: [0, 0.68889, 0, 0, 0.55556],
              84: [0, 0.68889, 0, 0, 0.66667],
              85: [0, 0.68889, 0, 0, 0.72222],
              86: [0, 0.68889, 0, 0, 0.72222],
              87: [0, 0.68889, 0, 0, 1],
              88: [0, 0.68889, 0, 0, 0.72222],
              89: [0, 0.68889, 0, 0, 0.72222],
              90: [0, 0.68889, 0, 0, 0.66667],
              107: [0, 0.68889, 0, 0, 0.55556],
              160: [0, 0, 0, 0, 0.25],
              165: [0, 0.675, 0.025, 0, 0.75],
              174: [0.15559, 0.69224, 0, 0, 0.94666],
              240: [0, 0.68889, 0, 0, 0.55556],
              295: [0, 0.68889, 0, 0, 0.54028],
              710: [0, 0.825, 0, 0, 2.33334],
              732: [0, 0.9, 0, 0, 2.33334],
              770: [0, 0.825, 0, 0, 2.33334],
              771: [0, 0.9, 0, 0, 2.33334],
              989: [0.08167, 0.58167, 0, 0, 0.77778],
              1008: [0, 0.43056, 0.04028, 0, 0.66667],
              8245: [0, 0.54986, 0, 0, 0.275],
              8463: [0, 0.68889, 0, 0, 0.54028],
              8487: [0, 0.68889, 0, 0, 0.72222],
              8498: [0, 0.68889, 0, 0, 0.55556],
              8502: [0, 0.68889, 0, 0, 0.66667],
              8503: [0, 0.68889, 0, 0, 0.44445],
              8504: [0, 0.68889, 0, 0, 0.66667],
              8513: [0, 0.68889, 0, 0, 0.63889],
              8592: [-0.03598, 0.46402, 0, 0, 0.5],
              8594: [-0.03598, 0.46402, 0, 0, 0.5],
              8602: [-0.13313, 0.36687, 0, 0, 1],
              8603: [-0.13313, 0.36687, 0, 0, 1],
              8606: [0.01354, 0.52239, 0, 0, 1],
              8608: [0.01354, 0.52239, 0, 0, 1],
              8610: [0.01354, 0.52239, 0, 0, 1.11111],
              8611: [0.01354, 0.52239, 0, 0, 1.11111],
              8619: [0, 0.54986, 0, 0, 1],
              8620: [0, 0.54986, 0, 0, 1],
              8621: [-0.13313, 0.37788, 0, 0, 1.38889],
              8622: [-0.13313, 0.36687, 0, 0, 1],
              8624: [0, 0.69224, 0, 0, 0.5],
              8625: [0, 0.69224, 0, 0, 0.5],
              8630: [0, 0.43056, 0, 0, 1],
              8631: [0, 0.43056, 0, 0, 1],
              8634: [0.08198, 0.58198, 0, 0, 0.77778],
              8635: [0.08198, 0.58198, 0, 0, 0.77778],
              8638: [0.19444, 0.69224, 0, 0, 0.41667],
              8639: [0.19444, 0.69224, 0, 0, 0.41667],
              8642: [0.19444, 0.69224, 0, 0, 0.41667],
              8643: [0.19444, 0.69224, 0, 0, 0.41667],
              8644: [0.1808, 0.675, 0, 0, 1],
              8646: [0.1808, 0.675, 0, 0, 1],
              8647: [0.1808, 0.675, 0, 0, 1],
              8648: [0.19444, 0.69224, 0, 0, 0.83334],
              8649: [0.1808, 0.675, 0, 0, 1],
              8650: [0.19444, 0.69224, 0, 0, 0.83334],
              8651: [0.01354, 0.52239, 0, 0, 1],
              8652: [0.01354, 0.52239, 0, 0, 1],
              8653: [-0.13313, 0.36687, 0, 0, 1],
              8654: [-0.13313, 0.36687, 0, 0, 1],
              8655: [-0.13313, 0.36687, 0, 0, 1],
              8666: [0.13667, 0.63667, 0, 0, 1],
              8667: [0.13667, 0.63667, 0, 0, 1],
              8669: [-0.13313, 0.37788, 0, 0, 1],
              8672: [-0.064, 0.437, 0, 0, 1.334],
              8674: [-0.064, 0.437, 0, 0, 1.334],
              8705: [0, 0.825, 0, 0, 0.5],
              8708: [0, 0.68889, 0, 0, 0.55556],
              8709: [0.08167, 0.58167, 0, 0, 0.77778],
              8717: [0, 0.43056, 0, 0, 0.42917],
              8722: [-0.03598, 0.46402, 0, 0, 0.5],
              8724: [0.08198, 0.69224, 0, 0, 0.77778],
              8726: [0.08167, 0.58167, 0, 0, 0.77778],
              8733: [0, 0.69224, 0, 0, 0.77778],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8737: [0, 0.69224, 0, 0, 0.72222],
              8738: [0.03517, 0.52239, 0, 0, 0.72222],
              8739: [0.08167, 0.58167, 0, 0, 0.22222],
              8740: [0.25142, 0.74111, 0, 0, 0.27778],
              8741: [0.08167, 0.58167, 0, 0, 0.38889],
              8742: [0.25142, 0.74111, 0, 0, 0.5],
              8756: [0, 0.69224, 0, 0, 0.66667],
              8757: [0, 0.69224, 0, 0, 0.66667],
              8764: [-0.13313, 0.36687, 0, 0, 0.77778],
              8765: [-0.13313, 0.37788, 0, 0, 0.77778],
              8769: [-0.13313, 0.36687, 0, 0, 0.77778],
              8770: [-0.03625, 0.46375, 0, 0, 0.77778],
              8774: [0.30274, 0.79383, 0, 0, 0.77778],
              8776: [-0.01688, 0.48312, 0, 0, 0.77778],
              8778: [0.08167, 0.58167, 0, 0, 0.77778],
              8782: [0.06062, 0.54986, 0, 0, 0.77778],
              8783: [0.06062, 0.54986, 0, 0, 0.77778],
              8785: [0.08198, 0.58198, 0, 0, 0.77778],
              8786: [0.08198, 0.58198, 0, 0, 0.77778],
              8787: [0.08198, 0.58198, 0, 0, 0.77778],
              8790: [0, 0.69224, 0, 0, 0.77778],
              8791: [0.22958, 0.72958, 0, 0, 0.77778],
              8796: [0.08198, 0.91667, 0, 0, 0.77778],
              8806: [0.25583, 0.75583, 0, 0, 0.77778],
              8807: [0.25583, 0.75583, 0, 0, 0.77778],
              8808: [0.25142, 0.75726, 0, 0, 0.77778],
              8809: [0.25142, 0.75726, 0, 0, 0.77778],
              8812: [0.25583, 0.75583, 0, 0, 0.5],
              8814: [0.20576, 0.70576, 0, 0, 0.77778],
              8815: [0.20576, 0.70576, 0, 0, 0.77778],
              8816: [0.30274, 0.79383, 0, 0, 0.77778],
              8817: [0.30274, 0.79383, 0, 0, 0.77778],
              8818: [0.22958, 0.72958, 0, 0, 0.77778],
              8819: [0.22958, 0.72958, 0, 0, 0.77778],
              8822: [0.1808, 0.675, 0, 0, 0.77778],
              8823: [0.1808, 0.675, 0, 0, 0.77778],
              8828: [0.13667, 0.63667, 0, 0, 0.77778],
              8829: [0.13667, 0.63667, 0, 0, 0.77778],
              8830: [0.22958, 0.72958, 0, 0, 0.77778],
              8831: [0.22958, 0.72958, 0, 0, 0.77778],
              8832: [0.20576, 0.70576, 0, 0, 0.77778],
              8833: [0.20576, 0.70576, 0, 0, 0.77778],
              8840: [0.30274, 0.79383, 0, 0, 0.77778],
              8841: [0.30274, 0.79383, 0, 0, 0.77778],
              8842: [0.13597, 0.63597, 0, 0, 0.77778],
              8843: [0.13597, 0.63597, 0, 0, 0.77778],
              8847: [0.03517, 0.54986, 0, 0, 0.77778],
              8848: [0.03517, 0.54986, 0, 0, 0.77778],
              8858: [0.08198, 0.58198, 0, 0, 0.77778],
              8859: [0.08198, 0.58198, 0, 0, 0.77778],
              8861: [0.08198, 0.58198, 0, 0, 0.77778],
              8862: [0, 0.675, 0, 0, 0.77778],
              8863: [0, 0.675, 0, 0, 0.77778],
              8864: [0, 0.675, 0, 0, 0.77778],
              8865: [0, 0.675, 0, 0, 0.77778],
              8872: [0, 0.69224, 0, 0, 0.61111],
              8873: [0, 0.69224, 0, 0, 0.72222],
              8874: [0, 0.69224, 0, 0, 0.88889],
              8876: [0, 0.68889, 0, 0, 0.61111],
              8877: [0, 0.68889, 0, 0, 0.61111],
              8878: [0, 0.68889, 0, 0, 0.72222],
              8879: [0, 0.68889, 0, 0, 0.72222],
              8882: [0.03517, 0.54986, 0, 0, 0.77778],
              8883: [0.03517, 0.54986, 0, 0, 0.77778],
              8884: [0.13667, 0.63667, 0, 0, 0.77778],
              8885: [0.13667, 0.63667, 0, 0, 0.77778],
              8888: [0, 0.54986, 0, 0, 1.11111],
              8890: [0.19444, 0.43056, 0, 0, 0.55556],
              8891: [0.19444, 0.69224, 0, 0, 0.61111],
              8892: [0.19444, 0.69224, 0, 0, 0.61111],
              8901: [0, 0.54986, 0, 0, 0.27778],
              8903: [0.08167, 0.58167, 0, 0, 0.77778],
              8905: [0.08167, 0.58167, 0, 0, 0.77778],
              8906: [0.08167, 0.58167, 0, 0, 0.77778],
              8907: [0, 0.69224, 0, 0, 0.77778],
              8908: [0, 0.69224, 0, 0, 0.77778],
              8909: [-0.03598, 0.46402, 0, 0, 0.77778],
              8910: [0, 0.54986, 0, 0, 0.76042],
              8911: [0, 0.54986, 0, 0, 0.76042],
              8912: [0.03517, 0.54986, 0, 0, 0.77778],
              8913: [0.03517, 0.54986, 0, 0, 0.77778],
              8914: [0, 0.54986, 0, 0, 0.66667],
              8915: [0, 0.54986, 0, 0, 0.66667],
              8916: [0, 0.69224, 0, 0, 0.66667],
              8918: [0.0391, 0.5391, 0, 0, 0.77778],
              8919: [0.0391, 0.5391, 0, 0, 0.77778],
              8920: [0.03517, 0.54986, 0, 0, 1.33334],
              8921: [0.03517, 0.54986, 0, 0, 1.33334],
              8922: [0.38569, 0.88569, 0, 0, 0.77778],
              8923: [0.38569, 0.88569, 0, 0, 0.77778],
              8926: [0.13667, 0.63667, 0, 0, 0.77778],
              8927: [0.13667, 0.63667, 0, 0, 0.77778],
              8928: [0.30274, 0.79383, 0, 0, 0.77778],
              8929: [0.30274, 0.79383, 0, 0, 0.77778],
              8934: [0.23222, 0.74111, 0, 0, 0.77778],
              8935: [0.23222, 0.74111, 0, 0, 0.77778],
              8936: [0.23222, 0.74111, 0, 0, 0.77778],
              8937: [0.23222, 0.74111, 0, 0, 0.77778],
              8938: [0.20576, 0.70576, 0, 0, 0.77778],
              8939: [0.20576, 0.70576, 0, 0, 0.77778],
              8940: [0.30274, 0.79383, 0, 0, 0.77778],
              8941: [0.30274, 0.79383, 0, 0, 0.77778],
              8994: [0.19444, 0.69224, 0, 0, 0.77778],
              8995: [0.19444, 0.69224, 0, 0, 0.77778],
              9416: [0.15559, 0.69224, 0, 0, 0.90222],
              9484: [0, 0.69224, 0, 0, 0.5],
              9488: [0, 0.69224, 0, 0, 0.5],
              9492: [0, 0.37788, 0, 0, 0.5],
              9496: [0, 0.37788, 0, 0, 0.5],
              9585: [0.19444, 0.68889, 0, 0, 0.88889],
              9586: [0.19444, 0.74111, 0, 0, 0.88889],
              9632: [0, 0.675, 0, 0, 0.77778],
              9633: [0, 0.675, 0, 0, 0.77778],
              9650: [0, 0.54986, 0, 0, 0.72222],
              9651: [0, 0.54986, 0, 0, 0.72222],
              9654: [0.03517, 0.54986, 0, 0, 0.77778],
              9660: [0, 0.54986, 0, 0, 0.72222],
              9661: [0, 0.54986, 0, 0, 0.72222],
              9664: [0.03517, 0.54986, 0, 0, 0.77778],
              9674: [0.11111, 0.69224, 0, 0, 0.66667],
              9733: [0.19444, 0.69224, 0, 0, 0.94445],
              10003: [0, 0.69224, 0, 0, 0.83334],
              10016: [0, 0.69224, 0, 0, 0.83334],
              10731: [0.11111, 0.69224, 0, 0, 0.66667],
              10846: [0.19444, 0.75583, 0, 0, 0.61111],
              10877: [0.13667, 0.63667, 0, 0, 0.77778],
              10878: [0.13667, 0.63667, 0, 0, 0.77778],
              10885: [0.25583, 0.75583, 0, 0, 0.77778],
              10886: [0.25583, 0.75583, 0, 0, 0.77778],
              10887: [0.13597, 0.63597, 0, 0, 0.77778],
              10888: [0.13597, 0.63597, 0, 0, 0.77778],
              10889: [0.26167, 0.75726, 0, 0, 0.77778],
              10890: [0.26167, 0.75726, 0, 0, 0.77778],
              10891: [0.48256, 0.98256, 0, 0, 0.77778],
              10892: [0.48256, 0.98256, 0, 0, 0.77778],
              10901: [0.13667, 0.63667, 0, 0, 0.77778],
              10902: [0.13667, 0.63667, 0, 0, 0.77778],
              10933: [0.25142, 0.75726, 0, 0, 0.77778],
              10934: [0.25142, 0.75726, 0, 0, 0.77778],
              10935: [0.26167, 0.75726, 0, 0, 0.77778],
              10936: [0.26167, 0.75726, 0, 0, 0.77778],
              10937: [0.26167, 0.75726, 0, 0, 0.77778],
              10938: [0.26167, 0.75726, 0, 0, 0.77778],
              10949: [0.25583, 0.75583, 0, 0, 0.77778],
              10950: [0.25583, 0.75583, 0, 0, 0.77778],
              10955: [0.28481, 0.79383, 0, 0, 0.77778],
              10956: [0.28481, 0.79383, 0, 0, 0.77778],
              57350: [0.08167, 0.58167, 0, 0, 0.22222],
              57351: [0.08167, 0.58167, 0, 0, 0.38889],
              57352: [0.08167, 0.58167, 0, 0, 0.77778],
              57353: [0, 0.43056, 0.04028, 0, 0.66667],
              57356: [0.25142, 0.75726, 0, 0, 0.77778],
              57357: [0.25142, 0.75726, 0, 0, 0.77778],
              57358: [0.41951, 0.91951, 0, 0, 0.77778],
              57359: [0.30274, 0.79383, 0, 0, 0.77778],
              57360: [0.30274, 0.79383, 0, 0, 0.77778],
              57361: [0.41951, 0.91951, 0, 0, 0.77778],
              57366: [0.25142, 0.75726, 0, 0, 0.77778],
              57367: [0.25142, 0.75726, 0, 0, 0.77778],
              57368: [0.25142, 0.75726, 0, 0, 0.77778],
              57369: [0.25142, 0.75726, 0, 0, 0.77778],
              57370: [0.13597, 0.63597, 0, 0, 0.77778],
              57371: [0.13597, 0.63597, 0, 0, 0.77778]
            },
            "Caligraphic-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.68333, 0, 0.19445, 0.79847],
              66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
              67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
              68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
              69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
              70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
              71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
              72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
              73: [0, 0.68333, 0.07382, 0, 0.54452],
              74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
              75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
              76: [0, 0.68333, 0, 0.13889, 0.68972],
              77: [0, 0.68333, 0, 0.13889, 1.2009],
              78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
              79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
              80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
              81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
              82: [0, 0.68333, 0, 0.08334, 0.8475],
              83: [0, 0.68333, 0.075, 0.13889, 0.60556],
              84: [0, 0.68333, 0.25417, 0, 0.54464],
              85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
              86: [0, 0.68333, 0.08222, 0, 0.61278],
              87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
              88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
              89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
              90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
              160: [0, 0, 0, 0, 0.25]
            },
            "Fraktur-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69141, 0, 0, 0.29574],
              34: [0, 0.69141, 0, 0, 0.21471],
              38: [0, 0.69141, 0, 0, 0.73786],
              39: [0, 0.69141, 0, 0, 0.21201],
              40: [0.24982, 0.74947, 0, 0, 0.38865],
              41: [0.24982, 0.74947, 0, 0, 0.38865],
              42: [0, 0.62119, 0, 0, 0.27764],
              43: [0.08319, 0.58283, 0, 0, 0.75623],
              44: [0, 0.10803, 0, 0, 0.27764],
              45: [0.08319, 0.58283, 0, 0, 0.75623],
              46: [0, 0.10803, 0, 0, 0.27764],
              47: [0.24982, 0.74947, 0, 0, 0.50181],
              48: [0, 0.47534, 0, 0, 0.50181],
              49: [0, 0.47534, 0, 0, 0.50181],
              50: [0, 0.47534, 0, 0, 0.50181],
              51: [0.18906, 0.47534, 0, 0, 0.50181],
              52: [0.18906, 0.47534, 0, 0, 0.50181],
              53: [0.18906, 0.47534, 0, 0, 0.50181],
              54: [0, 0.69141, 0, 0, 0.50181],
              55: [0.18906, 0.47534, 0, 0, 0.50181],
              56: [0, 0.69141, 0, 0, 0.50181],
              57: [0.18906, 0.47534, 0, 0, 0.50181],
              58: [0, 0.47534, 0, 0, 0.21606],
              59: [0.12604, 0.47534, 0, 0, 0.21606],
              61: [-0.13099, 0.36866, 0, 0, 0.75623],
              63: [0, 0.69141, 0, 0, 0.36245],
              65: [0, 0.69141, 0, 0, 0.7176],
              66: [0, 0.69141, 0, 0, 0.88397],
              67: [0, 0.69141, 0, 0, 0.61254],
              68: [0, 0.69141, 0, 0, 0.83158],
              69: [0, 0.69141, 0, 0, 0.66278],
              70: [0.12604, 0.69141, 0, 0, 0.61119],
              71: [0, 0.69141, 0, 0, 0.78539],
              72: [0.06302, 0.69141, 0, 0, 0.7203],
              73: [0, 0.69141, 0, 0, 0.55448],
              74: [0.12604, 0.69141, 0, 0, 0.55231],
              75: [0, 0.69141, 0, 0, 0.66845],
              76: [0, 0.69141, 0, 0, 0.66602],
              77: [0, 0.69141, 0, 0, 1.04953],
              78: [0, 0.69141, 0, 0, 0.83212],
              79: [0, 0.69141, 0, 0, 0.82699],
              80: [0.18906, 0.69141, 0, 0, 0.82753],
              81: [0.03781, 0.69141, 0, 0, 0.82699],
              82: [0, 0.69141, 0, 0, 0.82807],
              83: [0, 0.69141, 0, 0, 0.82861],
              84: [0, 0.69141, 0, 0, 0.66899],
              85: [0, 0.69141, 0, 0, 0.64576],
              86: [0, 0.69141, 0, 0, 0.83131],
              87: [0, 0.69141, 0, 0, 1.04602],
              88: [0, 0.69141, 0, 0, 0.71922],
              89: [0.18906, 0.69141, 0, 0, 0.83293],
              90: [0.12604, 0.69141, 0, 0, 0.60201],
              91: [0.24982, 0.74947, 0, 0, 0.27764],
              93: [0.24982, 0.74947, 0, 0, 0.27764],
              94: [0, 0.69141, 0, 0, 0.49965],
              97: [0, 0.47534, 0, 0, 0.50046],
              98: [0, 0.69141, 0, 0, 0.51315],
              99: [0, 0.47534, 0, 0, 0.38946],
              100: [0, 0.62119, 0, 0, 0.49857],
              101: [0, 0.47534, 0, 0, 0.40053],
              102: [0.18906, 0.69141, 0, 0, 0.32626],
              103: [0.18906, 0.47534, 0, 0, 0.5037],
              104: [0.18906, 0.69141, 0, 0, 0.52126],
              105: [0, 0.69141, 0, 0, 0.27899],
              106: [0, 0.69141, 0, 0, 0.28088],
              107: [0, 0.69141, 0, 0, 0.38946],
              108: [0, 0.69141, 0, 0, 0.27953],
              109: [0, 0.47534, 0, 0, 0.76676],
              110: [0, 0.47534, 0, 0, 0.52666],
              111: [0, 0.47534, 0, 0, 0.48885],
              112: [0.18906, 0.52396, 0, 0, 0.50046],
              113: [0.18906, 0.47534, 0, 0, 0.48912],
              114: [0, 0.47534, 0, 0, 0.38919],
              115: [0, 0.47534, 0, 0, 0.44266],
              116: [0, 0.62119, 0, 0, 0.33301],
              117: [0, 0.47534, 0, 0, 0.5172],
              118: [0, 0.52396, 0, 0, 0.5118],
              119: [0, 0.52396, 0, 0, 0.77351],
              120: [0.18906, 0.47534, 0, 0, 0.38865],
              121: [0.18906, 0.47534, 0, 0, 0.49884],
              122: [0.18906, 0.47534, 0, 0, 0.39054],
              160: [0, 0, 0, 0, 0.25],
              8216: [0, 0.69141, 0, 0, 0.21471],
              8217: [0, 0.69141, 0, 0, 0.21471],
              58112: [0, 0.62119, 0, 0, 0.49749],
              58113: [0, 0.62119, 0, 0, 0.4983],
              58114: [0.18906, 0.69141, 0, 0, 0.33328],
              58115: [0.18906, 0.69141, 0, 0, 0.32923],
              58116: [0.18906, 0.47534, 0, 0, 0.50343],
              58117: [0, 0.69141, 0, 0, 0.33301],
              58118: [0, 0.62119, 0, 0, 0.33409],
              58119: [0, 0.47534, 0, 0, 0.50073]
            },
            "Main-Bold": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.35],
              34: [0, 0.69444, 0, 0, 0.60278],
              35: [0.19444, 0.69444, 0, 0, 0.95833],
              36: [0.05556, 0.75, 0, 0, 0.575],
              37: [0.05556, 0.75, 0, 0, 0.95833],
              38: [0, 0.69444, 0, 0, 0.89444],
              39: [0, 0.69444, 0, 0, 0.31944],
              40: [0.25, 0.75, 0, 0, 0.44722],
              41: [0.25, 0.75, 0, 0, 0.44722],
              42: [0, 0.75, 0, 0, 0.575],
              43: [0.13333, 0.63333, 0, 0, 0.89444],
              44: [0.19444, 0.15556, 0, 0, 0.31944],
              45: [0, 0.44444, 0, 0, 0.38333],
              46: [0, 0.15556, 0, 0, 0.31944],
              47: [0.25, 0.75, 0, 0, 0.575],
              48: [0, 0.64444, 0, 0, 0.575],
              49: [0, 0.64444, 0, 0, 0.575],
              50: [0, 0.64444, 0, 0, 0.575],
              51: [0, 0.64444, 0, 0, 0.575],
              52: [0, 0.64444, 0, 0, 0.575],
              53: [0, 0.64444, 0, 0, 0.575],
              54: [0, 0.64444, 0, 0, 0.575],
              55: [0, 0.64444, 0, 0, 0.575],
              56: [0, 0.64444, 0, 0, 0.575],
              57: [0, 0.64444, 0, 0, 0.575],
              58: [0, 0.44444, 0, 0, 0.31944],
              59: [0.19444, 0.44444, 0, 0, 0.31944],
              60: [0.08556, 0.58556, 0, 0, 0.89444],
              61: [-0.10889, 0.39111, 0, 0, 0.89444],
              62: [0.08556, 0.58556, 0, 0, 0.89444],
              63: [0, 0.69444, 0, 0, 0.54305],
              64: [0, 0.69444, 0, 0, 0.89444],
              65: [0, 0.68611, 0, 0, 0.86944],
              66: [0, 0.68611, 0, 0, 0.81805],
              67: [0, 0.68611, 0, 0, 0.83055],
              68: [0, 0.68611, 0, 0, 0.88194],
              69: [0, 0.68611, 0, 0, 0.75555],
              70: [0, 0.68611, 0, 0, 0.72361],
              71: [0, 0.68611, 0, 0, 0.90416],
              72: [0, 0.68611, 0, 0, 0.9],
              73: [0, 0.68611, 0, 0, 0.43611],
              74: [0, 0.68611, 0, 0, 0.59444],
              75: [0, 0.68611, 0, 0, 0.90138],
              76: [0, 0.68611, 0, 0, 0.69166],
              77: [0, 0.68611, 0, 0, 1.09166],
              78: [0, 0.68611, 0, 0, 0.9],
              79: [0, 0.68611, 0, 0, 0.86388],
              80: [0, 0.68611, 0, 0, 0.78611],
              81: [0.19444, 0.68611, 0, 0, 0.86388],
              82: [0, 0.68611, 0, 0, 0.8625],
              83: [0, 0.68611, 0, 0, 0.63889],
              84: [0, 0.68611, 0, 0, 0.8],
              85: [0, 0.68611, 0, 0, 0.88472],
              86: [0, 0.68611, 0.01597, 0, 0.86944],
              87: [0, 0.68611, 0.01597, 0, 1.18888],
              88: [0, 0.68611, 0, 0, 0.86944],
              89: [0, 0.68611, 0.02875, 0, 0.86944],
              90: [0, 0.68611, 0, 0, 0.70277],
              91: [0.25, 0.75, 0, 0, 0.31944],
              92: [0.25, 0.75, 0, 0, 0.575],
              93: [0.25, 0.75, 0, 0, 0.31944],
              94: [0, 0.69444, 0, 0, 0.575],
              95: [0.31, 0.13444, 0.03194, 0, 0.575],
              97: [0, 0.44444, 0, 0, 0.55902],
              98: [0, 0.69444, 0, 0, 0.63889],
              99: [0, 0.44444, 0, 0, 0.51111],
              100: [0, 0.69444, 0, 0, 0.63889],
              101: [0, 0.44444, 0, 0, 0.52708],
              102: [0, 0.69444, 0.10903, 0, 0.35139],
              103: [0.19444, 0.44444, 0.01597, 0, 0.575],
              104: [0, 0.69444, 0, 0, 0.63889],
              105: [0, 0.69444, 0, 0, 0.31944],
              106: [0.19444, 0.69444, 0, 0, 0.35139],
              107: [0, 0.69444, 0, 0, 0.60694],
              108: [0, 0.69444, 0, 0, 0.31944],
              109: [0, 0.44444, 0, 0, 0.95833],
              110: [0, 0.44444, 0, 0, 0.63889],
              111: [0, 0.44444, 0, 0, 0.575],
              112: [0.19444, 0.44444, 0, 0, 0.63889],
              113: [0.19444, 0.44444, 0, 0, 0.60694],
              114: [0, 0.44444, 0, 0, 0.47361],
              115: [0, 0.44444, 0, 0, 0.45361],
              116: [0, 0.63492, 0, 0, 0.44722],
              117: [0, 0.44444, 0, 0, 0.63889],
              118: [0, 0.44444, 0.01597, 0, 0.60694],
              119: [0, 0.44444, 0.01597, 0, 0.83055],
              120: [0, 0.44444, 0, 0, 0.60694],
              121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
              122: [0, 0.44444, 0, 0, 0.51111],
              123: [0.25, 0.75, 0, 0, 0.575],
              124: [0.25, 0.75, 0, 0, 0.31944],
              125: [0.25, 0.75, 0, 0, 0.575],
              126: [0.35, 0.34444, 0, 0, 0.575],
              160: [0, 0, 0, 0, 0.25],
              163: [0, 0.69444, 0, 0, 0.86853],
              168: [0, 0.69444, 0, 0, 0.575],
              172: [0, 0.44444, 0, 0, 0.76666],
              176: [0, 0.69444, 0, 0, 0.86944],
              177: [0.13333, 0.63333, 0, 0, 0.89444],
              184: [0.17014, 0, 0, 0, 0.51111],
              198: [0, 0.68611, 0, 0, 1.04166],
              215: [0.13333, 0.63333, 0, 0, 0.89444],
              216: [0.04861, 0.73472, 0, 0, 0.89444],
              223: [0, 0.69444, 0, 0, 0.59722],
              230: [0, 0.44444, 0, 0, 0.83055],
              247: [0.13333, 0.63333, 0, 0, 0.89444],
              248: [0.09722, 0.54167, 0, 0, 0.575],
              305: [0, 0.44444, 0, 0, 0.31944],
              338: [0, 0.68611, 0, 0, 1.16944],
              339: [0, 0.44444, 0, 0, 0.89444],
              567: [0.19444, 0.44444, 0, 0, 0.35139],
              710: [0, 0.69444, 0, 0, 0.575],
              711: [0, 0.63194, 0, 0, 0.575],
              713: [0, 0.59611, 0, 0, 0.575],
              714: [0, 0.69444, 0, 0, 0.575],
              715: [0, 0.69444, 0, 0, 0.575],
              728: [0, 0.69444, 0, 0, 0.575],
              729: [0, 0.69444, 0, 0, 0.31944],
              730: [0, 0.69444, 0, 0, 0.86944],
              732: [0, 0.69444, 0, 0, 0.575],
              733: [0, 0.69444, 0, 0, 0.575],
              915: [0, 0.68611, 0, 0, 0.69166],
              916: [0, 0.68611, 0, 0, 0.95833],
              920: [0, 0.68611, 0, 0, 0.89444],
              923: [0, 0.68611, 0, 0, 0.80555],
              926: [0, 0.68611, 0, 0, 0.76666],
              928: [0, 0.68611, 0, 0, 0.9],
              931: [0, 0.68611, 0, 0, 0.83055],
              933: [0, 0.68611, 0, 0, 0.89444],
              934: [0, 0.68611, 0, 0, 0.83055],
              936: [0, 0.68611, 0, 0, 0.89444],
              937: [0, 0.68611, 0, 0, 0.83055],
              8211: [0, 0.44444, 0.03194, 0, 0.575],
              8212: [0, 0.44444, 0.03194, 0, 1.14999],
              8216: [0, 0.69444, 0, 0, 0.31944],
              8217: [0, 0.69444, 0, 0, 0.31944],
              8220: [0, 0.69444, 0, 0, 0.60278],
              8221: [0, 0.69444, 0, 0, 0.60278],
              8224: [0.19444, 0.69444, 0, 0, 0.51111],
              8225: [0.19444, 0.69444, 0, 0, 0.51111],
              8242: [0, 0.55556, 0, 0, 0.34444],
              8407: [0, 0.72444, 0.15486, 0, 0.575],
              8463: [0, 0.69444, 0, 0, 0.66759],
              8465: [0, 0.69444, 0, 0, 0.83055],
              8467: [0, 0.69444, 0, 0, 0.47361],
              8472: [0.19444, 0.44444, 0, 0, 0.74027],
              8476: [0, 0.69444, 0, 0, 0.83055],
              8501: [0, 0.69444, 0, 0, 0.70277],
              8592: [-0.10889, 0.39111, 0, 0, 1.14999],
              8593: [0.19444, 0.69444, 0, 0, 0.575],
              8594: [-0.10889, 0.39111, 0, 0, 1.14999],
              8595: [0.19444, 0.69444, 0, 0, 0.575],
              8596: [-0.10889, 0.39111, 0, 0, 1.14999],
              8597: [0.25, 0.75, 0, 0, 0.575],
              8598: [0.19444, 0.69444, 0, 0, 1.14999],
              8599: [0.19444, 0.69444, 0, 0, 1.14999],
              8600: [0.19444, 0.69444, 0, 0, 1.14999],
              8601: [0.19444, 0.69444, 0, 0, 1.14999],
              8636: [-0.10889, 0.39111, 0, 0, 1.14999],
              8637: [-0.10889, 0.39111, 0, 0, 1.14999],
              8640: [-0.10889, 0.39111, 0, 0, 1.14999],
              8641: [-0.10889, 0.39111, 0, 0, 1.14999],
              8656: [-0.10889, 0.39111, 0, 0, 1.14999],
              8657: [0.19444, 0.69444, 0, 0, 0.70277],
              8658: [-0.10889, 0.39111, 0, 0, 1.14999],
              8659: [0.19444, 0.69444, 0, 0, 0.70277],
              8660: [-0.10889, 0.39111, 0, 0, 1.14999],
              8661: [0.25, 0.75, 0, 0, 0.70277],
              8704: [0, 0.69444, 0, 0, 0.63889],
              8706: [0, 0.69444, 0.06389, 0, 0.62847],
              8707: [0, 0.69444, 0, 0, 0.63889],
              8709: [0.05556, 0.75, 0, 0, 0.575],
              8711: [0, 0.68611, 0, 0, 0.95833],
              8712: [0.08556, 0.58556, 0, 0, 0.76666],
              8715: [0.08556, 0.58556, 0, 0, 0.76666],
              8722: [0.13333, 0.63333, 0, 0, 0.89444],
              8723: [0.13333, 0.63333, 0, 0, 0.89444],
              8725: [0.25, 0.75, 0, 0, 0.575],
              8726: [0.25, 0.75, 0, 0, 0.575],
              8727: [-0.02778, 0.47222, 0, 0, 0.575],
              8728: [-0.02639, 0.47361, 0, 0, 0.575],
              8729: [-0.02639, 0.47361, 0, 0, 0.575],
              8730: [0.18, 0.82, 0, 0, 0.95833],
              8733: [0, 0.44444, 0, 0, 0.89444],
              8734: [0, 0.44444, 0, 0, 1.14999],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8739: [0.25, 0.75, 0, 0, 0.31944],
              8741: [0.25, 0.75, 0, 0, 0.575],
              8743: [0, 0.55556, 0, 0, 0.76666],
              8744: [0, 0.55556, 0, 0, 0.76666],
              8745: [0, 0.55556, 0, 0, 0.76666],
              8746: [0, 0.55556, 0, 0, 0.76666],
              8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
              8764: [-0.10889, 0.39111, 0, 0, 0.89444],
              8768: [0.19444, 0.69444, 0, 0, 0.31944],
              8771: [222e-5, 0.50222, 0, 0, 0.89444],
              8773: [0.027, 0.638, 0, 0, 0.894],
              8776: [0.02444, 0.52444, 0, 0, 0.89444],
              8781: [222e-5, 0.50222, 0, 0, 0.89444],
              8801: [222e-5, 0.50222, 0, 0, 0.89444],
              8804: [0.19667, 0.69667, 0, 0, 0.89444],
              8805: [0.19667, 0.69667, 0, 0, 0.89444],
              8810: [0.08556, 0.58556, 0, 0, 1.14999],
              8811: [0.08556, 0.58556, 0, 0, 1.14999],
              8826: [0.08556, 0.58556, 0, 0, 0.89444],
              8827: [0.08556, 0.58556, 0, 0, 0.89444],
              8834: [0.08556, 0.58556, 0, 0, 0.89444],
              8835: [0.08556, 0.58556, 0, 0, 0.89444],
              8838: [0.19667, 0.69667, 0, 0, 0.89444],
              8839: [0.19667, 0.69667, 0, 0, 0.89444],
              8846: [0, 0.55556, 0, 0, 0.76666],
              8849: [0.19667, 0.69667, 0, 0, 0.89444],
              8850: [0.19667, 0.69667, 0, 0, 0.89444],
              8851: [0, 0.55556, 0, 0, 0.76666],
              8852: [0, 0.55556, 0, 0, 0.76666],
              8853: [0.13333, 0.63333, 0, 0, 0.89444],
              8854: [0.13333, 0.63333, 0, 0, 0.89444],
              8855: [0.13333, 0.63333, 0, 0, 0.89444],
              8856: [0.13333, 0.63333, 0, 0, 0.89444],
              8857: [0.13333, 0.63333, 0, 0, 0.89444],
              8866: [0, 0.69444, 0, 0, 0.70277],
              8867: [0, 0.69444, 0, 0, 0.70277],
              8868: [0, 0.69444, 0, 0, 0.89444],
              8869: [0, 0.69444, 0, 0, 0.89444],
              8900: [-0.02639, 0.47361, 0, 0, 0.575],
              8901: [-0.02639, 0.47361, 0, 0, 0.31944],
              8902: [-0.02778, 0.47222, 0, 0, 0.575],
              8968: [0.25, 0.75, 0, 0, 0.51111],
              8969: [0.25, 0.75, 0, 0, 0.51111],
              8970: [0.25, 0.75, 0, 0, 0.51111],
              8971: [0.25, 0.75, 0, 0, 0.51111],
              8994: [-0.13889, 0.36111, 0, 0, 1.14999],
              8995: [-0.13889, 0.36111, 0, 0, 1.14999],
              9651: [0.19444, 0.69444, 0, 0, 1.02222],
              9657: [-0.02778, 0.47222, 0, 0, 0.575],
              9661: [0.19444, 0.69444, 0, 0, 1.02222],
              9667: [-0.02778, 0.47222, 0, 0, 0.575],
              9711: [0.19444, 0.69444, 0, 0, 1.14999],
              9824: [0.12963, 0.69444, 0, 0, 0.89444],
              9825: [0.12963, 0.69444, 0, 0, 0.89444],
              9826: [0.12963, 0.69444, 0, 0, 0.89444],
              9827: [0.12963, 0.69444, 0, 0, 0.89444],
              9837: [0, 0.75, 0, 0, 0.44722],
              9838: [0.19444, 0.69444, 0, 0, 0.44722],
              9839: [0.19444, 0.69444, 0, 0, 0.44722],
              10216: [0.25, 0.75, 0, 0, 0.44722],
              10217: [0.25, 0.75, 0, 0, 0.44722],
              10815: [0, 0.68611, 0, 0, 0.9],
              10927: [0.19667, 0.69667, 0, 0, 0.89444],
              10928: [0.19667, 0.69667, 0, 0, 0.89444],
              57376: [0.19444, 0.69444, 0, 0, 0]
            },
            "Main-BoldItalic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.11417, 0, 0.38611],
              34: [0, 0.69444, 0.07939, 0, 0.62055],
              35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
              37: [0.05556, 0.75, 0.12861, 0, 0.94444],
              38: [0, 0.69444, 0.08528, 0, 0.88555],
              39: [0, 0.69444, 0.12945, 0, 0.35555],
              40: [0.25, 0.75, 0.15806, 0, 0.47333],
              41: [0.25, 0.75, 0.03306, 0, 0.47333],
              42: [0, 0.75, 0.14333, 0, 0.59111],
              43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
              44: [0.19444, 0.14722, 0, 0, 0.35555],
              45: [0, 0.44444, 0.02611, 0, 0.41444],
              46: [0, 0.14722, 0, 0, 0.35555],
              47: [0.25, 0.75, 0.15806, 0, 0.59111],
              48: [0, 0.64444, 0.13167, 0, 0.59111],
              49: [0, 0.64444, 0.13167, 0, 0.59111],
              50: [0, 0.64444, 0.13167, 0, 0.59111],
              51: [0, 0.64444, 0.13167, 0, 0.59111],
              52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
              53: [0, 0.64444, 0.13167, 0, 0.59111],
              54: [0, 0.64444, 0.13167, 0, 0.59111],
              55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
              56: [0, 0.64444, 0.13167, 0, 0.59111],
              57: [0, 0.64444, 0.13167, 0, 0.59111],
              58: [0, 0.44444, 0.06695, 0, 0.35555],
              59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
              61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
              63: [0, 0.69444, 0.11472, 0, 0.59111],
              64: [0, 0.69444, 0.09208, 0, 0.88555],
              65: [0, 0.68611, 0, 0, 0.86555],
              66: [0, 0.68611, 0.0992, 0, 0.81666],
              67: [0, 0.68611, 0.14208, 0, 0.82666],
              68: [0, 0.68611, 0.09062, 0, 0.87555],
              69: [0, 0.68611, 0.11431, 0, 0.75666],
              70: [0, 0.68611, 0.12903, 0, 0.72722],
              71: [0, 0.68611, 0.07347, 0, 0.89527],
              72: [0, 0.68611, 0.17208, 0, 0.8961],
              73: [0, 0.68611, 0.15681, 0, 0.47166],
              74: [0, 0.68611, 0.145, 0, 0.61055],
              75: [0, 0.68611, 0.14208, 0, 0.89499],
              76: [0, 0.68611, 0, 0, 0.69777],
              77: [0, 0.68611, 0.17208, 0, 1.07277],
              78: [0, 0.68611, 0.17208, 0, 0.8961],
              79: [0, 0.68611, 0.09062, 0, 0.85499],
              80: [0, 0.68611, 0.0992, 0, 0.78721],
              81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
              82: [0, 0.68611, 0.02559, 0, 0.85944],
              83: [0, 0.68611, 0.11264, 0, 0.64999],
              84: [0, 0.68611, 0.12903, 0, 0.7961],
              85: [0, 0.68611, 0.17208, 0, 0.88083],
              86: [0, 0.68611, 0.18625, 0, 0.86555],
              87: [0, 0.68611, 0.18625, 0, 1.15999],
              88: [0, 0.68611, 0.15681, 0, 0.86555],
              89: [0, 0.68611, 0.19803, 0, 0.86555],
              90: [0, 0.68611, 0.14208, 0, 0.70888],
              91: [0.25, 0.75, 0.1875, 0, 0.35611],
              93: [0.25, 0.75, 0.09972, 0, 0.35611],
              94: [0, 0.69444, 0.06709, 0, 0.59111],
              95: [0.31, 0.13444, 0.09811, 0, 0.59111],
              97: [0, 0.44444, 0.09426, 0, 0.59111],
              98: [0, 0.69444, 0.07861, 0, 0.53222],
              99: [0, 0.44444, 0.05222, 0, 0.53222],
              100: [0, 0.69444, 0.10861, 0, 0.59111],
              101: [0, 0.44444, 0.085, 0, 0.53222],
              102: [0.19444, 0.69444, 0.21778, 0, 0.4],
              103: [0.19444, 0.44444, 0.105, 0, 0.53222],
              104: [0, 0.69444, 0.09426, 0, 0.59111],
              105: [0, 0.69326, 0.11387, 0, 0.35555],
              106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
              107: [0, 0.69444, 0.11111, 0, 0.53222],
              108: [0, 0.69444, 0.10861, 0, 0.29666],
              109: [0, 0.44444, 0.09426, 0, 0.94444],
              110: [0, 0.44444, 0.09426, 0, 0.64999],
              111: [0, 0.44444, 0.07861, 0, 0.59111],
              112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
              113: [0.19444, 0.44444, 0.105, 0, 0.53222],
              114: [0, 0.44444, 0.11111, 0, 0.50167],
              115: [0, 0.44444, 0.08167, 0, 0.48694],
              116: [0, 0.63492, 0.09639, 0, 0.385],
              117: [0, 0.44444, 0.09426, 0, 0.62055],
              118: [0, 0.44444, 0.11111, 0, 0.53222],
              119: [0, 0.44444, 0.11111, 0, 0.76777],
              120: [0, 0.44444, 0.12583, 0, 0.56055],
              121: [0.19444, 0.44444, 0.105, 0, 0.56166],
              122: [0, 0.44444, 0.13889, 0, 0.49055],
              126: [0.35, 0.34444, 0.11472, 0, 0.59111],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.69444, 0.11473, 0, 0.59111],
              176: [0, 0.69444, 0, 0, 0.94888],
              184: [0.17014, 0, 0, 0, 0.53222],
              198: [0, 0.68611, 0.11431, 0, 1.02277],
              216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
              223: [0.19444, 0.69444, 0.09736, 0, 0.665],
              230: [0, 0.44444, 0.085, 0, 0.82666],
              248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
              305: [0, 0.44444, 0.09426, 0, 0.35555],
              338: [0, 0.68611, 0.11431, 0, 1.14054],
              339: [0, 0.44444, 0.085, 0, 0.82666],
              567: [0.19444, 0.44444, 0.04611, 0, 0.385],
              710: [0, 0.69444, 0.06709, 0, 0.59111],
              711: [0, 0.63194, 0.08271, 0, 0.59111],
              713: [0, 0.59444, 0.10444, 0, 0.59111],
              714: [0, 0.69444, 0.08528, 0, 0.59111],
              715: [0, 0.69444, 0, 0, 0.59111],
              728: [0, 0.69444, 0.10333, 0, 0.59111],
              729: [0, 0.69444, 0.12945, 0, 0.35555],
              730: [0, 0.69444, 0, 0, 0.94888],
              732: [0, 0.69444, 0.11472, 0, 0.59111],
              733: [0, 0.69444, 0.11472, 0, 0.59111],
              915: [0, 0.68611, 0.12903, 0, 0.69777],
              916: [0, 0.68611, 0, 0, 0.94444],
              920: [0, 0.68611, 0.09062, 0, 0.88555],
              923: [0, 0.68611, 0, 0, 0.80666],
              926: [0, 0.68611, 0.15092, 0, 0.76777],
              928: [0, 0.68611, 0.17208, 0, 0.8961],
              931: [0, 0.68611, 0.11431, 0, 0.82666],
              933: [0, 0.68611, 0.10778, 0, 0.88555],
              934: [0, 0.68611, 0.05632, 0, 0.82666],
              936: [0, 0.68611, 0.10778, 0, 0.88555],
              937: [0, 0.68611, 0.0992, 0, 0.82666],
              8211: [0, 0.44444, 0.09811, 0, 0.59111],
              8212: [0, 0.44444, 0.09811, 0, 1.18221],
              8216: [0, 0.69444, 0.12945, 0, 0.35555],
              8217: [0, 0.69444, 0.12945, 0, 0.35555],
              8220: [0, 0.69444, 0.16772, 0, 0.62055],
              8221: [0, 0.69444, 0.07939, 0, 0.62055]
            },
            "Main-Italic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.12417, 0, 0.30667],
              34: [0, 0.69444, 0.06961, 0, 0.51444],
              35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
              37: [0.05556, 0.75, 0.13639, 0, 0.81777],
              38: [0, 0.69444, 0.09694, 0, 0.76666],
              39: [0, 0.69444, 0.12417, 0, 0.30667],
              40: [0.25, 0.75, 0.16194, 0, 0.40889],
              41: [0.25, 0.75, 0.03694, 0, 0.40889],
              42: [0, 0.75, 0.14917, 0, 0.51111],
              43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
              44: [0.19444, 0.10556, 0, 0, 0.30667],
              45: [0, 0.43056, 0.02826, 0, 0.35778],
              46: [0, 0.10556, 0, 0, 0.30667],
              47: [0.25, 0.75, 0.16194, 0, 0.51111],
              48: [0, 0.64444, 0.13556, 0, 0.51111],
              49: [0, 0.64444, 0.13556, 0, 0.51111],
              50: [0, 0.64444, 0.13556, 0, 0.51111],
              51: [0, 0.64444, 0.13556, 0, 0.51111],
              52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
              53: [0, 0.64444, 0.13556, 0, 0.51111],
              54: [0, 0.64444, 0.13556, 0, 0.51111],
              55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
              56: [0, 0.64444, 0.13556, 0, 0.51111],
              57: [0, 0.64444, 0.13556, 0, 0.51111],
              58: [0, 0.43056, 0.0582, 0, 0.30667],
              59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
              61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
              63: [0, 0.69444, 0.1225, 0, 0.51111],
              64: [0, 0.69444, 0.09597, 0, 0.76666],
              65: [0, 0.68333, 0, 0, 0.74333],
              66: [0, 0.68333, 0.10257, 0, 0.70389],
              67: [0, 0.68333, 0.14528, 0, 0.71555],
              68: [0, 0.68333, 0.09403, 0, 0.755],
              69: [0, 0.68333, 0.12028, 0, 0.67833],
              70: [0, 0.68333, 0.13305, 0, 0.65277],
              71: [0, 0.68333, 0.08722, 0, 0.77361],
              72: [0, 0.68333, 0.16389, 0, 0.74333],
              73: [0, 0.68333, 0.15806, 0, 0.38555],
              74: [0, 0.68333, 0.14028, 0, 0.525],
              75: [0, 0.68333, 0.14528, 0, 0.76888],
              76: [0, 0.68333, 0, 0, 0.62722],
              77: [0, 0.68333, 0.16389, 0, 0.89666],
              78: [0, 0.68333, 0.16389, 0, 0.74333],
              79: [0, 0.68333, 0.09403, 0, 0.76666],
              80: [0, 0.68333, 0.10257, 0, 0.67833],
              81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
              82: [0, 0.68333, 0.03868, 0, 0.72944],
              83: [0, 0.68333, 0.11972, 0, 0.56222],
              84: [0, 0.68333, 0.13305, 0, 0.71555],
              85: [0, 0.68333, 0.16389, 0, 0.74333],
              86: [0, 0.68333, 0.18361, 0, 0.74333],
              87: [0, 0.68333, 0.18361, 0, 0.99888],
              88: [0, 0.68333, 0.15806, 0, 0.74333],
              89: [0, 0.68333, 0.19383, 0, 0.74333],
              90: [0, 0.68333, 0.14528, 0, 0.61333],
              91: [0.25, 0.75, 0.1875, 0, 0.30667],
              93: [0.25, 0.75, 0.10528, 0, 0.30667],
              94: [0, 0.69444, 0.06646, 0, 0.51111],
              95: [0.31, 0.12056, 0.09208, 0, 0.51111],
              97: [0, 0.43056, 0.07671, 0, 0.51111],
              98: [0, 0.69444, 0.06312, 0, 0.46],
              99: [0, 0.43056, 0.05653, 0, 0.46],
              100: [0, 0.69444, 0.10333, 0, 0.51111],
              101: [0, 0.43056, 0.07514, 0, 0.46],
              102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
              103: [0.19444, 0.43056, 0.08847, 0, 0.46],
              104: [0, 0.69444, 0.07671, 0, 0.51111],
              105: [0, 0.65536, 0.1019, 0, 0.30667],
              106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
              107: [0, 0.69444, 0.10764, 0, 0.46],
              108: [0, 0.69444, 0.10333, 0, 0.25555],
              109: [0, 0.43056, 0.07671, 0, 0.81777],
              110: [0, 0.43056, 0.07671, 0, 0.56222],
              111: [0, 0.43056, 0.06312, 0, 0.51111],
              112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
              113: [0.19444, 0.43056, 0.08847, 0, 0.46],
              114: [0, 0.43056, 0.10764, 0, 0.42166],
              115: [0, 0.43056, 0.08208, 0, 0.40889],
              116: [0, 0.61508, 0.09486, 0, 0.33222],
              117: [0, 0.43056, 0.07671, 0, 0.53666],
              118: [0, 0.43056, 0.10764, 0, 0.46],
              119: [0, 0.43056, 0.10764, 0, 0.66444],
              120: [0, 0.43056, 0.12042, 0, 0.46389],
              121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
              122: [0, 0.43056, 0.12292, 0, 0.40889],
              126: [0.35, 0.31786, 0.11585, 0, 0.51111],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.66786, 0.10474, 0, 0.51111],
              176: [0, 0.69444, 0, 0, 0.83129],
              184: [0.17014, 0, 0, 0, 0.46],
              198: [0, 0.68333, 0.12028, 0, 0.88277],
              216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
              223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
              230: [0, 0.43056, 0.07514, 0, 0.71555],
              248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
              338: [0, 0.68333, 0.12028, 0, 0.98499],
              339: [0, 0.43056, 0.07514, 0, 0.71555],
              710: [0, 0.69444, 0.06646, 0, 0.51111],
              711: [0, 0.62847, 0.08295, 0, 0.51111],
              713: [0, 0.56167, 0.10333, 0, 0.51111],
              714: [0, 0.69444, 0.09694, 0, 0.51111],
              715: [0, 0.69444, 0, 0, 0.51111],
              728: [0, 0.69444, 0.10806, 0, 0.51111],
              729: [0, 0.66786, 0.11752, 0, 0.30667],
              730: [0, 0.69444, 0, 0, 0.83129],
              732: [0, 0.66786, 0.11585, 0, 0.51111],
              733: [0, 0.69444, 0.1225, 0, 0.51111],
              915: [0, 0.68333, 0.13305, 0, 0.62722],
              916: [0, 0.68333, 0, 0, 0.81777],
              920: [0, 0.68333, 0.09403, 0, 0.76666],
              923: [0, 0.68333, 0, 0, 0.69222],
              926: [0, 0.68333, 0.15294, 0, 0.66444],
              928: [0, 0.68333, 0.16389, 0, 0.74333],
              931: [0, 0.68333, 0.12028, 0, 0.71555],
              933: [0, 0.68333, 0.11111, 0, 0.76666],
              934: [0, 0.68333, 0.05986, 0, 0.71555],
              936: [0, 0.68333, 0.11111, 0, 0.76666],
              937: [0, 0.68333, 0.10257, 0, 0.71555],
              8211: [0, 0.43056, 0.09208, 0, 0.51111],
              8212: [0, 0.43056, 0.09208, 0, 1.02222],
              8216: [0, 0.69444, 0.12417, 0, 0.30667],
              8217: [0, 0.69444, 0.12417, 0, 0.30667],
              8220: [0, 0.69444, 0.1685, 0, 0.51444],
              8221: [0, 0.69444, 0.06961, 0, 0.51444],
              8463: [0, 0.68889, 0, 0, 0.54028]
            },
            "Main-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.27778],
              34: [0, 0.69444, 0, 0, 0.5],
              35: [0.19444, 0.69444, 0, 0, 0.83334],
              36: [0.05556, 0.75, 0, 0, 0.5],
              37: [0.05556, 0.75, 0, 0, 0.83334],
              38: [0, 0.69444, 0, 0, 0.77778],
              39: [0, 0.69444, 0, 0, 0.27778],
              40: [0.25, 0.75, 0, 0, 0.38889],
              41: [0.25, 0.75, 0, 0, 0.38889],
              42: [0, 0.75, 0, 0, 0.5],
              43: [0.08333, 0.58333, 0, 0, 0.77778],
              44: [0.19444, 0.10556, 0, 0, 0.27778],
              45: [0, 0.43056, 0, 0, 0.33333],
              46: [0, 0.10556, 0, 0, 0.27778],
              47: [0.25, 0.75, 0, 0, 0.5],
              48: [0, 0.64444, 0, 0, 0.5],
              49: [0, 0.64444, 0, 0, 0.5],
              50: [0, 0.64444, 0, 0, 0.5],
              51: [0, 0.64444, 0, 0, 0.5],
              52: [0, 0.64444, 0, 0, 0.5],
              53: [0, 0.64444, 0, 0, 0.5],
              54: [0, 0.64444, 0, 0, 0.5],
              55: [0, 0.64444, 0, 0, 0.5],
              56: [0, 0.64444, 0, 0, 0.5],
              57: [0, 0.64444, 0, 0, 0.5],
              58: [0, 0.43056, 0, 0, 0.27778],
              59: [0.19444, 0.43056, 0, 0, 0.27778],
              60: [0.0391, 0.5391, 0, 0, 0.77778],
              61: [-0.13313, 0.36687, 0, 0, 0.77778],
              62: [0.0391, 0.5391, 0, 0, 0.77778],
              63: [0, 0.69444, 0, 0, 0.47222],
              64: [0, 0.69444, 0, 0, 0.77778],
              65: [0, 0.68333, 0, 0, 0.75],
              66: [0, 0.68333, 0, 0, 0.70834],
              67: [0, 0.68333, 0, 0, 0.72222],
              68: [0, 0.68333, 0, 0, 0.76389],
              69: [0, 0.68333, 0, 0, 0.68056],
              70: [0, 0.68333, 0, 0, 0.65278],
              71: [0, 0.68333, 0, 0, 0.78472],
              72: [0, 0.68333, 0, 0, 0.75],
              73: [0, 0.68333, 0, 0, 0.36111],
              74: [0, 0.68333, 0, 0, 0.51389],
              75: [0, 0.68333, 0, 0, 0.77778],
              76: [0, 0.68333, 0, 0, 0.625],
              77: [0, 0.68333, 0, 0, 0.91667],
              78: [0, 0.68333, 0, 0, 0.75],
              79: [0, 0.68333, 0, 0, 0.77778],
              80: [0, 0.68333, 0, 0, 0.68056],
              81: [0.19444, 0.68333, 0, 0, 0.77778],
              82: [0, 0.68333, 0, 0, 0.73611],
              83: [0, 0.68333, 0, 0, 0.55556],
              84: [0, 0.68333, 0, 0, 0.72222],
              85: [0, 0.68333, 0, 0, 0.75],
              86: [0, 0.68333, 0.01389, 0, 0.75],
              87: [0, 0.68333, 0.01389, 0, 1.02778],
              88: [0, 0.68333, 0, 0, 0.75],
              89: [0, 0.68333, 0.025, 0, 0.75],
              90: [0, 0.68333, 0, 0, 0.61111],
              91: [0.25, 0.75, 0, 0, 0.27778],
              92: [0.25, 0.75, 0, 0, 0.5],
              93: [0.25, 0.75, 0, 0, 0.27778],
              94: [0, 0.69444, 0, 0, 0.5],
              95: [0.31, 0.12056, 0.02778, 0, 0.5],
              97: [0, 0.43056, 0, 0, 0.5],
              98: [0, 0.69444, 0, 0, 0.55556],
              99: [0, 0.43056, 0, 0, 0.44445],
              100: [0, 0.69444, 0, 0, 0.55556],
              101: [0, 0.43056, 0, 0, 0.44445],
              102: [0, 0.69444, 0.07778, 0, 0.30556],
              103: [0.19444, 0.43056, 0.01389, 0, 0.5],
              104: [0, 0.69444, 0, 0, 0.55556],
              105: [0, 0.66786, 0, 0, 0.27778],
              106: [0.19444, 0.66786, 0, 0, 0.30556],
              107: [0, 0.69444, 0, 0, 0.52778],
              108: [0, 0.69444, 0, 0, 0.27778],
              109: [0, 0.43056, 0, 0, 0.83334],
              110: [0, 0.43056, 0, 0, 0.55556],
              111: [0, 0.43056, 0, 0, 0.5],
              112: [0.19444, 0.43056, 0, 0, 0.55556],
              113: [0.19444, 0.43056, 0, 0, 0.52778],
              114: [0, 0.43056, 0, 0, 0.39167],
              115: [0, 0.43056, 0, 0, 0.39445],
              116: [0, 0.61508, 0, 0, 0.38889],
              117: [0, 0.43056, 0, 0, 0.55556],
              118: [0, 0.43056, 0.01389, 0, 0.52778],
              119: [0, 0.43056, 0.01389, 0, 0.72222],
              120: [0, 0.43056, 0, 0, 0.52778],
              121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
              122: [0, 0.43056, 0, 0, 0.44445],
              123: [0.25, 0.75, 0, 0, 0.5],
              124: [0.25, 0.75, 0, 0, 0.27778],
              125: [0.25, 0.75, 0, 0, 0.5],
              126: [0.35, 0.31786, 0, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              163: [0, 0.69444, 0, 0, 0.76909],
              167: [0.19444, 0.69444, 0, 0, 0.44445],
              168: [0, 0.66786, 0, 0, 0.5],
              172: [0, 0.43056, 0, 0, 0.66667],
              176: [0, 0.69444, 0, 0, 0.75],
              177: [0.08333, 0.58333, 0, 0, 0.77778],
              182: [0.19444, 0.69444, 0, 0, 0.61111],
              184: [0.17014, 0, 0, 0, 0.44445],
              198: [0, 0.68333, 0, 0, 0.90278],
              215: [0.08333, 0.58333, 0, 0, 0.77778],
              216: [0.04861, 0.73194, 0, 0, 0.77778],
              223: [0, 0.69444, 0, 0, 0.5],
              230: [0, 0.43056, 0, 0, 0.72222],
              247: [0.08333, 0.58333, 0, 0, 0.77778],
              248: [0.09722, 0.52778, 0, 0, 0.5],
              305: [0, 0.43056, 0, 0, 0.27778],
              338: [0, 0.68333, 0, 0, 1.01389],
              339: [0, 0.43056, 0, 0, 0.77778],
              567: [0.19444, 0.43056, 0, 0, 0.30556],
              710: [0, 0.69444, 0, 0, 0.5],
              711: [0, 0.62847, 0, 0, 0.5],
              713: [0, 0.56778, 0, 0, 0.5],
              714: [0, 0.69444, 0, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0, 0, 0.5],
              729: [0, 0.66786, 0, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.75],
              732: [0, 0.66786, 0, 0, 0.5],
              733: [0, 0.69444, 0, 0, 0.5],
              915: [0, 0.68333, 0, 0, 0.625],
              916: [0, 0.68333, 0, 0, 0.83334],
              920: [0, 0.68333, 0, 0, 0.77778],
              923: [0, 0.68333, 0, 0, 0.69445],
              926: [0, 0.68333, 0, 0, 0.66667],
              928: [0, 0.68333, 0, 0, 0.75],
              931: [0, 0.68333, 0, 0, 0.72222],
              933: [0, 0.68333, 0, 0, 0.77778],
              934: [0, 0.68333, 0, 0, 0.72222],
              936: [0, 0.68333, 0, 0, 0.77778],
              937: [0, 0.68333, 0, 0, 0.72222],
              8211: [0, 0.43056, 0.02778, 0, 0.5],
              8212: [0, 0.43056, 0.02778, 0, 1],
              8216: [0, 0.69444, 0, 0, 0.27778],
              8217: [0, 0.69444, 0, 0, 0.27778],
              8220: [0, 0.69444, 0, 0, 0.5],
              8221: [0, 0.69444, 0, 0, 0.5],
              8224: [0.19444, 0.69444, 0, 0, 0.44445],
              8225: [0.19444, 0.69444, 0, 0, 0.44445],
              8230: [0, 0.123, 0, 0, 1.172],
              8242: [0, 0.55556, 0, 0, 0.275],
              8407: [0, 0.71444, 0.15382, 0, 0.5],
              8463: [0, 0.68889, 0, 0, 0.54028],
              8465: [0, 0.69444, 0, 0, 0.72222],
              8467: [0, 0.69444, 0, 0.11111, 0.41667],
              8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
              8476: [0, 0.69444, 0, 0, 0.72222],
              8501: [0, 0.69444, 0, 0, 0.61111],
              8592: [-0.13313, 0.36687, 0, 0, 1],
              8593: [0.19444, 0.69444, 0, 0, 0.5],
              8594: [-0.13313, 0.36687, 0, 0, 1],
              8595: [0.19444, 0.69444, 0, 0, 0.5],
              8596: [-0.13313, 0.36687, 0, 0, 1],
              8597: [0.25, 0.75, 0, 0, 0.5],
              8598: [0.19444, 0.69444, 0, 0, 1],
              8599: [0.19444, 0.69444, 0, 0, 1],
              8600: [0.19444, 0.69444, 0, 0, 1],
              8601: [0.19444, 0.69444, 0, 0, 1],
              8614: [0.011, 0.511, 0, 0, 1],
              8617: [0.011, 0.511, 0, 0, 1.126],
              8618: [0.011, 0.511, 0, 0, 1.126],
              8636: [-0.13313, 0.36687, 0, 0, 1],
              8637: [-0.13313, 0.36687, 0, 0, 1],
              8640: [-0.13313, 0.36687, 0, 0, 1],
              8641: [-0.13313, 0.36687, 0, 0, 1],
              8652: [0.011, 0.671, 0, 0, 1],
              8656: [-0.13313, 0.36687, 0, 0, 1],
              8657: [0.19444, 0.69444, 0, 0, 0.61111],
              8658: [-0.13313, 0.36687, 0, 0, 1],
              8659: [0.19444, 0.69444, 0, 0, 0.61111],
              8660: [-0.13313, 0.36687, 0, 0, 1],
              8661: [0.25, 0.75, 0, 0, 0.61111],
              8704: [0, 0.69444, 0, 0, 0.55556],
              8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
              8707: [0, 0.69444, 0, 0, 0.55556],
              8709: [0.05556, 0.75, 0, 0, 0.5],
              8711: [0, 0.68333, 0, 0, 0.83334],
              8712: [0.0391, 0.5391, 0, 0, 0.66667],
              8715: [0.0391, 0.5391, 0, 0, 0.66667],
              8722: [0.08333, 0.58333, 0, 0, 0.77778],
              8723: [0.08333, 0.58333, 0, 0, 0.77778],
              8725: [0.25, 0.75, 0, 0, 0.5],
              8726: [0.25, 0.75, 0, 0, 0.5],
              8727: [-0.03472, 0.46528, 0, 0, 0.5],
              8728: [-0.05555, 0.44445, 0, 0, 0.5],
              8729: [-0.05555, 0.44445, 0, 0, 0.5],
              8730: [0.2, 0.8, 0, 0, 0.83334],
              8733: [0, 0.43056, 0, 0, 0.77778],
              8734: [0, 0.43056, 0, 0, 1],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8739: [0.25, 0.75, 0, 0, 0.27778],
              8741: [0.25, 0.75, 0, 0, 0.5],
              8743: [0, 0.55556, 0, 0, 0.66667],
              8744: [0, 0.55556, 0, 0, 0.66667],
              8745: [0, 0.55556, 0, 0, 0.66667],
              8746: [0, 0.55556, 0, 0, 0.66667],
              8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
              8764: [-0.13313, 0.36687, 0, 0, 0.77778],
              8768: [0.19444, 0.69444, 0, 0, 0.27778],
              8771: [-0.03625, 0.46375, 0, 0, 0.77778],
              8773: [-0.022, 0.589, 0, 0, 0.778],
              8776: [-0.01688, 0.48312, 0, 0, 0.77778],
              8781: [-0.03625, 0.46375, 0, 0, 0.77778],
              8784: [-0.133, 0.673, 0, 0, 0.778],
              8801: [-0.03625, 0.46375, 0, 0, 0.77778],
              8804: [0.13597, 0.63597, 0, 0, 0.77778],
              8805: [0.13597, 0.63597, 0, 0, 0.77778],
              8810: [0.0391, 0.5391, 0, 0, 1],
              8811: [0.0391, 0.5391, 0, 0, 1],
              8826: [0.0391, 0.5391, 0, 0, 0.77778],
              8827: [0.0391, 0.5391, 0, 0, 0.77778],
              8834: [0.0391, 0.5391, 0, 0, 0.77778],
              8835: [0.0391, 0.5391, 0, 0, 0.77778],
              8838: [0.13597, 0.63597, 0, 0, 0.77778],
              8839: [0.13597, 0.63597, 0, 0, 0.77778],
              8846: [0, 0.55556, 0, 0, 0.66667],
              8849: [0.13597, 0.63597, 0, 0, 0.77778],
              8850: [0.13597, 0.63597, 0, 0, 0.77778],
              8851: [0, 0.55556, 0, 0, 0.66667],
              8852: [0, 0.55556, 0, 0, 0.66667],
              8853: [0.08333, 0.58333, 0, 0, 0.77778],
              8854: [0.08333, 0.58333, 0, 0, 0.77778],
              8855: [0.08333, 0.58333, 0, 0, 0.77778],
              8856: [0.08333, 0.58333, 0, 0, 0.77778],
              8857: [0.08333, 0.58333, 0, 0, 0.77778],
              8866: [0, 0.69444, 0, 0, 0.61111],
              8867: [0, 0.69444, 0, 0, 0.61111],
              8868: [0, 0.69444, 0, 0, 0.77778],
              8869: [0, 0.69444, 0, 0, 0.77778],
              8872: [0.249, 0.75, 0, 0, 0.867],
              8900: [-0.05555, 0.44445, 0, 0, 0.5],
              8901: [-0.05555, 0.44445, 0, 0, 0.27778],
              8902: [-0.03472, 0.46528, 0, 0, 0.5],
              8904: [5e-3, 0.505, 0, 0, 0.9],
              8942: [0.03, 0.903, 0, 0, 0.278],
              8943: [-0.19, 0.313, 0, 0, 1.172],
              8945: [-0.1, 0.823, 0, 0, 1.282],
              8968: [0.25, 0.75, 0, 0, 0.44445],
              8969: [0.25, 0.75, 0, 0, 0.44445],
              8970: [0.25, 0.75, 0, 0, 0.44445],
              8971: [0.25, 0.75, 0, 0, 0.44445],
              8994: [-0.14236, 0.35764, 0, 0, 1],
              8995: [-0.14236, 0.35764, 0, 0, 1],
              9136: [0.244, 0.744, 0, 0, 0.412],
              9137: [0.244, 0.745, 0, 0, 0.412],
              9651: [0.19444, 0.69444, 0, 0, 0.88889],
              9657: [-0.03472, 0.46528, 0, 0, 0.5],
              9661: [0.19444, 0.69444, 0, 0, 0.88889],
              9667: [-0.03472, 0.46528, 0, 0, 0.5],
              9711: [0.19444, 0.69444, 0, 0, 1],
              9824: [0.12963, 0.69444, 0, 0, 0.77778],
              9825: [0.12963, 0.69444, 0, 0, 0.77778],
              9826: [0.12963, 0.69444, 0, 0, 0.77778],
              9827: [0.12963, 0.69444, 0, 0, 0.77778],
              9837: [0, 0.75, 0, 0, 0.38889],
              9838: [0.19444, 0.69444, 0, 0, 0.38889],
              9839: [0.19444, 0.69444, 0, 0, 0.38889],
              10216: [0.25, 0.75, 0, 0, 0.38889],
              10217: [0.25, 0.75, 0, 0, 0.38889],
              10222: [0.244, 0.744, 0, 0, 0.412],
              10223: [0.244, 0.745, 0, 0, 0.412],
              10229: [0.011, 0.511, 0, 0, 1.609],
              10230: [0.011, 0.511, 0, 0, 1.638],
              10231: [0.011, 0.511, 0, 0, 1.859],
              10232: [0.024, 0.525, 0, 0, 1.609],
              10233: [0.024, 0.525, 0, 0, 1.638],
              10234: [0.024, 0.525, 0, 0, 1.858],
              10236: [0.011, 0.511, 0, 0, 1.638],
              10815: [0, 0.68333, 0, 0, 0.75],
              10927: [0.13597, 0.63597, 0, 0, 0.77778],
              10928: [0.13597, 0.63597, 0, 0, 0.77778],
              57376: [0.19444, 0.69444, 0, 0, 0]
            },
            "Math-BoldItalic": {
              32: [0, 0, 0, 0, 0.25],
              48: [0, 0.44444, 0, 0, 0.575],
              49: [0, 0.44444, 0, 0, 0.575],
              50: [0, 0.44444, 0, 0, 0.575],
              51: [0.19444, 0.44444, 0, 0, 0.575],
              52: [0.19444, 0.44444, 0, 0, 0.575],
              53: [0.19444, 0.44444, 0, 0, 0.575],
              54: [0, 0.64444, 0, 0, 0.575],
              55: [0.19444, 0.44444, 0, 0, 0.575],
              56: [0, 0.64444, 0, 0, 0.575],
              57: [0.19444, 0.44444, 0, 0, 0.575],
              65: [0, 0.68611, 0, 0, 0.86944],
              66: [0, 0.68611, 0.04835, 0, 0.8664],
              67: [0, 0.68611, 0.06979, 0, 0.81694],
              68: [0, 0.68611, 0.03194, 0, 0.93812],
              69: [0, 0.68611, 0.05451, 0, 0.81007],
              70: [0, 0.68611, 0.15972, 0, 0.68889],
              71: [0, 0.68611, 0, 0, 0.88673],
              72: [0, 0.68611, 0.08229, 0, 0.98229],
              73: [0, 0.68611, 0.07778, 0, 0.51111],
              74: [0, 0.68611, 0.10069, 0, 0.63125],
              75: [0, 0.68611, 0.06979, 0, 0.97118],
              76: [0, 0.68611, 0, 0, 0.75555],
              77: [0, 0.68611, 0.11424, 0, 1.14201],
              78: [0, 0.68611, 0.11424, 0, 0.95034],
              79: [0, 0.68611, 0.03194, 0, 0.83666],
              80: [0, 0.68611, 0.15972, 0, 0.72309],
              81: [0.19444, 0.68611, 0, 0, 0.86861],
              82: [0, 0.68611, 421e-5, 0, 0.87235],
              83: [0, 0.68611, 0.05382, 0, 0.69271],
              84: [0, 0.68611, 0.15972, 0, 0.63663],
              85: [0, 0.68611, 0.11424, 0, 0.80027],
              86: [0, 0.68611, 0.25555, 0, 0.67778],
              87: [0, 0.68611, 0.15972, 0, 1.09305],
              88: [0, 0.68611, 0.07778, 0, 0.94722],
              89: [0, 0.68611, 0.25555, 0, 0.67458],
              90: [0, 0.68611, 0.06979, 0, 0.77257],
              97: [0, 0.44444, 0, 0, 0.63287],
              98: [0, 0.69444, 0, 0, 0.52083],
              99: [0, 0.44444, 0, 0, 0.51342],
              100: [0, 0.69444, 0, 0, 0.60972],
              101: [0, 0.44444, 0, 0, 0.55361],
              102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
              103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
              104: [0, 0.69444, 0, 0, 0.66759],
              105: [0, 0.69326, 0, 0, 0.4048],
              106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
              107: [0, 0.69444, 0.01852, 0, 0.6037],
              108: [0, 0.69444, 88e-4, 0, 0.34815],
              109: [0, 0.44444, 0, 0, 1.0324],
              110: [0, 0.44444, 0, 0, 0.71296],
              111: [0, 0.44444, 0, 0, 0.58472],
              112: [0.19444, 0.44444, 0, 0, 0.60092],
              113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
              114: [0, 0.44444, 0.03194, 0, 0.5287],
              115: [0, 0.44444, 0, 0, 0.53125],
              116: [0, 0.63492, 0, 0, 0.41528],
              117: [0, 0.44444, 0, 0, 0.68102],
              118: [0, 0.44444, 0.03704, 0, 0.56666],
              119: [0, 0.44444, 0.02778, 0, 0.83148],
              120: [0, 0.44444, 0, 0, 0.65903],
              121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
              122: [0, 0.44444, 0.04213, 0, 0.55509],
              160: [0, 0, 0, 0, 0.25],
              915: [0, 0.68611, 0.15972, 0, 0.65694],
              916: [0, 0.68611, 0, 0, 0.95833],
              920: [0, 0.68611, 0.03194, 0, 0.86722],
              923: [0, 0.68611, 0, 0, 0.80555],
              926: [0, 0.68611, 0.07458, 0, 0.84125],
              928: [0, 0.68611, 0.08229, 0, 0.98229],
              931: [0, 0.68611, 0.05451, 0, 0.88507],
              933: [0, 0.68611, 0.15972, 0, 0.67083],
              934: [0, 0.68611, 0, 0, 0.76666],
              936: [0, 0.68611, 0.11653, 0, 0.71402],
              937: [0, 0.68611, 0.04835, 0, 0.8789],
              945: [0, 0.44444, 0, 0, 0.76064],
              946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
              947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
              948: [0, 0.69444, 0.03819, 0, 0.52222],
              949: [0, 0.44444, 0, 0, 0.52882],
              950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
              951: [0.19444, 0.44444, 0.03704, 0, 0.6],
              952: [0, 0.69444, 0.03194, 0, 0.5618],
              953: [0, 0.44444, 0, 0, 0.41204],
              954: [0, 0.44444, 0, 0, 0.66759],
              955: [0, 0.69444, 0, 0, 0.67083],
              956: [0.19444, 0.44444, 0, 0, 0.70787],
              957: [0, 0.44444, 0.06898, 0, 0.57685],
              958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
              959: [0, 0.44444, 0, 0, 0.58472],
              960: [0, 0.44444, 0.03704, 0, 0.68241],
              961: [0.19444, 0.44444, 0, 0, 0.6118],
              962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
              963: [0, 0.44444, 0.03704, 0, 0.68588],
              964: [0, 0.44444, 0.13472, 0, 0.52083],
              965: [0, 0.44444, 0.03704, 0, 0.63055],
              966: [0.19444, 0.44444, 0, 0, 0.74722],
              967: [0.19444, 0.44444, 0, 0, 0.71805],
              968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
              969: [0, 0.44444, 0.03704, 0, 0.71782],
              977: [0, 0.69444, 0, 0, 0.69155],
              981: [0.19444, 0.69444, 0, 0, 0.7125],
              982: [0, 0.44444, 0.03194, 0, 0.975],
              1009: [0.19444, 0.44444, 0, 0, 0.6118],
              1013: [0, 0.44444, 0, 0, 0.48333],
              57649: [0, 0.44444, 0, 0, 0.39352],
              57911: [0.19444, 0.44444, 0, 0, 0.43889]
            },
            "Math-Italic": {
              32: [0, 0, 0, 0, 0.25],
              48: [0, 0.43056, 0, 0, 0.5],
              49: [0, 0.43056, 0, 0, 0.5],
              50: [0, 0.43056, 0, 0, 0.5],
              51: [0.19444, 0.43056, 0, 0, 0.5],
              52: [0.19444, 0.43056, 0, 0, 0.5],
              53: [0.19444, 0.43056, 0, 0, 0.5],
              54: [0, 0.64444, 0, 0, 0.5],
              55: [0.19444, 0.43056, 0, 0, 0.5],
              56: [0, 0.64444, 0, 0, 0.5],
              57: [0.19444, 0.43056, 0, 0, 0.5],
              65: [0, 0.68333, 0, 0.13889, 0.75],
              66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
              67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
              68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
              69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
              70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
              71: [0, 0.68333, 0, 0.08334, 0.78625],
              72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
              73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
              74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
              75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
              76: [0, 0.68333, 0, 0.02778, 0.68056],
              77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
              78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
              79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
              80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
              81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
              82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
              83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
              84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
              85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
              86: [0, 0.68333, 0.22222, 0, 0.58333],
              87: [0, 0.68333, 0.13889, 0, 0.94445],
              88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
              89: [0, 0.68333, 0.22222, 0, 0.58056],
              90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
              97: [0, 0.43056, 0, 0, 0.52859],
              98: [0, 0.69444, 0, 0, 0.42917],
              99: [0, 0.43056, 0, 0.05556, 0.43276],
              100: [0, 0.69444, 0, 0.16667, 0.52049],
              101: [0, 0.43056, 0, 0.05556, 0.46563],
              102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
              103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
              104: [0, 0.69444, 0, 0, 0.57616],
              105: [0, 0.65952, 0, 0, 0.34451],
              106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
              107: [0, 0.69444, 0.03148, 0, 0.5206],
              108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
              109: [0, 0.43056, 0, 0, 0.87801],
              110: [0, 0.43056, 0, 0, 0.60023],
              111: [0, 0.43056, 0, 0.05556, 0.48472],
              112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
              113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
              114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
              115: [0, 0.43056, 0, 0.05556, 0.46875],
              116: [0, 0.61508, 0, 0.08334, 0.36111],
              117: [0, 0.43056, 0, 0.02778, 0.57246],
              118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
              119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
              120: [0, 0.43056, 0, 0.02778, 0.57153],
              121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
              122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
              160: [0, 0, 0, 0, 0.25],
              915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
              916: [0, 0.68333, 0, 0.16667, 0.83334],
              920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
              923: [0, 0.68333, 0, 0.16667, 0.69445],
              926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
              928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
              931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
              933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
              934: [0, 0.68333, 0, 0.08334, 0.66667],
              936: [0, 0.68333, 0.11, 0.05556, 0.61222],
              937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
              945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
              946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
              947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
              948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
              949: [0, 0.43056, 0, 0.08334, 0.46632],
              950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
              951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
              952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
              953: [0, 0.43056, 0, 0.05556, 0.35394],
              954: [0, 0.43056, 0, 0, 0.57616],
              955: [0, 0.69444, 0, 0, 0.58334],
              956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
              957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
              958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
              959: [0, 0.43056, 0, 0.05556, 0.48472],
              960: [0, 0.43056, 0.03588, 0, 0.57003],
              961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
              962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
              963: [0, 0.43056, 0.03588, 0, 0.57141],
              964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
              965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
              966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
              967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
              968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
              969: [0, 0.43056, 0.03588, 0, 0.62245],
              977: [0, 0.69444, 0, 0.08334, 0.59144],
              981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
              982: [0, 0.43056, 0.02778, 0, 0.82813],
              1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
              1013: [0, 0.43056, 0, 0.05556, 0.4059],
              57649: [0, 0.43056, 0, 0.02778, 0.32246],
              57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
            },
            "SansSerif-Bold": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.36667],
              34: [0, 0.69444, 0, 0, 0.55834],
              35: [0.19444, 0.69444, 0, 0, 0.91667],
              36: [0.05556, 0.75, 0, 0, 0.55],
              37: [0.05556, 0.75, 0, 0, 1.02912],
              38: [0, 0.69444, 0, 0, 0.83056],
              39: [0, 0.69444, 0, 0, 0.30556],
              40: [0.25, 0.75, 0, 0, 0.42778],
              41: [0.25, 0.75, 0, 0, 0.42778],
              42: [0, 0.75, 0, 0, 0.55],
              43: [0.11667, 0.61667, 0, 0, 0.85556],
              44: [0.10556, 0.13056, 0, 0, 0.30556],
              45: [0, 0.45833, 0, 0, 0.36667],
              46: [0, 0.13056, 0, 0, 0.30556],
              47: [0.25, 0.75, 0, 0, 0.55],
              48: [0, 0.69444, 0, 0, 0.55],
              49: [0, 0.69444, 0, 0, 0.55],
              50: [0, 0.69444, 0, 0, 0.55],
              51: [0, 0.69444, 0, 0, 0.55],
              52: [0, 0.69444, 0, 0, 0.55],
              53: [0, 0.69444, 0, 0, 0.55],
              54: [0, 0.69444, 0, 0, 0.55],
              55: [0, 0.69444, 0, 0, 0.55],
              56: [0, 0.69444, 0, 0, 0.55],
              57: [0, 0.69444, 0, 0, 0.55],
              58: [0, 0.45833, 0, 0, 0.30556],
              59: [0.10556, 0.45833, 0, 0, 0.30556],
              61: [-0.09375, 0.40625, 0, 0, 0.85556],
              63: [0, 0.69444, 0, 0, 0.51945],
              64: [0, 0.69444, 0, 0, 0.73334],
              65: [0, 0.69444, 0, 0, 0.73334],
              66: [0, 0.69444, 0, 0, 0.73334],
              67: [0, 0.69444, 0, 0, 0.70278],
              68: [0, 0.69444, 0, 0, 0.79445],
              69: [0, 0.69444, 0, 0, 0.64167],
              70: [0, 0.69444, 0, 0, 0.61111],
              71: [0, 0.69444, 0, 0, 0.73334],
              72: [0, 0.69444, 0, 0, 0.79445],
              73: [0, 0.69444, 0, 0, 0.33056],
              74: [0, 0.69444, 0, 0, 0.51945],
              75: [0, 0.69444, 0, 0, 0.76389],
              76: [0, 0.69444, 0, 0, 0.58056],
              77: [0, 0.69444, 0, 0, 0.97778],
              78: [0, 0.69444, 0, 0, 0.79445],
              79: [0, 0.69444, 0, 0, 0.79445],
              80: [0, 0.69444, 0, 0, 0.70278],
              81: [0.10556, 0.69444, 0, 0, 0.79445],
              82: [0, 0.69444, 0, 0, 0.70278],
              83: [0, 0.69444, 0, 0, 0.61111],
              84: [0, 0.69444, 0, 0, 0.73334],
              85: [0, 0.69444, 0, 0, 0.76389],
              86: [0, 0.69444, 0.01528, 0, 0.73334],
              87: [0, 0.69444, 0.01528, 0, 1.03889],
              88: [0, 0.69444, 0, 0, 0.73334],
              89: [0, 0.69444, 0.0275, 0, 0.73334],
              90: [0, 0.69444, 0, 0, 0.67223],
              91: [0.25, 0.75, 0, 0, 0.34306],
              93: [0.25, 0.75, 0, 0, 0.34306],
              94: [0, 0.69444, 0, 0, 0.55],
              95: [0.35, 0.10833, 0.03056, 0, 0.55],
              97: [0, 0.45833, 0, 0, 0.525],
              98: [0, 0.69444, 0, 0, 0.56111],
              99: [0, 0.45833, 0, 0, 0.48889],
              100: [0, 0.69444, 0, 0, 0.56111],
              101: [0, 0.45833, 0, 0, 0.51111],
              102: [0, 0.69444, 0.07639, 0, 0.33611],
              103: [0.19444, 0.45833, 0.01528, 0, 0.55],
              104: [0, 0.69444, 0, 0, 0.56111],
              105: [0, 0.69444, 0, 0, 0.25556],
              106: [0.19444, 0.69444, 0, 0, 0.28611],
              107: [0, 0.69444, 0, 0, 0.53056],
              108: [0, 0.69444, 0, 0, 0.25556],
              109: [0, 0.45833, 0, 0, 0.86667],
              110: [0, 0.45833, 0, 0, 0.56111],
              111: [0, 0.45833, 0, 0, 0.55],
              112: [0.19444, 0.45833, 0, 0, 0.56111],
              113: [0.19444, 0.45833, 0, 0, 0.56111],
              114: [0, 0.45833, 0.01528, 0, 0.37222],
              115: [0, 0.45833, 0, 0, 0.42167],
              116: [0, 0.58929, 0, 0, 0.40417],
              117: [0, 0.45833, 0, 0, 0.56111],
              118: [0, 0.45833, 0.01528, 0, 0.5],
              119: [0, 0.45833, 0.01528, 0, 0.74445],
              120: [0, 0.45833, 0, 0, 0.5],
              121: [0.19444, 0.45833, 0.01528, 0, 0.5],
              122: [0, 0.45833, 0, 0, 0.47639],
              126: [0.35, 0.34444, 0, 0, 0.55],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.69444, 0, 0, 0.55],
              176: [0, 0.69444, 0, 0, 0.73334],
              180: [0, 0.69444, 0, 0, 0.55],
              184: [0.17014, 0, 0, 0, 0.48889],
              305: [0, 0.45833, 0, 0, 0.25556],
              567: [0.19444, 0.45833, 0, 0, 0.28611],
              710: [0, 0.69444, 0, 0, 0.55],
              711: [0, 0.63542, 0, 0, 0.55],
              713: [0, 0.63778, 0, 0, 0.55],
              728: [0, 0.69444, 0, 0, 0.55],
              729: [0, 0.69444, 0, 0, 0.30556],
              730: [0, 0.69444, 0, 0, 0.73334],
              732: [0, 0.69444, 0, 0, 0.55],
              733: [0, 0.69444, 0, 0, 0.55],
              915: [0, 0.69444, 0, 0, 0.58056],
              916: [0, 0.69444, 0, 0, 0.91667],
              920: [0, 0.69444, 0, 0, 0.85556],
              923: [0, 0.69444, 0, 0, 0.67223],
              926: [0, 0.69444, 0, 0, 0.73334],
              928: [0, 0.69444, 0, 0, 0.79445],
              931: [0, 0.69444, 0, 0, 0.79445],
              933: [0, 0.69444, 0, 0, 0.85556],
              934: [0, 0.69444, 0, 0, 0.79445],
              936: [0, 0.69444, 0, 0, 0.85556],
              937: [0, 0.69444, 0, 0, 0.79445],
              8211: [0, 0.45833, 0.03056, 0, 0.55],
              8212: [0, 0.45833, 0.03056, 0, 1.10001],
              8216: [0, 0.69444, 0, 0, 0.30556],
              8217: [0, 0.69444, 0, 0, 0.30556],
              8220: [0, 0.69444, 0, 0, 0.55834],
              8221: [0, 0.69444, 0, 0, 0.55834]
            },
            "SansSerif-Italic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.05733, 0, 0.31945],
              34: [0, 0.69444, 316e-5, 0, 0.5],
              35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
              36: [0.05556, 0.75, 0.11156, 0, 0.5],
              37: [0.05556, 0.75, 0.03126, 0, 0.83334],
              38: [0, 0.69444, 0.03058, 0, 0.75834],
              39: [0, 0.69444, 0.07816, 0, 0.27778],
              40: [0.25, 0.75, 0.13164, 0, 0.38889],
              41: [0.25, 0.75, 0.02536, 0, 0.38889],
              42: [0, 0.75, 0.11775, 0, 0.5],
              43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
              44: [0.125, 0.08333, 0, 0, 0.27778],
              45: [0, 0.44444, 0.01946, 0, 0.33333],
              46: [0, 0.08333, 0, 0, 0.27778],
              47: [0.25, 0.75, 0.13164, 0, 0.5],
              48: [0, 0.65556, 0.11156, 0, 0.5],
              49: [0, 0.65556, 0.11156, 0, 0.5],
              50: [0, 0.65556, 0.11156, 0, 0.5],
              51: [0, 0.65556, 0.11156, 0, 0.5],
              52: [0, 0.65556, 0.11156, 0, 0.5],
              53: [0, 0.65556, 0.11156, 0, 0.5],
              54: [0, 0.65556, 0.11156, 0, 0.5],
              55: [0, 0.65556, 0.11156, 0, 0.5],
              56: [0, 0.65556, 0.11156, 0, 0.5],
              57: [0, 0.65556, 0.11156, 0, 0.5],
              58: [0, 0.44444, 0.02502, 0, 0.27778],
              59: [0.125, 0.44444, 0.02502, 0, 0.27778],
              61: [-0.13, 0.37, 0.05087, 0, 0.77778],
              63: [0, 0.69444, 0.11809, 0, 0.47222],
              64: [0, 0.69444, 0.07555, 0, 0.66667],
              65: [0, 0.69444, 0, 0, 0.66667],
              66: [0, 0.69444, 0.08293, 0, 0.66667],
              67: [0, 0.69444, 0.11983, 0, 0.63889],
              68: [0, 0.69444, 0.07555, 0, 0.72223],
              69: [0, 0.69444, 0.11983, 0, 0.59722],
              70: [0, 0.69444, 0.13372, 0, 0.56945],
              71: [0, 0.69444, 0.11983, 0, 0.66667],
              72: [0, 0.69444, 0.08094, 0, 0.70834],
              73: [0, 0.69444, 0.13372, 0, 0.27778],
              74: [0, 0.69444, 0.08094, 0, 0.47222],
              75: [0, 0.69444, 0.11983, 0, 0.69445],
              76: [0, 0.69444, 0, 0, 0.54167],
              77: [0, 0.69444, 0.08094, 0, 0.875],
              78: [0, 0.69444, 0.08094, 0, 0.70834],
              79: [0, 0.69444, 0.07555, 0, 0.73611],
              80: [0, 0.69444, 0.08293, 0, 0.63889],
              81: [0.125, 0.69444, 0.07555, 0, 0.73611],
              82: [0, 0.69444, 0.08293, 0, 0.64584],
              83: [0, 0.69444, 0.09205, 0, 0.55556],
              84: [0, 0.69444, 0.13372, 0, 0.68056],
              85: [0, 0.69444, 0.08094, 0, 0.6875],
              86: [0, 0.69444, 0.1615, 0, 0.66667],
              87: [0, 0.69444, 0.1615, 0, 0.94445],
              88: [0, 0.69444, 0.13372, 0, 0.66667],
              89: [0, 0.69444, 0.17261, 0, 0.66667],
              90: [0, 0.69444, 0.11983, 0, 0.61111],
              91: [0.25, 0.75, 0.15942, 0, 0.28889],
              93: [0.25, 0.75, 0.08719, 0, 0.28889],
              94: [0, 0.69444, 0.0799, 0, 0.5],
              95: [0.35, 0.09444, 0.08616, 0, 0.5],
              97: [0, 0.44444, 981e-5, 0, 0.48056],
              98: [0, 0.69444, 0.03057, 0, 0.51667],
              99: [0, 0.44444, 0.08336, 0, 0.44445],
              100: [0, 0.69444, 0.09483, 0, 0.51667],
              101: [0, 0.44444, 0.06778, 0, 0.44445],
              102: [0, 0.69444, 0.21705, 0, 0.30556],
              103: [0.19444, 0.44444, 0.10836, 0, 0.5],
              104: [0, 0.69444, 0.01778, 0, 0.51667],
              105: [0, 0.67937, 0.09718, 0, 0.23889],
              106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
              107: [0, 0.69444, 0.08336, 0, 0.48889],
              108: [0, 0.69444, 0.09483, 0, 0.23889],
              109: [0, 0.44444, 0.01778, 0, 0.79445],
              110: [0, 0.44444, 0.01778, 0, 0.51667],
              111: [0, 0.44444, 0.06613, 0, 0.5],
              112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
              113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
              114: [0, 0.44444, 0.10836, 0, 0.34167],
              115: [0, 0.44444, 0.0778, 0, 0.38333],
              116: [0, 0.57143, 0.07225, 0, 0.36111],
              117: [0, 0.44444, 0.04169, 0, 0.51667],
              118: [0, 0.44444, 0.10836, 0, 0.46111],
              119: [0, 0.44444, 0.10836, 0, 0.68334],
              120: [0, 0.44444, 0.09169, 0, 0.46111],
              121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
              122: [0, 0.44444, 0.08752, 0, 0.43472],
              126: [0.35, 0.32659, 0.08826, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.67937, 0.06385, 0, 0.5],
              176: [0, 0.69444, 0, 0, 0.73752],
              184: [0.17014, 0, 0, 0, 0.44445],
              305: [0, 0.44444, 0.04169, 0, 0.23889],
              567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
              710: [0, 0.69444, 0.0799, 0, 0.5],
              711: [0, 0.63194, 0.08432, 0, 0.5],
              713: [0, 0.60889, 0.08776, 0, 0.5],
              714: [0, 0.69444, 0.09205, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0.09483, 0, 0.5],
              729: [0, 0.67937, 0.07774, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.73752],
              732: [0, 0.67659, 0.08826, 0, 0.5],
              733: [0, 0.69444, 0.09205, 0, 0.5],
              915: [0, 0.69444, 0.13372, 0, 0.54167],
              916: [0, 0.69444, 0, 0, 0.83334],
              920: [0, 0.69444, 0.07555, 0, 0.77778],
              923: [0, 0.69444, 0, 0, 0.61111],
              926: [0, 0.69444, 0.12816, 0, 0.66667],
              928: [0, 0.69444, 0.08094, 0, 0.70834],
              931: [0, 0.69444, 0.11983, 0, 0.72222],
              933: [0, 0.69444, 0.09031, 0, 0.77778],
              934: [0, 0.69444, 0.04603, 0, 0.72222],
              936: [0, 0.69444, 0.09031, 0, 0.77778],
              937: [0, 0.69444, 0.08293, 0, 0.72222],
              8211: [0, 0.44444, 0.08616, 0, 0.5],
              8212: [0, 0.44444, 0.08616, 0, 1],
              8216: [0, 0.69444, 0.07816, 0, 0.27778],
              8217: [0, 0.69444, 0.07816, 0, 0.27778],
              8220: [0, 0.69444, 0.14205, 0, 0.5],
              8221: [0, 0.69444, 316e-5, 0, 0.5]
            },
            "SansSerif-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.31945],
              34: [0, 0.69444, 0, 0, 0.5],
              35: [0.19444, 0.69444, 0, 0, 0.83334],
              36: [0.05556, 0.75, 0, 0, 0.5],
              37: [0.05556, 0.75, 0, 0, 0.83334],
              38: [0, 0.69444, 0, 0, 0.75834],
              39: [0, 0.69444, 0, 0, 0.27778],
              40: [0.25, 0.75, 0, 0, 0.38889],
              41: [0.25, 0.75, 0, 0, 0.38889],
              42: [0, 0.75, 0, 0, 0.5],
              43: [0.08333, 0.58333, 0, 0, 0.77778],
              44: [0.125, 0.08333, 0, 0, 0.27778],
              45: [0, 0.44444, 0, 0, 0.33333],
              46: [0, 0.08333, 0, 0, 0.27778],
              47: [0.25, 0.75, 0, 0, 0.5],
              48: [0, 0.65556, 0, 0, 0.5],
              49: [0, 0.65556, 0, 0, 0.5],
              50: [0, 0.65556, 0, 0, 0.5],
              51: [0, 0.65556, 0, 0, 0.5],
              52: [0, 0.65556, 0, 0, 0.5],
              53: [0, 0.65556, 0, 0, 0.5],
              54: [0, 0.65556, 0, 0, 0.5],
              55: [0, 0.65556, 0, 0, 0.5],
              56: [0, 0.65556, 0, 0, 0.5],
              57: [0, 0.65556, 0, 0, 0.5],
              58: [0, 0.44444, 0, 0, 0.27778],
              59: [0.125, 0.44444, 0, 0, 0.27778],
              61: [-0.13, 0.37, 0, 0, 0.77778],
              63: [0, 0.69444, 0, 0, 0.47222],
              64: [0, 0.69444, 0, 0, 0.66667],
              65: [0, 0.69444, 0, 0, 0.66667],
              66: [0, 0.69444, 0, 0, 0.66667],
              67: [0, 0.69444, 0, 0, 0.63889],
              68: [0, 0.69444, 0, 0, 0.72223],
              69: [0, 0.69444, 0, 0, 0.59722],
              70: [0, 0.69444, 0, 0, 0.56945],
              71: [0, 0.69444, 0, 0, 0.66667],
              72: [0, 0.69444, 0, 0, 0.70834],
              73: [0, 0.69444, 0, 0, 0.27778],
              74: [0, 0.69444, 0, 0, 0.47222],
              75: [0, 0.69444, 0, 0, 0.69445],
              76: [0, 0.69444, 0, 0, 0.54167],
              77: [0, 0.69444, 0, 0, 0.875],
              78: [0, 0.69444, 0, 0, 0.70834],
              79: [0, 0.69444, 0, 0, 0.73611],
              80: [0, 0.69444, 0, 0, 0.63889],
              81: [0.125, 0.69444, 0, 0, 0.73611],
              82: [0, 0.69444, 0, 0, 0.64584],
              83: [0, 0.69444, 0, 0, 0.55556],
              84: [0, 0.69444, 0, 0, 0.68056],
              85: [0, 0.69444, 0, 0, 0.6875],
              86: [0, 0.69444, 0.01389, 0, 0.66667],
              87: [0, 0.69444, 0.01389, 0, 0.94445],
              88: [0, 0.69444, 0, 0, 0.66667],
              89: [0, 0.69444, 0.025, 0, 0.66667],
              90: [0, 0.69444, 0, 0, 0.61111],
              91: [0.25, 0.75, 0, 0, 0.28889],
              93: [0.25, 0.75, 0, 0, 0.28889],
              94: [0, 0.69444, 0, 0, 0.5],
              95: [0.35, 0.09444, 0.02778, 0, 0.5],
              97: [0, 0.44444, 0, 0, 0.48056],
              98: [0, 0.69444, 0, 0, 0.51667],
              99: [0, 0.44444, 0, 0, 0.44445],
              100: [0, 0.69444, 0, 0, 0.51667],
              101: [0, 0.44444, 0, 0, 0.44445],
              102: [0, 0.69444, 0.06944, 0, 0.30556],
              103: [0.19444, 0.44444, 0.01389, 0, 0.5],
              104: [0, 0.69444, 0, 0, 0.51667],
              105: [0, 0.67937, 0, 0, 0.23889],
              106: [0.19444, 0.67937, 0, 0, 0.26667],
              107: [0, 0.69444, 0, 0, 0.48889],
              108: [0, 0.69444, 0, 0, 0.23889],
              109: [0, 0.44444, 0, 0, 0.79445],
              110: [0, 0.44444, 0, 0, 0.51667],
              111: [0, 0.44444, 0, 0, 0.5],
              112: [0.19444, 0.44444, 0, 0, 0.51667],
              113: [0.19444, 0.44444, 0, 0, 0.51667],
              114: [0, 0.44444, 0.01389, 0, 0.34167],
              115: [0, 0.44444, 0, 0, 0.38333],
              116: [0, 0.57143, 0, 0, 0.36111],
              117: [0, 0.44444, 0, 0, 0.51667],
              118: [0, 0.44444, 0.01389, 0, 0.46111],
              119: [0, 0.44444, 0.01389, 0, 0.68334],
              120: [0, 0.44444, 0, 0, 0.46111],
              121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
              122: [0, 0.44444, 0, 0, 0.43472],
              126: [0.35, 0.32659, 0, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.67937, 0, 0, 0.5],
              176: [0, 0.69444, 0, 0, 0.66667],
              184: [0.17014, 0, 0, 0, 0.44445],
              305: [0, 0.44444, 0, 0, 0.23889],
              567: [0.19444, 0.44444, 0, 0, 0.26667],
              710: [0, 0.69444, 0, 0, 0.5],
              711: [0, 0.63194, 0, 0, 0.5],
              713: [0, 0.60889, 0, 0, 0.5],
              714: [0, 0.69444, 0, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0, 0, 0.5],
              729: [0, 0.67937, 0, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.66667],
              732: [0, 0.67659, 0, 0, 0.5],
              733: [0, 0.69444, 0, 0, 0.5],
              915: [0, 0.69444, 0, 0, 0.54167],
              916: [0, 0.69444, 0, 0, 0.83334],
              920: [0, 0.69444, 0, 0, 0.77778],
              923: [0, 0.69444, 0, 0, 0.61111],
              926: [0, 0.69444, 0, 0, 0.66667],
              928: [0, 0.69444, 0, 0, 0.70834],
              931: [0, 0.69444, 0, 0, 0.72222],
              933: [0, 0.69444, 0, 0, 0.77778],
              934: [0, 0.69444, 0, 0, 0.72222],
              936: [0, 0.69444, 0, 0, 0.77778],
              937: [0, 0.69444, 0, 0, 0.72222],
              8211: [0, 0.44444, 0.02778, 0, 0.5],
              8212: [0, 0.44444, 0.02778, 0, 1],
              8216: [0, 0.69444, 0, 0, 0.27778],
              8217: [0, 0.69444, 0, 0, 0.27778],
              8220: [0, 0.69444, 0, 0, 0.5],
              8221: [0, 0.69444, 0, 0, 0.5]
            },
            "Script-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.7, 0.22925, 0, 0.80253],
              66: [0, 0.7, 0.04087, 0, 0.90757],
              67: [0, 0.7, 0.1689, 0, 0.66619],
              68: [0, 0.7, 0.09371, 0, 0.77443],
              69: [0, 0.7, 0.18583, 0, 0.56162],
              70: [0, 0.7, 0.13634, 0, 0.89544],
              71: [0, 0.7, 0.17322, 0, 0.60961],
              72: [0, 0.7, 0.29694, 0, 0.96919],
              73: [0, 0.7, 0.19189, 0, 0.80907],
              74: [0.27778, 0.7, 0.19189, 0, 1.05159],
              75: [0, 0.7, 0.31259, 0, 0.91364],
              76: [0, 0.7, 0.19189, 0, 0.87373],
              77: [0, 0.7, 0.15981, 0, 1.08031],
              78: [0, 0.7, 0.3525, 0, 0.9015],
              79: [0, 0.7, 0.08078, 0, 0.73787],
              80: [0, 0.7, 0.08078, 0, 1.01262],
              81: [0, 0.7, 0.03305, 0, 0.88282],
              82: [0, 0.7, 0.06259, 0, 0.85],
              83: [0, 0.7, 0.19189, 0, 0.86767],
              84: [0, 0.7, 0.29087, 0, 0.74697],
              85: [0, 0.7, 0.25815, 0, 0.79996],
              86: [0, 0.7, 0.27523, 0, 0.62204],
              87: [0, 0.7, 0.27523, 0, 0.80532],
              88: [0, 0.7, 0.26006, 0, 0.94445],
              89: [0, 0.7, 0.2939, 0, 0.70961],
              90: [0, 0.7, 0.24037, 0, 0.8212],
              160: [0, 0, 0, 0, 0.25]
            },
            "Size1-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.35001, 0.85, 0, 0, 0.45834],
              41: [0.35001, 0.85, 0, 0, 0.45834],
              47: [0.35001, 0.85, 0, 0, 0.57778],
              91: [0.35001, 0.85, 0, 0, 0.41667],
              92: [0.35001, 0.85, 0, 0, 0.57778],
              93: [0.35001, 0.85, 0, 0, 0.41667],
              123: [0.35001, 0.85, 0, 0, 0.58334],
              125: [0.35001, 0.85, 0, 0, 0.58334],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.72222, 0, 0, 0.55556],
              732: [0, 0.72222, 0, 0, 0.55556],
              770: [0, 0.72222, 0, 0, 0.55556],
              771: [0, 0.72222, 0, 0, 0.55556],
              8214: [-99e-5, 0.601, 0, 0, 0.77778],
              8593: [1e-5, 0.6, 0, 0, 0.66667],
              8595: [1e-5, 0.6, 0, 0, 0.66667],
              8657: [1e-5, 0.6, 0, 0, 0.77778],
              8659: [1e-5, 0.6, 0, 0, 0.77778],
              8719: [0.25001, 0.75, 0, 0, 0.94445],
              8720: [0.25001, 0.75, 0, 0, 0.94445],
              8721: [0.25001, 0.75, 0, 0, 1.05556],
              8730: [0.35001, 0.85, 0, 0, 1],
              8739: [-599e-5, 0.606, 0, 0, 0.33333],
              8741: [-599e-5, 0.606, 0, 0, 0.55556],
              8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
              8748: [0.306, 0.805, 0.19445, 0, 0.47222],
              8749: [0.306, 0.805, 0.19445, 0, 0.47222],
              8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
              8896: [0.25001, 0.75, 0, 0, 0.83334],
              8897: [0.25001, 0.75, 0, 0, 0.83334],
              8898: [0.25001, 0.75, 0, 0, 0.83334],
              8899: [0.25001, 0.75, 0, 0, 0.83334],
              8968: [0.35001, 0.85, 0, 0, 0.47222],
              8969: [0.35001, 0.85, 0, 0, 0.47222],
              8970: [0.35001, 0.85, 0, 0, 0.47222],
              8971: [0.35001, 0.85, 0, 0, 0.47222],
              9168: [-99e-5, 0.601, 0, 0, 0.66667],
              10216: [0.35001, 0.85, 0, 0, 0.47222],
              10217: [0.35001, 0.85, 0, 0, 0.47222],
              10752: [0.25001, 0.75, 0, 0, 1.11111],
              10753: [0.25001, 0.75, 0, 0, 1.11111],
              10754: [0.25001, 0.75, 0, 0, 1.11111],
              10756: [0.25001, 0.75, 0, 0, 0.83334],
              10758: [0.25001, 0.75, 0, 0, 0.83334]
            },
            "Size2-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.65002, 1.15, 0, 0, 0.59722],
              41: [0.65002, 1.15, 0, 0, 0.59722],
              47: [0.65002, 1.15, 0, 0, 0.81111],
              91: [0.65002, 1.15, 0, 0, 0.47222],
              92: [0.65002, 1.15, 0, 0, 0.81111],
              93: [0.65002, 1.15, 0, 0, 0.47222],
              123: [0.65002, 1.15, 0, 0, 0.66667],
              125: [0.65002, 1.15, 0, 0, 0.66667],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.75, 0, 0, 1],
              732: [0, 0.75, 0, 0, 1],
              770: [0, 0.75, 0, 0, 1],
              771: [0, 0.75, 0, 0, 1],
              8719: [0.55001, 1.05, 0, 0, 1.27778],
              8720: [0.55001, 1.05, 0, 0, 1.27778],
              8721: [0.55001, 1.05, 0, 0, 1.44445],
              8730: [0.65002, 1.15, 0, 0, 1],
              8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
              8748: [0.862, 1.36, 0.44445, 0, 0.55556],
              8749: [0.862, 1.36, 0.44445, 0, 0.55556],
              8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
              8896: [0.55001, 1.05, 0, 0, 1.11111],
              8897: [0.55001, 1.05, 0, 0, 1.11111],
              8898: [0.55001, 1.05, 0, 0, 1.11111],
              8899: [0.55001, 1.05, 0, 0, 1.11111],
              8968: [0.65002, 1.15, 0, 0, 0.52778],
              8969: [0.65002, 1.15, 0, 0, 0.52778],
              8970: [0.65002, 1.15, 0, 0, 0.52778],
              8971: [0.65002, 1.15, 0, 0, 0.52778],
              10216: [0.65002, 1.15, 0, 0, 0.61111],
              10217: [0.65002, 1.15, 0, 0, 0.61111],
              10752: [0.55001, 1.05, 0, 0, 1.51112],
              10753: [0.55001, 1.05, 0, 0, 1.51112],
              10754: [0.55001, 1.05, 0, 0, 1.51112],
              10756: [0.55001, 1.05, 0, 0, 1.11111],
              10758: [0.55001, 1.05, 0, 0, 1.11111]
            },
            "Size3-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.95003, 1.45, 0, 0, 0.73611],
              41: [0.95003, 1.45, 0, 0, 0.73611],
              47: [0.95003, 1.45, 0, 0, 1.04445],
              91: [0.95003, 1.45, 0, 0, 0.52778],
              92: [0.95003, 1.45, 0, 0, 1.04445],
              93: [0.95003, 1.45, 0, 0, 0.52778],
              123: [0.95003, 1.45, 0, 0, 0.75],
              125: [0.95003, 1.45, 0, 0, 0.75],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.75, 0, 0, 1.44445],
              732: [0, 0.75, 0, 0, 1.44445],
              770: [0, 0.75, 0, 0, 1.44445],
              771: [0, 0.75, 0, 0, 1.44445],
              8730: [0.95003, 1.45, 0, 0, 1],
              8968: [0.95003, 1.45, 0, 0, 0.58334],
              8969: [0.95003, 1.45, 0, 0, 0.58334],
              8970: [0.95003, 1.45, 0, 0, 0.58334],
              8971: [0.95003, 1.45, 0, 0, 0.58334],
              10216: [0.95003, 1.45, 0, 0, 0.75],
              10217: [0.95003, 1.45, 0, 0, 0.75]
            },
            "Size4-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [1.25003, 1.75, 0, 0, 0.79167],
              41: [1.25003, 1.75, 0, 0, 0.79167],
              47: [1.25003, 1.75, 0, 0, 1.27778],
              91: [1.25003, 1.75, 0, 0, 0.58334],
              92: [1.25003, 1.75, 0, 0, 1.27778],
              93: [1.25003, 1.75, 0, 0, 0.58334],
              123: [1.25003, 1.75, 0, 0, 0.80556],
              125: [1.25003, 1.75, 0, 0, 0.80556],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.825, 0, 0, 1.8889],
              732: [0, 0.825, 0, 0, 1.8889],
              770: [0, 0.825, 0, 0, 1.8889],
              771: [0, 0.825, 0, 0, 1.8889],
              8730: [1.25003, 1.75, 0, 0, 1],
              8968: [1.25003, 1.75, 0, 0, 0.63889],
              8969: [1.25003, 1.75, 0, 0, 0.63889],
              8970: [1.25003, 1.75, 0, 0, 0.63889],
              8971: [1.25003, 1.75, 0, 0, 0.63889],
              9115: [0.64502, 1.155, 0, 0, 0.875],
              9116: [1e-5, 0.6, 0, 0, 0.875],
              9117: [0.64502, 1.155, 0, 0, 0.875],
              9118: [0.64502, 1.155, 0, 0, 0.875],
              9119: [1e-5, 0.6, 0, 0, 0.875],
              9120: [0.64502, 1.155, 0, 0, 0.875],
              9121: [0.64502, 1.155, 0, 0, 0.66667],
              9122: [-99e-5, 0.601, 0, 0, 0.66667],
              9123: [0.64502, 1.155, 0, 0, 0.66667],
              9124: [0.64502, 1.155, 0, 0, 0.66667],
              9125: [-99e-5, 0.601, 0, 0, 0.66667],
              9126: [0.64502, 1.155, 0, 0, 0.66667],
              9127: [1e-5, 0.9, 0, 0, 0.88889],
              9128: [0.65002, 1.15, 0, 0, 0.88889],
              9129: [0.90001, 0, 0, 0, 0.88889],
              9130: [0, 0.3, 0, 0, 0.88889],
              9131: [1e-5, 0.9, 0, 0, 0.88889],
              9132: [0.65002, 1.15, 0, 0, 0.88889],
              9133: [0.90001, 0, 0, 0, 0.88889],
              9143: [0.88502, 0.915, 0, 0, 1.05556],
              10216: [1.25003, 1.75, 0, 0, 0.80556],
              10217: [1.25003, 1.75, 0, 0, 0.80556],
              57344: [-499e-5, 0.605, 0, 0, 1.05556],
              57345: [-499e-5, 0.605, 0, 0, 1.05556],
              57680: [0, 0.12, 0, 0, 0.45],
              57681: [0, 0.12, 0, 0, 0.45],
              57682: [0, 0.12, 0, 0, 0.45],
              57683: [0, 0.12, 0, 0, 0.45]
            },
            "Typewriter-Regular": {
              32: [0, 0, 0, 0, 0.525],
              33: [0, 0.61111, 0, 0, 0.525],
              34: [0, 0.61111, 0, 0, 0.525],
              35: [0, 0.61111, 0, 0, 0.525],
              36: [0.08333, 0.69444, 0, 0, 0.525],
              37: [0.08333, 0.69444, 0, 0, 0.525],
              38: [0, 0.61111, 0, 0, 0.525],
              39: [0, 0.61111, 0, 0, 0.525],
              40: [0.08333, 0.69444, 0, 0, 0.525],
              41: [0.08333, 0.69444, 0, 0, 0.525],
              42: [0, 0.52083, 0, 0, 0.525],
              43: [-0.08056, 0.53055, 0, 0, 0.525],
              44: [0.13889, 0.125, 0, 0, 0.525],
              45: [-0.08056, 0.53055, 0, 0, 0.525],
              46: [0, 0.125, 0, 0, 0.525],
              47: [0.08333, 0.69444, 0, 0, 0.525],
              48: [0, 0.61111, 0, 0, 0.525],
              49: [0, 0.61111, 0, 0, 0.525],
              50: [0, 0.61111, 0, 0, 0.525],
              51: [0, 0.61111, 0, 0, 0.525],
              52: [0, 0.61111, 0, 0, 0.525],
              53: [0, 0.61111, 0, 0, 0.525],
              54: [0, 0.61111, 0, 0, 0.525],
              55: [0, 0.61111, 0, 0, 0.525],
              56: [0, 0.61111, 0, 0, 0.525],
              57: [0, 0.61111, 0, 0, 0.525],
              58: [0, 0.43056, 0, 0, 0.525],
              59: [0.13889, 0.43056, 0, 0, 0.525],
              60: [-0.05556, 0.55556, 0, 0, 0.525],
              61: [-0.19549, 0.41562, 0, 0, 0.525],
              62: [-0.05556, 0.55556, 0, 0, 0.525],
              63: [0, 0.61111, 0, 0, 0.525],
              64: [0, 0.61111, 0, 0, 0.525],
              65: [0, 0.61111, 0, 0, 0.525],
              66: [0, 0.61111, 0, 0, 0.525],
              67: [0, 0.61111, 0, 0, 0.525],
              68: [0, 0.61111, 0, 0, 0.525],
              69: [0, 0.61111, 0, 0, 0.525],
              70: [0, 0.61111, 0, 0, 0.525],
              71: [0, 0.61111, 0, 0, 0.525],
              72: [0, 0.61111, 0, 0, 0.525],
              73: [0, 0.61111, 0, 0, 0.525],
              74: [0, 0.61111, 0, 0, 0.525],
              75: [0, 0.61111, 0, 0, 0.525],
              76: [0, 0.61111, 0, 0, 0.525],
              77: [0, 0.61111, 0, 0, 0.525],
              78: [0, 0.61111, 0, 0, 0.525],
              79: [0, 0.61111, 0, 0, 0.525],
              80: [0, 0.61111, 0, 0, 0.525],
              81: [0.13889, 0.61111, 0, 0, 0.525],
              82: [0, 0.61111, 0, 0, 0.525],
              83: [0, 0.61111, 0, 0, 0.525],
              84: [0, 0.61111, 0, 0, 0.525],
              85: [0, 0.61111, 0, 0, 0.525],
              86: [0, 0.61111, 0, 0, 0.525],
              87: [0, 0.61111, 0, 0, 0.525],
              88: [0, 0.61111, 0, 0, 0.525],
              89: [0, 0.61111, 0, 0, 0.525],
              90: [0, 0.61111, 0, 0, 0.525],
              91: [0.08333, 0.69444, 0, 0, 0.525],
              92: [0.08333, 0.69444, 0, 0, 0.525],
              93: [0.08333, 0.69444, 0, 0, 0.525],
              94: [0, 0.61111, 0, 0, 0.525],
              95: [0.09514, 0, 0, 0, 0.525],
              96: [0, 0.61111, 0, 0, 0.525],
              97: [0, 0.43056, 0, 0, 0.525],
              98: [0, 0.61111, 0, 0, 0.525],
              99: [0, 0.43056, 0, 0, 0.525],
              100: [0, 0.61111, 0, 0, 0.525],
              101: [0, 0.43056, 0, 0, 0.525],
              102: [0, 0.61111, 0, 0, 0.525],
              103: [0.22222, 0.43056, 0, 0, 0.525],
              104: [0, 0.61111, 0, 0, 0.525],
              105: [0, 0.61111, 0, 0, 0.525],
              106: [0.22222, 0.61111, 0, 0, 0.525],
              107: [0, 0.61111, 0, 0, 0.525],
              108: [0, 0.61111, 0, 0, 0.525],
              109: [0, 0.43056, 0, 0, 0.525],
              110: [0, 0.43056, 0, 0, 0.525],
              111: [0, 0.43056, 0, 0, 0.525],
              112: [0.22222, 0.43056, 0, 0, 0.525],
              113: [0.22222, 0.43056, 0, 0, 0.525],
              114: [0, 0.43056, 0, 0, 0.525],
              115: [0, 0.43056, 0, 0, 0.525],
              116: [0, 0.55358, 0, 0, 0.525],
              117: [0, 0.43056, 0, 0, 0.525],
              118: [0, 0.43056, 0, 0, 0.525],
              119: [0, 0.43056, 0, 0, 0.525],
              120: [0, 0.43056, 0, 0, 0.525],
              121: [0.22222, 0.43056, 0, 0, 0.525],
              122: [0, 0.43056, 0, 0, 0.525],
              123: [0.08333, 0.69444, 0, 0, 0.525],
              124: [0.08333, 0.69444, 0, 0, 0.525],
              125: [0.08333, 0.69444, 0, 0, 0.525],
              126: [0, 0.61111, 0, 0, 0.525],
              127: [0, 0.61111, 0, 0, 0.525],
              160: [0, 0, 0, 0, 0.525],
              176: [0, 0.61111, 0, 0, 0.525],
              184: [0.19445, 0, 0, 0, 0.525],
              305: [0, 0.43056, 0, 0, 0.525],
              567: [0.22222, 0.43056, 0, 0, 0.525],
              711: [0, 0.56597, 0, 0, 0.525],
              713: [0, 0.56555, 0, 0, 0.525],
              714: [0, 0.61111, 0, 0, 0.525],
              715: [0, 0.61111, 0, 0, 0.525],
              728: [0, 0.61111, 0, 0, 0.525],
              730: [0, 0.61111, 0, 0, 0.525],
              770: [0, 0.61111, 0, 0, 0.525],
              771: [0, 0.61111, 0, 0, 0.525],
              776: [0, 0.61111, 0, 0, 0.525],
              915: [0, 0.61111, 0, 0, 0.525],
              916: [0, 0.61111, 0, 0, 0.525],
              920: [0, 0.61111, 0, 0, 0.525],
              923: [0, 0.61111, 0, 0, 0.525],
              926: [0, 0.61111, 0, 0, 0.525],
              928: [0, 0.61111, 0, 0, 0.525],
              931: [0, 0.61111, 0, 0, 0.525],
              933: [0, 0.61111, 0, 0, 0.525],
              934: [0, 0.61111, 0, 0, 0.525],
              936: [0, 0.61111, 0, 0, 0.525],
              937: [0, 0.61111, 0, 0, 0.525],
              8216: [0, 0.61111, 0, 0, 0.525],
              8217: [0, 0.61111, 0, 0, 0.525],
              8242: [0, 0.61111, 0, 0, 0.525],
              9251: [0.11111, 0.21944, 0, 0, 0.525]
            }
          };
          const ii = {
            slant: [0.25, 0.25, 0.25],
            // sigma1
            space: [0, 0, 0],
            // sigma2
            stretch: [0, 0, 0],
            // sigma3
            shrink: [0, 0, 0],
            // sigma4
            xHeight: [0.431, 0.431, 0.431],
            // sigma5
            quad: [1, 1.171, 1.472],
            // sigma6
            extraSpace: [0, 0, 0],
            // sigma7
            num1: [0.677, 0.732, 0.925],
            // sigma8
            num2: [0.394, 0.384, 0.387],
            // sigma9
            num3: [0.444, 0.471, 0.504],
            // sigma10
            denom1: [0.686, 0.752, 1.025],
            // sigma11
            denom2: [0.345, 0.344, 0.532],
            // sigma12
            sup1: [0.413, 0.503, 0.504],
            // sigma13
            sup2: [0.363, 0.431, 0.404],
            // sigma14
            sup3: [0.289, 0.286, 0.294],
            // sigma15
            sub1: [0.15, 0.143, 0.2],
            // sigma16
            sub2: [0.247, 0.286, 0.4],
            // sigma17
            supDrop: [0.386, 0.353, 0.494],
            // sigma18
            subDrop: [0.05, 0.071, 0.1],
            // sigma19
            delim1: [2.39, 1.7, 1.98],
            // sigma20
            delim2: [1.01, 1.157, 1.42],
            // sigma21
            axisHeight: [0.25, 0.25, 0.25],
            // sigma22
            // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
            // they correspond to the font parameters of the extension fonts (family 3).
            // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
            // match cmex7, we'd use cmex7.tfm values for script and scriptscript
            // values.
            defaultRuleThickness: [0.04, 0.049, 0.049],
            // xi8; cmex7: 0.049
            bigOpSpacing1: [0.111, 0.111, 0.111],
            // xi9
            bigOpSpacing2: [0.166, 0.166, 0.166],
            // xi10
            bigOpSpacing3: [0.2, 0.2, 0.2],
            // xi11
            bigOpSpacing4: [0.6, 0.611, 0.611],
            // xi12; cmex7: 0.611
            bigOpSpacing5: [0.1, 0.143, 0.143],
            // xi13; cmex7: 0.143
            // The \sqrt rule width is taken from the height of the surd character.
            // Since we use the same font at all sizes, this thickness doesn't scale.
            sqrtRuleThickness: [0.04, 0.04, 0.04],
            // This value determines how large a pt is, for metrics which are defined
            // in terms of pts.
            // This value is also used in katex.scss; if you change it make sure the
            // values match.
            ptPerEm: [10, 10, 10],
            // The space between adjacent `|` columns in an array definition. From
            // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
            doubleRuleSep: [0.2, 0.2, 0.2],
            // The width of separator lines in {array} environments. From
            // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
            arrayRuleWidth: [0.04, 0.04, 0.04],
            // Two values from LaTeX source2e:
            fboxsep: [0.3, 0.3, 0.3],
            //        3 pt / ptPerEm
            fboxrule: [0.04, 0.04, 0.04]
            // 0.4 pt / ptPerEm
          }, ko = {
            // Latin-1
            Å: "A",
            Ð: "D",
            Þ: "o",
            å: "a",
            ð: "d",
            þ: "o",
            // Cyrillic
            А: "A",
            Б: "B",
            В: "B",
            Г: "F",
            Д: "A",
            Е: "E",
            Ж: "K",
            З: "3",
            И: "N",
            Й: "N",
            К: "K",
            Л: "N",
            М: "M",
            Н: "H",
            О: "O",
            П: "N",
            Р: "P",
            С: "C",
            Т: "T",
            У: "y",
            Ф: "O",
            Х: "X",
            Ц: "U",
            Ч: "h",
            Ш: "W",
            Щ: "W",
            Ъ: "B",
            Ы: "X",
            Ь: "B",
            Э: "3",
            Ю: "X",
            Я: "R",
            а: "a",
            б: "b",
            в: "a",
            г: "r",
            д: "y",
            е: "e",
            ж: "m",
            з: "e",
            и: "n",
            й: "n",
            к: "n",
            л: "n",
            м: "m",
            н: "n",
            о: "o",
            п: "n",
            р: "p",
            с: "c",
            т: "o",
            у: "y",
            ф: "b",
            х: "x",
            ц: "n",
            ч: "n",
            ш: "w",
            щ: "w",
            ъ: "a",
            ы: "m",
            ь: "a",
            э: "e",
            ю: "m",
            я: "r"
          };
          function wc(d, u) {
            br[d] = u;
          }
          function vo(d, u, f) {
            if (!br[u])
              throw new Error("Font metrics not found for font: " + u + ".");
            let b = d.charCodeAt(0), w = br[u][b];
            if (!w && d[0] in ko && (b = ko[d[0]].charCodeAt(0), w = br[u][b]), !w && f === "text" && gt(b) && (w = br[u][77]), w)
              return {
                depth: w[0],
                height: w[1],
                italic: w[2],
                skew: w[3],
                width: w[4]
              };
          }
          const ms = {};
          function gs(d) {
            let u;
            if (d >= 5 ? u = 0 : d >= 3 ? u = 1 : u = 2, !ms[u]) {
              const f = ms[u] = {
                cssEmPerMu: ii.quad[u] / 18
              };
              for (const b in ii)
                ii.hasOwnProperty(b) && (f[b] = ii[b][u]);
            }
            return ms[u];
          }
          const Ii = [
            // Each element contains [textsize, scriptsize, scriptscriptsize].
            // The size mappings are taken from TeX with \normalsize=10pt.
            [1, 1, 1],
            // size1: [5, 5, 5]              \tiny
            [2, 1, 1],
            // size2: [6, 5, 5]
            [3, 1, 1],
            // size3: [7, 5, 5]              \scriptsize
            [4, 2, 1],
            // size4: [8, 6, 5]              \footnotesize
            [5, 2, 1],
            // size5: [9, 6, 5]              \small
            [6, 3, 1],
            // size6: [10, 7, 5]             \normalsize
            [7, 4, 2],
            // size7: [12, 8, 6]             \large
            [8, 6, 3],
            // size8: [14.4, 10, 7]          \Large
            [9, 7, 6],
            // size9: [17.28, 12, 10]        \LARGE
            [10, 8, 7],
            // size10: [20.74, 14.4, 12]     \huge
            [11, 10, 9]
            // size11: [24.88, 20.74, 17.28] \HUGE
          ], si = [
            // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
            // you change size indexes, change that function.
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            1,
            1.2,
            1.44,
            1.728,
            2.074,
            2.488
          ], Co = function(d, u) {
            return u.size < 2 ? d : Ii[d - 1][u.size - 1];
          };
          class nn {
            // A font family applies to a group of fonts (i.e. SansSerif), while a font
            // represents a specific font (i.e. SansSerif Bold).
            // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
            /**
             * The base size index.
             */
            constructor(u) {
              this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = u.style, this.color = u.color, this.size = u.size || nn.BASESIZE, this.textSize = u.textSize || this.size, this.phantom = !!u.phantom, this.font = u.font || "", this.fontFamily = u.fontFamily || "", this.fontWeight = u.fontWeight || "", this.fontShape = u.fontShape || "", this.sizeMultiplier = si[this.size - 1], this.maxSize = u.maxSize, this.minRuleThickness = u.minRuleThickness, this._fontMetrics = void 0;
            }
            /**
             * Returns a new options object with the same properties as "this".  Properties
             * from "extension" will be copied to the new options object.
             */
            extend(u) {
              const f = {
                style: this.style,
                size: this.size,
                textSize: this.textSize,
                color: this.color,
                phantom: this.phantom,
                font: this.font,
                fontFamily: this.fontFamily,
                fontWeight: this.fontWeight,
                fontShape: this.fontShape,
                maxSize: this.maxSize,
                minRuleThickness: this.minRuleThickness
              };
              for (const b in u)
                u.hasOwnProperty(b) && (f[b] = u[b]);
              return new nn(f);
            }
            /**
             * Return an options object with the given style. If `this.style === style`,
             * returns `this`.
             */
            havingStyle(u) {
              return this.style === u ? this : this.extend({
                style: u,
                size: Co(this.textSize, u)
              });
            }
            /**
             * Return an options object with a cramped version of the current style. If
             * the current style is cramped, returns `this`.
             */
            havingCrampedStyle() {
              return this.havingStyle(this.style.cramp());
            }
            /**
             * Return an options object with the given size and in at least `\textstyle`.
             * Returns `this` if appropriate.
             */
            havingSize(u) {
              return this.size === u && this.textSize === u ? this : this.extend({
                style: this.style.text(),
                size: u,
                textSize: u,
                sizeMultiplier: si[u - 1]
              });
            }
            /**
             * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
             * changes to at least `\textstyle`.
             */
            havingBaseStyle(u) {
              u = u || this.style.text();
              const f = Co(nn.BASESIZE, u);
              return this.size === f && this.textSize === nn.BASESIZE && this.style === u ? this : this.extend({
                style: u,
                size: f
              });
            }
            /**
             * Remove the effect of sizing changes such as \Huge.
             * Keep the effect of the current style, such as \scriptstyle.
             */
            havingBaseSizing() {
              let u;
              switch (this.style.id) {
                case 4:
                case 5:
                  u = 3;
                  break;
                case 6:
                case 7:
                  u = 1;
                  break;
                default:
                  u = 6;
              }
              return this.extend({
                style: this.style.text(),
                size: u
              });
            }
            /**
             * Create a new options object with the given color.
             */
            withColor(u) {
              return this.extend({
                color: u
              });
            }
            /**
             * Create a new options object with "phantom" set to true.
             */
            withPhantom() {
              return this.extend({
                phantom: true
              });
            }
            /**
             * Creates a new options object with the given math font or old text font.
             * @type {[type]}
             */
            withFont(u) {
              return this.extend({
                font: u
              });
            }
            /**
             * Create a new options objects with the given fontFamily.
             */
            withTextFontFamily(u) {
              return this.extend({
                fontFamily: u,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontWeight(u) {
              return this.extend({
                fontWeight: u,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontShape(u) {
              return this.extend({
                fontShape: u,
                font: ""
              });
            }
            /**
             * Return the CSS sizing classes required to switch from enclosing options
             * `oldOptions` to `this`. Returns an array of classes.
             */
            sizingClasses(u) {
              return u.size !== this.size ? ["sizing", "reset-size" + u.size, "size" + this.size] : [];
            }
            /**
             * Return the CSS sizing classes required to switch to the base size. Like
             * `this.havingSize(BASESIZE).sizingClasses(this)`.
             */
            baseSizingClasses() {
              return this.size !== nn.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + nn.BASESIZE] : [];
            }
            /**
             * Return the font metrics for this size.
             */
            fontMetrics() {
              return this._fontMetrics || (this._fontMetrics = gs(this.size)), this._fontMetrics;
            }
            /**
             * Gets the CSS color of the current options object
             */
            getColor() {
              return this.phantom ? "transparent" : this.color;
            }
          }
          nn.BASESIZE = 6;
          var kc = nn;
          const ys = {
            // https://en.wikibooks.org/wiki/LaTeX/Lengths and
            // https://tex.stackexchange.com/a/8263
            pt: 1,
            // TeX point
            mm: 7227 / 2540,
            // millimeter
            cm: 7227 / 254,
            // centimeter
            in: 72.27,
            // inch
            bp: 803 / 800,
            // big (PostScript) points
            pc: 12,
            // pica
            dd: 1238 / 1157,
            // didot
            cc: 14856 / 1157,
            // cicero (12 didot)
            nd: 685 / 642,
            // new didot
            nc: 1370 / 107,
            // new cicero (12 new didot)
            sp: 1 / 65536,
            // scaled point (TeX's internal smallest unit)
            // https://tex.stackexchange.com/a/41371
            px: 803 / 800
            // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
          }, vc = {
            ex: true,
            em: true,
            mu: true
          }, bs = function(d) {
            return typeof d != "string" && (d = d.unit), d in ys || d in vc || d === "ex";
          }, xe = function(d, u) {
            let f;
            if (d.unit in ys)
              f = ys[d.unit] / u.fontMetrics().ptPerEm / u.sizeMultiplier;
            else if (d.unit === "mu")
              f = u.fontMetrics().cssEmPerMu;
            else {
              let b;
              if (u.style.isTight() ? b = u.havingStyle(u.style.text()) : b = u, d.unit === "ex")
                f = b.fontMetrics().xHeight;
              else if (d.unit === "em")
                f = b.fontMetrics().quad;
              else
                throw new s("Invalid unit: '" + d.unit + "'");
              b !== u && (f *= b.sizeMultiplier / u.sizeMultiplier);
            }
            return Math.min(d.number * f, u.maxSize);
          }, bt = function(d) {
            return +d.toFixed(4) + "em";
          }, xr = function(d) {
            return d.filter((u) => u).join(" ");
          }, da = function(d, u, f) {
            if (this.classes = d || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = f || {}, u) {
              u.style.isTight() && this.classes.push("mtight");
              const b = u.getColor();
              b && (this.style.color = b);
            }
          }, pa = function(d) {
            const u = document.createElement(d);
            u.className = xr(this.classes);
            for (const f in this.style)
              this.style.hasOwnProperty(f) && (u.style[f] = this.style[f]);
            for (const f in this.attributes)
              this.attributes.hasOwnProperty(f) && u.setAttribute(f, this.attributes[f]);
            for (let f = 0; f < this.children.length; f++)
              u.appendChild(this.children[f].toNode());
            return u;
          }, Uu = /[\s"'>/=\x00-\x1f]/, xs = function(d) {
            let u = "<" + d;
            this.classes.length && (u += ' class="' + k.escape(xr(this.classes)) + '"');
            let f = "";
            for (const b in this.style)
              this.style.hasOwnProperty(b) && (f += k.hyphenate(b) + ":" + this.style[b] + ";");
            f && (u += ' style="' + k.escape(f) + '"');
            for (const b in this.attributes)
              if (this.attributes.hasOwnProperty(b)) {
                if (Uu.test(b))
                  throw new s("Invalid attribute name '" + b + "'");
                u += " " + b + '="' + k.escape(this.attributes[b]) + '"';
              }
            u += ">";
            for (let b = 0; b < this.children.length; b++)
              u += this.children[b].toMarkup();
            return u += "</" + d + ">", u;
          };
          class Mn {
            constructor(u, f, b, w) {
              this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, da.call(this, u, b, w), this.children = f || [];
            }
            /**
             * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
             * all browsers support attributes the same, and having too many custom
             * attributes is probably bad.
             */
            setAttribute(u, f) {
              this.attributes[u] = f;
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            toNode() {
              return pa.call(this, "span");
            }
            toMarkup() {
              return xs.call(this, "span");
            }
          }
          class _o {
            constructor(u, f, b, w) {
              this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, da.call(this, f, w), this.children = b || [], this.setAttribute("href", u);
            }
            setAttribute(u, f) {
              this.attributes[u] = f;
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            toNode() {
              return pa.call(this, "a");
            }
            toMarkup() {
              return xs.call(this, "a");
            }
          }
          class ws {
            constructor(u, f, b) {
              this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = f, this.src = u, this.classes = ["mord"], this.style = b;
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            toNode() {
              const u = document.createElement("img");
              u.src = this.src, u.alt = this.alt, u.className = "mord";
              for (const f in this.style)
                this.style.hasOwnProperty(f) && (u.style[f] = this.style[f]);
              return u;
            }
            toMarkup() {
              let u = '<img src="' + k.escape(this.src) + '"' + (' alt="' + k.escape(this.alt) + '"'), f = "";
              for (const b in this.style)
                this.style.hasOwnProperty(b) && (f += k.hyphenate(b) + ":" + this.style[b] + ";");
              return f && (u += ' style="' + k.escape(f) + '"'), u += "'/>", u;
            }
          }
          const Vu = {
            î: "ı̂",
            ï: "ı̈",
            í: "ı́",
            // 'ī': '\u0131\u0304', // enable when we add Extended Latin
            ì: "ı̀"
          };
          class Mr {
            constructor(u, f, b, w, S, E, D, P) {
              this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = u, this.height = f || 0, this.depth = b || 0, this.italic = w || 0, this.skew = S || 0, this.width = E || 0, this.classes = D || [], this.style = P || {}, this.maxFontSize = 0;
              const J = X(this.text.charCodeAt(0));
              J && this.classes.push(J + "_fallback"), /[îïíì]/.test(this.text) && (this.text = Vu[this.text]);
            }
            hasClass(u) {
              return k.contains(this.classes, u);
            }
            /**
             * Creates a text node or span from a symbol node. Note that a span is only
             * created if it is needed.
             */
            toNode() {
              const u = document.createTextNode(this.text);
              let f = null;
              this.italic > 0 && (f = document.createElement("span"), f.style.marginRight = bt(this.italic)), this.classes.length > 0 && (f = f || document.createElement("span"), f.className = xr(this.classes));
              for (const b in this.style)
                this.style.hasOwnProperty(b) && (f = f || document.createElement("span"), f.style[b] = this.style[b]);
              return f ? (f.appendChild(u), f) : u;
            }
            /**
             * Creates markup for a symbol node.
             */
            toMarkup() {
              let u = false, f = "<span";
              this.classes.length && (u = true, f += ' class="', f += k.escape(xr(this.classes)), f += '"');
              let b = "";
              this.italic > 0 && (b += "margin-right:" + this.italic + "em;");
              for (const S in this.style)
                this.style.hasOwnProperty(S) && (b += k.hyphenate(S) + ":" + this.style[S] + ";");
              b && (u = true, f += ' style="' + k.escape(b) + '"');
              const w = k.escape(this.text);
              return u ? (f += ">", f += w, f += "</span>", f) : w;
            }
          }
          class we {
            constructor(u, f) {
              this.children = void 0, this.attributes = void 0, this.children = u || [], this.attributes = f || {};
            }
            toNode() {
              const u = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && u.setAttribute(f, this.attributes[f]);
              for (let f = 0; f < this.children.length; f++)
                u.appendChild(this.children[f].toNode());
              return u;
            }
            toMarkup() {
              let u = '<svg xmlns="http://www.w3.org/2000/svg"';
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && (u += " " + f + '="' + k.escape(this.attributes[f]) + '"');
              u += ">";
              for (let f = 0; f < this.children.length; f++)
                u += this.children[f].toMarkup();
              return u += "</svg>", u;
            }
          }
          class wr {
            constructor(u, f) {
              this.pathName = void 0, this.alternate = void 0, this.pathName = u, this.alternate = f;
            }
            toNode() {
              const u = document.createElementNS("http://www.w3.org/2000/svg", "path");
              return this.alternate ? u.setAttribute("d", this.alternate) : u.setAttribute("d", ua[this.pathName]), u;
            }
            toMarkup() {
              return this.alternate ? '<path d="' + k.escape(this.alternate) + '"/>' : '<path d="' + k.escape(ua[this.pathName]) + '"/>';
            }
          }
          class So {
            constructor(u) {
              this.attributes = void 0, this.attributes = u || {};
            }
            toNode() {
              const u = document.createElementNS("http://www.w3.org/2000/svg", "line");
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && u.setAttribute(f, this.attributes[f]);
              return u;
            }
            toMarkup() {
              let u = "<line";
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && (u += " " + f + '="' + k.escape(this.attributes[f]) + '"');
              return u += "/>", u;
            }
          }
          function Ao(d) {
            if (d instanceof Mr)
              return d;
            throw new Error("Expected symbolNode but got " + String(d) + ".");
          }
          function To(d) {
            if (d instanceof Mn)
              return d;
            throw new Error("Expected span<HtmlDomNode> but got " + String(d) + ".");
          }
          const Cc = {
            bin: 1,
            close: 1,
            inner: 1,
            open: 1,
            punct: 1,
            rel: 1
          }, _c = {
            "accent-token": 1,
            mathord: 1,
            "op-token": 1,
            spacing: 1,
            textord: 1
          }, fa = {
            math: {},
            text: {}
          };
          var pe = fa;
          function v(d, u, f, b, w, S) {
            fa[d][w] = {
              font: u,
              group: f,
              replace: b
            }, S && b && (fa[d][b] = fa[d][w]);
          }
          const T = "math", dt = "text", M = "main", V = "ams", se = "accent-token", St = "bin", Je = "close", ai = "inner", It = "mathord", Oe = "op-token", Z = "open", Ct = "punct", O = "rel", Qt = "spacing", tt = "textord";
          v(T, M, O, "≡", "\\equiv", true), v(T, M, O, "≺", "\\prec", true), v(T, M, O, "≻", "\\succ", true), v(T, M, O, "∼", "\\sim", true), v(T, M, O, "⊥", "\\perp"), v(T, M, O, "⪯", "\\preceq", true), v(T, M, O, "⪰", "\\succeq", true), v(T, M, O, "≃", "\\simeq", true), v(T, M, O, "∣", "\\mid", true), v(T, M, O, "≪", "\\ll", true), v(T, M, O, "≫", "\\gg", true), v(T, M, O, "≍", "\\asymp", true), v(T, M, O, "∥", "\\parallel"), v(T, M, O, "⋈", "\\bowtie", true), v(T, M, O, "⌣", "\\smile", true), v(T, M, O, "⊑", "\\sqsubseteq", true), v(T, M, O, "⊒", "\\sqsupseteq", true), v(T, M, O, "≐", "\\doteq", true), v(T, M, O, "⌢", "\\frown", true), v(T, M, O, "∋", "\\ni", true), v(T, M, O, "∝", "\\propto", true), v(T, M, O, "⊢", "\\vdash", true), v(T, M, O, "⊣", "\\dashv", true), v(T, M, O, "∋", "\\owns"), v(T, M, Ct, ".", "\\ldotp"), v(T, M, Ct, "⋅", "\\cdotp"), v(T, M, tt, "#", "\\#"), v(dt, M, tt, "#", "\\#"), v(T, M, tt, "&", "\\&"), v(dt, M, tt, "&", "\\&"), v(T, M, tt, "ℵ", "\\aleph", true), v(T, M, tt, "∀", "\\forall", true), v(T, M, tt, "ℏ", "\\hbar", true), v(T, M, tt, "∃", "\\exists", true), v(T, M, tt, "∇", "\\nabla", true), v(T, M, tt, "♭", "\\flat", true), v(T, M, tt, "ℓ", "\\ell", true), v(T, M, tt, "♮", "\\natural", true), v(T, M, tt, "♣", "\\clubsuit", true), v(T, M, tt, "℘", "\\wp", true), v(T, M, tt, "♯", "\\sharp", true), v(T, M, tt, "♢", "\\diamondsuit", true), v(T, M, tt, "ℜ", "\\Re", true), v(T, M, tt, "♡", "\\heartsuit", true), v(T, M, tt, "ℑ", "\\Im", true), v(T, M, tt, "♠", "\\spadesuit", true), v(T, M, tt, "§", "\\S", true), v(dt, M, tt, "§", "\\S"), v(T, M, tt, "¶", "\\P", true), v(dt, M, tt, "¶", "\\P"), v(T, M, tt, "†", "\\dag"), v(dt, M, tt, "†", "\\dag"), v(dt, M, tt, "†", "\\textdagger"), v(T, M, tt, "‡", "\\ddag"), v(dt, M, tt, "‡", "\\ddag"), v(dt, M, tt, "‡", "\\textdaggerdbl"), v(T, M, Je, "⎱", "\\rmoustache", true), v(T, M, Z, "⎰", "\\lmoustache", true), v(T, M, Je, "⟯", "\\rgroup", true), v(T, M, Z, "⟮", "\\lgroup", true), v(T, M, St, "∓", "\\mp", true), v(T, M, St, "⊖", "\\ominus", true), v(T, M, St, "⊎", "\\uplus", true), v(T, M, St, "⊓", "\\sqcap", true), v(T, M, St, "∗", "\\ast"), v(T, M, St, "⊔", "\\sqcup", true), v(T, M, St, "◯", "\\bigcirc", true), v(T, M, St, "∙", "\\bullet", true), v(T, M, St, "‡", "\\ddagger"), v(T, M, St, "≀", "\\wr", true), v(T, M, St, "⨿", "\\amalg"), v(T, M, St, "&", "\\And"), v(T, M, O, "⟵", "\\longleftarrow", true), v(T, M, O, "⇐", "\\Leftarrow", true), v(T, M, O, "⟸", "\\Longleftarrow", true), v(T, M, O, "⟶", "\\longrightarrow", true), v(T, M, O, "⇒", "\\Rightarrow", true), v(T, M, O, "⟹", "\\Longrightarrow", true), v(T, M, O, "↔", "\\leftrightarrow", true), v(T, M, O, "⟷", "\\longleftrightarrow", true), v(T, M, O, "⇔", "\\Leftrightarrow", true), v(T, M, O, "⟺", "\\Longleftrightarrow", true), v(T, M, O, "↦", "\\mapsto", true), v(T, M, O, "⟼", "\\longmapsto", true), v(T, M, O, "↗", "\\nearrow", true), v(T, M, O, "↩", "\\hookleftarrow", true), v(T, M, O, "↪", "\\hookrightarrow", true), v(T, M, O, "↘", "\\searrow", true), v(T, M, O, "↼", "\\leftharpoonup", true), v(T, M, O, "⇀", "\\rightharpoonup", true), v(T, M, O, "↙", "\\swarrow", true), v(T, M, O, "↽", "\\leftharpoondown", true), v(T, M, O, "⇁", "\\rightharpoondown", true), v(T, M, O, "↖", "\\nwarrow", true), v(T, M, O, "⇌", "\\rightleftharpoons", true), v(T, V, O, "≮", "\\nless", true), v(T, V, O, "", "\\@nleqslant"), v(T, V, O, "", "\\@nleqq"), v(T, V, O, "⪇", "\\lneq", true), v(T, V, O, "≨", "\\lneqq", true), v(T, V, O, "", "\\@lvertneqq"), v(T, V, O, "⋦", "\\lnsim", true), v(T, V, O, "⪉", "\\lnapprox", true), v(T, V, O, "⊀", "\\nprec", true), v(T, V, O, "⋠", "\\npreceq", true), v(T, V, O, "⋨", "\\precnsim", true), v(T, V, O, "⪹", "\\precnapprox", true), v(T, V, O, "≁", "\\nsim", true), v(T, V, O, "", "\\@nshortmid"), v(T, V, O, "∤", "\\nmid", true), v(T, V, O, "⊬", "\\nvdash", true), v(T, V, O, "⊭", "\\nvDash", true), v(T, V, O, "⋪", "\\ntriangleleft"), v(T, V, O, "⋬", "\\ntrianglelefteq", true), v(T, V, O, "⊊", "\\subsetneq", true), v(T, V, O, "", "\\@varsubsetneq"), v(T, V, O, "⫋", "\\subsetneqq", true), v(T, V, O, "", "\\@varsubsetneqq"), v(T, V, O, "≯", "\\ngtr", true), v(T, V, O, "", "\\@ngeqslant"), v(T, V, O, "", "\\@ngeqq"), v(T, V, O, "⪈", "\\gneq", true), v(T, V, O, "≩", "\\gneqq", true), v(T, V, O, "", "\\@gvertneqq"), v(T, V, O, "⋧", "\\gnsim", true), v(T, V, O, "⪊", "\\gnapprox", true), v(T, V, O, "⊁", "\\nsucc", true), v(T, V, O, "⋡", "\\nsucceq", true), v(T, V, O, "⋩", "\\succnsim", true), v(T, V, O, "⪺", "\\succnapprox", true), v(T, V, O, "≆", "\\ncong", true), v(T, V, O, "", "\\@nshortparallel"), v(T, V, O, "∦", "\\nparallel", true), v(T, V, O, "⊯", "\\nVDash", true), v(T, V, O, "⋫", "\\ntriangleright"), v(T, V, O, "⋭", "\\ntrianglerighteq", true), v(T, V, O, "", "\\@nsupseteqq"), v(T, V, O, "⊋", "\\supsetneq", true), v(T, V, O, "", "\\@varsupsetneq"), v(T, V, O, "⫌", "\\supsetneqq", true), v(T, V, O, "", "\\@varsupsetneqq"), v(T, V, O, "⊮", "\\nVdash", true), v(T, V, O, "⪵", "\\precneqq", true), v(T, V, O, "⪶", "\\succneqq", true), v(T, V, O, "", "\\@nsubseteqq"), v(T, V, St, "⊴", "\\unlhd"), v(T, V, St, "⊵", "\\unrhd"), v(T, V, O, "↚", "\\nleftarrow", true), v(T, V, O, "↛", "\\nrightarrow", true), v(T, V, O, "⇍", "\\nLeftarrow", true), v(T, V, O, "⇏", "\\nRightarrow", true), v(T, V, O, "↮", "\\nleftrightarrow", true), v(T, V, O, "⇎", "\\nLeftrightarrow", true), v(T, V, O, "△", "\\vartriangle"), v(T, V, tt, "ℏ", "\\hslash"), v(T, V, tt, "▽", "\\triangledown"), v(T, V, tt, "◊", "\\lozenge"), v(T, V, tt, "Ⓢ", "\\circledS"), v(T, V, tt, "®", "\\circledR"), v(dt, V, tt, "®", "\\circledR"), v(T, V, tt, "∡", "\\measuredangle", true), v(T, V, tt, "∄", "\\nexists"), v(T, V, tt, "℧", "\\mho"), v(T, V, tt, "Ⅎ", "\\Finv", true), v(T, V, tt, "⅁", "\\Game", true), v(T, V, tt, "‵", "\\backprime"), v(T, V, tt, "▲", "\\blacktriangle"), v(T, V, tt, "▼", "\\blacktriangledown"), v(T, V, tt, "■", "\\blacksquare"), v(T, V, tt, "⧫", "\\blacklozenge"), v(T, V, tt, "★", "\\bigstar"), v(T, V, tt, "∢", "\\sphericalangle", true), v(T, V, tt, "∁", "\\complement", true), v(T, V, tt, "ð", "\\eth", true), v(dt, M, tt, "ð", "ð"), v(T, V, tt, "╱", "\\diagup"), v(T, V, tt, "╲", "\\diagdown"), v(T, V, tt, "□", "\\square"), v(T, V, tt, "□", "\\Box"), v(T, V, tt, "◊", "\\Diamond"), v(T, V, tt, "¥", "\\yen", true), v(dt, V, tt, "¥", "\\yen", true), v(T, V, tt, "✓", "\\checkmark", true), v(dt, V, tt, "✓", "\\checkmark"), v(T, V, tt, "ℶ", "\\beth", true), v(T, V, tt, "ℸ", "\\daleth", true), v(T, V, tt, "ℷ", "\\gimel", true), v(T, V, tt, "ϝ", "\\digamma", true), v(T, V, tt, "ϰ", "\\varkappa"), v(T, V, Z, "┌", "\\@ulcorner", true), v(T, V, Je, "┐", "\\@urcorner", true), v(T, V, Z, "└", "\\@llcorner", true), v(T, V, Je, "┘", "\\@lrcorner", true), v(T, V, O, "≦", "\\leqq", true), v(T, V, O, "⩽", "\\leqslant", true), v(T, V, O, "⪕", "\\eqslantless", true), v(T, V, O, "≲", "\\lesssim", true), v(T, V, O, "⪅", "\\lessapprox", true), v(T, V, O, "≊", "\\approxeq", true), v(T, V, St, "⋖", "\\lessdot"), v(T, V, O, "⋘", "\\lll", true), v(T, V, O, "≶", "\\lessgtr", true), v(T, V, O, "⋚", "\\lesseqgtr", true), v(T, V, O, "⪋", "\\lesseqqgtr", true), v(T, V, O, "≑", "\\doteqdot"), v(T, V, O, "≓", "\\risingdotseq", true), v(T, V, O, "≒", "\\fallingdotseq", true), v(T, V, O, "∽", "\\backsim", true), v(T, V, O, "⋍", "\\backsimeq", true), v(T, V, O, "⫅", "\\subseteqq", true), v(T, V, O, "⋐", "\\Subset", true), v(T, V, O, "⊏", "\\sqsubset", true), v(T, V, O, "≼", "\\preccurlyeq", true), v(T, V, O, "⋞", "\\curlyeqprec", true), v(T, V, O, "≾", "\\precsim", true), v(T, V, O, "⪷", "\\precapprox", true), v(T, V, O, "⊲", "\\vartriangleleft"), v(T, V, O, "⊴", "\\trianglelefteq"), v(T, V, O, "⊨", "\\vDash", true), v(T, V, O, "⊪", "\\Vvdash", true), v(T, V, O, "⌣", "\\smallsmile"), v(T, V, O, "⌢", "\\smallfrown"), v(T, V, O, "≏", "\\bumpeq", true), v(T, V, O, "≎", "\\Bumpeq", true), v(T, V, O, "≧", "\\geqq", true), v(T, V, O, "⩾", "\\geqslant", true), v(T, V, O, "⪖", "\\eqslantgtr", true), v(T, V, O, "≳", "\\gtrsim", true), v(T, V, O, "⪆", "\\gtrapprox", true), v(T, V, St, "⋗", "\\gtrdot"), v(T, V, O, "⋙", "\\ggg", true), v(T, V, O, "≷", "\\gtrless", true), v(T, V, O, "⋛", "\\gtreqless", true), v(T, V, O, "⪌", "\\gtreqqless", true), v(T, V, O, "≖", "\\eqcirc", true), v(T, V, O, "≗", "\\circeq", true), v(T, V, O, "≜", "\\triangleq", true), v(T, V, O, "∼", "\\thicksim"), v(T, V, O, "≈", "\\thickapprox"), v(T, V, O, "⫆", "\\supseteqq", true), v(T, V, O, "⋑", "\\Supset", true), v(T, V, O, "⊐", "\\sqsupset", true), v(T, V, O, "≽", "\\succcurlyeq", true), v(T, V, O, "⋟", "\\curlyeqsucc", true), v(T, V, O, "≿", "\\succsim", true), v(T, V, O, "⪸", "\\succapprox", true), v(T, V, O, "⊳", "\\vartriangleright"), v(T, V, O, "⊵", "\\trianglerighteq"), v(T, V, O, "⊩", "\\Vdash", true), v(T, V, O, "∣", "\\shortmid"), v(T, V, O, "∥", "\\shortparallel"), v(T, V, O, "≬", "\\between", true), v(T, V, O, "⋔", "\\pitchfork", true), v(T, V, O, "∝", "\\varpropto"), v(T, V, O, "◀", "\\blacktriangleleft"), v(T, V, O, "∴", "\\therefore", true), v(T, V, O, "∍", "\\backepsilon"), v(T, V, O, "▶", "\\blacktriangleright"), v(T, V, O, "∵", "\\because", true), v(T, V, O, "⋘", "\\llless"), v(T, V, O, "⋙", "\\gggtr"), v(T, V, St, "⊲", "\\lhd"), v(T, V, St, "⊳", "\\rhd"), v(T, V, O, "≂", "\\eqsim", true), v(T, M, O, "⋈", "\\Join"), v(T, V, O, "≑", "\\Doteq", true), v(T, V, St, "∔", "\\dotplus", true), v(T, V, St, "∖", "\\smallsetminus"), v(T, V, St, "⋒", "\\Cap", true), v(T, V, St, "⋓", "\\Cup", true), v(T, V, St, "⩞", "\\doublebarwedge", true), v(T, V, St, "⊟", "\\boxminus", true), v(T, V, St, "⊞", "\\boxplus", true), v(T, V, St, "⋇", "\\divideontimes", true), v(T, V, St, "⋉", "\\ltimes", true), v(T, V, St, "⋊", "\\rtimes", true), v(T, V, St, "⋋", "\\leftthreetimes", true), v(T, V, St, "⋌", "\\rightthreetimes", true), v(T, V, St, "⋏", "\\curlywedge", true), v(T, V, St, "⋎", "\\curlyvee", true), v(T, V, St, "⊝", "\\circleddash", true), v(T, V, St, "⊛", "\\circledast", true), v(T, V, St, "⋅", "\\centerdot"), v(T, V, St, "⊺", "\\intercal", true), v(T, V, St, "⋒", "\\doublecap"), v(T, V, St, "⋓", "\\doublecup"), v(T, V, St, "⊠", "\\boxtimes", true), v(T, V, O, "⇢", "\\dashrightarrow", true), v(T, V, O, "⇠", "\\dashleftarrow", true), v(T, V, O, "⇇", "\\leftleftarrows", true), v(T, V, O, "⇆", "\\leftrightarrows", true), v(T, V, O, "⇚", "\\Lleftarrow", true), v(T, V, O, "↞", "\\twoheadleftarrow", true), v(T, V, O, "↢", "\\leftarrowtail", true), v(T, V, O, "↫", "\\looparrowleft", true), v(T, V, O, "⇋", "\\leftrightharpoons", true), v(T, V, O, "↶", "\\curvearrowleft", true), v(T, V, O, "↺", "\\circlearrowleft", true), v(T, V, O, "↰", "\\Lsh", true), v(T, V, O, "⇈", "\\upuparrows", true), v(T, V, O, "↿", "\\upharpoonleft", true), v(T, V, O, "⇃", "\\downharpoonleft", true), v(T, M, O, "⊶", "\\origof", true), v(T, M, O, "⊷", "\\imageof", true), v(T, V, O, "⊸", "\\multimap", true), v(T, V, O, "↭", "\\leftrightsquigarrow", true), v(T, V, O, "⇉", "\\rightrightarrows", true), v(T, V, O, "⇄", "\\rightleftarrows", true), v(T, V, O, "↠", "\\twoheadrightarrow", true), v(T, V, O, "↣", "\\rightarrowtail", true), v(T, V, O, "↬", "\\looparrowright", true), v(T, V, O, "↷", "\\curvearrowright", true), v(T, V, O, "↻", "\\circlearrowright", true), v(T, V, O, "↱", "\\Rsh", true), v(T, V, O, "⇊", "\\downdownarrows", true), v(T, V, O, "↾", "\\upharpoonright", true), v(T, V, O, "⇂", "\\downharpoonright", true), v(T, V, O, "⇝", "\\rightsquigarrow", true), v(T, V, O, "⇝", "\\leadsto"), v(T, V, O, "⇛", "\\Rrightarrow", true), v(T, V, O, "↾", "\\restriction"), v(T, M, tt, "‘", "`"), v(T, M, tt, "$", "\\$"), v(dt, M, tt, "$", "\\$"), v(dt, M, tt, "$", "\\textdollar"), v(T, M, tt, "%", "\\%"), v(dt, M, tt, "%", "\\%"), v(T, M, tt, "_", "\\_"), v(dt, M, tt, "_", "\\_"), v(dt, M, tt, "_", "\\textunderscore"), v(T, M, tt, "∠", "\\angle", true), v(T, M, tt, "∞", "\\infty", true), v(T, M, tt, "′", "\\prime"), v(T, M, tt, "△", "\\triangle"), v(T, M, tt, "Γ", "\\Gamma", true), v(T, M, tt, "Δ", "\\Delta", true), v(T, M, tt, "Θ", "\\Theta", true), v(T, M, tt, "Λ", "\\Lambda", true), v(T, M, tt, "Ξ", "\\Xi", true), v(T, M, tt, "Π", "\\Pi", true), v(T, M, tt, "Σ", "\\Sigma", true), v(T, M, tt, "Υ", "\\Upsilon", true), v(T, M, tt, "Φ", "\\Phi", true), v(T, M, tt, "Ψ", "\\Psi", true), v(T, M, tt, "Ω", "\\Omega", true), v(T, M, tt, "A", "Α"), v(T, M, tt, "B", "Β"), v(T, M, tt, "E", "Ε"), v(T, M, tt, "Z", "Ζ"), v(T, M, tt, "H", "Η"), v(T, M, tt, "I", "Ι"), v(T, M, tt, "K", "Κ"), v(T, M, tt, "M", "Μ"), v(T, M, tt, "N", "Ν"), v(T, M, tt, "O", "Ο"), v(T, M, tt, "P", "Ρ"), v(T, M, tt, "T", "Τ"), v(T, M, tt, "X", "Χ"), v(T, M, tt, "¬", "\\neg", true), v(T, M, tt, "¬", "\\lnot"), v(T, M, tt, "⊤", "\\top"), v(T, M, tt, "⊥", "\\bot"), v(T, M, tt, "∅", "\\emptyset"), v(T, V, tt, "∅", "\\varnothing"), v(T, M, It, "α", "\\alpha", true), v(T, M, It, "β", "\\beta", true), v(T, M, It, "γ", "\\gamma", true), v(T, M, It, "δ", "\\delta", true), v(T, M, It, "ϵ", "\\epsilon", true), v(T, M, It, "ζ", "\\zeta", true), v(T, M, It, "η", "\\eta", true), v(T, M, It, "θ", "\\theta", true), v(T, M, It, "ι", "\\iota", true), v(T, M, It, "κ", "\\kappa", true), v(T, M, It, "λ", "\\lambda", true), v(T, M, It, "μ", "\\mu", true), v(T, M, It, "ν", "\\nu", true), v(T, M, It, "ξ", "\\xi", true), v(T, M, It, "ο", "\\omicron", true), v(T, M, It, "π", "\\pi", true), v(T, M, It, "ρ", "\\rho", true), v(T, M, It, "σ", "\\sigma", true), v(T, M, It, "τ", "\\tau", true), v(T, M, It, "υ", "\\upsilon", true), v(T, M, It, "ϕ", "\\phi", true), v(T, M, It, "χ", "\\chi", true), v(T, M, It, "ψ", "\\psi", true), v(T, M, It, "ω", "\\omega", true), v(T, M, It, "ε", "\\varepsilon", true), v(T, M, It, "ϑ", "\\vartheta", true), v(T, M, It, "ϖ", "\\varpi", true), v(T, M, It, "ϱ", "\\varrho", true), v(T, M, It, "ς", "\\varsigma", true), v(T, M, It, "φ", "\\varphi", true), v(T, M, St, "∗", "*", true), v(T, M, St, "+", "+"), v(T, M, St, "−", "-", true), v(T, M, St, "⋅", "\\cdot", true), v(T, M, St, "∘", "\\circ", true), v(T, M, St, "÷", "\\div", true), v(T, M, St, "±", "\\pm", true), v(T, M, St, "×", "\\times", true), v(T, M, St, "∩", "\\cap", true), v(T, M, St, "∪", "\\cup", true), v(T, M, St, "∖", "\\setminus", true), v(T, M, St, "∧", "\\land"), v(T, M, St, "∨", "\\lor"), v(T, M, St, "∧", "\\wedge", true), v(T, M, St, "∨", "\\vee", true), v(T, M, tt, "√", "\\surd"), v(T, M, Z, "⟨", "\\langle", true), v(T, M, Z, "∣", "\\lvert"), v(T, M, Z, "∥", "\\lVert"), v(T, M, Je, "?", "?"), v(T, M, Je, "!", "!"), v(T, M, Je, "⟩", "\\rangle", true), v(T, M, Je, "∣", "\\rvert"), v(T, M, Je, "∥", "\\rVert"), v(T, M, O, "=", "="), v(T, M, O, ":", ":"), v(T, M, O, "≈", "\\approx", true), v(T, M, O, "≅", "\\cong", true), v(T, M, O, "≥", "\\ge"), v(T, M, O, "≥", "\\geq", true), v(T, M, O, "←", "\\gets"), v(T, M, O, ">", "\\gt", true), v(T, M, O, "∈", "\\in", true), v(T, M, O, "", "\\@not"), v(T, M, O, "⊂", "\\subset", true), v(T, M, O, "⊃", "\\supset", true), v(T, M, O, "⊆", "\\subseteq", true), v(T, M, O, "⊇", "\\supseteq", true), v(T, V, O, "⊈", "\\nsubseteq", true), v(T, V, O, "⊉", "\\nsupseteq", true), v(T, M, O, "⊨", "\\models"), v(T, M, O, "←", "\\leftarrow", true), v(T, M, O, "≤", "\\le"), v(T, M, O, "≤", "\\leq", true), v(T, M, O, "<", "\\lt", true), v(T, M, O, "→", "\\rightarrow", true), v(T, M, O, "→", "\\to"), v(T, V, O, "≱", "\\ngeq", true), v(T, V, O, "≰", "\\nleq", true), v(T, M, Qt, " ", "\\ "), v(T, M, Qt, " ", "\\space"), v(T, M, Qt, " ", "\\nobreakspace"), v(dt, M, Qt, " ", "\\ "), v(dt, M, Qt, " ", " "), v(dt, M, Qt, " ", "\\space"), v(dt, M, Qt, " ", "\\nobreakspace"), v(T, M, Qt, null, "\\nobreak"), v(T, M, Qt, null, "\\allowbreak"), v(T, M, Ct, ",", ","), v(T, M, Ct, ";", ";"), v(T, V, St, "⊼", "\\barwedge", true), v(T, V, St, "⊻", "\\veebar", true), v(T, M, St, "⊙", "\\odot", true), v(T, M, St, "⊕", "\\oplus", true), v(T, M, St, "⊗", "\\otimes", true), v(T, M, tt, "∂", "\\partial", true), v(T, M, St, "⊘", "\\oslash", true), v(T, V, St, "⊚", "\\circledcirc", true), v(T, V, St, "⊡", "\\boxdot", true), v(T, M, St, "△", "\\bigtriangleup"), v(T, M, St, "▽", "\\bigtriangledown"), v(T, M, St, "†", "\\dagger"), v(T, M, St, "⋄", "\\diamond"), v(T, M, St, "⋆", "\\star"), v(T, M, St, "◃", "\\triangleleft"), v(T, M, St, "▹", "\\triangleright"), v(T, M, Z, "{", "\\{"), v(dt, M, tt, "{", "\\{"), v(dt, M, tt, "{", "\\textbraceleft"), v(T, M, Je, "}", "\\}"), v(dt, M, tt, "}", "\\}"), v(dt, M, tt, "}", "\\textbraceright"), v(T, M, Z, "{", "\\lbrace"), v(T, M, Je, "}", "\\rbrace"), v(T, M, Z, "[", "\\lbrack", true), v(dt, M, tt, "[", "\\lbrack", true), v(T, M, Je, "]", "\\rbrack", true), v(dt, M, tt, "]", "\\rbrack", true), v(T, M, Z, "(", "\\lparen", true), v(T, M, Je, ")", "\\rparen", true), v(dt, M, tt, "<", "\\textless", true), v(dt, M, tt, ">", "\\textgreater", true), v(T, M, Z, "⌊", "\\lfloor", true), v(T, M, Je, "⌋", "\\rfloor", true), v(T, M, Z, "⌈", "\\lceil", true), v(T, M, Je, "⌉", "\\rceil", true), v(T, M, tt, "\\", "\\backslash"), v(T, M, tt, "∣", "|"), v(T, M, tt, "∣", "\\vert"), v(dt, M, tt, "|", "\\textbar", true), v(T, M, tt, "∥", "\\|"), v(T, M, tt, "∥", "\\Vert"), v(dt, M, tt, "∥", "\\textbardbl"), v(dt, M, tt, "~", "\\textasciitilde"), v(dt, M, tt, "\\", "\\textbackslash"), v(dt, M, tt, "^", "\\textasciicircum"), v(T, M, O, "↑", "\\uparrow", true), v(T, M, O, "⇑", "\\Uparrow", true), v(T, M, O, "↓", "\\downarrow", true), v(T, M, O, "⇓", "\\Downarrow", true), v(T, M, O, "↕", "\\updownarrow", true), v(T, M, O, "⇕", "\\Updownarrow", true), v(T, M, Oe, "∐", "\\coprod"), v(T, M, Oe, "⋁", "\\bigvee"), v(T, M, Oe, "⋀", "\\bigwedge"), v(T, M, Oe, "⨄", "\\biguplus"), v(T, M, Oe, "⋂", "\\bigcap"), v(T, M, Oe, "⋃", "\\bigcup"), v(T, M, Oe, "∫", "\\int"), v(T, M, Oe, "∫", "\\intop"), v(T, M, Oe, "∬", "\\iint"), v(T, M, Oe, "∭", "\\iiint"), v(T, M, Oe, "∏", "\\prod"), v(T, M, Oe, "∑", "\\sum"), v(T, M, Oe, "⨂", "\\bigotimes"), v(T, M, Oe, "⨁", "\\bigoplus"), v(T, M, Oe, "⨀", "\\bigodot"), v(T, M, Oe, "∮", "\\oint"), v(T, M, Oe, "∯", "\\oiint"), v(T, M, Oe, "∰", "\\oiiint"), v(T, M, Oe, "⨆", "\\bigsqcup"), v(T, M, Oe, "∫", "\\smallint"), v(dt, M, ai, "…", "\\textellipsis"), v(T, M, ai, "…", "\\mathellipsis"), v(dt, M, ai, "…", "\\ldots", true), v(T, M, ai, "…", "\\ldots", true), v(T, M, ai, "⋯", "\\@cdots", true), v(T, M, ai, "⋱", "\\ddots", true), v(T, M, tt, "⋮", "\\varvdots"), v(dt, M, tt, "⋮", "\\varvdots"), v(T, M, se, "ˊ", "\\acute"), v(T, M, se, "ˋ", "\\grave"), v(T, M, se, "¨", "\\ddot"), v(T, M, se, "~", "\\tilde"), v(T, M, se, "ˉ", "\\bar"), v(T, M, se, "˘", "\\breve"), v(T, M, se, "ˇ", "\\check"), v(T, M, se, "^", "\\hat"), v(T, M, se, "⃗", "\\vec"), v(T, M, se, "˙", "\\dot"), v(T, M, se, "˚", "\\mathring"), v(T, M, It, "", "\\@imath"), v(T, M, It, "", "\\@jmath"), v(T, M, tt, "ı", "ı"), v(T, M, tt, "ȷ", "ȷ"), v(dt, M, tt, "ı", "\\i", true), v(dt, M, tt, "ȷ", "\\j", true), v(dt, M, tt, "ß", "\\ss", true), v(dt, M, tt, "æ", "\\ae", true), v(dt, M, tt, "œ", "\\oe", true), v(dt, M, tt, "ø", "\\o", true), v(dt, M, tt, "Æ", "\\AE", true), v(dt, M, tt, "Œ", "\\OE", true), v(dt, M, tt, "Ø", "\\O", true), v(dt, M, se, "ˊ", "\\'"), v(dt, M, se, "ˋ", "\\`"), v(dt, M, se, "ˆ", "\\^"), v(dt, M, se, "˜", "\\~"), v(dt, M, se, "ˉ", "\\="), v(dt, M, se, "˘", "\\u"), v(dt, M, se, "˙", "\\."), v(dt, M, se, "¸", "\\c"), v(dt, M, se, "˚", "\\r"), v(dt, M, se, "ˇ", "\\v"), v(dt, M, se, "¨", '\\"'), v(dt, M, se, "˝", "\\H"), v(dt, M, se, "◯", "\\textcircled");
          const Te = {
            "--": true,
            "---": true,
            "``": true,
            "''": true
          };
          v(dt, M, tt, "–", "--", true), v(dt, M, tt, "–", "\\textendash"), v(dt, M, tt, "—", "---", true), v(dt, M, tt, "—", "\\textemdash"), v(dt, M, tt, "‘", "`", true), v(dt, M, tt, "‘", "\\textquoteleft"), v(dt, M, tt, "’", "'", true), v(dt, M, tt, "’", "\\textquoteright"), v(dt, M, tt, "“", "``", true), v(dt, M, tt, "“", "\\textquotedblleft"), v(dt, M, tt, "”", "''", true), v(dt, M, tt, "”", "\\textquotedblright"), v(T, M, tt, "°", "\\degree", true), v(dt, M, tt, "°", "\\degree"), v(dt, M, tt, "°", "\\textdegree", true), v(T, M, tt, "£", "\\pounds"), v(T, M, tt, "£", "\\mathsterling", true), v(dt, M, tt, "£", "\\pounds"), v(dt, M, tt, "£", "\\textsterling", true), v(T, V, tt, "✠", "\\maltese"), v(dt, V, tt, "✠", "\\maltese");
          const sn = '0123456789/@."';
          for (let d = 0; d < sn.length; d++) {
            const u = sn.charAt(d);
            v(T, M, tt, u, u);
          }
          const Br = '0123456789!@*()-=+";:?/.,';
          for (let d = 0; d < Br.length; d++) {
            const u = Br.charAt(d);
            v(dt, M, tt, u, u);
          }
          const kr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          for (let d = 0; d < kr.length; d++) {
            const u = kr.charAt(d);
            v(T, M, It, u, u), v(dt, M, tt, u, u);
          }
          v(T, V, tt, "C", "ℂ"), v(dt, V, tt, "C", "ℂ"), v(T, V, tt, "H", "ℍ"), v(dt, V, tt, "H", "ℍ"), v(T, V, tt, "N", "ℕ"), v(dt, V, tt, "N", "ℕ"), v(T, V, tt, "P", "ℙ"), v(dt, V, tt, "P", "ℙ"), v(T, V, tt, "Q", "ℚ"), v(dt, V, tt, "Q", "ℚ"), v(T, V, tt, "R", "ℝ"), v(dt, V, tt, "R", "ℝ"), v(T, V, tt, "Z", "ℤ"), v(dt, V, tt, "Z", "ℤ"), v(T, M, It, "h", "ℎ"), v(dt, M, It, "h", "ℎ");
          let zt = "";
          for (let d = 0; d < kr.length; d++) {
            const u = kr.charAt(d);
            zt = String.fromCharCode(55349, 56320 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56372 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56424 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56580 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56684 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56736 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56788 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56840 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56944 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), d < 26 && (zt = String.fromCharCode(55349, 56632 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 56476 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt));
          }
          zt = "𝕜", v(T, M, It, "k", zt), v(dt, M, tt, "k", zt);
          for (let d = 0; d < 10; d++) {
            const u = d.toString();
            zt = String.fromCharCode(55349, 57294 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 57314 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 57324 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt), zt = String.fromCharCode(55349, 57334 + d), v(T, M, It, u, zt), v(dt, M, tt, u, zt);
          }
          const He = "ÐÞþ";
          for (let d = 0; d < He.length; d++) {
            const u = He.charAt(d);
            v(T, M, It, u, u), v(dt, M, tt, u, u);
          }
          const ks = [
            ["mathbf", "textbf", "Main-Bold"],
            // A-Z bold upright
            ["mathbf", "textbf", "Main-Bold"],
            // a-z bold upright
            ["mathnormal", "textit", "Math-Italic"],
            // A-Z italic
            ["mathnormal", "textit", "Math-Italic"],
            // a-z italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // A-Z bold italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // a-z bold italic
            // Map fancy A-Z letters to script, not calligraphic.
            // This aligns with unicode-math and math fonts (except Cambria Math).
            ["mathscr", "textscr", "Script-Regular"],
            // A-Z script
            ["", "", ""],
            // a-z script.  No font
            ["", "", ""],
            // A-Z bold script. No font
            ["", "", ""],
            // a-z bold script. No font
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // A-Z Fraktur
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // a-z Fraktur
            ["mathbb", "textbb", "AMS-Regular"],
            // A-Z double-struck
            ["mathbb", "textbb", "AMS-Regular"],
            // k double-struck
            // Note that we are using a bold font, but font metrics for regular Fraktur.
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // A-Z bold Fraktur
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // a-z bold Fraktur
            ["mathsf", "textsf", "SansSerif-Regular"],
            // A-Z sans-serif
            ["mathsf", "textsf", "SansSerif-Regular"],
            // a-z sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // A-Z bold sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // a-z bold sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // A-Z italic sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // a-z italic sans-serif
            ["", "", ""],
            // A-Z bold italic sans. No font
            ["", "", ""],
            // a-z bold italic sans. No font
            ["mathtt", "texttt", "Typewriter-Regular"],
            // A-Z monospace
            ["mathtt", "texttt", "Typewriter-Regular"]
            // a-z monospace
          ], Sc = [
            ["mathbf", "textbf", "Main-Bold"],
            // 0-9 bold
            ["", "", ""],
            // 0-9 double-struck. No KaTeX font.
            ["mathsf", "textsf", "SansSerif-Regular"],
            // 0-9 sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // 0-9 bold sans-serif
            ["mathtt", "texttt", "Typewriter-Regular"]
            // 0-9 monospace
          ], Z9 = function(d, u) {
            const f = d.charCodeAt(0), b = d.charCodeAt(1), w = (f - 55296) * 1024 + (b - 56320) + 65536, S = u === "math" ? 0 : 1;
            if (119808 <= w && w < 120484) {
              const E = Math.floor((w - 119808) / 26);
              return [ks[E][2], ks[E][S]];
            } else if (120782 <= w && w <= 120831) {
              const E = Math.floor((w - 120782) / 10);
              return [Sc[E][2], Sc[E][S]];
            } else {
              if (w === 120485 || w === 120486)
                return [ks[0][2], ks[0][S]];
              if (120486 < w && w < 120782)
                return ["", ""];
              throw new s("Unsupported character: " + d);
            }
          }, Ac = function(d, u, f) {
            return pe[f][d] && pe[f][d].replace && (d = pe[f][d].replace), {
              value: d,
              metrics: vo(d, u, f)
            };
          }, xn = function(d, u, f, b, w) {
            const S = Ac(d, u, f), E = S.metrics;
            d = S.value;
            let D;
            if (E) {
              let P = E.italic;
              (f === "text" || b && b.font === "mathit") && (P = 0), D = new Mr(d, E.height, E.depth, P, E.skew, E.width, w);
            } else
              typeof console < "u" && console.warn("No character metrics " + ("for '" + d + "' in style '" + u + "' and mode '" + f + "'")), D = new Mr(d, 0, 0, 0, 0, 0, w);
            if (b) {
              D.maxFontSize = b.sizeMultiplier, b.style.isTight() && D.classes.push("mtight");
              const P = b.getColor();
              P && (D.style.color = P);
            }
            return D;
          }, J9 = function(d, u, f, b) {
            return b === void 0 && (b = []), f.font === "boldsymbol" && Ac(d, "Main-Bold", u).metrics ? xn(d, "Main-Bold", u, f, b.concat(["mathbf"])) : d === "\\" || pe[u][d].font === "main" ? xn(d, "Main-Regular", u, f, b) : xn(d, "AMS-Regular", u, f, b.concat(["amsrm"]));
          }, Q9 = function(d, u, f, b, w) {
            return w !== "textord" && Ac(d, "Math-BoldItalic", u).metrics ? {
              fontName: "Math-BoldItalic",
              fontClass: "boldsymbol"
            } : {
              fontName: "Main-Bold",
              fontClass: "mathbf"
            };
          }, tC = function(d, u, f) {
            const b = d.mode, w = d.text, S = ["mord"], E = b === "math" || b === "text" && u.font, D = E ? u.font : u.fontFamily;
            let P = "", J = "";
            if (w.charCodeAt(0) === 55349 && ([P, J] = Z9(w, b)), P.length > 0)
              return xn(w, P, b, u, S.concat(J));
            if (D) {
              let nt, it;
              if (D === "boldsymbol") {
                const lt = Q9(w, b, u, S, f);
                nt = lt.fontName, it = [lt.fontClass];
              } else E ? (nt = Mg[D].fontName, it = [D]) : (nt = Tc(D, u.fontWeight, u.fontShape), it = [D, u.fontWeight, u.fontShape]);
              if (Ac(w, nt, b).metrics)
                return xn(w, nt, b, u, S.concat(it));
              if (Te.hasOwnProperty(w) && nt.slice(0, 10) === "Typewriter") {
                const lt = [];
                for (let yt = 0; yt < w.length; yt++)
                  lt.push(xn(w[yt], nt, b, u, S.concat(it)));
                return Eg(lt);
              }
            }
            if (f === "mathord")
              return xn(w, "Math-Italic", b, u, S.concat(["mathnormal"]));
            if (f === "textord") {
              const nt = pe[b][w] && pe[b][w].font;
              if (nt === "ams") {
                const it = Tc("amsrm", u.fontWeight, u.fontShape);
                return xn(w, it, b, u, S.concat("amsrm", u.fontWeight, u.fontShape));
              } else if (nt === "main" || !nt) {
                const it = Tc("textrm", u.fontWeight, u.fontShape);
                return xn(w, it, b, u, S.concat(u.fontWeight, u.fontShape));
              } else {
                const it = Tc(nt, u.fontWeight, u.fontShape);
                return xn(w, it, b, u, S.concat(it, u.fontWeight, u.fontShape));
              }
            } else
              throw new Error("unexpected type: " + f + " in makeOrd");
          }, eC = (d, u) => {
            if (xr(d.classes) !== xr(u.classes) || d.skew !== u.skew || d.maxFontSize !== u.maxFontSize)
              return false;
            if (d.classes.length === 1) {
              const f = d.classes[0];
              if (f === "mbin" || f === "mord")
                return false;
            }
            for (const f in d.style)
              if (d.style.hasOwnProperty(f) && d.style[f] !== u.style[f])
                return false;
            for (const f in u.style)
              if (u.style.hasOwnProperty(f) && d.style[f] !== u.style[f])
                return false;
            return true;
          }, rC = (d) => {
            for (let u = 0; u < d.length - 1; u++) {
              const f = d[u], b = d[u + 1];
              f instanceof Mr && b instanceof Mr && eC(f, b) && (f.text += b.text, f.height = Math.max(f.height, b.height), f.depth = Math.max(f.depth, b.depth), f.italic = b.italic, d.splice(u + 1, 1), u--);
            }
            return d;
          }, Gu = function(d) {
            let u = 0, f = 0, b = 0;
            for (let w = 0; w < d.children.length; w++) {
              const S = d.children[w];
              S.height > u && (u = S.height), S.depth > f && (f = S.depth), S.maxFontSize > b && (b = S.maxFontSize);
            }
            d.height = u, d.depth = f, d.maxFontSize = b;
          }, Lr = function(d, u, f, b) {
            const w = new Mn(d, u, f, b);
            return Gu(w), w;
          }, $g = (d, u, f, b) => new Mn(d, u, f, b), nC = function(d, u, f) {
            const b = Lr([d], [], u);
            return b.height = Math.max(f || u.fontMetrics().defaultRuleThickness, u.minRuleThickness), b.style.borderBottomWidth = bt(b.height), b.maxFontSize = 1, b;
          }, iC = function(d, u, f, b) {
            const w = new _o(d, u, f, b);
            return Gu(w), w;
          }, Eg = function(d) {
            const u = new rn(d);
            return Gu(u), u;
          }, sC = function(d, u) {
            return d instanceof rn ? Lr([], [d], u) : d;
          }, aC = function(d) {
            if (d.positionType === "individualShift") {
              const f = d.children, b = [f[0]], w = -f[0].shift - f[0].elem.depth;
              let S = w;
              for (let E = 1; E < f.length; E++) {
                const D = -f[E].shift - S - f[E].elem.depth, P = D - (f[E - 1].elem.height + f[E - 1].elem.depth);
                S = S + D, b.push({
                  type: "kern",
                  size: P
                }), b.push(f[E]);
              }
              return {
                children: b,
                depth: w
              };
            }
            let u;
            if (d.positionType === "top") {
              let f = d.positionData;
              for (let b = 0; b < d.children.length; b++) {
                const w = d.children[b];
                f -= w.type === "kern" ? w.size : w.elem.height + w.elem.depth;
              }
              u = f;
            } else if (d.positionType === "bottom")
              u = -d.positionData;
            else {
              const f = d.children[0];
              if (f.type !== "elem")
                throw new Error('First child must have type "elem".');
              if (d.positionType === "shift")
                u = -f.elem.depth - d.positionData;
              else if (d.positionType === "firstBaseline")
                u = -f.elem.depth;
              else
                throw new Error("Invalid positionType " + d.positionType + ".");
            }
            return {
              children: d.children,
              depth: u
            };
          }, oC = function(d, u) {
            const {
              children: f,
              depth: b
            } = aC(d);
            let w = 0;
            for (let yt = 0; yt < f.length; yt++) {
              const kt = f[yt];
              if (kt.type === "elem") {
                const Yt = kt.elem;
                w = Math.max(w, Yt.maxFontSize, Yt.height);
              }
            }
            w += 2;
            const S = Lr(["pstrut"], []);
            S.style.height = bt(w);
            const E = [];
            let D = b, P = b, J = b;
            for (let yt = 0; yt < f.length; yt++) {
              const kt = f[yt];
              if (kt.type === "kern")
                J += kt.size;
              else {
                const Yt = kt.elem, ie = kt.wrapperClasses || [], te = kt.wrapperStyle || {}, ue = Lr(ie, [S, Yt], void 0, te);
                ue.style.top = bt(-w - J - Yt.depth), kt.marginLeft && (ue.style.marginLeft = kt.marginLeft), kt.marginRight && (ue.style.marginRight = kt.marginRight), E.push(ue), J += Yt.height + Yt.depth;
              }
              D = Math.min(D, J), P = Math.max(P, J);
            }
            const nt = Lr(["vlist"], E);
            nt.style.height = bt(P);
            let it;
            if (D < 0) {
              const yt = Lr([], []), kt = Lr(["vlist"], [yt]);
              kt.style.height = bt(-D);
              const Yt = Lr(["vlist-s"], [new Mr("​")]);
              it = [Lr(["vlist-r"], [nt, Yt]), Lr(["vlist-r"], [kt])];
            } else
              it = [Lr(["vlist-r"], [nt])];
            const lt = Lr(["vlist-t"], it);
            return it.length === 2 && lt.classes.push("vlist-t2"), lt.height = P, lt.depth = -D, lt;
          }, lC = (d, u) => {
            const f = Lr(["mspace"], [], u), b = xe(d, u);
            return f.style.marginRight = bt(b), f;
          }, Tc = function(d, u, f) {
            let b = "";
            switch (d) {
              case "amsrm":
                b = "AMS";
                break;
              case "textrm":
                b = "Main";
                break;
              case "textsf":
                b = "SansSerif";
                break;
              case "texttt":
                b = "Typewriter";
                break;
              default:
                b = d;
            }
            let w;
            return u === "textbf" && f === "textit" ? w = "BoldItalic" : u === "textbf" ? w = "Bold" : u === "textit" ? w = "Italic" : w = "Regular", b + "-" + w;
          }, Mg = {
            // styles
            mathbf: {
              variant: "bold",
              fontName: "Main-Bold"
            },
            mathrm: {
              variant: "normal",
              fontName: "Main-Regular"
            },
            textit: {
              variant: "italic",
              fontName: "Main-Italic"
            },
            mathit: {
              variant: "italic",
              fontName: "Main-Italic"
            },
            mathnormal: {
              variant: "italic",
              fontName: "Math-Italic"
            },
            mathsfit: {
              variant: "sans-serif-italic",
              fontName: "SansSerif-Italic"
            },
            // "boldsymbol" is missing because they require the use of multiple fonts:
            // Math-BoldItalic and Main-Bold.  This is handled by a special case in
            // makeOrd which ends up calling boldsymbol.
            // families
            mathbb: {
              variant: "double-struck",
              fontName: "AMS-Regular"
            },
            mathcal: {
              variant: "script",
              fontName: "Caligraphic-Regular"
            },
            mathfrak: {
              variant: "fraktur",
              fontName: "Fraktur-Regular"
            },
            mathscr: {
              variant: "script",
              fontName: "Script-Regular"
            },
            mathsf: {
              variant: "sans-serif",
              fontName: "SansSerif-Regular"
            },
            mathtt: {
              variant: "monospace",
              fontName: "Typewriter-Regular"
            }
          }, Bg = {
            //   path, width, height
            vec: ["vec", 0.471, 0.714],
            // values from the font glyph
            oiintSize1: ["oiintSize1", 0.957, 0.499],
            // oval to overlay the integrand
            oiintSize2: ["oiintSize2", 1.472, 0.659],
            oiiintSize1: ["oiiintSize1", 1.304, 0.499],
            oiiintSize2: ["oiiintSize2", 1.98, 0.659]
          };
          var at = {
            fontMap: Mg,
            makeSymbol: xn,
            mathsym: J9,
            makeSpan: Lr,
            makeSvgSpan: $g,
            makeLineSpan: nC,
            makeAnchor: iC,
            makeFragment: Eg,
            wrapFragment: sC,
            makeVList: oC,
            makeOrd: tC,
            makeGlue: lC,
            staticSvg: function(d, u) {
              const [f, b, w] = Bg[d], S = new wr(f), E = new we([S], {
                width: bt(b),
                height: bt(w),
                // Override CSS rule `.katex svg { width: 100% }`
                style: "width:" + bt(b),
                viewBox: "0 0 " + 1e3 * b + " " + 1e3 * w,
                preserveAspectRatio: "xMinYMin"
              }), D = $g(["overlay"], [E], u);
              return D.height = w, D.style.height = bt(w), D.style.width = bt(b), D;
            },
            svgData: Bg,
            tryCombineChars: rC
          };
          const Fe = {
            number: 3,
            unit: "mu"
          }, vs = {
            number: 4,
            unit: "mu"
          }, oi = {
            number: 5,
            unit: "mu"
          }, cC = {
            mord: {
              mop: Fe,
              mbin: vs,
              mrel: oi,
              minner: Fe
            },
            mop: {
              mord: Fe,
              mop: Fe,
              mrel: oi,
              minner: Fe
            },
            mbin: {
              mord: vs,
              mop: vs,
              mopen: vs,
              minner: vs
            },
            mrel: {
              mord: oi,
              mop: oi,
              mopen: oi,
              minner: oi
            },
            mopen: {},
            mclose: {
              mop: Fe,
              mbin: vs,
              mrel: oi,
              minner: Fe
            },
            mpunct: {
              mord: Fe,
              mop: Fe,
              mrel: oi,
              mopen: Fe,
              mclose: Fe,
              mpunct: Fe,
              minner: Fe
            },
            minner: {
              mord: Fe,
              mop: Fe,
              mbin: vs,
              mrel: oi,
              mopen: Fe,
              mpunct: Fe,
              minner: Fe
            }
          }, hC = {
            mord: {
              mop: Fe
            },
            mop: {
              mord: Fe,
              mop: Fe
            },
            mbin: {},
            mrel: {},
            mopen: {},
            mclose: {
              mop: Fe
            },
            mpunct: {},
            minner: {
              mop: Fe
            }
          }, Lg = {}, $c = {}, Ec = {};
          function _t(d) {
            let {
              type: u,
              names: f,
              props: b,
              handler: w,
              htmlBuilder: S,
              mathmlBuilder: E
            } = d;
            const D = {
              type: u,
              numArgs: b.numArgs,
              argTypes: b.argTypes,
              allowedInArgument: !!b.allowedInArgument,
              allowedInText: !!b.allowedInText,
              allowedInMath: b.allowedInMath === void 0 ? true : b.allowedInMath,
              numOptionalArgs: b.numOptionalArgs || 0,
              infix: !!b.infix,
              primitive: !!b.primitive,
              handler: w
            };
            for (let P = 0; P < f.length; ++P)
              Lg[f[P]] = D;
            u && (S && ($c[u] = S), E && (Ec[u] = E));
          }
          function Cs(d) {
            let {
              type: u,
              htmlBuilder: f,
              mathmlBuilder: b
            } = d;
            _t({
              type: u,
              names: [],
              props: {
                numArgs: 0
              },
              handler() {
                throw new Error("Should never be called.");
              },
              htmlBuilder: f,
              mathmlBuilder: b
            });
          }
          const Mc = function(d) {
            return d.type === "ordgroup" && d.body.length === 1 ? d.body[0] : d;
          }, qe = function(d) {
            return d.type === "ordgroup" ? d.body : [d];
          }, li = at.makeSpan, uC = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], dC = ["rightmost", "mrel", "mclose", "mpunct"], pC = {
            display: et.DISPLAY,
            text: et.TEXT,
            script: et.SCRIPT,
            scriptscript: et.SCRIPTSCRIPT
          }, fC = {
            mord: "mord",
            mop: "mop",
            mbin: "mbin",
            mrel: "mrel",
            mopen: "mopen",
            mclose: "mclose",
            mpunct: "mpunct",
            minner: "minner"
          }, Ve = function(d, u, f, b) {
            b === void 0 && (b = [null, null]);
            const w = [];
            for (let J = 0; J < d.length; J++) {
              const nt = le(d[J], u);
              if (nt instanceof rn) {
                const it = nt.children;
                w.push(...it);
              } else
                w.push(nt);
            }
            if (at.tryCombineChars(w), !f)
              return w;
            let S = u;
            if (d.length === 1) {
              const J = d[0];
              J.type === "sizing" ? S = u.havingSize(J.size) : J.type === "styling" && (S = u.havingStyle(pC[J.style]));
            }
            const E = li([b[0] || "leftmost"], [], u), D = li([b[1] || "rightmost"], [], u), P = f === "root";
            return Xu(w, (J, nt) => {
              const it = nt.classes[0], lt = J.classes[0];
              it === "mbin" && k.contains(dC, lt) ? nt.classes[0] = "mord" : lt === "mbin" && k.contains(uC, it) && (J.classes[0] = "mord");
            }, {
              node: E
            }, D, P), Xu(w, (J, nt) => {
              const it = Ku(nt), lt = Ku(J), yt = it && lt ? J.hasClass("mtight") ? hC[it][lt] : cC[it][lt] : null;
              if (yt)
                return at.makeGlue(yt, S);
            }, {
              node: E
            }, D, P), w;
          }, Xu = function(d, u, f, b, w) {
            b && d.push(b);
            let S = 0;
            for (; S < d.length; S++) {
              const E = d[S], D = Dg(E);
              if (D) {
                Xu(D.children, u, f, null, w);
                continue;
              }
              const P = !E.hasClass("mspace");
              if (P) {
                const J = u(E, f.node);
                J && (f.insertAfter ? f.insertAfter(J) : (d.unshift(J), S++));
              }
              P ? f.node = E : w && E.hasClass("newline") && (f.node = li(["leftmost"])), f.insertAfter = /* @__PURE__ */ ((J) => (nt) => {
                d.splice(J + 1, 0, nt), S++;
              })(S);
            }
            b && d.pop();
          }, Dg = function(d) {
            return d instanceof rn || d instanceof _o || d instanceof Mn && d.hasClass("enclosing") ? d : null;
          }, Yu = function(d, u) {
            const f = Dg(d);
            if (f) {
              const b = f.children;
              if (b.length) {
                if (u === "right")
                  return Yu(b[b.length - 1], "right");
                if (u === "left")
                  return Yu(b[0], "left");
              }
            }
            return d;
          }, Ku = function(d, u) {
            return d ? (u && (d = Yu(d, u)), fC[d.classes[0]] || null) : null;
          }, $o = function(d, u) {
            const f = ["nulldelimiter"].concat(d.baseSizingClasses());
            return li(u.concat(f));
          }, le = function(d, u, f) {
            if (!d)
              return li();
            if ($c[d.type]) {
              let b = $c[d.type](d, u);
              if (f && u.size !== f.size) {
                b = li(u.sizingClasses(f), [b], u);
                const w = u.sizeMultiplier / f.sizeMultiplier;
                b.height *= w, b.depth *= w;
              }
              return b;
            } else
              throw new s("Got group of unknown type: '" + d.type + "'");
          };
          function Bc(d, u) {
            const f = li(["base"], d, u), b = li(["strut"]);
            return b.style.height = bt(f.height + f.depth), f.depth && (b.style.verticalAlign = bt(-f.depth)), f.children.unshift(b), f;
          }
          function Zu(d, u) {
            let f = null;
            d.length === 1 && d[0].type === "tag" && (f = d[0].tag, d = d[0].body);
            const b = Ve(d, u, "root");
            let w;
            b.length === 2 && b[1].hasClass("tag") && (w = b.pop());
            const S = [];
            let E = [];
            for (let J = 0; J < b.length; J++)
              if (E.push(b[J]), b[J].hasClass("mbin") || b[J].hasClass("mrel") || b[J].hasClass("allowbreak")) {
                let nt = false;
                for (; J < b.length - 1 && b[J + 1].hasClass("mspace") && !b[J + 1].hasClass("newline"); )
                  J++, E.push(b[J]), b[J].hasClass("nobreak") && (nt = true);
                nt || (S.push(Bc(E, u)), E = []);
              } else b[J].hasClass("newline") && (E.pop(), E.length > 0 && (S.push(Bc(E, u)), E = []), S.push(b[J]));
            E.length > 0 && S.push(Bc(E, u));
            let D;
            f ? (D = Bc(Ve(f, u, true)), D.classes = ["tag"], S.push(D)) : w && S.push(w);
            const P = li(["katex-html"], S);
            if (P.setAttribute("aria-hidden", "true"), D) {
              const J = D.children[0];
              J.style.height = bt(P.height + P.depth), P.depth && (J.style.verticalAlign = bt(-P.depth));
            }
            return P;
          }
          function Fg(d) {
            return new rn(d);
          }
          class Vr {
            constructor(u, f, b) {
              this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = u, this.attributes = {}, this.children = f || [], this.classes = b || [];
            }
            /**
             * Sets an attribute on a MathML node. MathML depends on attributes to convey a
             * semantic content, so this is used heavily.
             */
            setAttribute(u, f) {
              this.attributes[u] = f;
            }
            /**
             * Gets an attribute on a MathML node.
             */
            getAttribute(u) {
              return this.attributes[u];
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              const u = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && u.setAttribute(f, this.attributes[f]);
              this.classes.length > 0 && (u.className = xr(this.classes));
              for (let f = 0; f < this.children.length; f++)
                if (this.children[f] instanceof Bn && this.children[f + 1] instanceof Bn) {
                  let b = this.children[f].toText() + this.children[++f].toText();
                  for (; this.children[f + 1] instanceof Bn; )
                    b += this.children[++f].toText();
                  u.appendChild(new Bn(b).toNode());
                } else
                  u.appendChild(this.children[f].toNode());
              return u;
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              let u = "<" + this.type;
              for (const f in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, f) && (u += " " + f + '="', u += k.escape(this.attributes[f]), u += '"');
              this.classes.length > 0 && (u += ' class ="' + k.escape(xr(this.classes)) + '"'), u += ">";
              for (let f = 0; f < this.children.length; f++)
                u += this.children[f].toMarkup();
              return u += "</" + this.type + ">", u;
            }
            /**
             * Converts the math node into a string, similar to innerText, but escaped.
             */
            toText() {
              return this.children.map((u) => u.toText()).join("");
            }
          }
          class Bn {
            constructor(u) {
              this.text = void 0, this.text = u;
            }
            /**
             * Converts the text node into a DOM text node.
             */
            toNode() {
              return document.createTextNode(this.text);
            }
            /**
             * Converts the text node into escaped HTML markup
             * (representing the text itself).
             */
            toMarkup() {
              return k.escape(this.toText());
            }
            /**
             * Converts the text node into a string
             * (representing the text itself).
             */
            toText() {
              return this.text;
            }
          }
          class mC {
            /**
             * Create a Space node with width given in CSS ems.
             */
            constructor(u) {
              this.width = void 0, this.character = void 0, this.width = u, u >= 0.05555 && u <= 0.05556 ? this.character = " " : u >= 0.1666 && u <= 0.1667 ? this.character = " " : u >= 0.2222 && u <= 0.2223 ? this.character = " " : u >= 0.2777 && u <= 0.2778 ? this.character = "  " : u >= -0.05556 && u <= -0.05555 ? this.character = " ⁣" : u >= -0.1667 && u <= -0.1666 ? this.character = " ⁣" : u >= -0.2223 && u <= -0.2222 ? this.character = " ⁣" : u >= -0.2778 && u <= -0.2777 ? this.character = " ⁣" : this.character = null;
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              if (this.character)
                return document.createTextNode(this.character);
              {
                const u = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                return u.setAttribute("width", bt(this.width)), u;
              }
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + bt(this.width) + '"/>';
            }
            /**
             * Converts the math node into a string, similar to innerText.
             */
            toText() {
              return this.character ? this.character : " ";
            }
          }
          var ft = {
            MathNode: Vr,
            TextNode: Bn,
            SpaceNode: mC,
            newDocumentFragment: Fg
          };
          const an = function(d, u, f) {
            return pe[u][d] && pe[u][d].replace && d.charCodeAt(0) !== 55349 && !(Te.hasOwnProperty(d) && f && (f.fontFamily && f.fontFamily.slice(4, 6) === "tt" || f.font && f.font.slice(4, 6) === "tt")) && (d = pe[u][d].replace), new ft.TextNode(d);
          }, Ju = function(d) {
            return d.length === 1 ? d[0] : new ft.MathNode("mrow", d);
          }, Qu = function(d, u) {
            if (u.fontFamily === "texttt")
              return "monospace";
            if (u.fontFamily === "textsf")
              return u.fontShape === "textit" && u.fontWeight === "textbf" ? "sans-serif-bold-italic" : u.fontShape === "textit" ? "sans-serif-italic" : u.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
            if (u.fontShape === "textit" && u.fontWeight === "textbf")
              return "bold-italic";
            if (u.fontShape === "textit")
              return "italic";
            if (u.fontWeight === "textbf")
              return "bold";
            const f = u.font;
            if (!f || f === "mathnormal")
              return null;
            const b = d.mode;
            if (f === "mathit")
              return "italic";
            if (f === "boldsymbol")
              return d.type === "textord" ? "bold" : "bold-italic";
            if (f === "mathbf")
              return "bold";
            if (f === "mathbb")
              return "double-struck";
            if (f === "mathsfit")
              return "sans-serif-italic";
            if (f === "mathfrak")
              return "fraktur";
            if (f === "mathscr" || f === "mathcal")
              return "script";
            if (f === "mathsf")
              return "sans-serif";
            if (f === "mathtt")
              return "monospace";
            let w = d.text;
            if (k.contains(["\\imath", "\\jmath"], w))
              return null;
            pe[b][w] && pe[b][w].replace && (w = pe[b][w].replace);
            const S = at.fontMap[f].fontName;
            return vo(w, S, b) ? at.fontMap[f].variant : null;
          };
          function td(d) {
            if (!d)
              return false;
            if (d.type === "mi" && d.children.length === 1) {
              const u = d.children[0];
              return u instanceof Bn && u.text === ".";
            } else if (d.type === "mo" && d.children.length === 1 && d.getAttribute("separator") === "true" && d.getAttribute("lspace") === "0em" && d.getAttribute("rspace") === "0em") {
              const u = d.children[0];
              return u instanceof Bn && u.text === ",";
            } else
              return false;
          }
          const Dr = function(d, u, f) {
            if (d.length === 1) {
              const S = ve(d[0], u);
              return f && S instanceof Vr && S.type === "mo" && (S.setAttribute("lspace", "0em"), S.setAttribute("rspace", "0em")), [S];
            }
            const b = [];
            let w;
            for (let S = 0; S < d.length; S++) {
              const E = ve(d[S], u);
              if (E instanceof Vr && w instanceof Vr) {
                if (E.type === "mtext" && w.type === "mtext" && E.getAttribute("mathvariant") === w.getAttribute("mathvariant")) {
                  w.children.push(...E.children);
                  continue;
                } else if (E.type === "mn" && w.type === "mn") {
                  w.children.push(...E.children);
                  continue;
                } else if (td(E) && w.type === "mn") {
                  w.children.push(...E.children);
                  continue;
                } else if (E.type === "mn" && td(w))
                  E.children = [...w.children, ...E.children], b.pop();
                else if ((E.type === "msup" || E.type === "msub") && E.children.length >= 1 && (w.type === "mn" || td(w))) {
                  const D = E.children[0];
                  D instanceof Vr && D.type === "mn" && (D.children = [...w.children, ...D.children], b.pop());
                } else if (w.type === "mi" && w.children.length === 1) {
                  const D = w.children[0];
                  if (D instanceof Bn && D.text === "̸" && (E.type === "mo" || E.type === "mi" || E.type === "mn")) {
                    const P = E.children[0];
                    P instanceof Bn && P.text.length > 0 && (P.text = P.text.slice(0, 1) + "̸" + P.text.slice(1), b.pop());
                  }
                }
              }
              b.push(E), w = E;
            }
            return b;
          }, Oi = function(d, u, f) {
            return Ju(Dr(d, u, f));
          }, ve = function(d, u) {
            if (!d)
              return new ft.MathNode("mrow");
            if (Ec[d.type])
              return Ec[d.type](d, u);
            throw new s("Got group of unknown type: '" + d.type + "'");
          };
          function Ng(d, u, f, b, w) {
            const S = Dr(d, f);
            let E;
            S.length === 1 && S[0] instanceof Vr && k.contains(["mrow", "mtable"], S[0].type) ? E = S[0] : E = new ft.MathNode("mrow", S);
            const D = new ft.MathNode("annotation", [new ft.TextNode(u)]);
            D.setAttribute("encoding", "application/x-tex");
            const P = new ft.MathNode("semantics", [E, D]), J = new ft.MathNode("math", [P]);
            J.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), b && J.setAttribute("display", "block");
            const nt = w ? "katex" : "katex-mathml";
            return at.makeSpan([nt], [J]);
          }
          const Ig = function(d) {
            return new kc({
              style: d.displayMode ? et.DISPLAY : et.TEXT,
              maxSize: d.maxSize,
              minRuleThickness: d.minRuleThickness
            });
          }, Og = function(d, u) {
            if (u.displayMode) {
              const f = ["katex-display"];
              u.leqno && f.push("leqno"), u.fleqn && f.push("fleqn"), d = at.makeSpan(f, [d]);
            }
            return d;
          }, gC = function(d, u, f) {
            const b = Ig(f);
            let w;
            if (f.output === "mathml")
              return Ng(d, u, b, f.displayMode, true);
            if (f.output === "html") {
              const S = Zu(d, b);
              w = at.makeSpan(["katex"], [S]);
            } else {
              const S = Ng(d, u, b, f.displayMode, false), E = Zu(d, b);
              w = at.makeSpan(["katex"], [S, E]);
            }
            return Og(w, f);
          }, yC = function(d, u, f) {
            const b = Ig(f), w = Zu(d, b), S = at.makeSpan(["katex"], [w]);
            return Og(S, f);
          }, bC = {
            widehat: "^",
            widecheck: "ˇ",
            widetilde: "~",
            utilde: "~",
            overleftarrow: "←",
            underleftarrow: "←",
            xleftarrow: "←",
            overrightarrow: "→",
            underrightarrow: "→",
            xrightarrow: "→",
            underbrace: "⏟",
            overbrace: "⏞",
            overgroup: "⏠",
            undergroup: "⏡",
            overleftrightarrow: "↔",
            underleftrightarrow: "↔",
            xleftrightarrow: "↔",
            Overrightarrow: "⇒",
            xRightarrow: "⇒",
            overleftharpoon: "↼",
            xleftharpoonup: "↼",
            overrightharpoon: "⇀",
            xrightharpoonup: "⇀",
            xLeftarrow: "⇐",
            xLeftrightarrow: "⇔",
            xhookleftarrow: "↩",
            xhookrightarrow: "↪",
            xmapsto: "↦",
            xrightharpoondown: "⇁",
            xleftharpoondown: "↽",
            xrightleftharpoons: "⇌",
            xleftrightharpoons: "⇋",
            xtwoheadleftarrow: "↞",
            xtwoheadrightarrow: "↠",
            xlongequal: "=",
            xtofrom: "⇄",
            xrightleftarrows: "⇄",
            xrightequilibrium: "⇌",
            // Not a perfect match.
            xleftequilibrium: "⇋",
            // None better available.
            "\\cdrightarrow": "→",
            "\\cdleftarrow": "←",
            "\\cdlongequal": "="
          }, xC = function(d) {
            const u = new ft.MathNode("mo", [new ft.TextNode(bC[d.replace(/^\\/, "")])]);
            return u.setAttribute("stretchy", "true"), u;
          }, wC = {
            //   path(s), minWidth, height, align
            overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
            "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
            // CD minwwidth2.5pc
            xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
            "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
            Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
            xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
            xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
            overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
            overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
            xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
            "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
            xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
            xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
            overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
            underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
            underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
            xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
            xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
            xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
            xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
            xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
            overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
            undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
            xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
            xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
            // The next three arrows are from the mhchem package.
            // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
            // document as \xrightarrow or \xrightleftharpoons. Those have
            // min-length = 1.75em, so we set min-length on these next three to match.
            xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
            xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
            xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
          }, kC = function(d) {
            return d.type === "ordgroup" ? d.body.length : 1;
          };
          var ci = {
            encloseSpan: function(d, u, f, b, w) {
              let S;
              const E = d.height + d.depth + f + b;
              if (/fbox|color|angl/.test(u)) {
                if (S = at.makeSpan(["stretchy", u], [], w), u === "fbox") {
                  const D = w.color && w.getColor();
                  D && (S.style.borderColor = D);
                }
              } else {
                const D = [];
                /^[bx]cancel$/.test(u) && D.push(new So({
                  x1: "0",
                  y1: "0",
                  x2: "100%",
                  y2: "100%",
                  "stroke-width": "0.046em"
                })), /^x?cancel$/.test(u) && D.push(new So({
                  x1: "0",
                  y1: "100%",
                  x2: "100%",
                  y2: "0",
                  "stroke-width": "0.046em"
                }));
                const P = new we(D, {
                  width: "100%",
                  height: bt(E)
                });
                S = at.makeSvgSpan([], [P], w);
              }
              return S.height = E, S.style.height = bt(E), S;
            },
            mathMLnode: xC,
            svgSpan: function(d, u) {
              function f() {
                let E = 4e5;
                const D = d.label.slice(1);
                if (k.contains(["widehat", "widecheck", "widetilde", "utilde"], D)) {
                  const P = kC(d.base);
                  let J, nt, it;
                  if (P > 5)
                    D === "widehat" || D === "widecheck" ? (J = 420, E = 2364, it = 0.42, nt = D + "4") : (J = 312, E = 2340, it = 0.34, nt = "tilde4");
                  else {
                    const kt = [1, 1, 2, 2, 3, 3][P];
                    D === "widehat" || D === "widecheck" ? (E = [0, 1062, 2364, 2364, 2364][kt], J = [0, 239, 300, 360, 420][kt], it = [0, 0.24, 0.3, 0.3, 0.36, 0.42][kt], nt = D + kt) : (E = [0, 600, 1033, 2339, 2340][kt], J = [0, 260, 286, 306, 312][kt], it = [0, 0.26, 0.286, 0.3, 0.306, 0.34][kt], nt = "tilde" + kt);
                  }
                  const lt = new wr(nt), yt = new we([lt], {
                    width: "100%",
                    height: bt(it),
                    viewBox: "0 0 " + E + " " + J,
                    preserveAspectRatio: "none"
                  });
                  return {
                    span: at.makeSvgSpan([], [yt], u),
                    minWidth: 0,
                    height: it
                  };
                } else {
                  const P = [], J = wC[D], [nt, it, lt] = J, yt = lt / 1e3, kt = nt.length;
                  let Yt, ie;
                  if (kt === 1) {
                    const te = J[3];
                    Yt = ["hide-tail"], ie = [te];
                  } else if (kt === 2)
                    Yt = ["halfarrow-left", "halfarrow-right"], ie = ["xMinYMin", "xMaxYMin"];
                  else if (kt === 3)
                    Yt = ["brace-left", "brace-center", "brace-right"], ie = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                  else
                    throw new Error(`Correct katexImagesData or update code here to support
                    ` + kt + " children.");
                  for (let te = 0; te < kt; te++) {
                    const ue = new wr(nt[te]), ce = new we([ue], {
                      width: "400em",
                      height: bt(yt),
                      viewBox: "0 0 " + E + " " + lt,
                      preserveAspectRatio: ie[te] + " slice"
                    }), $e = at.makeSvgSpan([Yt[te]], [ce], u);
                    if (kt === 1)
                      return {
                        span: $e,
                        minWidth: it,
                        height: yt
                      };
                    $e.style.height = bt(yt), P.push($e);
                  }
                  return {
                    span: at.makeSpan(["stretchy"], P, u),
                    minWidth: it,
                    height: yt
                  };
                }
              }
              const {
                span: b,
                minWidth: w,
                height: S
              } = f();
              return b.height = S, b.style.height = bt(S), w > 0 && (b.style.minWidth = bt(w)), b;
            }
          };
          function Zt(d, u) {
            if (!d || d.type !== u)
              throw new Error("Expected node of type " + u + ", but got " + (d ? "node of type " + d.type : String(d)));
            return d;
          }
          function ed(d) {
            const u = Lc(d);
            if (!u)
              throw new Error("Expected node of symbol group type, but got " + (d ? "node of type " + d.type : String(d)));
            return u;
          }
          function Lc(d) {
            return d && (d.type === "atom" || _c.hasOwnProperty(d.type)) ? d : null;
          }
          const rd = (d, u) => {
            let f, b, w;
            d && d.type === "supsub" ? (b = Zt(d.base, "accent"), f = b.base, d.base = f, w = To(le(d, u)), d.base = b) : (b = Zt(d, "accent"), f = b.base);
            const S = le(f, u.havingCrampedStyle()), E = b.isShifty && k.isCharacterBox(f);
            let D = 0;
            if (E) {
              const lt = k.getBaseElem(f), yt = le(lt, u.havingCrampedStyle());
              D = Ao(yt).skew;
            }
            const P = b.label === "\\c";
            let J = P ? S.height + S.depth : Math.min(S.height, u.fontMetrics().xHeight), nt;
            if (b.isStretchy)
              nt = ci.svgSpan(b, u), nt = at.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: S
                }, {
                  type: "elem",
                  elem: nt,
                  wrapperClasses: ["svg-align"],
                  wrapperStyle: D > 0 ? {
                    width: "calc(100% - " + bt(2 * D) + ")",
                    marginLeft: bt(2 * D)
                  } : void 0
                }]
              }, u);
            else {
              let lt, yt;
              b.label === "\\vec" ? (lt = at.staticSvg("vec", u), yt = at.svgData.vec[1]) : (lt = at.makeOrd({
                mode: b.mode,
                text: b.label
              }, u, "textord"), lt = Ao(lt), lt.italic = 0, yt = lt.width, P && (J += lt.depth)), nt = at.makeSpan(["accent-body"], [lt]);
              const kt = b.label === "\\textcircled";
              kt && (nt.classes.push("accent-full"), J = S.height);
              let Yt = D;
              kt || (Yt -= yt / 2), nt.style.left = bt(Yt), b.label === "\\textcircled" && (nt.style.top = ".2em"), nt = at.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: S
                }, {
                  type: "kern",
                  size: -J
                }, {
                  type: "elem",
                  elem: nt
                }]
              }, u);
            }
            const it = at.makeSpan(["mord", "accent"], [nt], u);
            return w ? (w.children[0] = it, w.height = Math.max(it.height, w.height), w.classes[0] = "mord", w) : it;
          }, zg = (d, u) => {
            const f = d.isStretchy ? ci.mathMLnode(d.label) : new ft.MathNode("mo", [an(d.label, d.mode)]), b = new ft.MathNode("mover", [ve(d.base, u), f]);
            return b.setAttribute("accent", "true"), b;
          }, vC = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((d) => "\\" + d).join("|"));
          _t({
            type: "accent",
            names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
            props: {
              numArgs: 1
            },
            handler: (d, u) => {
              const f = Mc(u[0]), b = !vC.test(d.funcName), w = !b || d.funcName === "\\widehat" || d.funcName === "\\widetilde" || d.funcName === "\\widecheck";
              return {
                type: "accent",
                mode: d.parser.mode,
                label: d.funcName,
                isStretchy: b,
                isShifty: w,
                base: f
              };
            },
            htmlBuilder: rd,
            mathmlBuilder: zg
          }), _t({
            type: "accent",
            names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
            props: {
              numArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              // unless in strict mode
              argTypes: ["primitive"]
            },
            handler: (d, u) => {
              const f = u[0];
              let b = d.parser.mode;
              return b === "math" && (d.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + d.funcName + " works only in text mode"), b = "text"), {
                type: "accent",
                mode: b,
                label: d.funcName,
                isStretchy: false,
                isShifty: true,
                base: f
              };
            },
            htmlBuilder: rd,
            mathmlBuilder: zg
          }), _t({
            type: "accentUnder",
            names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
            props: {
              numArgs: 1
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "accentUnder",
                mode: f.mode,
                label: b,
                base: w
              };
            },
            htmlBuilder: (d, u) => {
              const f = le(d.base, u), b = ci.svgSpan(d, u), w = d.label === "\\utilde" ? 0.12 : 0, S = at.makeVList({
                positionType: "top",
                positionData: f.height,
                children: [{
                  type: "elem",
                  elem: b,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: w
                }, {
                  type: "elem",
                  elem: f
                }]
              }, u);
              return at.makeSpan(["mord", "accentunder"], [S], u);
            },
            mathmlBuilder: (d, u) => {
              const f = ci.mathMLnode(d.label), b = new ft.MathNode("munder", [ve(d.base, u), f]);
              return b.setAttribute("accentunder", "true"), b;
            }
          });
          const Dc = (d) => {
            const u = new ft.MathNode("mpadded", d ? [d] : []);
            return u.setAttribute("width", "+0.6em"), u.setAttribute("lspace", "0.3em"), u;
          };
          _t({
            type: "xArrow",
            names: [
              "\\xleftarrow",
              "\\xrightarrow",
              "\\xLeftarrow",
              "\\xRightarrow",
              "\\xleftrightarrow",
              "\\xLeftrightarrow",
              "\\xhookleftarrow",
              "\\xhookrightarrow",
              "\\xmapsto",
              "\\xrightharpoondown",
              "\\xrightharpoonup",
              "\\xleftharpoondown",
              "\\xleftharpoonup",
              "\\xrightleftharpoons",
              "\\xleftrightharpoons",
              "\\xlongequal",
              "\\xtwoheadrightarrow",
              "\\xtwoheadleftarrow",
              "\\xtofrom",
              // The next 3 functions are here to support the mhchem extension.
              // Direct use of these functions is discouraged and may break someday.
              "\\xrightleftarrows",
              "\\xrightequilibrium",
              "\\xleftequilibrium",
              // The next 3 functions are here only to support the {CD} environment.
              "\\\\cdrightarrow",
              "\\\\cdleftarrow",
              "\\\\cdlongequal"
            ],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(d, u, f) {
              let {
                parser: b,
                funcName: w
              } = d;
              return {
                type: "xArrow",
                mode: b.mode,
                label: w,
                body: u[0],
                below: f[0]
              };
            },
            // Flow is unable to correctly infer the type of `group`, even though it's
            // unambiguously determined from the passed-in `type` above.
            htmlBuilder(d, u) {
              const f = u.style;
              let b = u.havingStyle(f.sup());
              const w = at.wrapFragment(le(d.body, b, u), u), S = d.label.slice(0, 2) === "\\x" ? "x" : "cd";
              w.classes.push(S + "-arrow-pad");
              let E;
              d.below && (b = u.havingStyle(f.sub()), E = at.wrapFragment(le(d.below, b, u), u), E.classes.push(S + "-arrow-pad"));
              const D = ci.svgSpan(d, u), P = -u.fontMetrics().axisHeight + 0.5 * D.height;
              let J = -u.fontMetrics().axisHeight - 0.5 * D.height - 0.111;
              (w.depth > 0.25 || d.label === "\\xleftequilibrium") && (J -= w.depth);
              let nt;
              if (E) {
                const it = -u.fontMetrics().axisHeight + E.height + 0.5 * D.height + 0.111;
                nt = at.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: w,
                    shift: J
                  }, {
                    type: "elem",
                    elem: D,
                    shift: P
                  }, {
                    type: "elem",
                    elem: E,
                    shift: it
                  }]
                }, u);
              } else
                nt = at.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: w,
                    shift: J
                  }, {
                    type: "elem",
                    elem: D,
                    shift: P
                  }]
                }, u);
              return nt.children[0].children[0].children[1].classes.push("svg-align"), at.makeSpan(["mrel", "x-arrow"], [nt], u);
            },
            mathmlBuilder(d, u) {
              const f = ci.mathMLnode(d.label);
              f.setAttribute("minsize", d.label.charAt(0) === "x" ? "1.75em" : "3.0em");
              let b;
              if (d.body) {
                const w = Dc(ve(d.body, u));
                if (d.below) {
                  const S = Dc(ve(d.below, u));
                  b = new ft.MathNode("munderover", [f, S, w]);
                } else
                  b = new ft.MathNode("mover", [f, w]);
              } else if (d.below) {
                const w = Dc(ve(d.below, u));
                b = new ft.MathNode("munder", [f, w]);
              } else
                b = Dc(), b = new ft.MathNode("mover", [f, b]);
              return b;
            }
          });
          const CC = at.makeSpan;
          function qg(d, u) {
            const f = Ve(d.body, u, true);
            return CC([d.mclass], f, u);
          }
          function Rg(d, u) {
            let f;
            const b = Dr(d.body, u);
            return d.mclass === "minner" ? f = new ft.MathNode("mpadded", b) : d.mclass === "mord" ? d.isCharacterBox ? (f = b[0], f.type = "mi") : f = new ft.MathNode("mi", b) : (d.isCharacterBox ? (f = b[0], f.type = "mo") : f = new ft.MathNode("mo", b), d.mclass === "mbin" ? (f.attributes.lspace = "0.22em", f.attributes.rspace = "0.22em") : d.mclass === "mpunct" ? (f.attributes.lspace = "0em", f.attributes.rspace = "0.17em") : d.mclass === "mopen" || d.mclass === "mclose" ? (f.attributes.lspace = "0em", f.attributes.rspace = "0em") : d.mclass === "minner" && (f.attributes.lspace = "0.0556em", f.attributes.width = "+0.1111em")), f;
          }
          _t({
            type: "mclass",
            names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "mclass",
                mode: f.mode,
                mclass: "m" + b.slice(5),
                // TODO(kevinb): don't prefix with 'm'
                body: qe(w),
                isCharacterBox: k.isCharacterBox(w)
              };
            },
            htmlBuilder: qg,
            mathmlBuilder: Rg
          });
          const Fc = (d) => {
            const u = d.type === "ordgroup" && d.body.length ? d.body[0] : d;
            return u.type === "atom" && (u.family === "bin" || u.family === "rel") ? "m" + u.family : "mord";
          };
          _t({
            type: "mclass",
            names: ["\\@binrel"],
            props: {
              numArgs: 2
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "mclass",
                mode: f.mode,
                mclass: Fc(u[0]),
                body: qe(u[1]),
                isCharacterBox: k.isCharacterBox(u[1])
              };
            }
          }), _t({
            type: "mclass",
            names: ["\\stackrel", "\\overset", "\\underset"],
            props: {
              numArgs: 2
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[1], S = u[0];
              let E;
              b !== "\\stackrel" ? E = Fc(w) : E = "mrel";
              const D = {
                type: "op",
                mode: w.mode,
                limits: true,
                alwaysHandleSupSub: true,
                parentIsSupSub: false,
                symbol: false,
                suppressBaseShift: b !== "\\stackrel",
                body: qe(w)
              }, P = {
                type: "supsub",
                mode: S.mode,
                base: D,
                sup: b === "\\underset" ? null : S,
                sub: b === "\\underset" ? S : null
              };
              return {
                type: "mclass",
                mode: f.mode,
                mclass: E,
                body: [P],
                isCharacterBox: k.isCharacterBox(P)
              };
            },
            htmlBuilder: qg,
            mathmlBuilder: Rg
          }), _t({
            type: "pmb",
            names: ["\\pmb"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "pmb",
                mode: f.mode,
                mclass: Fc(u[0]),
                body: qe(u[0])
              };
            },
            htmlBuilder(d, u) {
              const f = Ve(d.body, u, true), b = at.makeSpan([d.mclass], f, u);
              return b.style.textShadow = "0.02em 0.01em 0.04px", b;
            },
            mathmlBuilder(d, u) {
              const f = Dr(d.body, u), b = new ft.MathNode("mstyle", f);
              return b.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), b;
            }
          });
          const _C = {
            ">": "\\\\cdrightarrow",
            "<": "\\\\cdleftarrow",
            "=": "\\\\cdlongequal",
            A: "\\uparrow",
            V: "\\downarrow",
            "|": "\\Vert",
            ".": "no arrow"
          }, Pg = () => ({
            type: "styling",
            body: [],
            mode: "math",
            style: "display"
          }), jg = (d) => d.type === "textord" && d.text === "@", SC = (d, u) => (d.type === "mathord" || d.type === "atom") && d.text === u;
          function AC(d, u, f) {
            const b = _C[d];
            switch (b) {
              case "\\\\cdrightarrow":
              case "\\\\cdleftarrow":
                return f.callFunction(b, [u[0]], [u[1]]);
              case "\\uparrow":
              case "\\downarrow": {
                const w = f.callFunction("\\\\cdleft", [u[0]], []), S = {
                  type: "atom",
                  text: b,
                  mode: "math",
                  family: "rel"
                }, E = f.callFunction("\\Big", [S], []), D = f.callFunction("\\\\cdright", [u[1]], []), P = {
                  type: "ordgroup",
                  mode: "math",
                  body: [w, E, D]
                };
                return f.callFunction("\\\\cdparent", [P], []);
              }
              case "\\\\cdlongequal":
                return f.callFunction("\\\\cdlongequal", [], []);
              case "\\Vert": {
                const w = {
                  type: "textord",
                  text: "\\Vert",
                  mode: "math"
                };
                return f.callFunction("\\Big", [w], []);
              }
              default:
                return {
                  type: "textord",
                  text: " ",
                  mode: "math"
                };
            }
          }
          function TC(d) {
            const u = [];
            for (d.gullet.beginGroup(), d.gullet.macros.set("\\cr", "\\\\\\relax"), d.gullet.beginGroup(); ; ) {
              u.push(d.parseExpression(false, "\\\\")), d.gullet.endGroup(), d.gullet.beginGroup();
              const S = d.fetch().text;
              if (S === "&" || S === "\\\\")
                d.consume();
              else if (S === "\\end") {
                u[u.length - 1].length === 0 && u.pop();
                break;
              } else
                throw new s("Expected \\\\ or \\cr or \\end", d.nextToken);
            }
            let f = [];
            const b = [f];
            for (let S = 0; S < u.length; S++) {
              const E = u[S];
              let D = Pg();
              for (let P = 0; P < E.length; P++)
                if (!jg(E[P]))
                  D.body.push(E[P]);
                else {
                  f.push(D), P += 1;
                  const J = ed(E[P]).text, nt = new Array(2);
                  if (nt[0] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  }, nt[1] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  }, !("=|.".indexOf(J) > -1)) if ("<>AV".indexOf(J) > -1)
                    for (let lt = 0; lt < 2; lt++) {
                      let yt = true;
                      for (let kt = P + 1; kt < E.length; kt++) {
                        if (SC(E[kt], J)) {
                          yt = false, P = kt;
                          break;
                        }
                        if (jg(E[kt]))
                          throw new s("Missing a " + J + " character to complete a CD arrow.", E[kt]);
                        nt[lt].body.push(E[kt]);
                      }
                      if (yt)
                        throw new s("Missing a " + J + " character to complete a CD arrow.", E[P]);
                    }
                  else
                    throw new s('Expected one of "<>AV=|." after @', E[P]);
                  const it = {
                    type: "styling",
                    body: [AC(J, nt, d)],
                    mode: "math",
                    style: "display"
                    // CD is always displaystyle.
                  };
                  f.push(it), D = Pg();
                }
              S % 2 === 0 ? f.push(D) : f.shift(), f = [], b.push(f);
            }
            d.gullet.endGroup(), d.gullet.endGroup();
            const w = new Array(b[0].length).fill({
              type: "align",
              align: "c",
              pregap: 0.25,
              // CD package sets \enskip between columns.
              postgap: 0.25
              // So pre and post each get half an \enskip, i.e. 0.25em.
            });
            return {
              type: "array",
              mode: "math",
              body: b,
              arraystretch: 1,
              addJot: true,
              rowGaps: [null],
              cols: w,
              colSeparationType: "CD",
              hLinesBeforeRow: new Array(b.length + 1).fill([])
            };
          }
          _t({
            type: "cdlabel",
            names: ["\\\\cdleft", "\\\\cdright"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              return {
                type: "cdlabel",
                mode: f.mode,
                side: b.slice(4),
                label: u[0]
              };
            },
            htmlBuilder(d, u) {
              const f = u.havingStyle(u.style.sup()), b = at.wrapFragment(le(d.label, f, u), u);
              return b.classes.push("cd-label-" + d.side), b.style.bottom = bt(0.8 - b.depth), b.height = 0, b.depth = 0, b;
            },
            mathmlBuilder(d, u) {
              let f = new ft.MathNode("mrow", [ve(d.label, u)]);
              return f = new ft.MathNode("mpadded", [f]), f.setAttribute("width", "0"), d.side === "left" && f.setAttribute("lspace", "-1width"), f.setAttribute("voffset", "0.7em"), f = new ft.MathNode("mstyle", [f]), f.setAttribute("displaystyle", "false"), f.setAttribute("scriptlevel", "1"), f;
            }
          }), _t({
            type: "cdlabelparent",
            names: ["\\\\cdparent"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "cdlabelparent",
                mode: f.mode,
                fragment: u[0]
              };
            },
            htmlBuilder(d, u) {
              const f = at.wrapFragment(le(d.fragment, u), u);
              return f.classes.push("cd-vert-arrow"), f;
            },
            mathmlBuilder(d, u) {
              return new ft.MathNode("mrow", [ve(d.fragment, u)]);
            }
          }), _t({
            type: "textord",
            names: ["\\@char"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = Zt(u[0], "ordgroup").body;
              let w = "";
              for (let D = 0; D < b.length; D++) {
                const P = Zt(b[D], "textord");
                w += P.text;
              }
              let S = parseInt(w), E;
              if (isNaN(S))
                throw new s("\\@char has non-numeric argument " + w);
              if (S < 0 || S >= 1114111)
                throw new s("\\@char with invalid code point " + w);
              return S <= 65535 ? E = String.fromCharCode(S) : (S -= 65536, E = String.fromCharCode((S >> 10) + 55296, (S & 1023) + 56320)), {
                type: "textord",
                mode: f.mode,
                text: E
              };
            }
          });
          const Wg = (d, u) => {
            const f = Ve(d.body, u.withColor(d.color), false);
            return at.makeFragment(f);
          }, Hg = (d, u) => {
            const f = Dr(d.body, u.withColor(d.color)), b = new ft.MathNode("mstyle", f);
            return b.setAttribute("mathcolor", d.color), b;
          };
          _t({
            type: "color",
            names: ["\\textcolor"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "original"]
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = Zt(u[0], "color-token").color, w = u[1];
              return {
                type: "color",
                mode: f.mode,
                color: b,
                body: qe(w)
              };
            },
            htmlBuilder: Wg,
            mathmlBuilder: Hg
          }), _t({
            type: "color",
            names: ["\\color"],
            props: {
              numArgs: 1,
              allowedInText: true,
              argTypes: ["color"]
            },
            handler(d, u) {
              let {
                parser: f,
                breakOnTokenText: b
              } = d;
              const w = Zt(u[0], "color-token").color;
              f.gullet.macros.set("\\current@color", w);
              const S = f.parseExpression(true, b);
              return {
                type: "color",
                mode: f.mode,
                color: w,
                body: S
              };
            },
            htmlBuilder: Wg,
            mathmlBuilder: Hg
          }), _t({
            type: "cr",
            names: ["\\\\"],
            props: {
              numArgs: 0,
              numOptionalArgs: 0,
              allowedInText: true
            },
            handler(d, u, f) {
              let {
                parser: b
              } = d;
              const w = b.gullet.future().text === "[" ? b.parseSizeGroup(true) : null, S = !b.settings.displayMode || !b.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
              return {
                type: "cr",
                mode: b.mode,
                newLine: S,
                size: w && Zt(w, "size").value
              };
            },
            // The following builders are called only at the top level,
            // not within tabular/array environments.
            htmlBuilder(d, u) {
              const f = at.makeSpan(["mspace"], [], u);
              return d.newLine && (f.classes.push("newline"), d.size && (f.style.marginTop = bt(xe(d.size, u)))), f;
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mspace");
              return d.newLine && (f.setAttribute("linebreak", "newline"), d.size && f.setAttribute("height", bt(xe(d.size, u)))), f;
            }
          });
          const nd = {
            "\\global": "\\global",
            "\\long": "\\\\globallong",
            "\\\\globallong": "\\\\globallong",
            "\\def": "\\gdef",
            "\\gdef": "\\gdef",
            "\\edef": "\\xdef",
            "\\xdef": "\\xdef",
            "\\let": "\\\\globallet",
            "\\futurelet": "\\\\globalfuture"
          }, Ug = (d) => {
            const u = d.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(u))
              throw new s("Expected a control sequence", d);
            return u;
          }, $C = (d) => {
            let u = d.gullet.popToken();
            return u.text === "=" && (u = d.gullet.popToken(), u.text === " " && (u = d.gullet.popToken())), u;
          }, Vg = (d, u, f, b) => {
            let w = d.gullet.macros.get(f.text);
            w == null && (f.noexpand = true, w = {
              tokens: [f],
              numArgs: 0,
              // reproduce the same behavior in expansion
              unexpandable: !d.gullet.isExpandable(f.text)
            }), d.gullet.macros.set(u, w, b);
          };
          _t({
            type: "internal",
            names: [
              "\\global",
              "\\long",
              "\\\\globallong"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              u.consumeSpaces();
              const b = u.fetch();
              if (nd[b.text])
                return (f === "\\global" || f === "\\\\globallong") && (b.text = nd[b.text]), Zt(u.parseFunction(), "internal");
              throw new s("Invalid token after macro prefix", b);
            }
          }), _t({
            type: "internal",
            names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d, b = u.gullet.popToken();
              const w = b.text;
              if (/^(?:[\\{}$&#^_]|EOF)$/.test(w))
                throw new s("Expected a control sequence", b);
              let S = 0, E;
              const D = [[]];
              for (; u.gullet.future().text !== "{"; )
                if (b = u.gullet.popToken(), b.text === "#") {
                  if (u.gullet.future().text === "{") {
                    E = u.gullet.future(), D[S].push("{");
                    break;
                  }
                  if (b = u.gullet.popToken(), !/^[1-9]$/.test(b.text))
                    throw new s('Invalid argument number "' + b.text + '"');
                  if (parseInt(b.text) !== S + 1)
                    throw new s('Argument number "' + b.text + '" out of order');
                  S++, D.push([]);
                } else {
                  if (b.text === "EOF")
                    throw new s("Expected a macro definition");
                  D[S].push(b.text);
                }
              let {
                tokens: P
              } = u.gullet.consumeArg();
              return E && P.unshift(E), (f === "\\edef" || f === "\\xdef") && (P = u.gullet.expandTokens(P), P.reverse()), u.gullet.macros.set(w, {
                tokens: P,
                numArgs: S,
                delimiters: D
              }, f === nd[f]), {
                type: "internal",
                mode: u.mode
              };
            }
          }), _t({
            type: "internal",
            names: [
              "\\let",
              "\\\\globallet"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              const b = Ug(u.gullet.popToken());
              u.gullet.consumeSpaces();
              const w = $C(u);
              return Vg(u, b, w, f === "\\\\globallet"), {
                type: "internal",
                mode: u.mode
              };
            }
          }), _t({
            type: "internal",
            names: [
              "\\futurelet",
              "\\\\globalfuture"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              const b = Ug(u.gullet.popToken()), w = u.gullet.popToken(), S = u.gullet.popToken();
              return Vg(u, b, S, f === "\\\\globalfuture"), u.gullet.pushToken(S), u.gullet.pushToken(w), {
                type: "internal",
                mode: u.mode
              };
            }
          });
          const Eo = function(d, u, f) {
            const b = pe.math[d] && pe.math[d].replace, w = vo(b || d, u, f);
            if (!w)
              throw new Error("Unsupported symbol " + d + " and font size " + u + ".");
            return w;
          }, id = function(d, u, f, b) {
            const w = f.havingBaseStyle(u), S = at.makeSpan(b.concat(w.sizingClasses(f)), [d], f), E = w.sizeMultiplier / f.sizeMultiplier;
            return S.height *= E, S.depth *= E, S.maxFontSize = w.sizeMultiplier, S;
          }, Gg = function(d, u, f) {
            const b = u.havingBaseStyle(f), w = (1 - u.sizeMultiplier / b.sizeMultiplier) * u.fontMetrics().axisHeight;
            d.classes.push("delimcenter"), d.style.top = bt(w), d.height -= w, d.depth += w;
          }, EC = function(d, u, f, b, w, S) {
            const E = at.makeSymbol(d, "Main-Regular", w, b), D = id(E, u, b, S);
            return f && Gg(D, b, u), D;
          }, MC = function(d, u, f, b) {
            return at.makeSymbol(d, "Size" + u + "-Regular", f, b);
          }, Xg = function(d, u, f, b, w, S) {
            const E = MC(d, u, w, b), D = id(at.makeSpan(["delimsizing", "size" + u], [E], b), et.TEXT, b, S);
            return f && Gg(D, b, et.TEXT), D;
          }, sd = function(d, u, f) {
            let b;
            return u === "Size1-Regular" ? b = "delim-size1" : b = "delim-size4", {
              type: "elem",
              elem: at.makeSpan(["delimsizinginner", b], [at.makeSpan([], [at.makeSymbol(d, u, f)])])
            };
          }, ad = function(d, u, f) {
            const b = br["Size4-Regular"][d.charCodeAt(0)] ? br["Size4-Regular"][d.charCodeAt(0)][4] : br["Size1-Regular"][d.charCodeAt(0)][4], w = new wr("inner", ni(d, Math.round(1e3 * u))), S = new we([w], {
              width: bt(b),
              height: bt(u),
              // Override CSS rule `.katex svg { width: 100% }`
              style: "width:" + bt(b),
              viewBox: "0 0 " + 1e3 * b + " " + Math.round(1e3 * u),
              preserveAspectRatio: "xMinYMin"
            }), E = at.makeSvgSpan([], [S], f);
            return E.height = u, E.style.height = bt(u), E.style.width = bt(b), {
              type: "elem",
              elem: E
            };
          }, od = 8e-3, Nc = {
            type: "kern",
            size: -1 * od
          }, BC = ["|", "\\lvert", "\\rvert", "\\vert"], LC = ["\\|", "\\lVert", "\\rVert", "\\Vert"], Yg = function(d, u, f, b, w, S) {
            let E, D, P, J, nt = "", it = 0;
            E = P = J = d, D = null;
            let lt = "Size1-Regular";
            d === "\\uparrow" ? P = J = "⏐" : d === "\\Uparrow" ? P = J = "‖" : d === "\\downarrow" ? E = P = "⏐" : d === "\\Downarrow" ? E = P = "‖" : d === "\\updownarrow" ? (E = "\\uparrow", P = "⏐", J = "\\downarrow") : d === "\\Updownarrow" ? (E = "\\Uparrow", P = "‖", J = "\\Downarrow") : k.contains(BC, d) ? (P = "∣", nt = "vert", it = 333) : k.contains(LC, d) ? (P = "∥", nt = "doublevert", it = 556) : d === "[" || d === "\\lbrack" ? (E = "⎡", P = "⎢", J = "⎣", lt = "Size4-Regular", nt = "lbrack", it = 667) : d === "]" || d === "\\rbrack" ? (E = "⎤", P = "⎥", J = "⎦", lt = "Size4-Regular", nt = "rbrack", it = 667) : d === "\\lfloor" || d === "⌊" ? (P = E = "⎢", J = "⎣", lt = "Size4-Regular", nt = "lfloor", it = 667) : d === "\\lceil" || d === "⌈" ? (E = "⎡", P = J = "⎢", lt = "Size4-Regular", nt = "lceil", it = 667) : d === "\\rfloor" || d === "⌋" ? (P = E = "⎥", J = "⎦", lt = "Size4-Regular", nt = "rfloor", it = 667) : d === "\\rceil" || d === "⌉" ? (E = "⎤", P = J = "⎥", lt = "Size4-Regular", nt = "rceil", it = 667) : d === "(" || d === "\\lparen" ? (E = "⎛", P = "⎜", J = "⎝", lt = "Size4-Regular", nt = "lparen", it = 875) : d === ")" || d === "\\rparen" ? (E = "⎞", P = "⎟", J = "⎠", lt = "Size4-Regular", nt = "rparen", it = 875) : d === "\\{" || d === "\\lbrace" ? (E = "⎧", D = "⎨", J = "⎩", P = "⎪", lt = "Size4-Regular") : d === "\\}" || d === "\\rbrace" ? (E = "⎫", D = "⎬", J = "⎭", P = "⎪", lt = "Size4-Regular") : d === "\\lgroup" || d === "⟮" ? (E = "⎧", J = "⎩", P = "⎪", lt = "Size4-Regular") : d === "\\rgroup" || d === "⟯" ? (E = "⎫", J = "⎭", P = "⎪", lt = "Size4-Regular") : d === "\\lmoustache" || d === "⎰" ? (E = "⎧", J = "⎭", P = "⎪", lt = "Size4-Regular") : (d === "\\rmoustache" || d === "⎱") && (E = "⎫", J = "⎩", P = "⎪", lt = "Size4-Regular");
            const yt = Eo(E, lt, w), kt = yt.height + yt.depth, Yt = Eo(P, lt, w), ie = Yt.height + Yt.depth, te = Eo(J, lt, w), ue = te.height + te.depth;
            let ce = 0, $e = 1;
            if (D !== null) {
              const ze = Eo(D, lt, w);
              ce = ze.height + ze.depth, $e = 2;
            }
            const or = kt + ue + ce, vr = Math.max(0, Math.ceil((u - or) / ($e * ie))), ln = or + vr * $e * ie;
            let ga = b.fontMetrics().axisHeight;
            f && (ga *= b.sizeMultiplier);
            const de = ln / 2 - ga, be = [];
            if (nt.length > 0) {
              const ze = ln - kt - ue, Ne = Math.round(ln * 1e3), cn = wo(nt, Math.round(ze * 1e3)), i_ = new wr(nt, cn), qy = (it / 1e3).toFixed(3) + "em", Ry = (Ne / 1e3).toFixed(3) + "em", s_ = new we([i_], {
                width: qy,
                height: Ry,
                viewBox: "0 0 " + it + " " + Ne
              }), Rc = at.makeSvgSpan([], [s_], b);
              Rc.height = Ne / 1e3, Rc.style.width = qy, Rc.style.height = Ry, be.push({
                type: "elem",
                elem: Rc
              });
            } else {
              if (be.push(sd(J, lt, w)), be.push(Nc), D === null) {
                const ze = ln - kt - ue + 2 * od;
                be.push(ad(P, ze, b));
              } else {
                const ze = (ln - kt - ue - ce) / 2 + 2 * od;
                be.push(ad(P, ze, b)), be.push(Nc), be.push(sd(D, lt, w)), be.push(Nc), be.push(ad(P, ze, b));
              }
              be.push(Nc), be.push(sd(E, lt, w));
            }
            const Ee = b.havingBaseStyle(et.TEXT), Be = at.makeVList({
              positionType: "bottom",
              positionData: de,
              children: be
            }, Ee);
            return id(at.makeSpan(["delimsizing", "mult"], [Be], Ee), et.TEXT, b, S);
          }, ld = 80, cd = 0.08, hd = function(d, u, f, b, w) {
            const S = he(d, b, f), E = new wr(d, S), D = new we([E], {
              // Note: 1000:1 ratio of viewBox to document em width.
              width: "400em",
              height: bt(u),
              viewBox: "0 0 400000 " + f,
              preserveAspectRatio: "xMinYMin slice"
            });
            return at.makeSvgSpan(["hide-tail"], [D], w);
          }, DC = function(d, u) {
            const f = u.havingBaseSizing(), b = Qg("\\surd", d * f.sizeMultiplier, Jg, f);
            let w = f.sizeMultiplier;
            const S = Math.max(0, u.minRuleThickness - u.fontMetrics().sqrtRuleThickness);
            let E, D = 0, P = 0, J = 0, nt;
            return b.type === "small" ? (J = 1e3 + 1e3 * S + ld, d < 1 ? w = 1 : d < 1.4 && (w = 0.7), D = (1 + S + cd) / w, P = (1 + S) / w, E = hd("sqrtMain", D, J, S, u), E.style.minWidth = "0.853em", nt = 0.833 / w) : b.type === "large" ? (J = (1e3 + ld) * Mo[b.size], P = (Mo[b.size] + S) / w, D = (Mo[b.size] + S + cd) / w, E = hd("sqrtSize" + b.size, D, J, S, u), E.style.minWidth = "1.02em", nt = 1 / w) : (D = d + S + cd, P = d + S, J = Math.floor(1e3 * d + S) + ld, E = hd("sqrtTall", D, J, S, u), E.style.minWidth = "0.742em", nt = 1.056), E.height = P, E.style.height = bt(D), {
              span: E,
              advanceWidth: nt,
              // Calculate the actual line width.
              // This actually should depend on the chosen font -- e.g. \boldmath
              // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
              // have thicker rules.
              ruleWidth: (u.fontMetrics().sqrtRuleThickness + S) * w
            };
          }, Kg = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], FC = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], Zg = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], Mo = [0, 1.2, 1.8, 2.4, 3], NC = function(d, u, f, b, w) {
            if (d === "<" || d === "\\lt" || d === "⟨" ? d = "\\langle" : (d === ">" || d === "\\gt" || d === "⟩") && (d = "\\rangle"), k.contains(Kg, d) || k.contains(Zg, d))
              return Xg(d, u, false, f, b, w);
            if (k.contains(FC, d))
              return Yg(d, Mo[u], false, f, b, w);
            throw new s("Illegal delimiter: '" + d + "'");
          }, IC = [{
            type: "small",
            style: et.SCRIPTSCRIPT
          }, {
            type: "small",
            style: et.SCRIPT
          }, {
            type: "small",
            style: et.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }], OC = [{
            type: "small",
            style: et.SCRIPTSCRIPT
          }, {
            type: "small",
            style: et.SCRIPT
          }, {
            type: "small",
            style: et.TEXT
          }, {
            type: "stack"
          }], Jg = [{
            type: "small",
            style: et.SCRIPTSCRIPT
          }, {
            type: "small",
            style: et.SCRIPT
          }, {
            type: "small",
            style: et.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }, {
            type: "stack"
          }], zC = function(d) {
            if (d.type === "small")
              return "Main-Regular";
            if (d.type === "large")
              return "Size" + d.size + "-Regular";
            if (d.type === "stack")
              return "Size4-Regular";
            throw new Error("Add support for delim type '" + d.type + "' here.");
          }, Qg = function(d, u, f, b) {
            const w = Math.min(2, 3 - b.style.size);
            for (let S = w; S < f.length && f[S].type !== "stack"; S++) {
              const E = Eo(d, zC(f[S]), "math");
              let D = E.height + E.depth;
              if (f[S].type === "small") {
                const P = b.havingBaseStyle(f[S].style);
                D *= P.sizeMultiplier;
              }
              if (D > u)
                return f[S];
            }
            return f[f.length - 1];
          }, ty = function(d, u, f, b, w, S) {
            d === "<" || d === "\\lt" || d === "⟨" ? d = "\\langle" : (d === ">" || d === "\\gt" || d === "⟩") && (d = "\\rangle");
            let E;
            k.contains(Zg, d) ? E = IC : k.contains(Kg, d) ? E = Jg : E = OC;
            const D = Qg(d, u, E, b);
            return D.type === "small" ? EC(d, D.style, f, b, w, S) : D.type === "large" ? Xg(d, D.size, f, b, w, S) : Yg(d, u, f, b, w, S);
          };
          var hi = {
            sqrtImage: DC,
            sizedDelim: NC,
            sizeToMaxHeight: Mo,
            customSizedDelim: ty,
            leftRightDelim: function(d, u, f, b, w, S) {
              const E = b.fontMetrics().axisHeight * b.sizeMultiplier, D = 901, P = 5 / b.fontMetrics().ptPerEm, J = Math.max(u - E, f + E), nt = Math.max(
                // In real TeX, calculations are done using integral values which are
                // 65536 per pt, or 655360 per em. So, the division here truncates in
                // TeX but doesn't here, producing different results. If we wanted to
                // exactly match TeX's calculation, we could do
                //   Math.floor(655360 * maxDistFromAxis / 500) *
                //    delimiterFactor / 655360
                // (To see the difference, compare
                //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
                // in TeX and KaTeX)
                J / 500 * D,
                2 * J - P
              );
              return ty(d, nt, true, b, w, S);
            }
          };
          const ey = {
            "\\bigl": {
              mclass: "mopen",
              size: 1
            },
            "\\Bigl": {
              mclass: "mopen",
              size: 2
            },
            "\\biggl": {
              mclass: "mopen",
              size: 3
            },
            "\\Biggl": {
              mclass: "mopen",
              size: 4
            },
            "\\bigr": {
              mclass: "mclose",
              size: 1
            },
            "\\Bigr": {
              mclass: "mclose",
              size: 2
            },
            "\\biggr": {
              mclass: "mclose",
              size: 3
            },
            "\\Biggr": {
              mclass: "mclose",
              size: 4
            },
            "\\bigm": {
              mclass: "mrel",
              size: 1
            },
            "\\Bigm": {
              mclass: "mrel",
              size: 2
            },
            "\\biggm": {
              mclass: "mrel",
              size: 3
            },
            "\\Biggm": {
              mclass: "mrel",
              size: 4
            },
            "\\big": {
              mclass: "mord",
              size: 1
            },
            "\\Big": {
              mclass: "mord",
              size: 2
            },
            "\\bigg": {
              mclass: "mord",
              size: 3
            },
            "\\Bigg": {
              mclass: "mord",
              size: 4
            }
          }, qC = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
          function Ic(d, u) {
            const f = Lc(d);
            if (f && k.contains(qC, f.text))
              return f;
            throw f ? new s("Invalid delimiter '" + f.text + "' after '" + u.funcName + "'", d) : new s("Invalid delimiter type '" + d.type + "'", d);
          }
          _t({
            type: "delimsizing",
            names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
            props: {
              numArgs: 1,
              argTypes: ["primitive"]
            },
            handler: (d, u) => {
              const f = Ic(u[0], d);
              return {
                type: "delimsizing",
                mode: d.parser.mode,
                size: ey[d.funcName].size,
                mclass: ey[d.funcName].mclass,
                delim: f.text
              };
            },
            htmlBuilder: (d, u) => d.delim === "." ? at.makeSpan([d.mclass]) : hi.sizedDelim(d.delim, d.size, u, d.mode, [d.mclass]),
            mathmlBuilder: (d) => {
              const u = [];
              d.delim !== "." && u.push(an(d.delim, d.mode));
              const f = new ft.MathNode("mo", u);
              d.mclass === "mopen" || d.mclass === "mclose" ? f.setAttribute("fence", "true") : f.setAttribute("fence", "false"), f.setAttribute("stretchy", "true");
              const b = bt(hi.sizeToMaxHeight[d.size]);
              return f.setAttribute("minsize", b), f.setAttribute("maxsize", b), f;
            }
          });
          function ry(d) {
            if (!d.body)
              throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
          }
          _t({
            type: "leftright-right",
            names: ["\\right"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (d, u) => {
              const f = d.parser.gullet.macros.get("\\current@color");
              if (f && typeof f != "string")
                throw new s("\\current@color set to non-string in \\right");
              return {
                type: "leftright-right",
                mode: d.parser.mode,
                delim: Ic(u[0], d).text,
                color: f
                // undefined if not set via \color
              };
            }
          }), _t({
            type: "leftright",
            names: ["\\left"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (d, u) => {
              const f = Ic(u[0], d), b = d.parser;
              ++b.leftrightDepth;
              const w = b.parseExpression(false);
              --b.leftrightDepth, b.expect("\\right", false);
              const S = Zt(b.parseFunction(), "leftright-right");
              return {
                type: "leftright",
                mode: b.mode,
                body: w,
                left: f.text,
                right: S.delim,
                rightColor: S.color
              };
            },
            htmlBuilder: (d, u) => {
              ry(d);
              const f = Ve(d.body, u, true, ["mopen", "mclose"]);
              let b = 0, w = 0, S = false;
              for (let P = 0; P < f.length; P++)
                f[P].isMiddle ? S = true : (b = Math.max(f[P].height, b), w = Math.max(f[P].depth, w));
              b *= u.sizeMultiplier, w *= u.sizeMultiplier;
              let E;
              if (d.left === "." ? E = $o(u, ["mopen"]) : E = hi.leftRightDelim(d.left, b, w, u, d.mode, ["mopen"]), f.unshift(E), S)
                for (let P = 1; P < f.length; P++) {
                  const J = f[P].isMiddle;
                  J && (f[P] = hi.leftRightDelim(J.delim, b, w, J.options, d.mode, []));
                }
              let D;
              if (d.right === ".")
                D = $o(u, ["mclose"]);
              else {
                const P = d.rightColor ? u.withColor(d.rightColor) : u;
                D = hi.leftRightDelim(d.right, b, w, P, d.mode, ["mclose"]);
              }
              return f.push(D), at.makeSpan(["minner"], f, u);
            },
            mathmlBuilder: (d, u) => {
              ry(d);
              const f = Dr(d.body, u);
              if (d.left !== ".") {
                const b = new ft.MathNode("mo", [an(d.left, d.mode)]);
                b.setAttribute("fence", "true"), f.unshift(b);
              }
              if (d.right !== ".") {
                const b = new ft.MathNode("mo", [an(d.right, d.mode)]);
                b.setAttribute("fence", "true"), d.rightColor && b.setAttribute("mathcolor", d.rightColor), f.push(b);
              }
              return Ju(f);
            }
          }), _t({
            type: "middle",
            names: ["\\middle"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (d, u) => {
              const f = Ic(u[0], d);
              if (!d.parser.leftrightDepth)
                throw new s("\\middle without preceding \\left", f);
              return {
                type: "middle",
                mode: d.parser.mode,
                delim: f.text
              };
            },
            htmlBuilder: (d, u) => {
              let f;
              if (d.delim === ".")
                f = $o(u, []);
              else {
                f = hi.sizedDelim(d.delim, 1, u, d.mode, []);
                const b = {
                  delim: d.delim,
                  options: u
                };
                f.isMiddle = b;
              }
              return f;
            },
            mathmlBuilder: (d, u) => {
              const f = d.delim === "\\vert" || d.delim === "|" ? an("|", "text") : an(d.delim, d.mode), b = new ft.MathNode("mo", [f]);
              return b.setAttribute("fence", "true"), b.setAttribute("lspace", "0.05em"), b.setAttribute("rspace", "0.05em"), b;
            }
          });
          const ud = (d, u) => {
            const f = at.wrapFragment(le(d.body, u), u), b = d.label.slice(1);
            let w = u.sizeMultiplier, S, E = 0;
            const D = k.isCharacterBox(d.body);
            if (b === "sout")
              S = at.makeSpan(["stretchy", "sout"]), S.height = u.fontMetrics().defaultRuleThickness / w, E = -0.5 * u.fontMetrics().xHeight;
            else if (b === "phase") {
              const J = xe({
                number: 0.6,
                unit: "pt"
              }, u), nt = xe({
                number: 0.35,
                unit: "ex"
              }, u), it = u.havingBaseSizing();
              w = w / it.sizeMultiplier;
              const lt = f.height + f.depth + J + nt;
              f.style.paddingLeft = bt(lt / 2 + J);
              const yt = Math.floor(1e3 * lt * w), kt = Ht(yt), Yt = new we([new wr("phase", kt)], {
                width: "400em",
                height: bt(yt / 1e3),
                viewBox: "0 0 400000 " + yt,
                preserveAspectRatio: "xMinYMin slice"
              });
              S = at.makeSvgSpan(["hide-tail"], [Yt], u), S.style.height = bt(lt), E = f.depth + J + nt;
            } else {
              /cancel/.test(b) ? D || f.classes.push("cancel-pad") : b === "angl" ? f.classes.push("anglpad") : f.classes.push("boxpad");
              let J = 0, nt = 0, it = 0;
              /box/.test(b) ? (it = Math.max(
                u.fontMetrics().fboxrule,
                // default
                u.minRuleThickness
                // User override.
              ), J = u.fontMetrics().fboxsep + (b === "colorbox" ? 0 : it), nt = J) : b === "angl" ? (it = Math.max(u.fontMetrics().defaultRuleThickness, u.minRuleThickness), J = 4 * it, nt = Math.max(0, 0.25 - f.depth)) : (J = D ? 0.2 : 0, nt = J), S = ci.encloseSpan(f, b, J, nt, u), /fbox|boxed|fcolorbox/.test(b) ? (S.style.borderStyle = "solid", S.style.borderWidth = bt(it)) : b === "angl" && it !== 0.049 && (S.style.borderTopWidth = bt(it), S.style.borderRightWidth = bt(it)), E = f.depth + nt, d.backgroundColor && (S.style.backgroundColor = d.backgroundColor, d.borderColor && (S.style.borderColor = d.borderColor));
            }
            let P;
            if (d.backgroundColor)
              P = at.makeVList({
                positionType: "individualShift",
                children: [
                  // Put the color background behind inner;
                  {
                    type: "elem",
                    elem: S,
                    shift: E
                  },
                  {
                    type: "elem",
                    elem: f,
                    shift: 0
                  }
                ]
              }, u);
            else {
              const J = /cancel|phase/.test(b) ? ["svg-align"] : [];
              P = at.makeVList({
                positionType: "individualShift",
                children: [
                  // Write the \cancel stroke on top of inner.
                  {
                    type: "elem",
                    elem: f,
                    shift: 0
                  },
                  {
                    type: "elem",
                    elem: S,
                    shift: E,
                    wrapperClasses: J
                  }
                ]
              }, u);
            }
            return /cancel/.test(b) && (P.height = f.height, P.depth = f.depth), /cancel/.test(b) && !D ? at.makeSpan(["mord", "cancel-lap"], [P], u) : at.makeSpan(["mord"], [P], u);
          }, dd = (d, u) => {
            let f = 0;
            const b = new ft.MathNode(d.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [ve(d.body, u)]);
            switch (d.label) {
              case "\\cancel":
                b.setAttribute("notation", "updiagonalstrike");
                break;
              case "\\bcancel":
                b.setAttribute("notation", "downdiagonalstrike");
                break;
              case "\\phase":
                b.setAttribute("notation", "phasorangle");
                break;
              case "\\sout":
                b.setAttribute("notation", "horizontalstrike");
                break;
              case "\\fbox":
                b.setAttribute("notation", "box");
                break;
              case "\\angl":
                b.setAttribute("notation", "actuarial");
                break;
              case "\\fcolorbox":
              case "\\colorbox":
                if (f = u.fontMetrics().fboxsep * u.fontMetrics().ptPerEm, b.setAttribute("width", "+" + 2 * f + "pt"), b.setAttribute("height", "+" + 2 * f + "pt"), b.setAttribute("lspace", f + "pt"), b.setAttribute("voffset", f + "pt"), d.label === "\\fcolorbox") {
                  const w = Math.max(
                    u.fontMetrics().fboxrule,
                    // default
                    u.minRuleThickness
                    // user override
                  );
                  b.setAttribute("style", "border: " + w + "em solid " + String(d.borderColor));
                }
                break;
              case "\\xcancel":
                b.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                break;
            }
            return d.backgroundColor && b.setAttribute("mathbackground", d.backgroundColor), b;
          };
          _t({
            type: "enclose",
            names: ["\\colorbox"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "text"]
            },
            handler(d, u, f) {
              let {
                parser: b,
                funcName: w
              } = d;
              const S = Zt(u[0], "color-token").color, E = u[1];
              return {
                type: "enclose",
                mode: b.mode,
                label: w,
                backgroundColor: S,
                body: E
              };
            },
            htmlBuilder: ud,
            mathmlBuilder: dd
          }), _t({
            type: "enclose",
            names: ["\\fcolorbox"],
            props: {
              numArgs: 3,
              allowedInText: true,
              argTypes: ["color", "color", "text"]
            },
            handler(d, u, f) {
              let {
                parser: b,
                funcName: w
              } = d;
              const S = Zt(u[0], "color-token").color, E = Zt(u[1], "color-token").color, D = u[2];
              return {
                type: "enclose",
                mode: b.mode,
                label: w,
                backgroundColor: E,
                borderColor: S,
                body: D
              };
            },
            htmlBuilder: ud,
            mathmlBuilder: dd
          }), _t({
            type: "enclose",
            names: ["\\fbox"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "enclose",
                mode: f.mode,
                label: "\\fbox",
                body: u[0]
              };
            }
          }), _t({
            type: "enclose",
            names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "enclose",
                mode: f.mode,
                label: b,
                body: w
              };
            },
            htmlBuilder: ud,
            mathmlBuilder: dd
          }), _t({
            type: "enclose",
            names: ["\\angl"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: false
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "enclose",
                mode: f.mode,
                label: "\\angl",
                body: u[0]
              };
            }
          });
          const ny = {};
          function Ln(d) {
            let {
              type: u,
              names: f,
              props: b,
              handler: w,
              htmlBuilder: S,
              mathmlBuilder: E
            } = d;
            const D = {
              type: u,
              numArgs: b.numArgs || 0,
              allowedInText: false,
              numOptionalArgs: 0,
              handler: w
            };
            for (let P = 0; P < f.length; ++P)
              ny[f[P]] = D;
            S && ($c[u] = S), E && (Ec[u] = E);
          }
          const iy = {};
          function N(d, u) {
            iy[d] = u;
          }
          class Gr {
            // The + prefix indicates that these fields aren't writeable
            // Lexer holding the input string.
            // Start offset, zero-based inclusive.
            // End offset, zero-based exclusive.
            constructor(u, f, b) {
              this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = u, this.start = f, this.end = b;
            }
            /**
             * Merges two `SourceLocation`s from location providers, given they are
             * provided in order of appearance.
             * - Returns the first one's location if only the first is provided.
             * - Returns a merged range of the first and the last if both are provided
             *   and their lexers match.
             * - Otherwise, returns null.
             */
            static range(u, f) {
              return f ? !u || !u.loc || !f.loc || u.loc.lexer !== f.loc.lexer ? null : new Gr(u.loc.lexer, u.loc.start, f.loc.end) : u && u.loc;
            }
          }
          class on {
            // don't expand the token
            // used in \noexpand
            constructor(u, f) {
              this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = u, this.loc = f;
            }
            /**
             * Given a pair of tokens (this and endToken), compute a `Token` encompassing
             * the whole input range enclosed by these two.
             */
            range(u, f) {
              return new on(f, Gr.range(this, u));
            }
          }
          function sy(d) {
            const u = [];
            d.consumeSpaces();
            let f = d.fetch().text;
            for (f === "\\relax" && (d.consume(), d.consumeSpaces(), f = d.fetch().text); f === "\\hline" || f === "\\hdashline"; )
              d.consume(), u.push(f === "\\hdashline"), d.consumeSpaces(), f = d.fetch().text;
            return u;
          }
          const Oc = (d) => {
            if (!d.parser.settings.displayMode)
              throw new s("{" + d.envName + "} can be used only in display mode.");
          };
          function pd(d) {
            if (d.indexOf("ed") === -1)
              return d.indexOf("*") === -1;
          }
          function zi(d, u, f) {
            let {
              hskipBeforeAndAfter: b,
              addJot: w,
              cols: S,
              arraystretch: E,
              colSeparationType: D,
              autoTag: P,
              singleRow: J,
              emptySingleRow: nt,
              maxNumCols: it,
              leqno: lt
            } = u;
            if (d.gullet.beginGroup(), J || d.gullet.macros.set("\\cr", "\\\\\\relax"), !E) {
              const $e = d.gullet.expandMacroAsText("\\arraystretch");
              if ($e == null)
                E = 1;
              else if (E = parseFloat($e), !E || E < 0)
                throw new s("Invalid \\arraystretch: " + $e);
            }
            d.gullet.beginGroup();
            let yt = [];
            const kt = [yt], Yt = [], ie = [], te = P != null ? [] : void 0;
            function ue() {
              P && d.gullet.macros.set("\\@eqnsw", "1", true);
            }
            function ce() {
              te && (d.gullet.macros.get("\\df@tag") ? (te.push(d.subparse([new on("\\df@tag")])), d.gullet.macros.set("\\df@tag", void 0, true)) : te.push(!!P && d.gullet.macros.get("\\@eqnsw") === "1"));
            }
            for (ue(), ie.push(sy(d)); ; ) {
              let $e = d.parseExpression(false, J ? "\\end" : "\\\\");
              d.gullet.endGroup(), d.gullet.beginGroup(), $e = {
                type: "ordgroup",
                mode: d.mode,
                body: $e
              }, f && ($e = {
                type: "styling",
                mode: d.mode,
                style: f,
                body: [$e]
              }), yt.push($e);
              const or = d.fetch().text;
              if (or === "&") {
                if (it && yt.length === it) {
                  if (J || D)
                    throw new s("Too many tab characters: &", d.nextToken);
                  d.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                }
                d.consume();
              } else if (or === "\\end") {
                ce(), yt.length === 1 && $e.type === "styling" && $e.body[0].body.length === 0 && (kt.length > 1 || !nt) && kt.pop(), ie.length < kt.length + 1 && ie.push([]);
                break;
              } else if (or === "\\\\") {
                d.consume();
                let vr;
                d.gullet.future().text !== " " && (vr = d.parseSizeGroup(true)), Yt.push(vr ? vr.value : null), ce(), ie.push(sy(d)), yt = [], kt.push(yt), ue();
              } else
                throw new s("Expected & or \\\\ or \\cr or \\end", d.nextToken);
            }
            return d.gullet.endGroup(), d.gullet.endGroup(), {
              type: "array",
              mode: d.mode,
              addJot: w,
              arraystretch: E,
              body: kt,
              cols: S,
              rowGaps: Yt,
              hskipBeforeAndAfter: b,
              hLinesBeforeRow: ie,
              colSeparationType: D,
              tags: te,
              leqno: lt
            };
          }
          function fd(d) {
            return d.slice(0, 1) === "d" ? "display" : "text";
          }
          const Dn = function(d, u) {
            let f, b;
            const w = d.body.length, S = d.hLinesBeforeRow;
            let E = 0, D = new Array(w);
            const P = [], J = Math.max(
              // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
              u.fontMetrics().arrayRuleWidth,
              u.minRuleThickness
              // User override.
            ), nt = 1 / u.fontMetrics().ptPerEm;
            let it = 5 * nt;
            d.colSeparationType && d.colSeparationType === "small" && (it = 0.2778 * (u.havingStyle(et.SCRIPT).sizeMultiplier / u.sizeMultiplier));
            const lt = d.colSeparationType === "CD" ? xe({
              number: 3,
              unit: "ex"
            }, u) : 12 * nt, yt = 3 * nt, kt = d.arraystretch * lt, Yt = 0.7 * kt, ie = 0.3 * kt;
            let te = 0;
            function ue(de) {
              for (let be = 0; be < de.length; ++be)
                be > 0 && (te += 0.25), P.push({
                  pos: te,
                  isDashed: de[be]
                });
            }
            for (ue(S[0]), f = 0; f < d.body.length; ++f) {
              const de = d.body[f];
              let be = Yt, Ee = ie;
              E < de.length && (E = de.length);
              const Be = new Array(de.length);
              for (b = 0; b < de.length; ++b) {
                const cn = le(de[b], u);
                Ee < cn.depth && (Ee = cn.depth), be < cn.height && (be = cn.height), Be[b] = cn;
              }
              const ze = d.rowGaps[f];
              let Ne = 0;
              ze && (Ne = xe(ze, u), Ne > 0 && (Ne += ie, Ee < Ne && (Ee = Ne), Ne = 0)), d.addJot && (Ee += yt), Be.height = be, Be.depth = Ee, te += be, Be.pos = te, te += Ee + Ne, D[f] = Be, ue(S[f + 1]);
            }
            const ce = te / 2 + u.fontMetrics().axisHeight, $e = d.cols || [], or = [];
            let vr, ln;
            const ga = [];
            if (d.tags && d.tags.some((de) => de))
              for (f = 0; f < w; ++f) {
                const de = D[f], be = de.pos - ce, Ee = d.tags[f];
                let Be;
                Ee === true ? Be = at.makeSpan(["eqn-num"], [], u) : Ee === false ? Be = at.makeSpan([], [], u) : Be = at.makeSpan([], Ve(Ee, u, true), u), Be.depth = de.depth, Be.height = de.height, ga.push({
                  type: "elem",
                  elem: Be,
                  shift: be
                });
              }
            for (
              b = 0, ln = 0;
              // Continue while either there are more columns or more column
              // descriptions, so trailing separators don't get lost.
              b < E || ln < $e.length;
              ++b, ++ln
            ) {
              let de = $e[ln] || {}, be = true;
              for (; de.type === "separator"; ) {
                if (be || (vr = at.makeSpan(["arraycolsep"], []), vr.style.width = bt(u.fontMetrics().doubleRuleSep), or.push(vr)), de.separator === "|" || de.separator === ":") {
                  const ze = de.separator === "|" ? "solid" : "dashed", Ne = at.makeSpan(["vertical-separator"], [], u);
                  Ne.style.height = bt(te), Ne.style.borderRightWidth = bt(J), Ne.style.borderRightStyle = ze, Ne.style.margin = "0 " + bt(-J / 2);
                  const cn = te - ce;
                  cn && (Ne.style.verticalAlign = bt(-cn)), or.push(Ne);
                } else
                  throw new s("Invalid separator type: " + de.separator);
                ln++, de = $e[ln] || {}, be = false;
              }
              if (b >= E)
                continue;
              let Ee;
              (b > 0 || d.hskipBeforeAndAfter) && (Ee = k.deflt(de.pregap, it), Ee !== 0 && (vr = at.makeSpan(["arraycolsep"], []), vr.style.width = bt(Ee), or.push(vr)));
              let Be = [];
              for (f = 0; f < w; ++f) {
                const ze = D[f], Ne = ze[b];
                if (!Ne)
                  continue;
                const cn = ze.pos - ce;
                Ne.depth = ze.depth, Ne.height = ze.height, Be.push({
                  type: "elem",
                  elem: Ne,
                  shift: cn
                });
              }
              Be = at.makeVList({
                positionType: "individualShift",
                children: Be
              }, u), Be = at.makeSpan(["col-align-" + (de.align || "c")], [Be]), or.push(Be), (b < E - 1 || d.hskipBeforeAndAfter) && (Ee = k.deflt(de.postgap, it), Ee !== 0 && (vr = at.makeSpan(["arraycolsep"], []), vr.style.width = bt(Ee), or.push(vr)));
            }
            if (D = at.makeSpan(["mtable"], or), P.length > 0) {
              const de = at.makeLineSpan("hline", u, J), be = at.makeLineSpan("hdashline", u, J), Ee = [{
                type: "elem",
                elem: D,
                shift: 0
              }];
              for (; P.length > 0; ) {
                const Be = P.pop(), ze = Be.pos - ce;
                Be.isDashed ? Ee.push({
                  type: "elem",
                  elem: be,
                  shift: ze
                }) : Ee.push({
                  type: "elem",
                  elem: de,
                  shift: ze
                });
              }
              D = at.makeVList({
                positionType: "individualShift",
                children: Ee
              }, u);
            }
            if (ga.length === 0)
              return at.makeSpan(["mord"], [D], u);
            {
              let de = at.makeVList({
                positionType: "individualShift",
                children: ga
              }, u);
              return de = at.makeSpan(["tag"], [de], u), at.makeFragment([D, de]);
            }
          }, RC = {
            c: "center ",
            l: "left ",
            r: "right "
          }, Fn = function(d, u) {
            const f = [], b = new ft.MathNode("mtd", [], ["mtr-glue"]), w = new ft.MathNode("mtd", [], ["mml-eqn-num"]);
            for (let it = 0; it < d.body.length; it++) {
              const lt = d.body[it], yt = [];
              for (let kt = 0; kt < lt.length; kt++)
                yt.push(new ft.MathNode("mtd", [ve(lt[kt], u)]));
              d.tags && d.tags[it] && (yt.unshift(b), yt.push(b), d.leqno ? yt.unshift(w) : yt.push(w)), f.push(new ft.MathNode("mtr", yt));
            }
            let S = new ft.MathNode("mtable", f);
            const E = d.arraystretch === 0.5 ? 0.1 : 0.16 + d.arraystretch - 1 + (d.addJot ? 0.09 : 0);
            S.setAttribute("rowspacing", bt(E));
            let D = "", P = "";
            if (d.cols && d.cols.length > 0) {
              const it = d.cols;
              let lt = "", yt = false, kt = 0, Yt = it.length;
              it[0].type === "separator" && (D += "top ", kt = 1), it[it.length - 1].type === "separator" && (D += "bottom ", Yt -= 1);
              for (let ie = kt; ie < Yt; ie++)
                it[ie].type === "align" ? (P += RC[it[ie].align], yt && (lt += "none "), yt = true) : it[ie].type === "separator" && yt && (lt += it[ie].separator === "|" ? "solid " : "dashed ", yt = false);
              S.setAttribute("columnalign", P.trim()), /[sd]/.test(lt) && S.setAttribute("columnlines", lt.trim());
            }
            if (d.colSeparationType === "align") {
              const it = d.cols || [];
              let lt = "";
              for (let yt = 1; yt < it.length; yt++)
                lt += yt % 2 ? "0em " : "1em ";
              S.setAttribute("columnspacing", lt.trim());
            } else d.colSeparationType === "alignat" || d.colSeparationType === "gather" ? S.setAttribute("columnspacing", "0em") : d.colSeparationType === "small" ? S.setAttribute("columnspacing", "0.2778em") : d.colSeparationType === "CD" ? S.setAttribute("columnspacing", "0.5em") : S.setAttribute("columnspacing", "1em");
            let J = "";
            const nt = d.hLinesBeforeRow;
            D += nt[0].length > 0 ? "left " : "", D += nt[nt.length - 1].length > 0 ? "right " : "";
            for (let it = 1; it < nt.length - 1; it++)
              J += nt[it].length === 0 ? "none " : nt[it][0] ? "dashed " : "solid ";
            return /[sd]/.test(J) && S.setAttribute("rowlines", J.trim()), D !== "" && (S = new ft.MathNode("menclose", [S]), S.setAttribute("notation", D.trim())), d.arraystretch && d.arraystretch < 1 && (S = new ft.MathNode("mstyle", [S]), S.setAttribute("scriptlevel", "1")), S;
          }, ay = function(d, u) {
            d.envName.indexOf("ed") === -1 && Oc(d);
            const f = [], b = d.envName.indexOf("at") > -1 ? "alignat" : "align", w = d.envName === "split", S = zi(d.parser, {
              cols: f,
              addJot: true,
              autoTag: w ? void 0 : pd(d.envName),
              emptySingleRow: true,
              colSeparationType: b,
              maxNumCols: w ? 2 : void 0,
              leqno: d.parser.settings.leqno
            }, "display");
            let E, D = 0;
            const P = {
              type: "ordgroup",
              mode: d.mode,
              body: []
            };
            if (u[0] && u[0].type === "ordgroup") {
              let nt = "";
              for (let it = 0; it < u[0].body.length; it++) {
                const lt = Zt(u[0].body[it], "textord");
                nt += lt.text;
              }
              E = Number(nt), D = E * 2;
            }
            const J = !D;
            S.body.forEach(function(nt) {
              for (let it = 1; it < nt.length; it += 2) {
                const lt = Zt(nt[it], "styling");
                Zt(lt.body[0], "ordgroup").body.unshift(P);
              }
              if (J)
                D < nt.length && (D = nt.length);
              else {
                const it = nt.length / 2;
                if (E < it)
                  throw new s("Too many math in a row: " + ("expected " + E + ", but got " + it), nt[0]);
              }
            });
            for (let nt = 0; nt < D; ++nt) {
              let it = "r", lt = 0;
              nt % 2 === 1 ? it = "l" : nt > 0 && J && (lt = 1), f[nt] = {
                type: "align",
                align: it,
                pregap: lt,
                postgap: 0
              };
            }
            return S.colSeparationType = J ? "align" : "alignat", S;
          };
          Ln({
            type: "array",
            names: ["array", "darray"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              const f = (Lc(u[0]) ? [u[0]] : Zt(u[0], "ordgroup").body).map(function(w) {
                const S = ed(w).text;
                if ("lcr".indexOf(S) !== -1)
                  return {
                    type: "align",
                    align: S
                  };
                if (S === "|")
                  return {
                    type: "separator",
                    separator: "|"
                  };
                if (S === ":")
                  return {
                    type: "separator",
                    separator: ":"
                  };
                throw new s("Unknown column alignment: " + S, w);
              }), b = {
                cols: f,
                hskipBeforeAndAfter: true,
                // \@preamble in lttab.dtx
                maxNumCols: f.length
              };
              return zi(d.parser, b, fd(d.envName));
            },
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
            props: {
              numArgs: 0
            },
            handler(d) {
              const u = {
                matrix: null,
                pmatrix: ["(", ")"],
                bmatrix: ["[", "]"],
                Bmatrix: ["\\{", "\\}"],
                vmatrix: ["|", "|"],
                Vmatrix: ["\\Vert", "\\Vert"]
              }[d.envName.replace("*", "")];
              let f = "c";
              const b = {
                hskipBeforeAndAfter: false,
                cols: [{
                  type: "align",
                  align: f
                }]
              };
              if (d.envName.charAt(d.envName.length - 1) === "*") {
                const E = d.parser;
                if (E.consumeSpaces(), E.fetch().text === "[") {
                  if (E.consume(), E.consumeSpaces(), f = E.fetch().text, "lcr".indexOf(f) === -1)
                    throw new s("Expected l or c or r", E.nextToken);
                  E.consume(), E.consumeSpaces(), E.expect("]"), E.consume(), b.cols = [{
                    type: "align",
                    align: f
                  }];
                }
              }
              const w = zi(d.parser, b, fd(d.envName)), S = Math.max(0, ...w.body.map((E) => E.length));
              return w.cols = new Array(S).fill({
                type: "align",
                align: f
              }), u ? {
                type: "leftright",
                mode: d.mode,
                body: [w],
                left: u[0],
                right: u[1],
                rightColor: void 0
                // \right uninfluenced by \color in array
              } : w;
            },
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["smallmatrix"],
            props: {
              numArgs: 0
            },
            handler(d) {
              const u = {
                arraystretch: 0.5
              }, f = zi(d.parser, u, "script");
              return f.colSeparationType = "small", f;
            },
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["subarray"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              const f = (Lc(u[0]) ? [u[0]] : Zt(u[0], "ordgroup").body).map(function(w) {
                const S = ed(w).text;
                if ("lc".indexOf(S) !== -1)
                  return {
                    type: "align",
                    align: S
                  };
                throw new s("Unknown column alignment: " + S, w);
              });
              if (f.length > 1)
                throw new s("{subarray} can contain only one column");
              let b = {
                cols: f,
                hskipBeforeAndAfter: false,
                arraystretch: 0.5
              };
              if (b = zi(d.parser, b, "script"), b.body.length > 0 && b.body[0].length > 1)
                throw new s("{subarray} can contain only one column");
              return b;
            },
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["cases", "dcases", "rcases", "drcases"],
            props: {
              numArgs: 0
            },
            handler(d) {
              const u = {
                arraystretch: 1.2,
                cols: [{
                  type: "align",
                  align: "l",
                  pregap: 0,
                  // TODO(kevinb) get the current style.
                  // For now we use the metrics for TEXT style which is what we were
                  // doing before.  Before attempting to get the current style we
                  // should look at TeX's behavior especially for \over and matrices.
                  postgap: 1
                  /* 1em quad */
                }, {
                  type: "align",
                  align: "l",
                  pregap: 0,
                  postgap: 0
                }]
              }, f = zi(d.parser, u, fd(d.envName));
              return {
                type: "leftright",
                mode: d.mode,
                body: [f],
                left: d.envName.indexOf("r") > -1 ? "." : "\\{",
                right: d.envName.indexOf("r") > -1 ? "\\}" : ".",
                rightColor: void 0
              };
            },
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["align", "align*", "aligned", "split"],
            props: {
              numArgs: 0
            },
            handler: ay,
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["gathered", "gather", "gather*"],
            props: {
              numArgs: 0
            },
            handler(d) {
              k.contains(["gather", "gather*"], d.envName) && Oc(d);
              const u = {
                cols: [{
                  type: "align",
                  align: "c"
                }],
                addJot: true,
                colSeparationType: "gather",
                autoTag: pd(d.envName),
                emptySingleRow: true,
                leqno: d.parser.settings.leqno
              };
              return zi(d.parser, u, "display");
            },
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["alignat", "alignat*", "alignedat"],
            props: {
              numArgs: 1
            },
            handler: ay,
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["equation", "equation*"],
            props: {
              numArgs: 0
            },
            handler(d) {
              Oc(d);
              const u = {
                autoTag: pd(d.envName),
                emptySingleRow: true,
                singleRow: true,
                maxNumCols: 1,
                leqno: d.parser.settings.leqno
              };
              return zi(d.parser, u, "display");
            },
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), Ln({
            type: "array",
            names: ["CD"],
            props: {
              numArgs: 0
            },
            handler(d) {
              return Oc(d), TC(d.parser);
            },
            htmlBuilder: Dn,
            mathmlBuilder: Fn
          }), N("\\nonumber", "\\gdef\\@eqnsw{0}"), N("\\notag", "\\nonumber"), _t({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\hline", "\\hdashline"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: true
            },
            handler(d, u) {
              throw new s(d.funcName + " valid only within array environment");
            }
          });
          var oy = ny;
          _t({
            type: "environment",
            names: ["\\begin", "\\end"],
            props: {
              numArgs: 1,
              argTypes: ["text"]
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              if (w.type !== "ordgroup")
                throw new s("Invalid environment name", w);
              let S = "";
              for (let E = 0; E < w.body.length; ++E)
                S += Zt(w.body[E], "textord").text;
              if (b === "\\begin") {
                if (!oy.hasOwnProperty(S))
                  throw new s("No such environment: " + S, w);
                const E = oy[S], {
                  args: D,
                  optArgs: P
                } = f.parseArguments("\\begin{" + S + "}", E), J = {
                  mode: f.mode,
                  envName: S,
                  parser: f
                }, nt = E.handler(J, D, P);
                f.expect("\\end", false);
                const it = f.nextToken, lt = Zt(f.parseFunction(), "environment");
                if (lt.name !== S)
                  throw new s("Mismatch: \\begin{" + S + "} matched by \\end{" + lt.name + "}", it);
                return nt;
              }
              return {
                type: "environment",
                mode: f.mode,
                name: S,
                nameGroup: w
              };
            }
          });
          const ly = (d, u) => {
            const f = d.font, b = u.withFont(f);
            return le(d.body, b);
          }, cy = (d, u) => {
            const f = d.font, b = u.withFont(f);
            return ve(d.body, b);
          }, hy = {
            "\\Bbb": "\\mathbb",
            "\\bold": "\\mathbf",
            "\\frak": "\\mathfrak",
            "\\bm": "\\boldsymbol"
          };
          _t({
            type: "font",
            names: [
              // styles, except \boldsymbol defined below
              "\\mathrm",
              "\\mathit",
              "\\mathbf",
              "\\mathnormal",
              "\\mathsfit",
              // families
              "\\mathbb",
              "\\mathcal",
              "\\mathfrak",
              "\\mathscr",
              "\\mathsf",
              "\\mathtt",
              // aliases, except \bm defined below
              "\\Bbb",
              "\\bold",
              "\\frak"
            ],
            props: {
              numArgs: 1,
              allowedInArgument: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = Mc(u[0]);
              let S = b;
              return S in hy && (S = hy[S]), {
                type: "font",
                mode: f.mode,
                font: S.slice(1),
                body: w
              };
            },
            htmlBuilder: ly,
            mathmlBuilder: cy
          }), _t({
            type: "mclass",
            names: ["\\boldsymbol", "\\bm"],
            props: {
              numArgs: 1
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0], w = k.isCharacterBox(b);
              return {
                type: "mclass",
                mode: f.mode,
                mclass: Fc(b),
                body: [{
                  type: "font",
                  mode: f.mode,
                  font: "boldsymbol",
                  body: b
                }],
                isCharacterBox: w
              };
            }
          }), _t({
            type: "font",
            names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b,
                breakOnTokenText: w
              } = d;
              const {
                mode: S
              } = f, E = f.parseExpression(true, w), D = "math" + b.slice(1);
              return {
                type: "font",
                mode: S,
                font: D,
                body: {
                  type: "ordgroup",
                  mode: f.mode,
                  body: E
                }
              };
            },
            htmlBuilder: ly,
            mathmlBuilder: cy
          });
          const uy = (d, u) => {
            let f = u;
            return d === "display" ? f = f.id >= et.SCRIPT.id ? f.text() : et.DISPLAY : d === "text" && f.size === et.DISPLAY.size ? f = et.TEXT : d === "script" ? f = et.SCRIPT : d === "scriptscript" && (f = et.SCRIPTSCRIPT), f;
          }, md = (d, u) => {
            const f = uy(d.size, u.style), b = f.fracNum(), w = f.fracDen();
            let S;
            S = u.havingStyle(b);
            const E = le(d.numer, S, u);
            if (d.continued) {
              const ue = 8.5 / u.fontMetrics().ptPerEm, ce = 3.5 / u.fontMetrics().ptPerEm;
              E.height = E.height < ue ? ue : E.height, E.depth = E.depth < ce ? ce : E.depth;
            }
            S = u.havingStyle(w);
            const D = le(d.denom, S, u);
            let P, J, nt;
            d.hasBarLine ? (d.barSize ? (J = xe(d.barSize, u), P = at.makeLineSpan("frac-line", u, J)) : P = at.makeLineSpan("frac-line", u), J = P.height, nt = P.height) : (P = null, J = 0, nt = u.fontMetrics().defaultRuleThickness);
            let it, lt, yt;
            f.size === et.DISPLAY.size || d.size === "display" ? (it = u.fontMetrics().num1, J > 0 ? lt = 3 * nt : lt = 7 * nt, yt = u.fontMetrics().denom1) : (J > 0 ? (it = u.fontMetrics().num2, lt = nt) : (it = u.fontMetrics().num3, lt = 3 * nt), yt = u.fontMetrics().denom2);
            let kt;
            if (P) {
              const ue = u.fontMetrics().axisHeight;
              it - E.depth - (ue + 0.5 * J) < lt && (it += lt - (it - E.depth - (ue + 0.5 * J))), ue - 0.5 * J - (D.height - yt) < lt && (yt += lt - (ue - 0.5 * J - (D.height - yt)));
              const ce = -(ue - 0.5 * J);
              kt = at.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: D,
                  shift: yt
                }, {
                  type: "elem",
                  elem: P,
                  shift: ce
                }, {
                  type: "elem",
                  elem: E,
                  shift: -it
                }]
              }, u);
            } else {
              const ue = it - E.depth - (D.height - yt);
              ue < lt && (it += 0.5 * (lt - ue), yt += 0.5 * (lt - ue)), kt = at.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: D,
                  shift: yt
                }, {
                  type: "elem",
                  elem: E,
                  shift: -it
                }]
              }, u);
            }
            S = u.havingStyle(f), kt.height *= S.sizeMultiplier / u.sizeMultiplier, kt.depth *= S.sizeMultiplier / u.sizeMultiplier;
            let Yt;
            f.size === et.DISPLAY.size ? Yt = u.fontMetrics().delim1 : f.size === et.SCRIPTSCRIPT.size ? Yt = u.havingStyle(et.SCRIPT).fontMetrics().delim2 : Yt = u.fontMetrics().delim2;
            let ie, te;
            return d.leftDelim == null ? ie = $o(u, ["mopen"]) : ie = hi.customSizedDelim(d.leftDelim, Yt, true, u.havingStyle(f), d.mode, ["mopen"]), d.continued ? te = at.makeSpan([]) : d.rightDelim == null ? te = $o(u, ["mclose"]) : te = hi.customSizedDelim(d.rightDelim, Yt, true, u.havingStyle(f), d.mode, ["mclose"]), at.makeSpan(["mord"].concat(S.sizingClasses(u)), [ie, at.makeSpan(["mfrac"], [kt]), te], u);
          }, gd = (d, u) => {
            let f = new ft.MathNode("mfrac", [ve(d.numer, u), ve(d.denom, u)]);
            if (!d.hasBarLine)
              f.setAttribute("linethickness", "0px");
            else if (d.barSize) {
              const w = xe(d.barSize, u);
              f.setAttribute("linethickness", bt(w));
            }
            const b = uy(d.size, u.style);
            if (b.size !== u.style.size) {
              f = new ft.MathNode("mstyle", [f]);
              const w = b.size === et.DISPLAY.size ? "true" : "false";
              f.setAttribute("displaystyle", w), f.setAttribute("scriptlevel", "0");
            }
            if (d.leftDelim != null || d.rightDelim != null) {
              const w = [];
              if (d.leftDelim != null) {
                const S = new ft.MathNode("mo", [new ft.TextNode(d.leftDelim.replace("\\", ""))]);
                S.setAttribute("fence", "true"), w.push(S);
              }
              if (w.push(f), d.rightDelim != null) {
                const S = new ft.MathNode("mo", [new ft.TextNode(d.rightDelim.replace("\\", ""))]);
                S.setAttribute("fence", "true"), w.push(S);
              }
              return Ju(w);
            }
            return f;
          };
          _t({
            type: "genfrac",
            names: [
              "\\dfrac",
              "\\frac",
              "\\tfrac",
              "\\dbinom",
              "\\binom",
              "\\tbinom",
              "\\\\atopfrac",
              // can’t be entered directly
              "\\\\bracefrac",
              "\\\\brackfrac"
              // ditto
            ],
            props: {
              numArgs: 2,
              allowedInArgument: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0], S = u[1];
              let E, D = null, P = null, J = "auto";
              switch (b) {
                case "\\dfrac":
                case "\\frac":
                case "\\tfrac":
                  E = true;
                  break;
                case "\\\\atopfrac":
                  E = false;
                  break;
                case "\\dbinom":
                case "\\binom":
                case "\\tbinom":
                  E = false, D = "(", P = ")";
                  break;
                case "\\\\bracefrac":
                  E = false, D = "\\{", P = "\\}";
                  break;
                case "\\\\brackfrac":
                  E = false, D = "[", P = "]";
                  break;
                default:
                  throw new Error("Unrecognized genfrac command");
              }
              switch (b) {
                case "\\dfrac":
                case "\\dbinom":
                  J = "display";
                  break;
                case "\\tfrac":
                case "\\tbinom":
                  J = "text";
                  break;
              }
              return {
                type: "genfrac",
                mode: f.mode,
                continued: false,
                numer: w,
                denom: S,
                hasBarLine: E,
                leftDelim: D,
                rightDelim: P,
                size: J,
                barSize: null
              };
            },
            htmlBuilder: md,
            mathmlBuilder: gd
          }), _t({
            type: "genfrac",
            names: ["\\cfrac"],
            props: {
              numArgs: 2
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0], S = u[1];
              return {
                type: "genfrac",
                mode: f.mode,
                continued: true,
                numer: w,
                denom: S,
                hasBarLine: true,
                leftDelim: null,
                rightDelim: null,
                size: "display",
                barSize: null
              };
            }
          }), _t({
            type: "infix",
            names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
            props: {
              numArgs: 0,
              infix: true
            },
            handler(d) {
              let {
                parser: u,
                funcName: f,
                token: b
              } = d, w;
              switch (f) {
                case "\\over":
                  w = "\\frac";
                  break;
                case "\\choose":
                  w = "\\binom";
                  break;
                case "\\atop":
                  w = "\\\\atopfrac";
                  break;
                case "\\brace":
                  w = "\\\\bracefrac";
                  break;
                case "\\brack":
                  w = "\\\\brackfrac";
                  break;
                default:
                  throw new Error("Unrecognized infix genfrac command");
              }
              return {
                type: "infix",
                mode: u.mode,
                replaceWith: w,
                token: b
              };
            }
          });
          const dy = ["display", "text", "script", "scriptscript"], py = function(d) {
            let u = null;
            return d.length > 0 && (u = d, u = u === "." ? null : u), u;
          };
          _t({
            type: "genfrac",
            names: ["\\genfrac"],
            props: {
              numArgs: 6,
              allowedInArgument: true,
              argTypes: ["math", "math", "size", "text", "math", "math"]
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = u[4], w = u[5], S = Mc(u[0]), E = S.type === "atom" && S.family === "open" ? py(S.text) : null, D = Mc(u[1]), P = D.type === "atom" && D.family === "close" ? py(D.text) : null, J = Zt(u[2], "size");
              let nt, it = null;
              J.isBlank ? nt = true : (it = J.value, nt = it.number > 0);
              let lt = "auto", yt = u[3];
              if (yt.type === "ordgroup") {
                if (yt.body.length > 0) {
                  const kt = Zt(yt.body[0], "textord");
                  lt = dy[Number(kt.text)];
                }
              } else
                yt = Zt(yt, "textord"), lt = dy[Number(yt.text)];
              return {
                type: "genfrac",
                mode: f.mode,
                numer: b,
                denom: w,
                continued: false,
                hasBarLine: nt,
                barSize: it,
                leftDelim: E,
                rightDelim: P,
                size: lt
              };
            },
            htmlBuilder: md,
            mathmlBuilder: gd
          }), _t({
            type: "infix",
            names: ["\\above"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              infix: true
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b,
                token: w
              } = d;
              return {
                type: "infix",
                mode: f.mode,
                replaceWith: "\\\\abovefrac",
                size: Zt(u[0], "size").value,
                token: w
              };
            }
          }), _t({
            type: "genfrac",
            names: ["\\\\abovefrac"],
            props: {
              numArgs: 3,
              argTypes: ["math", "size", "math"]
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0], S = x(Zt(u[1], "infix").size), E = u[2], D = S.number > 0;
              return {
                type: "genfrac",
                mode: f.mode,
                numer: w,
                denom: E,
                continued: false,
                hasBarLine: D,
                barSize: S,
                leftDelim: null,
                rightDelim: null,
                size: "auto"
              };
            },
            htmlBuilder: md,
            mathmlBuilder: gd
          });
          const fy = (d, u) => {
            const f = u.style;
            let b, w;
            d.type === "supsub" ? (b = d.sup ? le(d.sup, u.havingStyle(f.sup()), u) : le(d.sub, u.havingStyle(f.sub()), u), w = Zt(d.base, "horizBrace")) : w = Zt(d, "horizBrace");
            const S = le(w.base, u.havingBaseStyle(et.DISPLAY)), E = ci.svgSpan(w, u);
            let D;
            if (w.isOver ? (D = at.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: S
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: E
              }]
            }, u), D.children[0].children[0].children[1].classes.push("svg-align")) : (D = at.makeVList({
              positionType: "bottom",
              positionData: S.depth + 0.1 + E.height,
              children: [{
                type: "elem",
                elem: E
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: S
              }]
            }, u), D.children[0].children[0].children[0].classes.push("svg-align")), b) {
              const P = at.makeSpan(["mord", w.isOver ? "mover" : "munder"], [D], u);
              w.isOver ? D = at.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: P
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: b
                }]
              }, u) : D = at.makeVList({
                positionType: "bottom",
                positionData: P.depth + 0.2 + b.height + b.depth,
                children: [{
                  type: "elem",
                  elem: b
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: P
                }]
              }, u);
            }
            return at.makeSpan(["mord", w.isOver ? "mover" : "munder"], [D], u);
          };
          _t({
            type: "horizBrace",
            names: ["\\overbrace", "\\underbrace"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              return {
                type: "horizBrace",
                mode: f.mode,
                label: b,
                isOver: /^\\over/.test(b),
                base: u[0]
              };
            },
            htmlBuilder: fy,
            mathmlBuilder: (d, u) => {
              const f = ci.mathMLnode(d.label);
              return new ft.MathNode(d.isOver ? "mover" : "munder", [ve(d.base, u), f]);
            }
          }), _t({
            type: "href",
            names: ["\\href"],
            props: {
              numArgs: 2,
              argTypes: ["url", "original"],
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[1], w = Zt(u[0], "url").url;
              return f.settings.isTrusted({
                command: "\\href",
                url: w
              }) ? {
                type: "href",
                mode: f.mode,
                href: w,
                body: qe(b)
              } : f.formatUnsupportedCmd("\\href");
            },
            htmlBuilder: (d, u) => {
              const f = Ve(d.body, u, false);
              return at.makeAnchor(d.href, [], f, u);
            },
            mathmlBuilder: (d, u) => {
              let f = Oi(d.body, u);
              return f instanceof Vr || (f = new Vr("mrow", [f])), f.setAttribute("href", d.href), f;
            }
          }), _t({
            type: "href",
            names: ["\\url"],
            props: {
              numArgs: 1,
              argTypes: ["url"],
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = Zt(u[0], "url").url;
              if (!f.settings.isTrusted({
                command: "\\url",
                url: b
              }))
                return f.formatUnsupportedCmd("\\url");
              const w = [];
              for (let E = 0; E < b.length; E++) {
                let D = b[E];
                D === "~" && (D = "\\textasciitilde"), w.push({
                  type: "textord",
                  mode: "text",
                  text: D
                });
              }
              const S = {
                type: "text",
                mode: f.mode,
                font: "\\texttt",
                body: w
              };
              return {
                type: "href",
                mode: f.mode,
                href: b,
                body: qe(S)
              };
            }
          }), _t({
            type: "hbox",
            names: ["\\hbox"],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInText: true,
              primitive: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "hbox",
                mode: f.mode,
                body: qe(u[0])
              };
            },
            htmlBuilder(d, u) {
              const f = Ve(d.body, u, false);
              return at.makeFragment(f);
            },
            mathmlBuilder(d, u) {
              return new ft.MathNode("mrow", Dr(d.body, u));
            }
          }), _t({
            type: "html",
            names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
            props: {
              numArgs: 2,
              argTypes: ["raw", "original"],
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b,
                token: w
              } = d;
              const S = Zt(u[0], "raw").string, E = u[1];
              f.settings.strict && f.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
              let D;
              const P = {};
              switch (b) {
                case "\\htmlClass":
                  P.class = S, D = {
                    command: "\\htmlClass",
                    class: S
                  };
                  break;
                case "\\htmlId":
                  P.id = S, D = {
                    command: "\\htmlId",
                    id: S
                  };
                  break;
                case "\\htmlStyle":
                  P.style = S, D = {
                    command: "\\htmlStyle",
                    style: S
                  };
                  break;
                case "\\htmlData": {
                  const J = S.split(",");
                  for (let nt = 0; nt < J.length; nt++) {
                    const it = J[nt].split("=");
                    if (it.length !== 2)
                      throw new s("Error parsing key-value for \\htmlData");
                    P["data-" + it[0].trim()] = it[1].trim();
                  }
                  D = {
                    command: "\\htmlData",
                    attributes: P
                  };
                  break;
                }
                default:
                  throw new Error("Unrecognized html command");
              }
              return f.settings.isTrusted(D) ? {
                type: "html",
                mode: f.mode,
                attributes: P,
                body: qe(E)
              } : f.formatUnsupportedCmd(b);
            },
            htmlBuilder: (d, u) => {
              const f = Ve(d.body, u, false), b = ["enclosing"];
              d.attributes.class && b.push(...d.attributes.class.trim().split(/\s+/));
              const w = at.makeSpan(b, f, u);
              for (const S in d.attributes)
                S !== "class" && d.attributes.hasOwnProperty(S) && w.setAttribute(S, d.attributes[S]);
              return w;
            },
            mathmlBuilder: (d, u) => Oi(d.body, u)
          }), _t({
            type: "htmlmathml",
            names: ["\\html@mathml"],
            props: {
              numArgs: 2,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              return {
                type: "htmlmathml",
                mode: f.mode,
                html: qe(u[0]),
                mathml: qe(u[1])
              };
            },
            htmlBuilder: (d, u) => {
              const f = Ve(d.html, u, false);
              return at.makeFragment(f);
            },
            mathmlBuilder: (d, u) => Oi(d.mathml, u)
          });
          const yd = function(d) {
            if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(d))
              return {
                number: +d,
                unit: "bp"
              };
            {
              const u = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(d);
              if (!u)
                throw new s("Invalid size: '" + d + "' in \\includegraphics");
              const f = {
                number: +(u[1] + u[2]),
                // sign + magnitude, cast to number
                unit: u[3]
              };
              if (!bs(f))
                throw new s("Invalid unit: '" + f.unit + "' in \\includegraphics.");
              return f;
            }
          };
          _t({
            type: "includegraphics",
            names: ["\\includegraphics"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              argTypes: ["raw", "url"],
              allowedInText: false
            },
            handler: (d, u, f) => {
              let {
                parser: b
              } = d, w = {
                number: 0,
                unit: "em"
              }, S = {
                number: 0.9,
                unit: "em"
              }, E = {
                number: 0,
                unit: "em"
              }, D = "";
              if (f[0]) {
                const J = Zt(f[0], "raw").string.split(",");
                for (let nt = 0; nt < J.length; nt++) {
                  const it = J[nt].split("=");
                  if (it.length === 2) {
                    const lt = it[1].trim();
                    switch (it[0].trim()) {
                      case "alt":
                        D = lt;
                        break;
                      case "width":
                        w = yd(lt);
                        break;
                      case "height":
                        S = yd(lt);
                        break;
                      case "totalheight":
                        E = yd(lt);
                        break;
                      default:
                        throw new s("Invalid key: '" + it[0] + "' in \\includegraphics.");
                    }
                  }
                }
              }
              const P = Zt(u[0], "url").url;
              return D === "" && (D = P, D = D.replace(/^.*[\\/]/, ""), D = D.substring(0, D.lastIndexOf("."))), b.settings.isTrusted({
                command: "\\includegraphics",
                url: P
              }) ? {
                type: "includegraphics",
                mode: b.mode,
                alt: D,
                width: w,
                height: S,
                totalheight: E,
                src: P
              } : b.formatUnsupportedCmd("\\includegraphics");
            },
            htmlBuilder: (d, u) => {
              const f = xe(d.height, u);
              let b = 0;
              d.totalheight.number > 0 && (b = xe(d.totalheight, u) - f);
              let w = 0;
              d.width.number > 0 && (w = xe(d.width, u));
              const S = {
                height: bt(f + b)
              };
              w > 0 && (S.width = bt(w)), b > 0 && (S.verticalAlign = bt(-b));
              const E = new ws(d.src, d.alt, S);
              return E.height = f, E.depth = b, E;
            },
            mathmlBuilder: (d, u) => {
              const f = new ft.MathNode("mglyph", []);
              f.setAttribute("alt", d.alt);
              const b = xe(d.height, u);
              let w = 0;
              if (d.totalheight.number > 0 && (w = xe(d.totalheight, u) - b, f.setAttribute("valign", bt(-w))), f.setAttribute("height", bt(b + w)), d.width.number > 0) {
                const S = xe(d.width, u);
                f.setAttribute("width", bt(S));
              }
              return f.setAttribute("src", d.src), f;
            }
          }), _t({
            type: "kern",
            names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              primitive: true,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = Zt(u[0], "size");
              if (f.settings.strict) {
                const S = b[1] === "m", E = w.value.unit === "mu";
                S ? (E || f.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + b + " supports only mu units, " + ("not " + w.value.unit + " units")), f.mode !== "math" && f.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + b + " works only in math mode")) : E && f.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + b + " doesn't support mu units");
              }
              return {
                type: "kern",
                mode: f.mode,
                dimension: w.value
              };
            },
            htmlBuilder(d, u) {
              return at.makeGlue(d.dimension, u);
            },
            mathmlBuilder(d, u) {
              const f = xe(d.dimension, u);
              return new ft.SpaceNode(f);
            }
          }), _t({
            type: "lap",
            names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "lap",
                mode: f.mode,
                alignment: b.slice(5),
                body: w
              };
            },
            htmlBuilder: (d, u) => {
              let f;
              d.alignment === "clap" ? (f = at.makeSpan([], [le(d.body, u)]), f = at.makeSpan(["inner"], [f], u)) : f = at.makeSpan(["inner"], [le(d.body, u)]);
              const b = at.makeSpan(["fix"], []);
              let w = at.makeSpan([d.alignment], [f, b], u);
              const S = at.makeSpan(["strut"]);
              return S.style.height = bt(w.height + w.depth), w.depth && (S.style.verticalAlign = bt(-w.depth)), w.children.unshift(S), w = at.makeSpan(["thinbox"], [w], u), at.makeSpan(["mord", "vbox"], [w], u);
            },
            mathmlBuilder: (d, u) => {
              const f = new ft.MathNode("mpadded", [ve(d.body, u)]);
              if (d.alignment !== "rlap") {
                const b = d.alignment === "llap" ? "-1" : "-0.5";
                f.setAttribute("lspace", b + "width");
              }
              return f.setAttribute("width", "0px"), f;
            }
          }), _t({
            type: "styling",
            names: ["\\(", "$"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(d, u) {
              let {
                funcName: f,
                parser: b
              } = d;
              const w = b.mode;
              b.switchMode("math");
              const S = f === "\\(" ? "\\)" : "$", E = b.parseExpression(false, S);
              return b.expect(S), b.switchMode(w), {
                type: "styling",
                mode: b.mode,
                style: "text",
                body: E
              };
            }
          }), _t({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\)", "\\]"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(d, u) {
              throw new s("Mismatched " + d.funcName);
            }
          });
          const my = (d, u) => {
            switch (u.style.size) {
              case et.DISPLAY.size:
                return d.display;
              case et.TEXT.size:
                return d.text;
              case et.SCRIPT.size:
                return d.script;
              case et.SCRIPTSCRIPT.size:
                return d.scriptscript;
              default:
                return d.text;
            }
          };
          _t({
            type: "mathchoice",
            names: ["\\mathchoice"],
            props: {
              numArgs: 4,
              primitive: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              return {
                type: "mathchoice",
                mode: f.mode,
                display: qe(u[0]),
                text: qe(u[1]),
                script: qe(u[2]),
                scriptscript: qe(u[3])
              };
            },
            htmlBuilder: (d, u) => {
              const f = my(d, u), b = Ve(f, u, false);
              return at.makeFragment(b);
            },
            mathmlBuilder: (d, u) => {
              const f = my(d, u);
              return Oi(f, u);
            }
          });
          const gy = (d, u, f, b, w, S, E) => {
            d = at.makeSpan([], [d]);
            const D = f && k.isCharacterBox(f);
            let P, J;
            if (u) {
              const lt = le(u, b.havingStyle(w.sup()), b);
              J = {
                elem: lt,
                kern: Math.max(b.fontMetrics().bigOpSpacing1, b.fontMetrics().bigOpSpacing3 - lt.depth)
              };
            }
            if (f) {
              const lt = le(f, b.havingStyle(w.sub()), b);
              P = {
                elem: lt,
                kern: Math.max(b.fontMetrics().bigOpSpacing2, b.fontMetrics().bigOpSpacing4 - lt.height)
              };
            }
            let nt;
            if (J && P) {
              const lt = b.fontMetrics().bigOpSpacing5 + P.elem.height + P.elem.depth + P.kern + d.depth + E;
              nt = at.makeVList({
                positionType: "bottom",
                positionData: lt,
                children: [{
                  type: "kern",
                  size: b.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: P.elem,
                  marginLeft: bt(-S)
                }, {
                  type: "kern",
                  size: P.kern
                }, {
                  type: "elem",
                  elem: d
                }, {
                  type: "kern",
                  size: J.kern
                }, {
                  type: "elem",
                  elem: J.elem,
                  marginLeft: bt(S)
                }, {
                  type: "kern",
                  size: b.fontMetrics().bigOpSpacing5
                }]
              }, b);
            } else if (P) {
              const lt = d.height - E;
              nt = at.makeVList({
                positionType: "top",
                positionData: lt,
                children: [{
                  type: "kern",
                  size: b.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: P.elem,
                  marginLeft: bt(-S)
                }, {
                  type: "kern",
                  size: P.kern
                }, {
                  type: "elem",
                  elem: d
                }]
              }, b);
            } else if (J) {
              const lt = d.depth + E;
              nt = at.makeVList({
                positionType: "bottom",
                positionData: lt,
                children: [{
                  type: "elem",
                  elem: d
                }, {
                  type: "kern",
                  size: J.kern
                }, {
                  type: "elem",
                  elem: J.elem,
                  marginLeft: bt(S)
                }, {
                  type: "kern",
                  size: b.fontMetrics().bigOpSpacing5
                }]
              }, b);
            } else
              return d;
            const it = [nt];
            if (P && S !== 0 && !D) {
              const lt = at.makeSpan(["mspace"], [], b);
              lt.style.marginRight = bt(S), it.unshift(lt);
            }
            return at.makeSpan(["mop", "op-limits"], it, b);
          }, yy = ["\\smallint"], ma = (d, u) => {
            let f, b, w = false, S;
            d.type === "supsub" ? (f = d.sup, b = d.sub, S = Zt(d.base, "op"), w = true) : S = Zt(d, "op");
            const E = u.style;
            let D = false;
            E.size === et.DISPLAY.size && S.symbol && !k.contains(yy, S.name) && (D = true);
            let P;
            if (S.symbol) {
              const it = D ? "Size2-Regular" : "Size1-Regular";
              let lt = "";
              if ((S.name === "\\oiint" || S.name === "\\oiiint") && (lt = S.name.slice(1), S.name = lt === "oiint" ? "\\iint" : "\\iiint"), P = at.makeSymbol(S.name, it, "math", u, ["mop", "op-symbol", D ? "large-op" : "small-op"]), lt.length > 0) {
                const yt = P.italic, kt = at.staticSvg(lt + "Size" + (D ? "2" : "1"), u);
                P = at.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: P,
                    shift: 0
                  }, {
                    type: "elem",
                    elem: kt,
                    shift: D ? 0.08 : 0
                  }]
                }, u), S.name = "\\" + lt, P.classes.unshift("mop"), P.italic = yt;
              }
            } else if (S.body) {
              const it = Ve(S.body, u, true);
              it.length === 1 && it[0] instanceof Mr ? (P = it[0], P.classes[0] = "mop") : P = at.makeSpan(["mop"], it, u);
            } else {
              const it = [];
              for (let lt = 1; lt < S.name.length; lt++)
                it.push(at.mathsym(S.name[lt], S.mode, u));
              P = at.makeSpan(["mop"], it, u);
            }
            let J = 0, nt = 0;
            return (P instanceof Mr || S.name === "\\oiint" || S.name === "\\oiiint") && !S.suppressBaseShift && (J = (P.height - P.depth) / 2 - u.fontMetrics().axisHeight, nt = P.italic), w ? gy(P, f, b, u, E, nt, J) : (J && (P.style.position = "relative", P.style.top = bt(J)), P);
          }, Bo = (d, u) => {
            let f;
            if (d.symbol)
              f = new Vr("mo", [an(d.name, d.mode)]), k.contains(yy, d.name) && f.setAttribute("largeop", "false");
            else if (d.body)
              f = new Vr("mo", Dr(d.body, u));
            else {
              f = new Vr("mi", [new Bn(d.name.slice(1))]);
              const b = new Vr("mo", [an("⁡", "text")]);
              d.parentIsSupSub ? f = new Vr("mrow", [f, b]) : f = Fg([f, b]);
            }
            return f;
          }, PC = {
            "∏": "\\prod",
            "∐": "\\coprod",
            "∑": "\\sum",
            "⋀": "\\bigwedge",
            "⋁": "\\bigvee",
            "⋂": "\\bigcap",
            "⋃": "\\bigcup",
            "⨀": "\\bigodot",
            "⨁": "\\bigoplus",
            "⨂": "\\bigotimes",
            "⨄": "\\biguplus",
            "⨆": "\\bigsqcup"
          };
          _t({
            type: "op",
            names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
            props: {
              numArgs: 0
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d, w = b;
              return w.length === 1 && (w = PC[w]), {
                type: "op",
                mode: f.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: true,
                name: w
              };
            },
            htmlBuilder: ma,
            mathmlBuilder: Bo
          }), _t({
            type: "op",
            names: ["\\mathop"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "op",
                mode: f.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                body: qe(b)
              };
            },
            htmlBuilder: ma,
            mathmlBuilder: Bo
          });
          const jC = {
            "∫": "\\int",
            "∬": "\\iint",
            "∭": "\\iiint",
            "∮": "\\oint",
            "∯": "\\oiint",
            "∰": "\\oiiint"
          };
          _t({
            type: "op",
            names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
            props: {
              numArgs: 0
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              return {
                type: "op",
                mode: u.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                name: f
              };
            },
            htmlBuilder: ma,
            mathmlBuilder: Bo
          }), _t({
            type: "op",
            names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
            props: {
              numArgs: 0
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d;
              return {
                type: "op",
                mode: u.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: false,
                name: f
              };
            },
            htmlBuilder: ma,
            mathmlBuilder: Bo
          }), _t({
            type: "op",
            names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
            props: {
              numArgs: 0
            },
            handler(d) {
              let {
                parser: u,
                funcName: f
              } = d, b = f;
              return b.length === 1 && (b = jC[b]), {
                type: "op",
                mode: u.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: true,
                name: b
              };
            },
            htmlBuilder: ma,
            mathmlBuilder: Bo
          });
          const by = (d, u) => {
            let f, b, w = false, S;
            d.type === "supsub" ? (f = d.sup, b = d.sub, S = Zt(d.base, "operatorname"), w = true) : S = Zt(d, "operatorname");
            let E;
            if (S.body.length > 0) {
              const D = S.body.map((J) => {
                const nt = J.text;
                return typeof nt == "string" ? {
                  type: "textord",
                  mode: J.mode,
                  text: nt
                } : J;
              }), P = Ve(D, u.withFont("mathrm"), true);
              for (let J = 0; J < P.length; J++) {
                const nt = P[J];
                nt instanceof Mr && (nt.text = nt.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
              }
              E = at.makeSpan(["mop"], P, u);
            } else
              E = at.makeSpan(["mop"], [], u);
            return w ? gy(E, f, b, u, u.style, 0, 0) : E;
          };
          _t({
            type: "operatorname",
            names: ["\\operatorname@", "\\operatornamewithlimits"],
            props: {
              numArgs: 1
            },
            handler: (d, u) => {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "operatorname",
                mode: f.mode,
                body: qe(w),
                alwaysHandleSupSub: b === "\\operatornamewithlimits",
                limits: false,
                parentIsSupSub: false
              };
            },
            htmlBuilder: by,
            mathmlBuilder: (d, u) => {
              let f = Dr(d.body, u.withFont("mathrm")), b = true;
              for (let E = 0; E < f.length; E++) {
                const D = f[E];
                if (!(D instanceof ft.SpaceNode)) if (D instanceof ft.MathNode)
                  switch (D.type) {
                    case "mi":
                    case "mn":
                    case "ms":
                    case "mspace":
                    case "mtext":
                      break;
                    case "mo": {
                      const P = D.children[0];
                      D.children.length === 1 && P instanceof ft.TextNode ? P.text = P.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : b = false;
                      break;
                    }
                    default:
                      b = false;
                  }
                else
                  b = false;
              }
              if (b) {
                const E = f.map((D) => D.toText()).join("");
                f = [new ft.TextNode(E)];
              }
              const w = new ft.MathNode("mi", f);
              w.setAttribute("mathvariant", "normal");
              const S = new ft.MathNode("mo", [an("⁡", "text")]);
              return d.parentIsSupSub ? new ft.MathNode("mrow", [w, S]) : ft.newDocumentFragment([w, S]);
            }
          }), N("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@"), Cs({
            type: "ordgroup",
            htmlBuilder(d, u) {
              return d.semisimple ? at.makeFragment(Ve(d.body, u, false)) : at.makeSpan(["mord"], Ve(d.body, u, true), u);
            },
            mathmlBuilder(d, u) {
              return Oi(d.body, u, true);
            }
          }), _t({
            type: "overline",
            names: ["\\overline"],
            props: {
              numArgs: 1
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "overline",
                mode: f.mode,
                body: b
              };
            },
            htmlBuilder(d, u) {
              const f = le(d.body, u.havingCrampedStyle()), b = at.makeLineSpan("overline-line", u), w = u.fontMetrics().defaultRuleThickness, S = at.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: f
                }, {
                  type: "kern",
                  size: 3 * w
                }, {
                  type: "elem",
                  elem: b
                }, {
                  type: "kern",
                  size: w
                }]
              }, u);
              return at.makeSpan(["mord", "overline"], [S], u);
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mo", [new ft.TextNode("‾")]);
              f.setAttribute("stretchy", "true");
              const b = new ft.MathNode("mover", [ve(d.body, u), f]);
              return b.setAttribute("accent", "true"), b;
            }
          }), _t({
            type: "phantom",
            names: ["\\phantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "phantom",
                mode: f.mode,
                body: qe(b)
              };
            },
            htmlBuilder: (d, u) => {
              const f = Ve(d.body, u.withPhantom(), false);
              return at.makeFragment(f);
            },
            mathmlBuilder: (d, u) => {
              const f = Dr(d.body, u);
              return new ft.MathNode("mphantom", f);
            }
          }), _t({
            type: "hphantom",
            names: ["\\hphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "hphantom",
                mode: f.mode,
                body: b
              };
            },
            htmlBuilder: (d, u) => {
              let f = at.makeSpan([], [le(d.body, u.withPhantom())]);
              if (f.height = 0, f.depth = 0, f.children)
                for (let b = 0; b < f.children.length; b++)
                  f.children[b].height = 0, f.children[b].depth = 0;
              return f = at.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: f
                }]
              }, u), at.makeSpan(["mord"], [f], u);
            },
            mathmlBuilder: (d, u) => {
              const f = Dr(qe(d.body), u), b = new ft.MathNode("mphantom", f), w = new ft.MathNode("mpadded", [b]);
              return w.setAttribute("height", "0px"), w.setAttribute("depth", "0px"), w;
            }
          }), _t({
            type: "vphantom",
            names: ["\\vphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                parser: f
              } = d;
              const b = u[0];
              return {
                type: "vphantom",
                mode: f.mode,
                body: b
              };
            },
            htmlBuilder: (d, u) => {
              const f = at.makeSpan(["inner"], [le(d.body, u.withPhantom())]), b = at.makeSpan(["fix"], []);
              return at.makeSpan(["mord", "rlap"], [f, b], u);
            },
            mathmlBuilder: (d, u) => {
              const f = Dr(qe(d.body), u), b = new ft.MathNode("mphantom", f), w = new ft.MathNode("mpadded", [b]);
              return w.setAttribute("width", "0px"), w;
            }
          }), _t({
            type: "raisebox",
            names: ["\\raisebox"],
            props: {
              numArgs: 2,
              argTypes: ["size", "hbox"],
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              const b = Zt(u[0], "size").value, w = u[1];
              return {
                type: "raisebox",
                mode: f.mode,
                dy: b,
                body: w
              };
            },
            htmlBuilder(d, u) {
              const f = le(d.body, u), b = xe(d.dy, u);
              return at.makeVList({
                positionType: "shift",
                positionData: -b,
                children: [{
                  type: "elem",
                  elem: f
                }]
              }, u);
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mpadded", [ve(d.body, u)]), b = d.dy.number + d.dy.unit;
              return f.setAttribute("voffset", b), f;
            }
          }), _t({
            type: "internal",
            names: ["\\relax"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInArgument: true
            },
            handler(d) {
              let {
                parser: u
              } = d;
              return {
                type: "internal",
                mode: u.mode
              };
            }
          }), _t({
            type: "rule",
            names: ["\\rule"],
            props: {
              numArgs: 2,
              numOptionalArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              argTypes: ["size", "size", "size"]
            },
            handler(d, u, f) {
              let {
                parser: b
              } = d;
              const w = f[0], S = Zt(u[0], "size"), E = Zt(u[1], "size");
              return {
                type: "rule",
                mode: b.mode,
                shift: w && Zt(w, "size").value,
                width: S.value,
                height: E.value
              };
            },
            htmlBuilder(d, u) {
              const f = at.makeSpan(["mord", "rule"], [], u), b = xe(d.width, u), w = xe(d.height, u), S = d.shift ? xe(d.shift, u) : 0;
              return f.style.borderRightWidth = bt(b), f.style.borderTopWidth = bt(w), f.style.bottom = bt(S), f.width = b, f.height = w + S, f.depth = -S, f.maxFontSize = w * 1.125 * u.sizeMultiplier, f;
            },
            mathmlBuilder(d, u) {
              const f = xe(d.width, u), b = xe(d.height, u), w = d.shift ? xe(d.shift, u) : 0, S = u.color && u.getColor() || "black", E = new ft.MathNode("mspace");
              E.setAttribute("mathbackground", S), E.setAttribute("width", bt(f)), E.setAttribute("height", bt(b));
              const D = new ft.MathNode("mpadded", [E]);
              return w >= 0 ? D.setAttribute("height", bt(w)) : (D.setAttribute("height", bt(w)), D.setAttribute("depth", bt(-w))), D.setAttribute("voffset", bt(w)), D;
            }
          });
          function xy(d, u, f) {
            const b = Ve(d, u, false), w = u.sizeMultiplier / f.sizeMultiplier;
            for (let S = 0; S < b.length; S++) {
              const E = b[S].classes.indexOf("sizing");
              E < 0 ? Array.prototype.push.apply(b[S].classes, u.sizingClasses(f)) : b[S].classes[E + 1] === "reset-size" + u.size && (b[S].classes[E + 1] = "reset-size" + f.size), b[S].height *= w, b[S].depth *= w;
            }
            return at.makeFragment(b);
          }
          const wy = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
          _t({
            type: "sizing",
            names: wy,
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (d, u) => {
              let {
                breakOnTokenText: f,
                funcName: b,
                parser: w
              } = d;
              const S = w.parseExpression(false, f);
              return {
                type: "sizing",
                mode: w.mode,
                // Figure out what size to use based on the list of functions above
                size: wy.indexOf(b) + 1,
                body: S
              };
            },
            htmlBuilder: (d, u) => {
              const f = u.havingSize(d.size);
              return xy(d.body, f, u);
            },
            mathmlBuilder: (d, u) => {
              const f = u.havingSize(d.size), b = Dr(d.body, f), w = new ft.MathNode("mstyle", b);
              return w.setAttribute("mathsize", bt(f.sizeMultiplier)), w;
            }
          }), _t({
            type: "smash",
            names: ["\\smash"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              allowedInText: true
            },
            handler: (d, u, f) => {
              let {
                parser: b
              } = d, w = false, S = false;
              const E = f[0] && Zt(f[0], "ordgroup");
              if (E) {
                let P = "";
                for (let J = 0; J < E.body.length; ++J)
                  if (P = E.body[J].text, P === "t")
                    w = true;
                  else if (P === "b")
                    S = true;
                  else {
                    w = false, S = false;
                    break;
                  }
              } else
                w = true, S = true;
              const D = u[0];
              return {
                type: "smash",
                mode: b.mode,
                body: D,
                smashHeight: w,
                smashDepth: S
              };
            },
            htmlBuilder: (d, u) => {
              const f = at.makeSpan([], [le(d.body, u)]);
              if (!d.smashHeight && !d.smashDepth)
                return f;
              if (d.smashHeight && (f.height = 0, f.children))
                for (let w = 0; w < f.children.length; w++)
                  f.children[w].height = 0;
              if (d.smashDepth && (f.depth = 0, f.children))
                for (let w = 0; w < f.children.length; w++)
                  f.children[w].depth = 0;
              const b = at.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: f
                }]
              }, u);
              return at.makeSpan(["mord"], [b], u);
            },
            mathmlBuilder: (d, u) => {
              const f = new ft.MathNode("mpadded", [ve(d.body, u)]);
              return d.smashHeight && f.setAttribute("height", "0px"), d.smashDepth && f.setAttribute("depth", "0px"), f;
            }
          }), _t({
            type: "sqrt",
            names: ["\\sqrt"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(d, u, f) {
              let {
                parser: b
              } = d;
              const w = f[0], S = u[0];
              return {
                type: "sqrt",
                mode: b.mode,
                body: S,
                index: w
              };
            },
            htmlBuilder(d, u) {
              let f = le(d.body, u.havingCrampedStyle());
              f.height === 0 && (f.height = u.fontMetrics().xHeight), f = at.wrapFragment(f, u);
              const b = u.fontMetrics().defaultRuleThickness;
              let w = b;
              u.style.id < et.TEXT.id && (w = u.fontMetrics().xHeight);
              let S = b + w / 4;
              const E = f.height + f.depth + S + b, {
                span: D,
                ruleWidth: P,
                advanceWidth: J
              } = hi.sqrtImage(E, u), nt = D.height - P;
              nt > f.height + f.depth + S && (S = (S + nt - f.height - f.depth) / 2);
              const it = D.height - f.height - S - P;
              f.style.paddingLeft = bt(J);
              const lt = at.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: f,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: -(f.height + it)
                }, {
                  type: "elem",
                  elem: D
                }, {
                  type: "kern",
                  size: P
                }]
              }, u);
              if (d.index) {
                const yt = u.havingStyle(et.SCRIPTSCRIPT), kt = le(d.index, yt, u), Yt = 0.6 * (lt.height - lt.depth), ie = at.makeVList({
                  positionType: "shift",
                  positionData: -Yt,
                  children: [{
                    type: "elem",
                    elem: kt
                  }]
                }, u), te = at.makeSpan(["root"], [ie]);
                return at.makeSpan(["mord", "sqrt"], [te, lt], u);
              } else
                return at.makeSpan(["mord", "sqrt"], [lt], u);
            },
            mathmlBuilder(d, u) {
              const {
                body: f,
                index: b
              } = d;
              return b ? new ft.MathNode("mroot", [ve(f, u), ve(b, u)]) : new ft.MathNode("msqrt", [ve(f, u)]);
            }
          });
          const ky = {
            display: et.DISPLAY,
            text: et.TEXT,
            script: et.SCRIPT,
            scriptscript: et.SCRIPTSCRIPT
          };
          _t({
            type: "styling",
            names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(d, u) {
              let {
                breakOnTokenText: f,
                funcName: b,
                parser: w
              } = d;
              const S = w.parseExpression(true, f), E = b.slice(1, b.length - 5);
              return {
                type: "styling",
                mode: w.mode,
                // Figure out what style to use by pulling out the style from
                // the function name
                style: E,
                body: S
              };
            },
            htmlBuilder(d, u) {
              const f = ky[d.style], b = u.havingStyle(f).withFont("");
              return xy(d.body, b, u);
            },
            mathmlBuilder(d, u) {
              const f = ky[d.style], b = u.havingStyle(f), w = Dr(d.body, b), S = new ft.MathNode("mstyle", w), E = {
                display: ["0", "true"],
                text: ["0", "false"],
                script: ["1", "false"],
                scriptscript: ["2", "false"]
              }[d.style];
              return S.setAttribute("scriptlevel", E[0]), S.setAttribute("displaystyle", E[1]), S;
            }
          });
          const WC = function(d, u) {
            const f = d.base;
            return f ? f.type === "op" ? f.limits && (u.style.size === et.DISPLAY.size || f.alwaysHandleSupSub) ? ma : null : f.type === "operatorname" ? f.alwaysHandleSupSub && (u.style.size === et.DISPLAY.size || f.limits) ? by : null : f.type === "accent" ? k.isCharacterBox(f.base) ? rd : null : f.type === "horizBrace" && !d.sub === f.isOver ? fy : null : null;
          };
          Cs({
            type: "supsub",
            htmlBuilder(d, u) {
              const f = WC(d, u);
              if (f)
                return f(d, u);
              const {
                base: b,
                sup: w,
                sub: S
              } = d, E = le(b, u);
              let D, P;
              const J = u.fontMetrics();
              let nt = 0, it = 0;
              const lt = b && k.isCharacterBox(b);
              if (w) {
                const ce = u.havingStyle(u.style.sup());
                D = le(w, ce, u), lt || (nt = E.height - ce.fontMetrics().supDrop * ce.sizeMultiplier / u.sizeMultiplier);
              }
              if (S) {
                const ce = u.havingStyle(u.style.sub());
                P = le(S, ce, u), lt || (it = E.depth + ce.fontMetrics().subDrop * ce.sizeMultiplier / u.sizeMultiplier);
              }
              let yt;
              u.style === et.DISPLAY ? yt = J.sup1 : u.style.cramped ? yt = J.sup3 : yt = J.sup2;
              const kt = u.sizeMultiplier, Yt = bt(0.5 / J.ptPerEm / kt);
              let ie = null;
              if (P) {
                const ce = d.base && d.base.type === "op" && d.base.name && (d.base.name === "\\oiint" || d.base.name === "\\oiiint");
                (E instanceof Mr || ce) && (ie = bt(-E.italic));
              }
              let te;
              if (D && P) {
                nt = Math.max(nt, yt, D.depth + 0.25 * J.xHeight), it = Math.max(it, J.sub2);
                const ce = 4 * J.defaultRuleThickness;
                if (nt - D.depth - (P.height - it) < ce) {
                  it = ce - (nt - D.depth) + P.height;
                  const or = 0.8 * J.xHeight - (nt - D.depth);
                  or > 0 && (nt += or, it -= or);
                }
                const $e = [{
                  type: "elem",
                  elem: P,
                  shift: it,
                  marginRight: Yt,
                  marginLeft: ie
                }, {
                  type: "elem",
                  elem: D,
                  shift: -nt,
                  marginRight: Yt
                }];
                te = at.makeVList({
                  positionType: "individualShift",
                  children: $e
                }, u);
              } else if (P) {
                it = Math.max(it, J.sub1, P.height - 0.8 * J.xHeight);
                const ce = [{
                  type: "elem",
                  elem: P,
                  marginLeft: ie,
                  marginRight: Yt
                }];
                te = at.makeVList({
                  positionType: "shift",
                  positionData: it,
                  children: ce
                }, u);
              } else if (D)
                nt = Math.max(nt, yt, D.depth + 0.25 * J.xHeight), te = at.makeVList({
                  positionType: "shift",
                  positionData: -nt,
                  children: [{
                    type: "elem",
                    elem: D,
                    marginRight: Yt
                  }]
                }, u);
              else
                throw new Error("supsub must have either sup or sub.");
              const ue = Ku(E, "right") || "mord";
              return at.makeSpan([ue], [E, at.makeSpan(["msupsub"], [te])], u);
            },
            mathmlBuilder(d, u) {
              let f = false, b, w;
              d.base && d.base.type === "horizBrace" && (w = !!d.sup, w === d.base.isOver && (f = true, b = d.base.isOver)), d.base && (d.base.type === "op" || d.base.type === "operatorname") && (d.base.parentIsSupSub = true);
              const S = [ve(d.base, u)];
              d.sub && S.push(ve(d.sub, u)), d.sup && S.push(ve(d.sup, u));
              let E;
              if (f)
                E = b ? "mover" : "munder";
              else if (d.sub)
                if (d.sup) {
                  const D = d.base;
                  D && D.type === "op" && D.limits && u.style === et.DISPLAY || D && D.type === "operatorname" && D.alwaysHandleSupSub && (u.style === et.DISPLAY || D.limits) ? E = "munderover" : E = "msubsup";
                } else {
                  const D = d.base;
                  D && D.type === "op" && D.limits && (u.style === et.DISPLAY || D.alwaysHandleSupSub) || D && D.type === "operatorname" && D.alwaysHandleSupSub && (D.limits || u.style === et.DISPLAY) ? E = "munder" : E = "msub";
                }
              else {
                const D = d.base;
                D && D.type === "op" && D.limits && (u.style === et.DISPLAY || D.alwaysHandleSupSub) || D && D.type === "operatorname" && D.alwaysHandleSupSub && (D.limits || u.style === et.DISPLAY) ? E = "mover" : E = "msup";
              }
              return new ft.MathNode(E, S);
            }
          }), Cs({
            type: "atom",
            htmlBuilder(d, u) {
              return at.mathsym(d.text, d.mode, u, ["m" + d.family]);
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mo", [an(d.text, d.mode)]);
              if (d.family === "bin") {
                const b = Qu(d, u);
                b === "bold-italic" && f.setAttribute("mathvariant", b);
              } else d.family === "punct" ? f.setAttribute("separator", "true") : (d.family === "open" || d.family === "close") && f.setAttribute("stretchy", "false");
              return f;
            }
          });
          const vy = {
            mi: "italic",
            mn: "normal",
            mtext: "normal"
          };
          Cs({
            type: "mathord",
            htmlBuilder(d, u) {
              return at.makeOrd(d, u, "mathord");
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mi", [an(d.text, d.mode, u)]), b = Qu(d, u) || "italic";
              return b !== vy[f.type] && f.setAttribute("mathvariant", b), f;
            }
          }), Cs({
            type: "textord",
            htmlBuilder(d, u) {
              return at.makeOrd(d, u, "textord");
            },
            mathmlBuilder(d, u) {
              const f = an(d.text, d.mode, u), b = Qu(d, u) || "normal";
              let w;
              return d.mode === "text" ? w = new ft.MathNode("mtext", [f]) : /[0-9]/.test(d.text) ? w = new ft.MathNode("mn", [f]) : d.text === "\\prime" ? w = new ft.MathNode("mo", [f]) : w = new ft.MathNode("mi", [f]), b !== vy[w.type] && w.setAttribute("mathvariant", b), w;
            }
          });
          const bd = {
            "\\nobreak": "nobreak",
            "\\allowbreak": "allowbreak"
          }, xd = {
            " ": {},
            "\\ ": {},
            "~": {
              className: "nobreak"
            },
            "\\space": {},
            "\\nobreakspace": {
              className: "nobreak"
            }
          };
          Cs({
            type: "spacing",
            htmlBuilder(d, u) {
              if (xd.hasOwnProperty(d.text)) {
                const f = xd[d.text].className || "";
                if (d.mode === "text") {
                  const b = at.makeOrd(d, u, "textord");
                  return b.classes.push(f), b;
                } else
                  return at.makeSpan(["mspace", f], [at.mathsym(d.text, d.mode, u)], u);
              } else {
                if (bd.hasOwnProperty(d.text))
                  return at.makeSpan(["mspace", bd[d.text]], [], u);
                throw new s('Unknown type of space "' + d.text + '"');
              }
            },
            mathmlBuilder(d, u) {
              let f;
              if (xd.hasOwnProperty(d.text))
                f = new ft.MathNode("mtext", [new ft.TextNode(" ")]);
              else {
                if (bd.hasOwnProperty(d.text))
                  return new ft.MathNode("mspace");
                throw new s('Unknown type of space "' + d.text + '"');
              }
              return f;
            }
          });
          const Cy = () => {
            const d = new ft.MathNode("mtd", []);
            return d.setAttribute("width", "50%"), d;
          };
          Cs({
            type: "tag",
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mtable", [new ft.MathNode("mtr", [Cy(), new ft.MathNode("mtd", [Oi(d.body, u)]), Cy(), new ft.MathNode("mtd", [Oi(d.tag, u)])])]);
              return f.setAttribute("width", "100%"), f;
            }
          });
          const _y = {
            "\\text": void 0,
            "\\textrm": "textrm",
            "\\textsf": "textsf",
            "\\texttt": "texttt",
            "\\textnormal": "textrm"
          }, Sy = {
            "\\textbf": "textbf",
            "\\textmd": "textmd"
          }, HC = {
            "\\textit": "textit",
            "\\textup": "textup"
          }, Ay = (d, u) => {
            const f = d.font;
            if (f) {
              if (_y[f])
                return u.withTextFontFamily(_y[f]);
              if (Sy[f])
                return u.withTextFontWeight(Sy[f]);
              if (f === "\\emph")
                return u.fontShape === "textit" ? u.withTextFontShape("textup") : u.withTextFontShape("textit");
            } else return u;
            return u.withTextFontShape(HC[f]);
          };
          _t({
            type: "text",
            names: [
              // Font families
              "\\text",
              "\\textrm",
              "\\textsf",
              "\\texttt",
              "\\textnormal",
              // Font weights
              "\\textbf",
              "\\textmd",
              // Font Shapes
              "\\textit",
              "\\textup",
              "\\emph"
            ],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInArgument: true,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f,
                funcName: b
              } = d;
              const w = u[0];
              return {
                type: "text",
                mode: f.mode,
                body: qe(w),
                font: b
              };
            },
            htmlBuilder(d, u) {
              const f = Ay(d, u), b = Ve(d.body, f, true);
              return at.makeSpan(["mord", "text"], b, f);
            },
            mathmlBuilder(d, u) {
              const f = Ay(d, u);
              return Oi(d.body, f);
            }
          }), _t({
            type: "underline",
            names: ["\\underline"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "underline",
                mode: f.mode,
                body: u[0]
              };
            },
            htmlBuilder(d, u) {
              const f = le(d.body, u), b = at.makeLineSpan("underline-line", u), w = u.fontMetrics().defaultRuleThickness, S = at.makeVList({
                positionType: "top",
                positionData: f.height,
                children: [{
                  type: "kern",
                  size: w
                }, {
                  type: "elem",
                  elem: b
                }, {
                  type: "kern",
                  size: 3 * w
                }, {
                  type: "elem",
                  elem: f
                }]
              }, u);
              return at.makeSpan(["mord", "underline"], [S], u);
            },
            mathmlBuilder(d, u) {
              const f = new ft.MathNode("mo", [new ft.TextNode("‾")]);
              f.setAttribute("stretchy", "true");
              const b = new ft.MathNode("munder", [ve(d.body, u), f]);
              return b.setAttribute("accentunder", "true"), b;
            }
          }), _t({
            type: "vcenter",
            names: ["\\vcenter"],
            props: {
              numArgs: 1,
              argTypes: ["original"],
              // In LaTeX, \vcenter can act only on a box.
              allowedInText: false
            },
            handler(d, u) {
              let {
                parser: f
              } = d;
              return {
                type: "vcenter",
                mode: f.mode,
                body: u[0]
              };
            },
            htmlBuilder(d, u) {
              const f = le(d.body, u), b = u.fontMetrics().axisHeight, w = 0.5 * (f.height - b - (f.depth + b));
              return at.makeVList({
                positionType: "shift",
                positionData: w,
                children: [{
                  type: "elem",
                  elem: f
                }]
              }, u);
            },
            mathmlBuilder(d, u) {
              return new ft.MathNode("mpadded", [ve(d.body, u)], ["vcenter"]);
            }
          }), _t({
            type: "verb",
            names: ["\\verb"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(d, u, f) {
              throw new s("\\verb ended by end of line instead of matching delimiter");
            },
            htmlBuilder(d, u) {
              const f = Ty(d), b = [], w = u.havingStyle(u.style.text());
              for (let S = 0; S < f.length; S++) {
                let E = f[S];
                E === "~" && (E = "\\textasciitilde"), b.push(at.makeSymbol(E, "Typewriter-Regular", d.mode, w, ["mord", "texttt"]));
              }
              return at.makeSpan(["mord", "text"].concat(w.sizingClasses(u)), at.tryCombineChars(b), w);
            },
            mathmlBuilder(d, u) {
              const f = new ft.TextNode(Ty(d)), b = new ft.MathNode("mtext", [f]);
              return b.setAttribute("mathvariant", "monospace"), b;
            }
          });
          const Ty = (d) => d.body.replace(/ /g, d.star ? "␣" : " ");
          var qi = Lg;
          const $y = `[ \r
	]`, UC = "\\\\[a-zA-Z@]+", VC = "\\\\[^\uD800-\uDFFF]", GC = "(" + UC + ")" + $y + "*", XC = `\\\\(
|[ \r	]+
?)[ \r	]*`, wd = "[̀-ͯ]", YC = new RegExp(wd + "+$"), KC = "(" + $y + "+)|" + // whitespace
          (XC + "|") + // \whitespace
          "([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
          (wd + "*") + // ...plus accents
          "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
          (wd + "*") + // ...plus accents
          "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
          ("|" + GC) + // \macroName + spaces
          ("|" + VC + ")");
          class Ey {
            // Category codes. The lexer only supports comment characters (14) for now.
            // MacroExpander additionally distinguishes active (13).
            constructor(u, f) {
              this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = u, this.settings = f, this.tokenRegex = new RegExp(KC, "g"), this.catcodes = {
                "%": 14,
                // comment character
                "~": 13
                // active character
              };
            }
            setCatcode(u, f) {
              this.catcodes[u] = f;
            }
            /**
             * This function lexes a single token.
             */
            lex() {
              const u = this.input, f = this.tokenRegex.lastIndex;
              if (f === u.length)
                return new on("EOF", new Gr(this, f, f));
              const b = this.tokenRegex.exec(u);
              if (b === null || b.index !== f)
                throw new s("Unexpected character: '" + u[f] + "'", new on(u[f], new Gr(this, f, f + 1)));
              const w = b[6] || b[3] || (b[2] ? "\\ " : " ");
              if (this.catcodes[w] === 14) {
                const S = u.indexOf(`
`, this.tokenRegex.lastIndex);
                return S === -1 ? (this.tokenRegex.lastIndex = u.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = S + 1, this.lex();
              }
              return new on(w, new Gr(this, f, this.tokenRegex.lastIndex));
            }
          }
          class ZC {
            /**
             * Both arguments are optional.  The first argument is an object of
             * built-in mappings which never change.  The second argument is an object
             * of initial (global-level) mappings, which will constantly change
             * according to any global/top-level `set`s done.
             */
            constructor(u, f) {
              u === void 0 && (u = {}), f === void 0 && (f = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = f, this.builtins = u, this.undefStack = [];
            }
            /**
             * Start a new nested group, affecting future local `set`s.
             */
            beginGroup() {
              this.undefStack.push({});
            }
            /**
             * End current nested group, restoring values before the group began.
             */
            endGroup() {
              if (this.undefStack.length === 0)
                throw new s("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
              const u = this.undefStack.pop();
              for (const f in u)
                u.hasOwnProperty(f) && (u[f] == null ? delete this.current[f] : this.current[f] = u[f]);
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              for (; this.undefStack.length > 0; )
                this.endGroup();
            }
            /**
             * Detect whether `name` has a definition.  Equivalent to
             * `get(name) != null`.
             */
            has(u) {
              return this.current.hasOwnProperty(u) || this.builtins.hasOwnProperty(u);
            }
            /**
             * Get the current value of a name, or `undefined` if there is no value.
             *
             * Note: Do not use `if (namespace.get(...))` to detect whether a macro
             * is defined, as the definition may be the empty string which evaluates
             * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
             * `if (namespace.has(...))`.
             */
            get(u) {
              return this.current.hasOwnProperty(u) ? this.current[u] : this.builtins[u];
            }
            /**
             * Set the current value of a name, and optionally set it globally too.
             * Local set() sets the current value and (when appropriate) adds an undo
             * operation to the undo stack.  Global set() may change the undo
             * operation at every level, so takes time linear in their number.
             * A value of undefined means to delete existing definitions.
             */
            set(u, f, b) {
              if (b === void 0 && (b = false), b) {
                for (let w = 0; w < this.undefStack.length; w++)
                  delete this.undefStack[w][u];
                this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][u] = f);
              } else {
                const w = this.undefStack[this.undefStack.length - 1];
                w && !w.hasOwnProperty(u) && (w[u] = this.current[u]);
              }
              f == null ? delete this.current[u] : this.current[u] = f;
            }
          }
          var JC = iy;
          N("\\noexpand", function(d) {
            const u = d.popToken();
            return d.isExpandable(u.text) && (u.noexpand = true, u.treatAsRelax = true), {
              tokens: [u],
              numArgs: 0
            };
          }), N("\\expandafter", function(d) {
            const u = d.popToken();
            return d.expandOnce(true), {
              tokens: [u],
              numArgs: 0
            };
          }), N("\\@firstoftwo", function(d) {
            return {
              tokens: d.consumeArgs(2)[0],
              numArgs: 0
            };
          }), N("\\@secondoftwo", function(d) {
            return {
              tokens: d.consumeArgs(2)[1],
              numArgs: 0
            };
          }), N("\\@ifnextchar", function(d) {
            const u = d.consumeArgs(3);
            d.consumeSpaces();
            const f = d.future();
            return u[0].length === 1 && u[0][0].text === f.text ? {
              tokens: u[1],
              numArgs: 0
            } : {
              tokens: u[2],
              numArgs: 0
            };
          }), N("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"), N("\\TextOrMath", function(d) {
            const u = d.consumeArgs(2);
            return d.mode === "text" ? {
              tokens: u[0],
              numArgs: 0
            } : {
              tokens: u[1],
              numArgs: 0
            };
          });
          const My = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            a: 10,
            A: 10,
            b: 11,
            B: 11,
            c: 12,
            C: 12,
            d: 13,
            D: 13,
            e: 14,
            E: 14,
            f: 15,
            F: 15
          };
          N("\\char", function(d) {
            let u = d.popToken(), f, b = "";
            if (u.text === "'")
              f = 8, u = d.popToken();
            else if (u.text === '"')
              f = 16, u = d.popToken();
            else if (u.text === "`")
              if (u = d.popToken(), u.text[0] === "\\")
                b = u.text.charCodeAt(1);
              else {
                if (u.text === "EOF")
                  throw new s("\\char` missing argument");
                b = u.text.charCodeAt(0);
              }
            else
              f = 10;
            if (f) {
              if (b = My[u.text], b == null || b >= f)
                throw new s("Invalid base-" + f + " digit " + u.text);
              let w;
              for (; (w = My[d.future().text]) != null && w < f; )
                b *= f, b += w, d.popToken();
            }
            return "\\@char{" + b + "}";
          });
          const kd = (d, u, f, b) => {
            let w = d.consumeArg().tokens;
            if (w.length !== 1)
              throw new s("\\newcommand's first argument must be a macro name");
            const S = w[0].text, E = d.isDefined(S);
            if (E && !u)
              throw new s("\\newcommand{" + S + "} attempting to redefine " + (S + "; use \\renewcommand"));
            if (!E && !f)
              throw new s("\\renewcommand{" + S + "} when command " + S + " does not yet exist; use \\newcommand");
            let D = 0;
            if (w = d.consumeArg().tokens, w.length === 1 && w[0].text === "[") {
              let P = "", J = d.expandNextToken();
              for (; J.text !== "]" && J.text !== "EOF"; )
                P += J.text, J = d.expandNextToken();
              if (!P.match(/^\s*[0-9]+\s*$/))
                throw new s("Invalid number of arguments: " + P);
              D = parseInt(P), w = d.consumeArg().tokens;
            }
            return E && b || d.macros.set(S, {
              tokens: w,
              numArgs: D
            }), "";
          };
          N("\\newcommand", (d) => kd(d, false, true, false)), N("\\renewcommand", (d) => kd(d, true, false, false)), N("\\providecommand", (d) => kd(d, true, true, true)), N("\\message", (d) => {
            const u = d.consumeArgs(1)[0];
            return console.log(u.reverse().map((f) => f.text).join("")), "";
          }), N("\\errmessage", (d) => {
            const u = d.consumeArgs(1)[0];
            return console.error(u.reverse().map((f) => f.text).join("")), "";
          }), N("\\show", (d) => {
            const u = d.popToken(), f = u.text;
            return console.log(u, d.macros.get(f), qi[f], pe.math[f], pe.text[f]), "";
          }), N("\\bgroup", "{"), N("\\egroup", "}"), N("~", "\\nobreakspace"), N("\\lq", "`"), N("\\rq", "'"), N("\\aa", "\\r a"), N("\\AA", "\\r A"), N("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}"), N("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}"), N("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}"), N("ℬ", "\\mathscr{B}"), N("ℰ", "\\mathscr{E}"), N("ℱ", "\\mathscr{F}"), N("ℋ", "\\mathscr{H}"), N("ℐ", "\\mathscr{I}"), N("ℒ", "\\mathscr{L}"), N("ℳ", "\\mathscr{M}"), N("ℛ", "\\mathscr{R}"), N("ℭ", "\\mathfrak{C}"), N("ℌ", "\\mathfrak{H}"), N("ℨ", "\\mathfrak{Z}"), N("\\Bbbk", "\\Bbb{k}"), N("·", "\\cdotp"), N("\\llap", "\\mathllap{\\textrm{#1}}"), N("\\rlap", "\\mathrlap{\\textrm{#1}}"), N("\\clap", "\\mathclap{\\textrm{#1}}"), N("\\mathstrut", "\\vphantom{(}"), N("\\underbar", "\\underline{\\text{#1}}"), N("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'), N("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}"), N("\\ne", "\\neq"), N("≠", "\\neq"), N("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}"), N("∉", "\\notin"), N("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}"), N("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}"), N("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}"), N("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}"), N("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}"), N("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}"), N("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}"), N("⟂", "\\perp"), N("‼", "\\mathclose{!\\mkern-0.8mu!}"), N("∌", "\\notni"), N("⌜", "\\ulcorner"), N("⌝", "\\urcorner"), N("⌞", "\\llcorner"), N("⌟", "\\lrcorner"), N("©", "\\copyright"), N("®", "\\textregistered"), N("️", "\\textregistered"), N("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}'), N("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}'), N("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}'), N("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}'), N("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}"), N("⋮", "\\vdots"), N("\\varGamma", "\\mathit{\\Gamma}"), N("\\varDelta", "\\mathit{\\Delta}"), N("\\varTheta", "\\mathit{\\Theta}"), N("\\varLambda", "\\mathit{\\Lambda}"), N("\\varXi", "\\mathit{\\Xi}"), N("\\varPi", "\\mathit{\\Pi}"), N("\\varSigma", "\\mathit{\\Sigma}"), N("\\varUpsilon", "\\mathit{\\Upsilon}"), N("\\varPhi", "\\mathit{\\Phi}"), N("\\varPsi", "\\mathit{\\Psi}"), N("\\varOmega", "\\mathit{\\Omega}"), N("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"), N("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"), N("\\boxed", "\\fbox{$\\displaystyle{#1}$}"), N("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;"), N("\\implies", "\\DOTSB\\;\\Longrightarrow\\;"), N("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"), N("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}"), N("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
          const By = {
            ",": "\\dotsc",
            "\\not": "\\dotsb",
            // \keybin@ checks for the following:
            "+": "\\dotsb",
            "=": "\\dotsb",
            "<": "\\dotsb",
            ">": "\\dotsb",
            "-": "\\dotsb",
            "*": "\\dotsb",
            ":": "\\dotsb",
            // Symbols whose definition starts with \DOTSB:
            "\\DOTSB": "\\dotsb",
            "\\coprod": "\\dotsb",
            "\\bigvee": "\\dotsb",
            "\\bigwedge": "\\dotsb",
            "\\biguplus": "\\dotsb",
            "\\bigcap": "\\dotsb",
            "\\bigcup": "\\dotsb",
            "\\prod": "\\dotsb",
            "\\sum": "\\dotsb",
            "\\bigotimes": "\\dotsb",
            "\\bigoplus": "\\dotsb",
            "\\bigodot": "\\dotsb",
            "\\bigsqcup": "\\dotsb",
            "\\And": "\\dotsb",
            "\\longrightarrow": "\\dotsb",
            "\\Longrightarrow": "\\dotsb",
            "\\longleftarrow": "\\dotsb",
            "\\Longleftarrow": "\\dotsb",
            "\\longleftrightarrow": "\\dotsb",
            "\\Longleftrightarrow": "\\dotsb",
            "\\mapsto": "\\dotsb",
            "\\longmapsto": "\\dotsb",
            "\\hookrightarrow": "\\dotsb",
            "\\doteq": "\\dotsb",
            // Symbols whose definition starts with \mathbin:
            "\\mathbin": "\\dotsb",
            // Symbols whose definition starts with \mathrel:
            "\\mathrel": "\\dotsb",
            "\\relbar": "\\dotsb",
            "\\Relbar": "\\dotsb",
            "\\xrightarrow": "\\dotsb",
            "\\xleftarrow": "\\dotsb",
            // Symbols whose definition starts with \DOTSI:
            "\\DOTSI": "\\dotsi",
            "\\int": "\\dotsi",
            "\\oint": "\\dotsi",
            "\\iint": "\\dotsi",
            "\\iiint": "\\dotsi",
            "\\iiiint": "\\dotsi",
            "\\idotsint": "\\dotsi",
            // Symbols whose definition starts with \DOTSX:
            "\\DOTSX": "\\dotsx"
          };
          N("\\dots", function(d) {
            let u = "\\dotso";
            const f = d.expandAfterFuture().text;
            return f in By ? u = By[f] : (f.slice(0, 4) === "\\not" || f in pe.math && k.contains(["bin", "rel"], pe.math[f].group)) && (u = "\\dotsb"), u;
          });
          const vd = {
            // \rightdelim@ checks for the following:
            ")": true,
            "]": true,
            "\\rbrack": true,
            "\\}": true,
            "\\rbrace": true,
            "\\rangle": true,
            "\\rceil": true,
            "\\rfloor": true,
            "\\rgroup": true,
            "\\rmoustache": true,
            "\\right": true,
            "\\bigr": true,
            "\\biggr": true,
            "\\Bigr": true,
            "\\Biggr": true,
            // \extra@ also tests for the following:
            $: true,
            // \extrap@ checks for the following:
            ";": true,
            ".": true,
            ",": true
          };
          N("\\dotso", function(d) {
            return d.future().text in vd ? "\\ldots\\," : "\\ldots";
          }), N("\\dotsc", function(d) {
            const u = d.future().text;
            return u in vd && u !== "," ? "\\ldots\\," : "\\ldots";
          }), N("\\cdots", function(d) {
            return d.future().text in vd ? "\\@cdots\\," : "\\@cdots";
          }), N("\\dotsb", "\\cdots"), N("\\dotsm", "\\cdots"), N("\\dotsi", "\\!\\cdots"), N("\\dotsx", "\\ldots\\,"), N("\\DOTSI", "\\relax"), N("\\DOTSB", "\\relax"), N("\\DOTSX", "\\relax"), N("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"), N("\\,", "\\tmspace+{3mu}{.1667em}"), N("\\thinspace", "\\,"), N("\\>", "\\mskip{4mu}"), N("\\:", "\\tmspace+{4mu}{.2222em}"), N("\\medspace", "\\:"), N("\\;", "\\tmspace+{5mu}{.2777em}"), N("\\thickspace", "\\;"), N("\\!", "\\tmspace-{3mu}{.1667em}"), N("\\negthinspace", "\\!"), N("\\negmedspace", "\\tmspace-{4mu}{.2222em}"), N("\\negthickspace", "\\tmspace-{5mu}{.277em}"), N("\\enspace", "\\kern.5em "), N("\\enskip", "\\hskip.5em\\relax"), N("\\quad", "\\hskip1em\\relax"), N("\\qquad", "\\hskip2em\\relax"), N("\\tag", "\\@ifstar\\tag@literal\\tag@paren"), N("\\tag@paren", "\\tag@literal{({#1})}"), N("\\tag@literal", (d) => {
            if (d.macros.get("\\df@tag"))
              throw new s("Multiple \\tag");
            return "\\gdef\\df@tag{\\text{#1}}";
          }), N("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"), N("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"), N("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}"), N("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"), N("\\newline", "\\\\\\relax"), N("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
          const Ly = bt(br["Main-Regular"][84][1] - 0.7 * br["Main-Regular"][65][1]);
          N("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + Ly + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"), N("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + Ly + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"), N("\\hspace", "\\@ifstar\\@hspacer\\@hspace"), N("\\@hspace", "\\hskip #1\\relax"), N("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"), N("\\ordinarycolon", ":"), N("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"), N("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}'), N("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}'), N("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}'), N("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}'), N("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}'), N("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}'), N("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}'), N("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}'), N("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}'), N("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}'), N("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}'), N("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}'), N("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}'), N("∷", "\\dblcolon"), N("∹", "\\eqcolon"), N("≔", "\\coloneqq"), N("≕", "\\eqqcolon"), N("⩴", "\\Coloneqq"), N("\\ratio", "\\vcentcolon"), N("\\coloncolon", "\\dblcolon"), N("\\colonequals", "\\coloneqq"), N("\\coloncolonequals", "\\Coloneqq"), N("\\equalscolon", "\\eqqcolon"), N("\\equalscoloncolon", "\\Eqqcolon"), N("\\colonminus", "\\coloneq"), N("\\coloncolonminus", "\\Coloneq"), N("\\minuscolon", "\\eqcolon"), N("\\minuscoloncolon", "\\Eqcolon"), N("\\coloncolonapprox", "\\Colonapprox"), N("\\coloncolonsim", "\\Colonsim"), N("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), N("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}"), N("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), N("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"), N("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}"), N("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}"), N("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"), N("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}"), N("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}"), N("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}"), N("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}"), N("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}"), N("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"), N("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}"), N("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}"), N("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}"), N("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}"), N("\\nleqq", "\\html@mathml{\\@nleqq}{≰}"), N("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}"), N("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}"), N("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}"), N("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}"), N("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}"), N("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}"), N("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}"), N("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}"), N("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}"), N("\\imath", "\\html@mathml{\\@imath}{ı}"), N("\\jmath", "\\html@mathml{\\@jmath}{ȷ}"), N("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}"), N("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}"), N("⟦", "\\llbracket"), N("⟧", "\\rrbracket"), N("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}"), N("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}"), N("⦃", "\\lBrace"), N("⦄", "\\rBrace"), N("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}"), N("⦵", "\\minuso"), N("\\darr", "\\downarrow"), N("\\dArr", "\\Downarrow"), N("\\Darr", "\\Downarrow"), N("\\lang", "\\langle"), N("\\rang", "\\rangle"), N("\\uarr", "\\uparrow"), N("\\uArr", "\\Uparrow"), N("\\Uarr", "\\Uparrow"), N("\\N", "\\mathbb{N}"), N("\\R", "\\mathbb{R}"), N("\\Z", "\\mathbb{Z}"), N("\\alef", "\\aleph"), N("\\alefsym", "\\aleph"), N("\\Alpha", "\\mathrm{A}"), N("\\Beta", "\\mathrm{B}"), N("\\bull", "\\bullet"), N("\\Chi", "\\mathrm{X}"), N("\\clubs", "\\clubsuit"), N("\\cnums", "\\mathbb{C}"), N("\\Complex", "\\mathbb{C}"), N("\\Dagger", "\\ddagger"), N("\\diamonds", "\\diamondsuit"), N("\\empty", "\\emptyset"), N("\\Epsilon", "\\mathrm{E}"), N("\\Eta", "\\mathrm{H}"), N("\\exist", "\\exists"), N("\\harr", "\\leftrightarrow"), N("\\hArr", "\\Leftrightarrow"), N("\\Harr", "\\Leftrightarrow"), N("\\hearts", "\\heartsuit"), N("\\image", "\\Im"), N("\\infin", "\\infty"), N("\\Iota", "\\mathrm{I}"), N("\\isin", "\\in"), N("\\Kappa", "\\mathrm{K}"), N("\\larr", "\\leftarrow"), N("\\lArr", "\\Leftarrow"), N("\\Larr", "\\Leftarrow"), N("\\lrarr", "\\leftrightarrow"), N("\\lrArr", "\\Leftrightarrow"), N("\\Lrarr", "\\Leftrightarrow"), N("\\Mu", "\\mathrm{M}"), N("\\natnums", "\\mathbb{N}"), N("\\Nu", "\\mathrm{N}"), N("\\Omicron", "\\mathrm{O}"), N("\\plusmn", "\\pm"), N("\\rarr", "\\rightarrow"), N("\\rArr", "\\Rightarrow"), N("\\Rarr", "\\Rightarrow"), N("\\real", "\\Re"), N("\\reals", "\\mathbb{R}"), N("\\Reals", "\\mathbb{R}"), N("\\Rho", "\\mathrm{P}"), N("\\sdot", "\\cdot"), N("\\sect", "\\S"), N("\\spades", "\\spadesuit"), N("\\sub", "\\subset"), N("\\sube", "\\subseteq"), N("\\supe", "\\supseteq"), N("\\Tau", "\\mathrm{T}"), N("\\thetasym", "\\vartheta"), N("\\weierp", "\\wp"), N("\\Zeta", "\\mathrm{Z}"), N("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}"), N("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}"), N("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"), N("\\bra", "\\mathinner{\\langle{#1}|}"), N("\\ket", "\\mathinner{|{#1}\\rangle}"), N("\\braket", "\\mathinner{\\langle{#1}\\rangle}"), N("\\Bra", "\\left\\langle#1\\right|"), N("\\Ket", "\\left|#1\\right\\rangle");
          const Dy = (d) => (u) => {
            const f = u.consumeArg().tokens, b = u.consumeArg().tokens, w = u.consumeArg().tokens, S = u.consumeArg().tokens, E = u.macros.get("|"), D = u.macros.get("\\|");
            u.macros.beginGroup();
            const P = (it) => (lt) => {
              d && (lt.macros.set("|", E), w.length && lt.macros.set("\\|", D));
              let yt = it;
              return !it && w.length && lt.future().text === "|" && (lt.popToken(), yt = true), {
                tokens: yt ? w : b,
                numArgs: 0
              };
            };
            u.macros.set("|", P(false)), w.length && u.macros.set("\\|", P(true));
            const J = u.consumeArg().tokens, nt = u.expandTokens([
              ...S,
              ...J,
              ...f
              // reversed
            ]);
            return u.macros.endGroup(), {
              tokens: nt.reverse(),
              numArgs: 0
            };
          };
          N("\\bra@ket", Dy(false)), N("\\bra@set", Dy(true)), N("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}"), N("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}"), N("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"), N("\\angln", "{\\angl n}"), N("\\blue", "\\textcolor{##6495ed}{#1}"), N("\\orange", "\\textcolor{##ffa500}{#1}"), N("\\pink", "\\textcolor{##ff00af}{#1}"), N("\\red", "\\textcolor{##df0030}{#1}"), N("\\green", "\\textcolor{##28ae7b}{#1}"), N("\\gray", "\\textcolor{gray}{#1}"), N("\\purple", "\\textcolor{##9d38bd}{#1}"), N("\\blueA", "\\textcolor{##ccfaff}{#1}"), N("\\blueB", "\\textcolor{##80f6ff}{#1}"), N("\\blueC", "\\textcolor{##63d9ea}{#1}"), N("\\blueD", "\\textcolor{##11accd}{#1}"), N("\\blueE", "\\textcolor{##0c7f99}{#1}"), N("\\tealA", "\\textcolor{##94fff5}{#1}"), N("\\tealB", "\\textcolor{##26edd5}{#1}"), N("\\tealC", "\\textcolor{##01d1c1}{#1}"), N("\\tealD", "\\textcolor{##01a995}{#1}"), N("\\tealE", "\\textcolor{##208170}{#1}"), N("\\greenA", "\\textcolor{##b6ffb0}{#1}"), N("\\greenB", "\\textcolor{##8af281}{#1}"), N("\\greenC", "\\textcolor{##74cf70}{#1}"), N("\\greenD", "\\textcolor{##1fab54}{#1}"), N("\\greenE", "\\textcolor{##0d923f}{#1}"), N("\\goldA", "\\textcolor{##ffd0a9}{#1}"), N("\\goldB", "\\textcolor{##ffbb71}{#1}"), N("\\goldC", "\\textcolor{##ff9c39}{#1}"), N("\\goldD", "\\textcolor{##e07d10}{#1}"), N("\\goldE", "\\textcolor{##a75a05}{#1}"), N("\\redA", "\\textcolor{##fca9a9}{#1}"), N("\\redB", "\\textcolor{##ff8482}{#1}"), N("\\redC", "\\textcolor{##f9685d}{#1}"), N("\\redD", "\\textcolor{##e84d39}{#1}"), N("\\redE", "\\textcolor{##bc2612}{#1}"), N("\\maroonA", "\\textcolor{##ffbde0}{#1}"), N("\\maroonB", "\\textcolor{##ff92c6}{#1}"), N("\\maroonC", "\\textcolor{##ed5fa6}{#1}"), N("\\maroonD", "\\textcolor{##ca337c}{#1}"), N("\\maroonE", "\\textcolor{##9e034e}{#1}"), N("\\purpleA", "\\textcolor{##ddd7ff}{#1}"), N("\\purpleB", "\\textcolor{##c6b9fc}{#1}"), N("\\purpleC", "\\textcolor{##aa87ff}{#1}"), N("\\purpleD", "\\textcolor{##7854ab}{#1}"), N("\\purpleE", "\\textcolor{##543b78}{#1}"), N("\\mintA", "\\textcolor{##f5f9e8}{#1}"), N("\\mintB", "\\textcolor{##edf2df}{#1}"), N("\\mintC", "\\textcolor{##e0e5cc}{#1}"), N("\\grayA", "\\textcolor{##f6f7f7}{#1}"), N("\\grayB", "\\textcolor{##f0f1f2}{#1}"), N("\\grayC", "\\textcolor{##e3e5e6}{#1}"), N("\\grayD", "\\textcolor{##d6d8da}{#1}"), N("\\grayE", "\\textcolor{##babec2}{#1}"), N("\\grayF", "\\textcolor{##888d93}{#1}"), N("\\grayG", "\\textcolor{##626569}{#1}"), N("\\grayH", "\\textcolor{##3b3e40}{#1}"), N("\\grayI", "\\textcolor{##21242c}{#1}"), N("\\kaBlue", "\\textcolor{##314453}{#1}"), N("\\kaGreen", "\\textcolor{##71B307}{#1}");
          const Fy = {
            "^": true,
            // Parser.js
            _: true,
            // Parser.js
            "\\limits": true,
            // Parser.js
            "\\nolimits": true
            // Parser.js
          };
          class QC {
            constructor(u, f, b) {
              this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = f, this.expansionCount = 0, this.feed(u), this.macros = new ZC(JC, f.macros), this.mode = b, this.stack = [];
            }
            /**
             * Feed a new input string to the same MacroExpander
             * (with existing macros etc.).
             */
            feed(u) {
              this.lexer = new Ey(u, this.settings);
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(u) {
              this.mode = u;
            }
            /**
             * Start a new group nesting within all namespaces.
             */
            beginGroup() {
              this.macros.beginGroup();
            }
            /**
             * End current group nesting within all namespaces.
             */
            endGroup() {
              this.macros.endGroup();
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              this.macros.endGroups();
            }
            /**
             * Returns the topmost token on the stack, without expanding it.
             * Similar in behavior to TeX's `\futurelet`.
             */
            future() {
              return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
            }
            /**
             * Remove and return the next unexpanded token.
             */
            popToken() {
              return this.future(), this.stack.pop();
            }
            /**
             * Add a given token to the token stack.  In particular, this get be used
             * to put back a token returned from one of the other methods.
             */
            pushToken(u) {
              this.stack.push(u);
            }
            /**
             * Append an array of tokens to the token stack.
             */
            pushTokens(u) {
              this.stack.push(...u);
            }
            /**
             * Find an macro argument without expanding tokens and append the array of
             * tokens to the token stack. Uses Token as a container for the result.
             */
            scanArgument(u) {
              let f, b, w;
              if (u) {
                if (this.consumeSpaces(), this.future().text !== "[")
                  return null;
                f = this.popToken(), {
                  tokens: w,
                  end: b
                } = this.consumeArg(["]"]);
              } else
                ({
                  tokens: w,
                  start: f,
                  end: b
                } = this.consumeArg());
              return this.pushToken(new on("EOF", b.loc)), this.pushTokens(w), f.range(b, "");
            }
            /**
             * Consume all following space tokens, without expansion.
             */
            consumeSpaces() {
              for (; this.future().text === " "; )
                this.stack.pop();
            }
            /**
             * Consume an argument from the token stream, and return the resulting array
             * of tokens and start/end token.
             */
            consumeArg(u) {
              const f = [], b = u && u.length > 0;
              b || this.consumeSpaces();
              const w = this.future();
              let S, E = 0, D = 0;
              do {
                if (S = this.popToken(), f.push(S), S.text === "{")
                  ++E;
                else if (S.text === "}") {
                  if (--E, E === -1)
                    throw new s("Extra }", S);
                } else if (S.text === "EOF")
                  throw new s("Unexpected end of input in a macro argument, expected '" + (u && b ? u[D] : "}") + "'", S);
                if (u && b)
                  if ((E === 0 || E === 1 && u[D] === "{") && S.text === u[D]) {
                    if (++D, D === u.length) {
                      f.splice(-D, D);
                      break;
                    }
                  } else
                    D = 0;
              } while (E !== 0 || b);
              return w.text === "{" && f[f.length - 1].text === "}" && (f.pop(), f.shift()), f.reverse(), {
                tokens: f,
                start: w,
                end: S
              };
            }
            /**
             * Consume the specified number of (delimited) arguments from the token
             * stream and return the resulting array of arguments.
             */
            consumeArgs(u, f) {
              if (f) {
                if (f.length !== u + 1)
                  throw new s("The length of delimiters doesn't match the number of args!");
                const w = f[0];
                for (let S = 0; S < w.length; S++) {
                  const E = this.popToken();
                  if (w[S] !== E.text)
                    throw new s("Use of the macro doesn't match its definition", E);
                }
              }
              const b = [];
              for (let w = 0; w < u; w++)
                b.push(this.consumeArg(f && f[w + 1]).tokens);
              return b;
            }
            /**
             * Increment `expansionCount` by the specified amount.
             * Throw an error if it exceeds `maxExpand`.
             */
            countExpansion(u) {
              if (this.expansionCount += u, this.expansionCount > this.settings.maxExpand)
                throw new s("Too many expansions: infinite loop or need to increase maxExpand setting");
            }
            /**
             * Expand the next token only once if possible.
             *
             * If the token is expanded, the resulting tokens will be pushed onto
             * the stack in reverse order, and the number of such tokens will be
             * returned.  This number might be zero or positive.
             *
             * If not, the return value is `false`, and the next token remains at the
             * top of the stack.
             *
             * In either case, the next token will be on the top of the stack,
             * or the stack will be empty (in case of empty expansion
             * and no other tokens).
             *
             * Used to implement `expandAfterFuture` and `expandNextToken`.
             *
             * If expandableOnly, only expandable tokens are expanded and
             * an undefined control sequence results in an error.
             */
            expandOnce(u) {
              const f = this.popToken(), b = f.text, w = f.noexpand ? null : this._getExpansion(b);
              if (w == null || u && w.unexpandable) {
                if (u && w == null && b[0] === "\\" && !this.isDefined(b))
                  throw new s("Undefined control sequence: " + b);
                return this.pushToken(f), false;
              }
              this.countExpansion(1);
              let S = w.tokens;
              const E = this.consumeArgs(w.numArgs, w.delimiters);
              if (w.numArgs) {
                S = S.slice();
                for (let D = S.length - 1; D >= 0; --D) {
                  let P = S[D];
                  if (P.text === "#") {
                    if (D === 0)
                      throw new s("Incomplete placeholder at end of macro body", P);
                    if (P = S[--D], P.text === "#")
                      S.splice(D + 1, 1);
                    else if (/^[1-9]$/.test(P.text))
                      S.splice(D, 2, ...E[+P.text - 1]);
                    else
                      throw new s("Not a valid argument number", P);
                  }
                }
              }
              return this.pushTokens(S), S.length;
            }
            /**
             * Expand the next token only once (if possible), and return the resulting
             * top token on the stack (without removing anything from the stack).
             * Similar in behavior to TeX's `\expandafter\futurelet`.
             * Equivalent to expandOnce() followed by future().
             */
            expandAfterFuture() {
              return this.expandOnce(), this.future();
            }
            /**
             * Recursively expand first token, then return first non-expandable token.
             */
            expandNextToken() {
              for (; ; )
                if (this.expandOnce() === false) {
                  const u = this.stack.pop();
                  return u.treatAsRelax && (u.text = "\\relax"), u;
                }
              throw new Error();
            }
            /**
             * Fully expand the given macro name and return the resulting list of
             * tokens, or return `undefined` if no such macro is defined.
             */
            expandMacro(u) {
              return this.macros.has(u) ? this.expandTokens([new on(u)]) : void 0;
            }
            /**
             * Fully expand the given token stream and return the resulting list of
             * tokens.  Note that the input tokens are in reverse order, but the
             * output tokens are in forward order.
             */
            expandTokens(u) {
              const f = [], b = this.stack.length;
              for (this.pushTokens(u); this.stack.length > b; )
                if (this.expandOnce(true) === false) {
                  const w = this.stack.pop();
                  w.treatAsRelax && (w.noexpand = false, w.treatAsRelax = false), f.push(w);
                }
              return this.countExpansion(f.length), f;
            }
            /**
             * Fully expand the given macro name and return the result as a string,
             * or return `undefined` if no such macro is defined.
             */
            expandMacroAsText(u) {
              const f = this.expandMacro(u);
              return f && f.map((b) => b.text).join("");
            }
            /**
             * Returns the expanded macro as a reversed array of tokens and a macro
             * argument count.  Or returns `null` if no such macro.
             */
            _getExpansion(u) {
              const f = this.macros.get(u);
              if (f == null)
                return f;
              if (u.length === 1) {
                const w = this.lexer.catcodes[u];
                if (w != null && w !== 13)
                  return;
              }
              const b = typeof f == "function" ? f(this) : f;
              if (typeof b == "string") {
                let w = 0;
                if (b.indexOf("#") !== -1) {
                  const P = b.replace(/##/g, "");
                  for (; P.indexOf("#" + (w + 1)) !== -1; )
                    ++w;
                }
                const S = new Ey(b, this.settings), E = [];
                let D = S.lex();
                for (; D.text !== "EOF"; )
                  E.push(D), D = S.lex();
                return E.reverse(), {
                  tokens: E,
                  numArgs: w
                };
              }
              return b;
            }
            /**
             * Determine whether a command is currently "defined" (has some
             * functionality), meaning that it's a macro (in the current group),
             * a function, a symbol, or one of the special commands listed in
             * `implicitCommands`.
             */
            isDefined(u) {
              return this.macros.has(u) || qi.hasOwnProperty(u) || pe.math.hasOwnProperty(u) || pe.text.hasOwnProperty(u) || Fy.hasOwnProperty(u);
            }
            /**
             * Determine whether a command is expandable.
             */
            isExpandable(u) {
              const f = this.macros.get(u);
              return f != null ? typeof f == "string" || typeof f == "function" || !f.unexpandable : qi.hasOwnProperty(u) && !qi[u].primitive;
            }
          }
          const Ny = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, zc = Object.freeze({
            "₊": "+",
            "₋": "-",
            "₌": "=",
            "₍": "(",
            "₎": ")",
            "₀": "0",
            "₁": "1",
            "₂": "2",
            "₃": "3",
            "₄": "4",
            "₅": "5",
            "₆": "6",
            "₇": "7",
            "₈": "8",
            "₉": "9",
            "ₐ": "a",
            "ₑ": "e",
            "ₕ": "h",
            "ᵢ": "i",
            "ⱼ": "j",
            "ₖ": "k",
            "ₗ": "l",
            "ₘ": "m",
            "ₙ": "n",
            "ₒ": "o",
            "ₚ": "p",
            "ᵣ": "r",
            "ₛ": "s",
            "ₜ": "t",
            "ᵤ": "u",
            "ᵥ": "v",
            "ₓ": "x",
            "ᵦ": "β",
            "ᵧ": "γ",
            "ᵨ": "ρ",
            "ᵩ": "ϕ",
            "ᵪ": "χ",
            "⁺": "+",
            "⁻": "-",
            "⁼": "=",
            "⁽": "(",
            "⁾": ")",
            "⁰": "0",
            "¹": "1",
            "²": "2",
            "³": "3",
            "⁴": "4",
            "⁵": "5",
            "⁶": "6",
            "⁷": "7",
            "⁸": "8",
            "⁹": "9",
            "ᴬ": "A",
            "ᴮ": "B",
            "ᴰ": "D",
            "ᴱ": "E",
            "ᴳ": "G",
            "ᴴ": "H",
            "ᴵ": "I",
            "ᴶ": "J",
            "ᴷ": "K",
            "ᴸ": "L",
            "ᴹ": "M",
            "ᴺ": "N",
            "ᴼ": "O",
            "ᴾ": "P",
            "ᴿ": "R",
            "ᵀ": "T",
            "ᵁ": "U",
            "ⱽ": "V",
            "ᵂ": "W",
            "ᵃ": "a",
            "ᵇ": "b",
            "ᶜ": "c",
            "ᵈ": "d",
            "ᵉ": "e",
            "ᶠ": "f",
            "ᵍ": "g",
            ʰ: "h",
            "ⁱ": "i",
            ʲ: "j",
            "ᵏ": "k",
            ˡ: "l",
            "ᵐ": "m",
            ⁿ: "n",
            "ᵒ": "o",
            "ᵖ": "p",
            ʳ: "r",
            ˢ: "s",
            "ᵗ": "t",
            "ᵘ": "u",
            "ᵛ": "v",
            ʷ: "w",
            ˣ: "x",
            ʸ: "y",
            "ᶻ": "z",
            "ᵝ": "β",
            "ᵞ": "γ",
            "ᵟ": "δ",
            "ᵠ": "ϕ",
            "ᵡ": "χ",
            "ᶿ": "θ"
          }), Cd = {
            "́": {
              text: "\\'",
              math: "\\acute"
            },
            "̀": {
              text: "\\`",
              math: "\\grave"
            },
            "̈": {
              text: '\\"',
              math: "\\ddot"
            },
            "̃": {
              text: "\\~",
              math: "\\tilde"
            },
            "̄": {
              text: "\\=",
              math: "\\bar"
            },
            "̆": {
              text: "\\u",
              math: "\\breve"
            },
            "̌": {
              text: "\\v",
              math: "\\check"
            },
            "̂": {
              text: "\\^",
              math: "\\hat"
            },
            "̇": {
              text: "\\.",
              math: "\\dot"
            },
            "̊": {
              text: "\\r",
              math: "\\mathring"
            },
            "̋": {
              text: "\\H"
            },
            "̧": {
              text: "\\c"
            }
          }, Iy = {
            á: "á",
            à: "à",
            ä: "ä",
            ǟ: "ǟ",
            ã: "ã",
            ā: "ā",
            ă: "ă",
            ắ: "ắ",
            ằ: "ằ",
            ẵ: "ẵ",
            ǎ: "ǎ",
            â: "â",
            ấ: "ấ",
            ầ: "ầ",
            ẫ: "ẫ",
            ȧ: "ȧ",
            ǡ: "ǡ",
            å: "å",
            ǻ: "ǻ",
            ḃ: "ḃ",
            ć: "ć",
            ḉ: "ḉ",
            č: "č",
            ĉ: "ĉ",
            ċ: "ċ",
            ç: "ç",
            ď: "ď",
            ḋ: "ḋ",
            ḑ: "ḑ",
            é: "é",
            è: "è",
            ë: "ë",
            ẽ: "ẽ",
            ē: "ē",
            ḗ: "ḗ",
            ḕ: "ḕ",
            ĕ: "ĕ",
            ḝ: "ḝ",
            ě: "ě",
            ê: "ê",
            ế: "ế",
            ề: "ề",
            ễ: "ễ",
            ė: "ė",
            ȩ: "ȩ",
            ḟ: "ḟ",
            ǵ: "ǵ",
            ḡ: "ḡ",
            ğ: "ğ",
            ǧ: "ǧ",
            ĝ: "ĝ",
            ġ: "ġ",
            ģ: "ģ",
            ḧ: "ḧ",
            ȟ: "ȟ",
            ĥ: "ĥ",
            ḣ: "ḣ",
            ḩ: "ḩ",
            í: "í",
            ì: "ì",
            ï: "ï",
            ḯ: "ḯ",
            ĩ: "ĩ",
            ī: "ī",
            ĭ: "ĭ",
            ǐ: "ǐ",
            î: "î",
            ǰ: "ǰ",
            ĵ: "ĵ",
            ḱ: "ḱ",
            ǩ: "ǩ",
            ķ: "ķ",
            ĺ: "ĺ",
            ľ: "ľ",
            ļ: "ļ",
            ḿ: "ḿ",
            ṁ: "ṁ",
            ń: "ń",
            ǹ: "ǹ",
            ñ: "ñ",
            ň: "ň",
            ṅ: "ṅ",
            ņ: "ņ",
            ó: "ó",
            ò: "ò",
            ö: "ö",
            ȫ: "ȫ",
            õ: "õ",
            ṍ: "ṍ",
            ṏ: "ṏ",
            ȭ: "ȭ",
            ō: "ō",
            ṓ: "ṓ",
            ṑ: "ṑ",
            ŏ: "ŏ",
            ǒ: "ǒ",
            ô: "ô",
            ố: "ố",
            ồ: "ồ",
            ỗ: "ỗ",
            ȯ: "ȯ",
            ȱ: "ȱ",
            ő: "ő",
            ṕ: "ṕ",
            ṗ: "ṗ",
            ŕ: "ŕ",
            ř: "ř",
            ṙ: "ṙ",
            ŗ: "ŗ",
            ś: "ś",
            ṥ: "ṥ",
            š: "š",
            ṧ: "ṧ",
            ŝ: "ŝ",
            ṡ: "ṡ",
            ş: "ş",
            ẗ: "ẗ",
            ť: "ť",
            ṫ: "ṫ",
            ţ: "ţ",
            ú: "ú",
            ù: "ù",
            ü: "ü",
            ǘ: "ǘ",
            ǜ: "ǜ",
            ǖ: "ǖ",
            ǚ: "ǚ",
            ũ: "ũ",
            ṹ: "ṹ",
            ū: "ū",
            ṻ: "ṻ",
            ŭ: "ŭ",
            ǔ: "ǔ",
            û: "û",
            ů: "ů",
            ű: "ű",
            ṽ: "ṽ",
            ẃ: "ẃ",
            ẁ: "ẁ",
            ẅ: "ẅ",
            ŵ: "ŵ",
            ẇ: "ẇ",
            ẘ: "ẘ",
            ẍ: "ẍ",
            ẋ: "ẋ",
            ý: "ý",
            ỳ: "ỳ",
            ÿ: "ÿ",
            ỹ: "ỹ",
            ȳ: "ȳ",
            ŷ: "ŷ",
            ẏ: "ẏ",
            ẙ: "ẙ",
            ź: "ź",
            ž: "ž",
            ẑ: "ẑ",
            ż: "ż",
            Á: "Á",
            À: "À",
            Ä: "Ä",
            Ǟ: "Ǟ",
            Ã: "Ã",
            Ā: "Ā",
            Ă: "Ă",
            Ắ: "Ắ",
            Ằ: "Ằ",
            Ẵ: "Ẵ",
            Ǎ: "Ǎ",
            Â: "Â",
            Ấ: "Ấ",
            Ầ: "Ầ",
            Ẫ: "Ẫ",
            Ȧ: "Ȧ",
            Ǡ: "Ǡ",
            Å: "Å",
            Ǻ: "Ǻ",
            Ḃ: "Ḃ",
            Ć: "Ć",
            Ḉ: "Ḉ",
            Č: "Č",
            Ĉ: "Ĉ",
            Ċ: "Ċ",
            Ç: "Ç",
            Ď: "Ď",
            Ḋ: "Ḋ",
            Ḑ: "Ḑ",
            É: "É",
            È: "È",
            Ë: "Ë",
            Ẽ: "Ẽ",
            Ē: "Ē",
            Ḗ: "Ḗ",
            Ḕ: "Ḕ",
            Ĕ: "Ĕ",
            Ḝ: "Ḝ",
            Ě: "Ě",
            Ê: "Ê",
            Ế: "Ế",
            Ề: "Ề",
            Ễ: "Ễ",
            Ė: "Ė",
            Ȩ: "Ȩ",
            Ḟ: "Ḟ",
            Ǵ: "Ǵ",
            Ḡ: "Ḡ",
            Ğ: "Ğ",
            Ǧ: "Ǧ",
            Ĝ: "Ĝ",
            Ġ: "Ġ",
            Ģ: "Ģ",
            Ḧ: "Ḧ",
            Ȟ: "Ȟ",
            Ĥ: "Ĥ",
            Ḣ: "Ḣ",
            Ḩ: "Ḩ",
            Í: "Í",
            Ì: "Ì",
            Ï: "Ï",
            Ḯ: "Ḯ",
            Ĩ: "Ĩ",
            Ī: "Ī",
            Ĭ: "Ĭ",
            Ǐ: "Ǐ",
            Î: "Î",
            İ: "İ",
            Ĵ: "Ĵ",
            Ḱ: "Ḱ",
            Ǩ: "Ǩ",
            Ķ: "Ķ",
            Ĺ: "Ĺ",
            Ľ: "Ľ",
            Ļ: "Ļ",
            Ḿ: "Ḿ",
            Ṁ: "Ṁ",
            Ń: "Ń",
            Ǹ: "Ǹ",
            Ñ: "Ñ",
            Ň: "Ň",
            Ṅ: "Ṅ",
            Ņ: "Ņ",
            Ó: "Ó",
            Ò: "Ò",
            Ö: "Ö",
            Ȫ: "Ȫ",
            Õ: "Õ",
            Ṍ: "Ṍ",
            Ṏ: "Ṏ",
            Ȭ: "Ȭ",
            Ō: "Ō",
            Ṓ: "Ṓ",
            Ṑ: "Ṑ",
            Ŏ: "Ŏ",
            Ǒ: "Ǒ",
            Ô: "Ô",
            Ố: "Ố",
            Ồ: "Ồ",
            Ỗ: "Ỗ",
            Ȯ: "Ȯ",
            Ȱ: "Ȱ",
            Ő: "Ő",
            Ṕ: "Ṕ",
            Ṗ: "Ṗ",
            Ŕ: "Ŕ",
            Ř: "Ř",
            Ṙ: "Ṙ",
            Ŗ: "Ŗ",
            Ś: "Ś",
            Ṥ: "Ṥ",
            Š: "Š",
            Ṧ: "Ṧ",
            Ŝ: "Ŝ",
            Ṡ: "Ṡ",
            Ş: "Ş",
            Ť: "Ť",
            Ṫ: "Ṫ",
            Ţ: "Ţ",
            Ú: "Ú",
            Ù: "Ù",
            Ü: "Ü",
            Ǘ: "Ǘ",
            Ǜ: "Ǜ",
            Ǖ: "Ǖ",
            Ǚ: "Ǚ",
            Ũ: "Ũ",
            Ṹ: "Ṹ",
            Ū: "Ū",
            Ṻ: "Ṻ",
            Ŭ: "Ŭ",
            Ǔ: "Ǔ",
            Û: "Û",
            Ů: "Ů",
            Ű: "Ű",
            Ṽ: "Ṽ",
            Ẃ: "Ẃ",
            Ẁ: "Ẁ",
            Ẅ: "Ẅ",
            Ŵ: "Ŵ",
            Ẇ: "Ẇ",
            Ẍ: "Ẍ",
            Ẋ: "Ẋ",
            Ý: "Ý",
            Ỳ: "Ỳ",
            Ÿ: "Ÿ",
            Ỹ: "Ỹ",
            Ȳ: "Ȳ",
            Ŷ: "Ŷ",
            Ẏ: "Ẏ",
            Ź: "Ź",
            Ž: "Ž",
            Ẑ: "Ẑ",
            Ż: "Ż",
            ά: "ά",
            ὰ: "ὰ",
            ᾱ: "ᾱ",
            ᾰ: "ᾰ",
            έ: "έ",
            ὲ: "ὲ",
            ή: "ή",
            ὴ: "ὴ",
            ί: "ί",
            ὶ: "ὶ",
            ϊ: "ϊ",
            ΐ: "ΐ",
            ῒ: "ῒ",
            ῑ: "ῑ",
            ῐ: "ῐ",
            ό: "ό",
            ὸ: "ὸ",
            ύ: "ύ",
            ὺ: "ὺ",
            ϋ: "ϋ",
            ΰ: "ΰ",
            ῢ: "ῢ",
            ῡ: "ῡ",
            ῠ: "ῠ",
            ώ: "ώ",
            ὼ: "ὼ",
            Ύ: "Ύ",
            Ὺ: "Ὺ",
            Ϋ: "Ϋ",
            Ῡ: "Ῡ",
            Ῠ: "Ῠ",
            Ώ: "Ώ",
            Ὼ: "Ὼ"
          };
          class qc {
            constructor(u, f) {
              this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new QC(u, f, this.mode), this.settings = f, this.leftrightDepth = 0;
            }
            /**
             * Checks a result to make sure it has the right type, and throws an
             * appropriate error otherwise.
             */
            expect(u, f) {
              if (f === void 0 && (f = true), this.fetch().text !== u)
                throw new s("Expected '" + u + "', got '" + this.fetch().text + "'", this.fetch());
              f && this.consume();
            }
            /**
             * Discards the current lookahead token, considering it consumed.
             */
            consume() {
              this.nextToken = null;
            }
            /**
             * Return the current lookahead token, or if there isn't one (at the
             * beginning, or if the previous lookahead token was consume()d),
             * fetch the next token as the new lookahead token and return it.
             */
            fetch() {
              return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(u) {
              this.mode = u, this.gullet.switchMode(u);
            }
            /**
             * Main parsing function, which parses an entire input.
             */
            parse() {
              this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
              try {
                const u = this.parseExpression(false);
                return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), u;
              } finally {
                this.gullet.endGroups();
              }
            }
            /**
             * Fully parse a separate sequence of tokens as a separate job.
             * Tokens should be specified in reverse order, as in a MacroDefinition.
             */
            subparse(u) {
              const f = this.nextToken;
              this.consume(), this.gullet.pushToken(new on("}")), this.gullet.pushTokens(u);
              const b = this.parseExpression(false);
              return this.expect("}"), this.nextToken = f, b;
            }
            /**
             * Parses an "expression", which is a list of atoms.
             *
             * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
             *                 happens when functions have higher precedence han infix
             *                 nodes in implicit parses.
             *
             * `breakOnTokenText`: The text of the token that the expression should end
             *                     with, or `null` if something else should end the
             *                     expression.
             */
            parseExpression(u, f) {
              const b = [];
              for (; ; ) {
                this.mode === "math" && this.consumeSpaces();
                const w = this.fetch();
                if (qc.endOfExpression.indexOf(w.text) !== -1 || f && w.text === f || u && qi[w.text] && qi[w.text].infix)
                  break;
                const S = this.parseAtom(f);
                if (S) {
                  if (S.type === "internal")
                    continue;
                } else break;
                b.push(S);
              }
              return this.mode === "text" && this.formLigatures(b), this.handleInfixNodes(b);
            }
            /**
             * Rewrites infix operators such as \over with corresponding commands such
             * as \frac.
             *
             * There can only be one infix operator per group.  If there's more than one
             * then the expression is ambiguous.  This can be resolved by adding {}.
             */
            handleInfixNodes(u) {
              let f = -1, b;
              for (let w = 0; w < u.length; w++)
                if (u[w].type === "infix") {
                  if (f !== -1)
                    throw new s("only one infix operator per group", u[w].token);
                  f = w, b = u[w].replaceWith;
                }
              if (f !== -1 && b) {
                let w, S;
                const E = u.slice(0, f), D = u.slice(f + 1);
                E.length === 1 && E[0].type === "ordgroup" ? w = E[0] : w = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: E
                }, D.length === 1 && D[0].type === "ordgroup" ? S = D[0] : S = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: D
                };
                let P;
                return b === "\\\\abovefrac" ? P = this.callFunction(b, [w, u[f], S], []) : P = this.callFunction(b, [w, S], []), [P];
              } else
                return u;
            }
            /**
             * Handle a subscript or superscript with nice errors.
             */
            handleSupSubscript(u) {
              const f = this.fetch(), b = f.text;
              this.consume(), this.consumeSpaces();
              let w;
              do {
                var S;
                w = this.parseGroup(u);
              } while (((S = w) == null ? void 0 : S.type) === "internal");
              if (!w)
                throw new s("Expected group after '" + b + "'", f);
              return w;
            }
            /**
             * Converts the textual input of an unsupported command into a text node
             * contained within a color node whose color is determined by errorColor
             */
            formatUnsupportedCmd(u) {
              const f = [];
              for (let w = 0; w < u.length; w++)
                f.push({
                  type: "textord",
                  mode: "text",
                  text: u[w]
                });
              const b = {
                type: "text",
                mode: this.mode,
                body: f
              };
              return {
                type: "color",
                mode: this.mode,
                color: this.settings.errorColor,
                body: [b]
              };
            }
            /**
             * Parses a group with optional super/subscripts.
             */
            parseAtom(u) {
              const f = this.parseGroup("atom", u);
              if ((f == null ? void 0 : f.type) === "internal" || this.mode === "text")
                return f;
              let b, w;
              for (; ; ) {
                this.consumeSpaces();
                const S = this.fetch();
                if (S.text === "\\limits" || S.text === "\\nolimits") {
                  if (f && f.type === "op") {
                    const E = S.text === "\\limits";
                    f.limits = E, f.alwaysHandleSupSub = true;
                  } else if (f && f.type === "operatorname")
                    f.alwaysHandleSupSub && (f.limits = S.text === "\\limits");
                  else
                    throw new s("Limit controls must follow a math operator", S);
                  this.consume();
                } else if (S.text === "^") {
                  if (b)
                    throw new s("Double superscript", S);
                  b = this.handleSupSubscript("superscript");
                } else if (S.text === "_") {
                  if (w)
                    throw new s("Double subscript", S);
                  w = this.handleSupSubscript("subscript");
                } else if (S.text === "'") {
                  if (b)
                    throw new s("Double superscript", S);
                  const E = {
                    type: "textord",
                    mode: this.mode,
                    text: "\\prime"
                  }, D = [E];
                  for (this.consume(); this.fetch().text === "'"; )
                    D.push(E), this.consume();
                  this.fetch().text === "^" && D.push(this.handleSupSubscript("superscript")), b = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: D
                  };
                } else if (zc[S.text]) {
                  const E = Ny.test(S.text), D = [];
                  for (D.push(new on(zc[S.text])), this.consume(); ; ) {
                    const J = this.fetch().text;
                    if (!zc[J] || Ny.test(J) !== E)
                      break;
                    D.unshift(new on(zc[J])), this.consume();
                  }
                  const P = this.subparse(D);
                  E ? w = {
                    type: "ordgroup",
                    mode: "math",
                    body: P
                  } : b = {
                    type: "ordgroup",
                    mode: "math",
                    body: P
                  };
                } else
                  break;
              }
              return b || w ? {
                type: "supsub",
                mode: this.mode,
                base: f,
                sup: b,
                sub: w
              } : f;
            }
            /**
             * Parses an entire function, including its base and all of its arguments.
             */
            parseFunction(u, f) {
              const b = this.fetch(), w = b.text, S = qi[w];
              if (!S)
                return null;
              if (this.consume(), f && f !== "atom" && !S.allowedInArgument)
                throw new s("Got function '" + w + "' with no arguments" + (f ? " as " + f : ""), b);
              if (this.mode === "text" && !S.allowedInText)
                throw new s("Can't use function '" + w + "' in text mode", b);
              if (this.mode === "math" && S.allowedInMath === false)
                throw new s("Can't use function '" + w + "' in math mode", b);
              const {
                args: E,
                optArgs: D
              } = this.parseArguments(w, S);
              return this.callFunction(w, E, D, b, u);
            }
            /**
             * Call a function handler with a suitable context and arguments.
             */
            callFunction(u, f, b, w, S) {
              const E = {
                funcName: u,
                parser: this,
                token: w,
                breakOnTokenText: S
              }, D = qi[u];
              if (D && D.handler)
                return D.handler(E, f, b);
              throw new s("No function handler for " + u);
            }
            /**
             * Parses the arguments of a function or environment
             */
            parseArguments(u, f) {
              const b = f.numArgs + f.numOptionalArgs;
              if (b === 0)
                return {
                  args: [],
                  optArgs: []
                };
              const w = [], S = [];
              for (let E = 0; E < b; E++) {
                let D = f.argTypes && f.argTypes[E];
                const P = E < f.numOptionalArgs;
                (f.primitive && D == null || // \sqrt expands into primitive if optional argument doesn't exist
                f.type === "sqrt" && E === 1 && S[0] == null) && (D = "primitive");
                const J = this.parseGroupOfType("argument to '" + u + "'", D, P);
                if (P)
                  S.push(J);
                else if (J != null)
                  w.push(J);
                else
                  throw new s("Null argument, please report this as a bug");
              }
              return {
                args: w,
                optArgs: S
              };
            }
            /**
             * Parses a group when the mode is changing.
             */
            parseGroupOfType(u, f, b) {
              switch (f) {
                case "color":
                  return this.parseColorGroup(b);
                case "size":
                  return this.parseSizeGroup(b);
                case "url":
                  return this.parseUrlGroup(b);
                case "math":
                case "text":
                  return this.parseArgumentGroup(b, f);
                case "hbox": {
                  const w = this.parseArgumentGroup(b, "text");
                  return w != null ? {
                    type: "styling",
                    mode: w.mode,
                    body: [w],
                    style: "text"
                    // simulate \textstyle
                  } : null;
                }
                case "raw": {
                  const w = this.parseStringGroup("raw", b);
                  return w != null ? {
                    type: "raw",
                    mode: "text",
                    string: w.text
                  } : null;
                }
                case "primitive": {
                  if (b)
                    throw new s("A primitive argument cannot be optional");
                  const w = this.parseGroup(u);
                  if (w == null)
                    throw new s("Expected group as " + u, this.fetch());
                  return w;
                }
                case "original":
                case null:
                case void 0:
                  return this.parseArgumentGroup(b);
                default:
                  throw new s("Unknown group type as " + u, this.fetch());
              }
            }
            /**
             * Discard any space tokens, fetching the next non-space token.
             */
            consumeSpaces() {
              for (; this.fetch().text === " "; )
                this.consume();
            }
            /**
             * Parses a group, essentially returning the string formed by the
             * brace-enclosed tokens plus some position information.
             */
            parseStringGroup(u, f) {
              const b = this.gullet.scanArgument(f);
              if (b == null)
                return null;
              let w = "", S;
              for (; (S = this.fetch()).text !== "EOF"; )
                w += S.text, this.consume();
              return this.consume(), b.text = w, b;
            }
            /**
             * Parses a regex-delimited group: the largest sequence of tokens
             * whose concatenated strings match `regex`. Returns the string
             * formed by the tokens plus some position information.
             */
            parseRegexGroup(u, f) {
              const b = this.fetch();
              let w = b, S = "", E;
              for (; (E = this.fetch()).text !== "EOF" && u.test(S + E.text); )
                w = E, S += w.text, this.consume();
              if (S === "")
                throw new s("Invalid " + f + ": '" + b.text + "'", b);
              return b.range(w, S);
            }
            /**
             * Parses a color description.
             */
            parseColorGroup(u) {
              const f = this.parseStringGroup("color", u);
              if (f == null)
                return null;
              const b = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(f.text);
              if (!b)
                throw new s("Invalid color: '" + f.text + "'", f);
              let w = b[0];
              return /^[0-9a-f]{6}$/i.test(w) && (w = "#" + w), {
                type: "color-token",
                mode: this.mode,
                color: w
              };
            }
            /**
             * Parses a size specification, consisting of magnitude and unit.
             */
            parseSizeGroup(u) {
              let f, b = false;
              if (this.gullet.consumeSpaces(), !u && this.gullet.future().text !== "{" ? f = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : f = this.parseStringGroup("size", u), !f)
                return null;
              !u && f.text.length === 0 && (f.text = "0pt", b = true);
              const w = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(f.text);
              if (!w)
                throw new s("Invalid size: '" + f.text + "'", f);
              const S = {
                number: +(w[1] + w[2]),
                // sign + magnitude, cast to number
                unit: w[3]
              };
              if (!bs(S))
                throw new s("Invalid unit: '" + S.unit + "'", f);
              return {
                type: "size",
                mode: this.mode,
                value: S,
                isBlank: b
              };
            }
            /**
             * Parses an URL, checking escaped letters and allowed protocols,
             * and setting the catcode of % as an active character (as in \hyperref).
             */
            parseUrlGroup(u) {
              this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
              const f = this.parseStringGroup("url", u);
              if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), f == null)
                return null;
              const b = f.text.replace(/\\([#$%&~_^{}])/g, "$1");
              return {
                type: "url",
                mode: this.mode,
                url: b
              };
            }
            /**
             * Parses an argument with the mode specified.
             */
            parseArgumentGroup(u, f) {
              const b = this.gullet.scanArgument(u);
              if (b == null)
                return null;
              const w = this.mode;
              f && this.switchMode(f), this.gullet.beginGroup();
              const S = this.parseExpression(false, "EOF");
              this.expect("EOF"), this.gullet.endGroup();
              const E = {
                type: "ordgroup",
                mode: this.mode,
                loc: b.loc,
                body: S
              };
              return f && this.switchMode(w), E;
            }
            /**
             * Parses an ordinary group, which is either a single nucleus (like "x")
             * or an expression in braces (like "{x+y}") or an implicit group, a group
             * that starts at the current position, and ends right before a higher explicit
             * group ends, or at EOF.
             */
            parseGroup(u, f) {
              const b = this.fetch(), w = b.text;
              let S;
              if (w === "{" || w === "\\begingroup") {
                this.consume();
                const E = w === "{" ? "}" : "\\endgroup";
                this.gullet.beginGroup();
                const D = this.parseExpression(false, E), P = this.fetch();
                this.expect(E), this.gullet.endGroup(), S = {
                  type: "ordgroup",
                  mode: this.mode,
                  loc: Gr.range(b, P),
                  body: D,
                  // A group formed by \begingroup...\endgroup is a semi-simple group
                  // which doesn't affect spacing in math mode, i.e., is transparent.
                  // https://tex.stackexchange.com/questions/1930/when-should-one-
                  // use-begingroup-instead-of-bgroup
                  semisimple: w === "\\begingroup" || void 0
                };
              } else if (S = this.parseFunction(f, u) || this.parseSymbol(), S == null && w[0] === "\\" && !Fy.hasOwnProperty(w)) {
                if (this.settings.throwOnError)
                  throw new s("Undefined control sequence: " + w, b);
                S = this.formatUnsupportedCmd(w), this.consume();
              }
              return S;
            }
            /**
             * Form ligature-like combinations of characters for text mode.
             * This includes inputs like "--", "---", "``" and "''".
             * The result will simply replace multiple textord nodes with a single
             * character in each value by a single textord node having multiple
             * characters in its value.  The representation is still ASCII source.
             * The group will be modified in place.
             */
            formLigatures(u) {
              let f = u.length - 1;
              for (let b = 0; b < f; ++b) {
                const w = u[b], S = w.text;
                S === "-" && u[b + 1].text === "-" && (b + 1 < f && u[b + 2].text === "-" ? (u.splice(b, 3, {
                  type: "textord",
                  mode: "text",
                  loc: Gr.range(w, u[b + 2]),
                  text: "---"
                }), f -= 2) : (u.splice(b, 2, {
                  type: "textord",
                  mode: "text",
                  loc: Gr.range(w, u[b + 1]),
                  text: "--"
                }), f -= 1)), (S === "'" || S === "`") && u[b + 1].text === S && (u.splice(b, 2, {
                  type: "textord",
                  mode: "text",
                  loc: Gr.range(w, u[b + 1]),
                  text: S + S
                }), f -= 1);
              }
            }
            /**
             * Parse a single symbol out of the string. Here, we handle single character
             * symbols and special functions like \verb.
             */
            parseSymbol() {
              const u = this.fetch();
              let f = u.text;
              if (/^\\verb[^a-zA-Z]/.test(f)) {
                this.consume();
                let S = f.slice(5);
                const E = S.charAt(0) === "*";
                if (E && (S = S.slice(1)), S.length < 2 || S.charAt(0) !== S.slice(-1))
                  throw new s(`\\verb assertion failed --
                    please report what input caused this bug`);
                return S = S.slice(1, -1), {
                  type: "verb",
                  mode: "text",
                  body: S,
                  star: E
                };
              }
              Iy.hasOwnProperty(f[0]) && !pe[this.mode][f[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + f[0] + '" used in math mode', u), f = Iy[f[0]] + f.slice(1));
              const b = YC.exec(f);
              b && (f = f.substring(0, b.index), f === "i" ? f = "ı" : f === "j" && (f = "ȷ"));
              let w;
              if (pe[this.mode][f]) {
                this.settings.strict && this.mode === "math" && He.indexOf(f) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + f[0] + '" used in math mode', u);
                const S = pe[this.mode][f].group, E = Gr.range(u);
                let D;
                if (Cc.hasOwnProperty(S)) {
                  const P = S;
                  D = {
                    type: "atom",
                    mode: this.mode,
                    family: P,
                    loc: E,
                    text: f
                  };
                } else
                  D = {
                    type: S,
                    mode: this.mode,
                    loc: E,
                    text: f
                  };
                w = D;
              } else if (f.charCodeAt(0) >= 128)
                this.settings.strict && (gt(f.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + f[0] + '" used in math mode', u) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + f[0] + '"' + (" (" + f.charCodeAt(0) + ")"), u)), w = {
                  type: "textord",
                  mode: "text",
                  loc: Gr.range(u),
                  text: f
                };
              else
                return null;
              if (this.consume(), b)
                for (let S = 0; S < b[0].length; S++) {
                  const E = b[0][S];
                  if (!Cd[E])
                    throw new s("Unknown accent ' " + E + "'", u);
                  const D = Cd[E][this.mode] || Cd[E].text;
                  if (!D)
                    throw new s("Accent " + E + " unsupported in " + this.mode + " mode", u);
                  w = {
                    type: "accent",
                    mode: this.mode,
                    loc: Gr.range(u),
                    label: D,
                    isStretchy: false,
                    isShifty: true,
                    // $FlowFixMe
                    base: w
                  };
                }
              return w;
            }
          }
          qc.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
          var _d = function(d, u) {
            if (!(typeof d == "string" || d instanceof String))
              throw new TypeError("KaTeX can only parse string typed expression");
            const f = new qc(d, u);
            delete f.gullet.macros.current["\\df@tag"];
            let b = f.parse();
            if (delete f.gullet.macros.current["\\current@color"], delete f.gullet.macros.current["\\color"], f.gullet.macros.get("\\df@tag")) {
              if (!u.displayMode)
                throw new s("\\tag works only in display equations");
              b = [{
                type: "tag",
                mode: "text",
                body: b,
                tag: f.subparse([new on("\\df@tag")])
              }];
            }
            return b;
          };
          let Oy = function(d, u, f) {
            u.textContent = "";
            const b = Sd(d, f).toNode();
            u.appendChild(b);
          };
          typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), Oy = function() {
            throw new s("KaTeX doesn't work in quirks mode.");
          });
          const t_ = function(d, u) {
            return Sd(d, u).toMarkup();
          }, e_ = function(d, u) {
            const f = new $(u);
            return _d(d, f);
          }, zy = function(d, u, f) {
            if (f.throwOnError || !(d instanceof s))
              throw d;
            const b = at.makeSpan(["katex-error"], [new Mr(u)]);
            return b.setAttribute("title", d.toString()), b.setAttribute("style", "color:" + f.errorColor), b;
          }, Sd = function(d, u) {
            const f = new $(u);
            try {
              const b = _d(d, f);
              return gC(b, d, f);
            } catch (b) {
              return zy(b, d, f);
            }
          };
          var r_ = {
            /**
             * Current KaTeX version
             */
            version: "0.16.22",
            /**
             * Renders the given LaTeX into an HTML+MathML combination, and adds
             * it as a child to the specified DOM node.
             */
            render: Oy,
            /**
             * Renders the given LaTeX into an HTML+MathML combination string,
             * for sending to the client.
             */
            renderToString: t_,
            /**
             * KaTeX error, usually during parsing.
             */
            ParseError: s,
            /**
             * The schema of Settings
             */
            SETTINGS_SCHEMA: C,
            /**
             * Parses the given LaTeX into KaTeX's internal parse tree structure,
             * without rendering to HTML or MathML.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __parse: e_,
            /**
             * Renders the given LaTeX into an HTML+MathML internal DOM tree
             * representation, without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToDomTree: Sd,
            /**
             * Renders the given LaTeX into an HTML internal DOM tree representation,
             * without MathML and without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToHTMLTree: function(d, u) {
              const f = new $(u);
              try {
                const b = _d(d, f);
                return yC(b, d, f);
              } catch (b) {
                return zy(b, d, f);
              }
            },
            /**
             * extends internal font metrics object with a new object
             * each key in the new object represents a font name
            */
            __setFontMetrics: wc,
            /**
             * adds a new symbol to builtin symbols table
             */
            __defineSymbol: v,
            /**
             * adds a new function to builtin function list,
             * which directly produce parse tree elements
             * and have their own html/mathml builders
             */
            __defineFunction: _t,
            /**
             * adds a new macro to builtin macro list
             */
            __defineMacro: N,
            /**
             * Expose the dom tree node types, which can be useful for type checking nodes.
             *
             * NOTE: These methods are not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __domTree: {
              Span: Mn,
              Anchor: _o,
              SymbolNode: Mr,
              SvgNode: we,
              PathNode: wr,
              LineNode: So
            }
          }, n_ = r_;
          return n = n.default, n;
        }()
      );
    });
  }(af)), af.exports;
}
var W2;
function $L() {
  if (W2) return ka;
  W2 = 1;
  var t15 = ka && ka.__importDefault || function(y) {
    return y && y.__esModule ? y : { default: y };
  };
  Object.defineProperty(ka, "__esModule", { value: true });
  const e = t15(TL());
  function r(y, x) {
    const k = y.src[x - 1], C = y.src[x], A = y.src[x + 1];
    if (C !== "$")
      return { can_open: false, can_close: false };
    let $ = false, B = false;
    return k !== "$" && k !== "\\" && (k === void 0 || n(k) || !i(k)) && ($ = true), A !== "$" && (A == null || n(A) || !i(A)) && (B = true), { can_open: $, can_close: B };
  }
  function n(y) {
    return /^\s$/u.test(y);
  }
  function i(y) {
    return /^[\w\d]$/u.test(y);
  }
  function s(y, x) {
    const k = y.src[x - 1], C = y.src[x], A = y.src[x + 1], $ = y.src[x + 2];
    return C === "$" && k !== "$" && k !== "\\" && A === "$" && $ !== "$" ? { can_open: true, can_close: true } : { can_open: false, can_close: false };
  }
  function a(y, x) {
    if (y.src[y.pos] !== "$")
      return false;
    const k = y.tokens.at(-1);
    if ((k == null ? void 0 : k.type) === "html_inline" && /^<\w+.+[^/]>$/.test(k.content))
      return false;
    let C = r(y, y.pos);
    if (!C.can_open)
      return x || (y.pending += "$"), y.pos += 1, true;
    let A = y.pos + 1, $ = A, B;
    for (; ($ = y.src.indexOf("$", $)) !== -1; ) {
      for (B = $ - 1; y.src[B] === "\\"; )
        B -= 1;
      if (($ - B) % 2 == 1)
        break;
      $ += 1;
    }
    if ($ === -1)
      return x || (y.pending += "$"), y.pos = A, true;
    if ($ - A === 0)
      return x || (y.pending += "$$"), y.pos = A + 1, true;
    if (C = r(y, $), !C.can_close)
      return x || (y.pending += "$"), y.pos = A, true;
    if (!x) {
      const L = y.push("math_inline", "math", 0);
      L.markup = "$", L.content = y.src.slice(A, $);
    }
    return y.pos = $ + 1, true;
  }
  function o(y, x, k, C) {
    let A = false, $ = y.bMarks[x] + y.tShift[x], B = y.eMarks[x];
    if ($ + 2 > B || y.src.slice($, $ + 2) !== "$$")
      return false;
    $ += 2;
    let L = y.src.slice($, B);
    const q = [...L.matchAll(/\$\$/g)];
    if (q.length === 1 && q[0].index === L.length - 2)
      L = L.trim().slice(0, -2), A = true;
    else if (q.length > 1)
      return false;
    if (C)
      return true;
    let U, G, F;
    for (G = x; !A && (G++, !(G >= k || ($ = y.bMarks[G] + y.tShift[G], B = y.eMarks[G], $ < B && y.tShift[G] < y.blkIndent))); )
      y.src.slice($, B).trim().slice(-2) === "$$" ? (F = y.src.slice(0, B).lastIndexOf("$$"), U = y.src.slice($, F), A = true) : y.src.slice($, B).trim().includes("$$") && (F = y.src.slice(0, B).trim().indexOf("$$"), U = y.src.slice($, F), A = true);
    y.line = G + 1;
    const W = y.push("math_block", "math", 0);
    return W.block = true, W.content = (L && L.trim() ? L + `
` : "") + y.getLines(x + 1, G, y.tShift[x], true) + (U && U.trim() ? U : ""), W.map = [x, y.line], W.markup = "$$", true;
  }
  function l(y, x, k, C) {
    const A = y.bMarks[x] + y.tShift[x], $ = y.eMarks[x];
    if (!y.src.slice(A, $).match(/^\s*\\begin\s*\{([^{}]+)\}/))
      return false;
    if (x > 0) {
      const F = y.bMarks[x - 1] + y.tShift[x - 1], W = y.eMarks[x - 1], R = y.src.slice(F, W);
      if (!/^\s*$/.test(R))
        return false;
    }
    if (C)
      return true;
    const B = [];
    let L = x, q, U = false;
    t: for (; !U && !(L >= k); L++) {
      const F = y.bMarks[L] + y.tShift[L], W = y.eMarks[L];
      if (F < W && y.tShift[L] < y.blkIndent)
        break;
      const R = y.src.slice(F, W);
      for (const Q of R.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
        if (Q[1] === "\\begin")
          B.push(Q[2].trim());
        else if (Q[1] === "\\end" && (B.pop(), !B.length)) {
          q = y.src.slice(F, W), U = true;
          break t;
        }
    }
    y.line = L + 1;
    const G = y.push("math_block", "math", 0);
    return G.block = true, G.content = (y.getLines(x, L, y.tShift[x], true) + (q ?? "")).trim(), G.map = [x, y.line], G.markup = "$$", true;
  }
  function c(y, x) {
    var k, C, A, $, B;
    if (y.src.slice(y.pos, y.pos + 2) !== "$$")
      return false;
    if ($ = s(y, y.pos), !$.can_open)
      return x || (y.pending += "$$"), y.pos += 2, true;
    for (k = y.pos + 2, C = k; (C = y.src.indexOf("$$", C)) !== -1; ) {
      for (B = C - 1; y.src[B] === "\\"; )
        B -= 1;
      if ((C - B) % 2 == 1)
        break;
      C += 2;
    }
    return C === -1 ? (x || (y.pending += "$$"), y.pos = k, true) : C - k === 0 ? (x || (y.pending += "$$$$"), y.pos = k + 2, true) : ($ = s(y, C), $.can_close ? (x || (A = y.push("math_block", "math", 0), A.block = true, A.markup = "$$", A.content = y.src.slice(k, C)), y.pos = C + 2, true) : (x || (y.pending += "$$"), y.pos = k, true));
  }
  function h(y, x) {
    const k = y.src.slice(y.pos);
    if (!/^\n\\begin/.test(k))
      return false;
    if (y.pos += 1, x)
      return true;
    const C = k.split(/\n/g).slice(1);
    let A;
    const $ = [];
    t: for (var B = 0; B < C.length; ++B) {
      const U = C[B];
      for (const G of U.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
        if (G[1] === "\\begin")
          $.push(G[2].trim());
        else if (G[1] === "\\end" && ($.pop(), !$.length)) {
          A = B;
          break t;
        }
    }
    if (typeof A > "u")
      return false;
    const L = C.slice(0, A + 1).reduce((U, G) => U + G.length, 0) + A + 1, q = y.push("math_inline_bare_block", "math", 0);
    return q.block = true, q.markup = "$$", q.content = k.slice(1, L), y.pos = y.pos + L, true;
  }
  function p(y, x, k, C) {
    const A = y.tokens;
    for (let $ = A.length - 1; $ >= 0; $--) {
      const B = A[$], L = [];
      if (B.type !== "html_block")
        continue;
      const q = B.content;
      for (const U of q.matchAll(C)) {
        if (!U.groups)
          continue;
        const G = U.groups.html_before_math, F = U.groups.math, W = U.groups.html_after_math;
        G && L.push({ ...B, type: "html_block", map: null, content: G }), F && L.push({
          ...B,
          type: x,
          map: null,
          content: F,
          markup: k,
          block: true,
          tag: "math"
        }), W && L.push({ ...B, type: "html_block", map: null, content: W });
      }
      L.length > 0 && A.splice($, 1, ...L);
    }
    return true;
  }
  function m(y) {
    return y.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  function g(y, x) {
    const k = (x == null ? void 0 : x.katex) ?? e.default, C = x == null ? void 0 : x.enableBareBlocks, A = x == null ? void 0 : x.enableMathBlockInHtml, $ = x == null ? void 0 : x.enableMathInlineInHtml, B = x == null ? void 0 : x.enableFencedBlocks;
    y.inline.ruler.after("escape", "math_inline", a), y.inline.ruler.after("escape", "math_inline_block", c), C && y.inline.ruler.before("text", "math_inline_bare_block", h), y.block.ruler.after("blockquote", "math_block", (R, Q, rt, I) => C && l(R, Q, rt, I) ? true : o(R, Q, rt, I), {
      alt: ["paragraph", "reference", "blockquote", "list"]
    });
    const L = /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm, q = /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
    A && y.core.ruler.push("math_block_in_html_block", (R) => p(R, "math_block", "$$", L)), $ && y.core.ruler.push("math_inline_in_html_block", (R) => p(R, "math_inline", "$", q));
    const U = (R) => {
      const Q = /\\begin\{(align|equation|gather|cd|alignat)\}/ig.test(R);
      try {
        return k.renderToString(R, { ...x, displayMode: Q });
      } catch (rt) {
        return (x == null ? void 0 : x.throwOnError) && console.log(rt), `<span class="katex-error" title="${m(R)}">${m(rt + "")}</span>`;
      }
    }, G = (R, Q) => {
      const rt = R[Q].content, I = rt.length > 2 && rt[0] === "`" && rt[rt.length - 1] === "`" ? rt.slice(1, -1) : rt;
      return U(I);
    }, F = (R) => {
      try {
        return `<p class="katex-block">${k.renderToString(R, { ...x, displayMode: true })}</p>`;
      } catch (Q) {
        return (x == null ? void 0 : x.throwOnError) && console.log(Q), `<p class="katex-block katex-error" title="${m(R)}">${m(Q + "")}</p>`;
      }
    }, W = (R, Q) => F(R[Q].content) + `
`;
    if (y.renderer.rules.math_inline = G, y.renderer.rules.math_inline_block = W, y.renderer.rules.math_inline_bare_block = W, y.renderer.rules.math_block = W, B) {
      const R = "math", Q = y.renderer.rules.fence;
      y.renderer.rules.fence = function(rt, I, j, z, K) {
        const Y = rt[I];
        return Y.info.trim().toLowerCase() === R && B ? F(Y.content) + `
` : (Q == null ? void 0 : Q.call(this, rt, I, j, z, K)) || "";
      };
    }
  }
  return ka.default = g, ka;
}
var EL = $L();
var ML = SL(EL);
function BL() {
  const t15 = mn({
    html: true,
    breaks: true
  });
  return t15.use(aB).use(oB).use(hB).use(pB), t15;
}
function LL(t15) {
  return {
    transformer: t15,
    parser: new Zo(),
    beforeParse: new Zo(),
    afterParse: new Zo(),
    retransform: new Zo()
  };
}
var DL = `<svg width="16" height="16" viewBox="0 -3 24 24"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"/></svg>
`;
var FL = `<svg width="16" height="16" viewBox="0 -3 24 24"><path fill-rule="evenodd" d="M6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1zM3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-5z" clip-rule="evenodd"/></svg>
`;
var NL = "checkbox";
var H2 = {
  " ": FL.trim(),
  x: DL.trim()
};
var IL = {
  name: NL,
  transform(t15) {
    return t15.parser.tap((e) => {
      e.core.ruler.before("inline", "checkbox", (r) => {
        for (let n = 2; n < r.tokens.length; n += 1) {
          const i = r.tokens[n];
          if (i.type === "inline" && i.content) {
            const s = r.tokens[n - 1].type, a = r.tokens[n - 2].type;
            (s === "heading_open" || s === "paragraph_open" && a === "list_item_open") && (i.content = i.content.replace(
              /^\[(.)\] /,
              (o, l) => H2[l] ? `${H2[l]} ` : o
            ));
          }
        }
        return false;
      });
    }), {};
  }
};
var OL = "frontmatter";
var zL = {
  name: OL,
  transform(t15) {
    return t15.beforeParse.tap((e, r) => {
      var n;
      const { content: i } = r;
      if (!/^---\r?\n/.test(i)) return;
      const s = /\n---\r?\n/.exec(i);
      if (!s) return;
      const a = i.slice(4, s.index).trimEnd();
      let o;
      try {
        o = _L(a.replace(/\r?\n|\r/g, `
`)), (o == null ? void 0 : o.markmap) && (o.markmap = qL(
          o.markmap
        ));
      } catch {
        return;
      }
      r.frontmatter = o, r.parserOptions = {
        ...r.parserOptions,
        ...(n = o == null ? void 0 : o.markmap) == null ? void 0 : n.htmlParser
      }, r.frontmatterInfo = {
        lines: i.slice(0, s.index).split(`
`).length + 1,
        offset: s.index + s[0].length
      };
    }), {};
  }
};
function qL(t15) {
  if (t15)
    return ["color", "extraJs", "extraCss"].forEach((e) => {
      t15[e] != null && (t15[e] = RL(t15[e]));
    }), ["duration", "maxWidth", "initialExpandLevel"].forEach((e) => {
      t15[e] != null && (t15[e] = PL(t15[e]));
    }), t15;
}
function RL(t15) {
  let e;
  return typeof t15 == "string" ? e = [t15] : Array.isArray(t15) && (e = t15.filter((r) => r && typeof r == "string")), (e == null ? void 0 : e.length) ? e : void 0;
}
function PL(t15) {
  if (!isNaN(+t15))
    return +t15;
}
function cm(t15, e) {
  return e.type === "script" && e.data.src ? {
    ...e,
    data: {
      ...e.data,
      src: t15.getFullUrl(e.data.src)
    }
  } : e;
}
function jL(t15, e) {
  return e.type === "stylesheet" && e.data.href ? {
    ...e,
    data: {
      ...e.data,
      href: t15.getFullUrl(e.data.href)
    }
  } : e;
}
var U2 = "hljs";
var WL = [
  "@highlightjs/cdn-assets@11.11.1/highlight.min.js"
].map((t15) => S1(t15));
var HL = [
  "@highlightjs/cdn-assets@11.11.1/styles/default.min.css"
].map((t15) => g5(t15));
var UL = {
  versions: {
    hljs: "11.11.1"
  },
  preloadScripts: WL,
  styles: HL
};
var of = {
  name: U2,
  config: UL,
  transform(t15) {
    var e, r, n;
    let i;
    const s = ((r = (e = of.config) == null ? void 0 : e.preloadScripts) == null ? void 0 : r.map(
      (l) => cm(t15.transformer.urlBuilder, l)
    )) || [], a = () => (i || (i = m5(s)), i);
    let o = Ta;
    return t15.parser.tap((l) => {
      l.set({
        highlight: (c, h) => {
          o();
          const { hljs: p } = window;
          return p ? p.highlightAuto(c, h ? [h] : void 0).value : (a().then(() => {
            t15.retransform.call();
          }), c);
        }
      });
    }), t15.beforeParse.tap((l, c) => {
      o = () => {
        c.features[U2] = true;
      };
    }), {
      styles: (n = of.config) == null ? void 0 : n.styles
    };
  }
};
function VL(t15, e, r) {
  return t15.map((n) => {
    if (typeof n == "string" && !n.includes("://")) {
      n.startsWith("npm:") || (n = `npm:${n}`);
      const i = 4 + e.length;
      n.startsWith(`npm:${e}/`) && (n = `${n.slice(0, i)}@${r}${n.slice(
        i
      )}`);
    }
    return n;
  });
}
var GL = ["katex@0.16.18/dist/fonts/KaTeX_AMS-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Script-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size1-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size2-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size3-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size4-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Typewriter-Regular.woff2"];
var Xd = "katex";
var XL = [
  "katex@0.16.18/dist/katex.min.js"
].map((t15) => S1(t15));
var k3 = S1(
  "webfontloader@1.6.28/webfontloader.js"
);
k3.data.defer = true;
var YL = ["katex@0.16.18/dist/katex.min.css"].map(
  (t15) => g5(t15)
);
var KL = {
  versions: {
    katex: "0.16.18",
    webfontloader: "1.6.28"
  },
  preloadScripts: XL,
  scripts: [
    {
      type: "iife",
      data: {
        fn: (t15) => {
          window.WebFontConfig = {
            custom: {
              families: [
                "KaTeX_AMS",
                "KaTeX_Caligraphic:n4,n7",
                "KaTeX_Fraktur:n4,n7",
                "KaTeX_Main:n4,n7,i4,i7",
                "KaTeX_Math:i4,i7",
                "KaTeX_Script",
                "KaTeX_SansSerif:n4,n7,i4",
                "KaTeX_Size1",
                "KaTeX_Size2",
                "KaTeX_Size3",
                "KaTeX_Size4",
                "KaTeX_Typewriter"
              ]
            },
            active: () => {
              t15().refreshHook.call();
            }
          };
        },
        getParams({ getMarkmap: t15 }) {
          return [t15];
        }
      }
    },
    k3
  ],
  styles: YL,
  resources: GL
};
function ZL(t15) {
  return t15.default || t15;
}
var JL = ZL(ML);
var el = {
  name: Xd,
  config: KL,
  transform(t15) {
    var e, r, n, i;
    let s;
    const a = ((r = (e = el.config) == null ? void 0 : e.preloadScripts) == null ? void 0 : r.map(
      (h) => cm(t15.transformer.urlBuilder, h)
    )) || [], o = () => (s || (s = m5(a)), s), l = (h, p) => {
      const { katex: m } = window;
      return m ? m.renderToString(h, {
        displayMode: p,
        throwOnError: false
      }) : (o().then(() => {
        t15.retransform.call();
      }), h);
    };
    let c = Ta;
    return t15.parser.tap((h) => {
      h.use(JL), ["math_block", "math_inline"].forEach((p) => {
        const m = (g, y) => (c(), l(g[y].content, !!g[y].block));
        h.renderer.rules[p] = m;
      });
    }), t15.beforeParse.tap((h, p) => {
      c = () => {
        p.features[Xd] = true;
      };
    }), t15.afterParse.tap((h, p) => {
      var m;
      const g = (m = p.frontmatter) == null ? void 0 : m.markmap;
      g && ["extraJs", "extraCss"].forEach((y) => {
        var x, k;
        const C = g[y];
        C && (g[y] = VL(
          C,
          Xd,
          ((k = (x = el.config) == null ? void 0 : x.versions) == null ? void 0 : k.katex) || ""
        ));
      });
    }), {
      styles: (n = el.config) == null ? void 0 : n.styles,
      scripts: (i = el.config) == null ? void 0 : i.scripts
    };
  }
};
var QL = "npmUrl";
var tD = {
  name: QL,
  transform(t15) {
    return t15.afterParse.tap((e, r) => {
      const { frontmatter: n } = r, i = n == null ? void 0 : n.markmap;
      i && ["extraJs", "extraCss"].forEach((s) => {
        const a = i[s];
        a && (i[s] = a.map((o) => o.startsWith("npm:") ? t15.transformer.urlBuilder.getFullUrl(
          o.slice(4)
        ) : o));
      });
    }), {};
  }
};
var eD = "sourceLines";
var rD = {
  name: eD,
  transform(t15) {
    let e = 0;
    return t15.beforeParse.tap((r, n) => {
      var i;
      e = ((i = n.frontmatterInfo) == null ? void 0 : i.lines) || 0;
    }), t15.parser.tap((r) => {
      r.renderer.renderAttrs = jy(
        r.renderer.renderAttrs,
        (n, i) => {
          if (i.block && i.map) {
            const s = i.map.map((a) => a + e);
            i.attrSet("data-lines", s.join(","));
          }
          return n(i);
        }
      ), r.renderer.rules.fence && (r.renderer.rules.fence = jy(
        r.renderer.rules.fence,
        (n, i, s, ...a) => {
          let o = n(i, s, ...a);
          const l = i[s];
          if (o.startsWith("<pre>") && l.map) {
            const c = l.map.map(
              (h) => h + e
            );
            o = o.slice(0, 4) + ` data-lines="${c.join(",")}"` + o.slice(4);
          }
          return o;
        }
      ));
    }), {};
  }
};
var nD = [
  zL,
  el,
  of,
  tD,
  IL,
  rD
];
var iD = nD;
function v3(t15) {
  for (; !t15.content && t15.children.length === 1; )
    t15 = t15.children[0];
  for (; t15.children.length === 1 && !t15.children[0].content; )
    t15 = {
      ...t15,
      children: t15.children[0].children
    };
  return {
    ...t15,
    children: t15.children.map(v3)
  };
}
var sD = class {
  constructor(e = iD) {
    this.assetsMap = {}, this.urlBuilder = new d_(), this.hooks = LL(this), this.plugins = e.map(
      (i) => typeof i == "function" ? i() : i
    );
    const r = {};
    for (const { name: i, transform: s } of this.plugins)
      r[i] = s(this.hooks);
    this.assetsMap = r;
    const n = BL();
    this.md = n, this.hooks.parser.call(n);
  }
  transform(e, r) {
    var n;
    const i = {
      content: e,
      features: {},
      parserOptions: r
    };
    this.hooks.beforeParse.call(this.md, i);
    let { content: s } = i;
    i.frontmatterInfo && (s = s.slice(i.frontmatterInfo.offset));
    const a = this.md.render(s, {});
    this.hooks.afterParse.call(this.md, i);
    const o = v3(w$(a, i.parserOptions));
    return o.content || (o.content = `${((n = i.frontmatter) == null ? void 0 : n.title) || ""}`), { ...i, root: o };
  }
  resolveJS(e) {
    return cm(this.urlBuilder, e);
  }
  resolveCSS(e) {
    return jL(this.urlBuilder, e);
  }
  /**
   * Get all assets from enabled plugins or filter them by plugin names as keys.
   */
  getAssets(e) {
    const r = [], n = [];
    e ?? (e = this.plugins.map((i) => i.name));
    for (const i of e.map((s) => this.assetsMap[s]))
      i && (i.styles && r.push(...i.styles), i.scripts && n.push(...i.scripts));
    return {
      styles: r.map((i) => this.resolveCSS(i)),
      scripts: n.map((i) => this.resolveJS(i))
    };
  }
  /**
   * Get used assets by features object returned by `transform`.
   */
  getUsedAssets(e) {
    const r = this.plugins.map((n) => n.name).filter((n) => e[n]);
    return this.getAssets(r);
  }
};
var V2 = class extends Map {
  constructor(e, r = lD) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), e != null) for (const [n, i] of e) this.set(n, i);
  }
  get(e) {
    return super.get(G2(this, e));
  }
  has(e) {
    return super.has(G2(this, e));
  }
  set(e, r) {
    return super.set(aD(this, e), r);
  }
  delete(e) {
    return super.delete(oD(this, e));
  }
};
function G2({ _intern: t15, _key: e }, r) {
  const n = e(r);
  return t15.has(n) ? t15.get(n) : r;
}
function aD({ _intern: t15, _key: e }, r) {
  const n = e(r);
  return t15.has(n) ? t15.get(n) : (t15.set(n, r), r);
}
function oD({ _intern: t15, _key: e }, r) {
  const n = e(r);
  return t15.has(n) && (r = t15.get(n), t15.delete(n)), r;
}
function lD(t15) {
  return t15 !== null && typeof t15 == "object" ? t15.valueOf() : t15;
}
function X2(t15, e) {
  let r;
  if (e === void 0)
    for (const n of t15)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t15)
      (i = e(i, ++n, t15)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Y2(t15, e) {
  let r;
  if (e === void 0)
    for (const n of t15)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t15)
      (i = e(i, ++n, t15)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function cD(t15, e) {
  let r, n = -1, i = -1;
  if (e === void 0)
    for (const s of t15)
      ++i, s != null && (r > s || r === void 0 && s >= s) && (r = s, n = i);
  else
    for (let s of t15)
      (s = e(s, ++i, t15)) != null && (r > s || r === void 0 && s >= s) && (r = s, n = i);
  return n;
}
var hD = { value: () => {
} };
function hm() {
  for (var t15 = 0, e = arguments.length, r = {}, n; t15 < e; ++t15) {
    if (!(n = arguments[t15] + "") || n in r || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new vh(r);
}
function vh(t15) {
  this._ = t15;
}
function uD(t15, e) {
  return t15.trim().split(/^|\s+/).map(function(r) {
    var n = "", i = r.indexOf(".");
    if (i >= 0 && (n = r.slice(i + 1), r = r.slice(0, i)), r && !e.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
vh.prototype = hm.prototype = {
  constructor: vh,
  on: function(t15, e) {
    var r = this._, n = uD(t15 + "", r), i, s = -1, a = n.length;
    if (arguments.length < 2) {
      for (; ++s < a; ) if ((i = (t15 = n[s]).type) && (i = dD(r[i], t15.name))) return i;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++s < a; )
      if (i = (t15 = n[s]).type) r[i] = K2(r[i], t15.name, e);
      else if (e == null) for (i in r) r[i] = K2(r[i], t15.name, null);
    return this;
  },
  copy: function() {
    var t15 = {}, e = this._;
    for (var r in e) t15[r] = e[r].slice();
    return new vh(t15);
  },
  call: function(t15, e) {
    if ((i = arguments.length - 2) > 0) for (var r = new Array(i), n = 0, i, s; n < i; ++n) r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(t15)) throw new Error("unknown type: " + t15);
    for (s = this._[t15], n = 0, i = s.length; n < i; ++n) s[n].value.apply(e, r);
  },
  apply: function(t15, e, r) {
    if (!this._.hasOwnProperty(t15)) throw new Error("unknown type: " + t15);
    for (var n = this._[t15], i = 0, s = n.length; i < s; ++i) n[i].value.apply(e, r);
  }
};
function dD(t15, e) {
  for (var r = 0, n = t15.length, i; r < n; ++r)
    if ((i = t15[r]).name === e)
      return i.value;
}
function K2(t15, e, r) {
  for (var n = 0, i = t15.length; n < i; ++n)
    if (t15[n].name === e) {
      t15[n] = hD, t15 = t15.slice(0, n).concat(t15.slice(n + 1));
      break;
    }
  return r != null && t15.push({ name: e, value: r }), t15;
}
var lf = "http://www.w3.org/1999/xhtml";
var Z2 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: lf,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function fu(t15) {
  var e = t15 += "", r = e.indexOf(":");
  return r >= 0 && (e = t15.slice(0, r)) !== "xmlns" && (t15 = t15.slice(r + 1)), Z2.hasOwnProperty(e) ? { space: Z2[e], local: t15 } : t15;
}
function pD(t15) {
  return function() {
    var e = this.ownerDocument, r = this.namespaceURI;
    return r === lf && e.documentElement.namespaceURI === lf ? e.createElement(t15) : e.createElementNS(r, t15);
  };
}
function fD(t15) {
  return function() {
    return this.ownerDocument.createElementNS(t15.space, t15.local);
  };
}
function C3(t15) {
  var e = fu(t15);
  return (e.local ? fD : pD)(e);
}
function mD() {
}
function um(t15) {
  return t15 == null ? mD : function() {
    return this.querySelector(t15);
  };
}
function gD(t15) {
  typeof t15 != "function" && (t15 = um(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = new Array(a), l, c, h = 0; h < a; ++h)
      (l = s[h]) && (c = t15.call(l, l.__data__, h, s)) && ("__data__" in l && (c.__data__ = l.__data__), o[h] = c);
  return new tn(n, this._parents);
}
function yD(t15) {
  return t15 == null ? [] : Array.isArray(t15) ? t15 : Array.from(t15);
}
function bD() {
  return [];
}
function _3(t15) {
  return t15 == null ? bD : function() {
    return this.querySelectorAll(t15);
  };
}
function xD(t15) {
  return function() {
    return yD(t15.apply(this, arguments));
  };
}
function wD(t15) {
  typeof t15 == "function" ? t15 = xD(t15) : t15 = _3(t15);
  for (var e = this._groups, r = e.length, n = [], i = [], s = 0; s < r; ++s)
    for (var a = e[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && (n.push(t15.call(l, l.__data__, c, a)), i.push(l));
  return new tn(n, i);
}
function S3(t15) {
  return function() {
    return this.matches(t15);
  };
}
function A3(t15) {
  return function(e) {
    return e.matches(t15);
  };
}
var kD = Array.prototype.find;
function vD(t15) {
  return function() {
    return kD.call(this.children, t15);
  };
}
function CD() {
  return this.firstElementChild;
}
function _D(t15) {
  return this.select(t15 == null ? CD : vD(typeof t15 == "function" ? t15 : A3(t15)));
}
var SD = Array.prototype.filter;
function AD() {
  return Array.from(this.children);
}
function TD(t15) {
  return function() {
    return SD.call(this.children, t15);
  };
}
function $D(t15) {
  return this.selectAll(t15 == null ? AD : TD(typeof t15 == "function" ? t15 : A3(t15)));
}
function ED(t15) {
  typeof t15 != "function" && (t15 = S3(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && t15.call(l, l.__data__, c, s) && o.push(l);
  return new tn(n, this._parents);
}
function T3(t15) {
  return new Array(t15.length);
}
function MD() {
  return new tn(this._enter || this._groups.map(T3), this._parents);
}
function a0(t15, e) {
  this.ownerDocument = t15.ownerDocument, this.namespaceURI = t15.namespaceURI, this._next = null, this._parent = t15, this.__data__ = e;
}
a0.prototype = {
  constructor: a0,
  appendChild: function(t15) {
    return this._parent.insertBefore(t15, this._next);
  },
  insertBefore: function(t15, e) {
    return this._parent.insertBefore(t15, e);
  },
  querySelector: function(t15) {
    return this._parent.querySelector(t15);
  },
  querySelectorAll: function(t15) {
    return this._parent.querySelectorAll(t15);
  }
};
function BD(t15) {
  return function() {
    return t15;
  };
}
function LD(t15, e, r, n, i, s) {
  for (var a = 0, o, l = e.length, c = s.length; a < c; ++a)
    (o = e[a]) ? (o.__data__ = s[a], n[a] = o) : r[a] = new a0(t15, s[a]);
  for (; a < l; ++a)
    (o = e[a]) && (i[a] = o);
}
function DD(t15, e, r, n, i, s, a) {
  var o, l, c = /* @__PURE__ */ new Map(), h = e.length, p = s.length, m = new Array(h), g;
  for (o = 0; o < h; ++o)
    (l = e[o]) && (m[o] = g = a.call(l, l.__data__, o, e) + "", c.has(g) ? i[o] = l : c.set(g, l));
  for (o = 0; o < p; ++o)
    g = a.call(t15, s[o], o, s) + "", (l = c.get(g)) ? (n[o] = l, l.__data__ = s[o], c.delete(g)) : r[o] = new a0(t15, s[o]);
  for (o = 0; o < h; ++o)
    (l = e[o]) && c.get(m[o]) === l && (i[o] = l);
}
function FD(t15) {
  return t15.__data__;
}
function ND(t15, e) {
  if (!arguments.length) return Array.from(this, FD);
  var r = e ? DD : LD, n = this._parents, i = this._groups;
  typeof t15 != "function" && (t15 = BD(t15));
  for (var s = i.length, a = new Array(s), o = new Array(s), l = new Array(s), c = 0; c < s; ++c) {
    var h = n[c], p = i[c], m = p.length, g = ID(t15.call(h, h && h.__data__, c, n)), y = g.length, x = o[c] = new Array(y), k = a[c] = new Array(y), C = l[c] = new Array(m);
    r(h, p, x, k, C, g, e);
    for (var A = 0, $ = 0, B, L; A < y; ++A)
      if (B = x[A]) {
        for (A >= $ && ($ = A + 1); !(L = k[$]) && ++$ < y; ) ;
        B._next = L || null;
      }
  }
  return a = new tn(a, n), a._enter = o, a._exit = l, a;
}
function ID(t15) {
  return typeof t15 == "object" && "length" in t15 ? t15 : Array.from(t15);
}
function OD() {
  return new tn(this._exit || this._groups.map(T3), this._parents);
}
function zD(t15, e, r) {
  var n = this.enter(), i = this, s = this.exit();
  return typeof t15 == "function" ? (n = t15(n), n && (n = n.selection())) : n = n.append(t15 + ""), e != null && (i = e(i), i && (i = i.selection())), r == null ? s.remove() : r(s), n && i ? n.merge(i).order() : i;
}
function qD(t15) {
  for (var e = t15.selection ? t15.selection() : t15, r = this._groups, n = e._groups, i = r.length, s = n.length, a = Math.min(i, s), o = new Array(i), l = 0; l < a; ++l)
    for (var c = r[l], h = n[l], p = c.length, m = o[l] = new Array(p), g, y = 0; y < p; ++y)
      (g = c[y] || h[y]) && (m[y] = g);
  for (; l < i; ++l)
    o[l] = r[l];
  return new tn(o, this._parents);
}
function RD() {
  for (var t15 = this._groups, e = -1, r = t15.length; ++e < r; )
    for (var n = t15[e], i = n.length - 1, s = n[i], a; --i >= 0; )
      (a = n[i]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function PD(t15) {
  t15 || (t15 = jD);
  function e(p, m) {
    return p && m ? t15(p.__data__, m.__data__) : !p - !m;
  }
  for (var r = this._groups, n = r.length, i = new Array(n), s = 0; s < n; ++s) {
    for (var a = r[s], o = a.length, l = i[s] = new Array(o), c, h = 0; h < o; ++h)
      (c = a[h]) && (l[h] = c);
    l.sort(e);
  }
  return new tn(i, this._parents).order();
}
function jD(t15, e) {
  return t15 < e ? -1 : t15 > e ? 1 : t15 >= e ? 0 : NaN;
}
function WD() {
  var t15 = arguments[0];
  return arguments[0] = this, t15.apply(null, arguments), this;
}
function HD() {
  return Array.from(this);
}
function UD() {
  for (var t15 = this._groups, e = 0, r = t15.length; e < r; ++e)
    for (var n = t15[e], i = 0, s = n.length; i < s; ++i) {
      var a = n[i];
      if (a) return a;
    }
  return null;
}
function VD() {
  let t15 = 0;
  for (const e of this) ++t15;
  return t15;
}
function GD() {
  return !this.node();
}
function XD(t15) {
  for (var e = this._groups, r = 0, n = e.length; r < n; ++r)
    for (var i = e[r], s = 0, a = i.length, o; s < a; ++s)
      (o = i[s]) && t15.call(o, o.__data__, s, i);
  return this;
}
function YD(t15) {
  return function() {
    this.removeAttribute(t15);
  };
}
function KD(t15) {
  return function() {
    this.removeAttributeNS(t15.space, t15.local);
  };
}
function ZD(t15, e) {
  return function() {
    this.setAttribute(t15, e);
  };
}
function JD(t15, e) {
  return function() {
    this.setAttributeNS(t15.space, t15.local, e);
  };
}
function QD(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttribute(t15) : this.setAttribute(t15, r);
  };
}
function tF(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttributeNS(t15.space, t15.local) : this.setAttributeNS(t15.space, t15.local, r);
  };
}
function eF(t15, e) {
  var r = fu(t15);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((e == null ? r.local ? KD : YD : typeof e == "function" ? r.local ? tF : QD : r.local ? JD : ZD)(r, e));
}
function $3(t15) {
  return t15.ownerDocument && t15.ownerDocument.defaultView || t15.document && t15 || t15.defaultView;
}
function rF(t15) {
  return function() {
    this.style.removeProperty(t15);
  };
}
function nF(t15, e, r) {
  return function() {
    this.style.setProperty(t15, e, r);
  };
}
function iF(t15, e, r) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(t15) : this.style.setProperty(t15, n, r);
  };
}
function sF(t15, e, r) {
  return arguments.length > 1 ? this.each((e == null ? rF : typeof e == "function" ? iF : nF)(t15, e, r ?? "")) : Ga(this.node(), t15);
}
function Ga(t15, e) {
  return t15.style.getPropertyValue(e) || $3(t15).getComputedStyle(t15, null).getPropertyValue(e);
}
function aF(t15) {
  return function() {
    delete this[t15];
  };
}
function oF(t15, e) {
  return function() {
    this[t15] = e;
  };
}
function lF(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? delete this[t15] : this[t15] = r;
  };
}
function cF(t15, e) {
  return arguments.length > 1 ? this.each((e == null ? aF : typeof e == "function" ? lF : oF)(t15, e)) : this.node()[t15];
}
function E3(t15) {
  return t15.trim().split(/^|\s+/);
}
function dm(t15) {
  return t15.classList || new M3(t15);
}
function M3(t15) {
  this._node = t15, this._names = E3(t15.getAttribute("class") || "");
}
M3.prototype = {
  add: function(t15) {
    var e = this._names.indexOf(t15);
    e < 0 && (this._names.push(t15), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t15) {
    var e = this._names.indexOf(t15);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t15) {
    return this._names.indexOf(t15) >= 0;
  }
};
function B3(t15, e) {
  for (var r = dm(t15), n = -1, i = e.length; ++n < i; ) r.add(e[n]);
}
function L3(t15, e) {
  for (var r = dm(t15), n = -1, i = e.length; ++n < i; ) r.remove(e[n]);
}
function hF(t15) {
  return function() {
    B3(this, t15);
  };
}
function uF(t15) {
  return function() {
    L3(this, t15);
  };
}
function dF(t15, e) {
  return function() {
    (e.apply(this, arguments) ? B3 : L3)(this, t15);
  };
}
function pF(t15, e) {
  var r = E3(t15 + "");
  if (arguments.length < 2) {
    for (var n = dm(this.node()), i = -1, s = r.length; ++i < s; ) if (!n.contains(r[i])) return false;
    return true;
  }
  return this.each((typeof e == "function" ? dF : e ? hF : uF)(r, e));
}
function fF() {
  this.textContent = "";
}
function mF(t15) {
  return function() {
    this.textContent = t15;
  };
}
function gF(t15) {
  return function() {
    var e = t15.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function yF(t15) {
  return arguments.length ? this.each(t15 == null ? fF : (typeof t15 == "function" ? gF : mF)(t15)) : this.node().textContent;
}
function bF() {
  this.innerHTML = "";
}
function xF(t15) {
  return function() {
    this.innerHTML = t15;
  };
}
function wF(t15) {
  return function() {
    var e = t15.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function kF(t15) {
  return arguments.length ? this.each(t15 == null ? bF : (typeof t15 == "function" ? wF : xF)(t15)) : this.node().innerHTML;
}
function vF() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function CF() {
  return this.each(vF);
}
function _F() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function SF() {
  return this.each(_F);
}
function AF(t15) {
  var e = typeof t15 == "function" ? t15 : C3(t15);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function TF() {
  return null;
}
function $F(t15, e) {
  var r = typeof t15 == "function" ? t15 : C3(t15), n = e == null ? TF : typeof e == "function" ? e : um(e);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function EF() {
  var t15 = this.parentNode;
  t15 && t15.removeChild(this);
}
function MF() {
  return this.each(EF);
}
function BF() {
  var t15 = this.cloneNode(false), e = this.parentNode;
  return e ? e.insertBefore(t15, this.nextSibling) : t15;
}
function LF() {
  var t15 = this.cloneNode(true), e = this.parentNode;
  return e ? e.insertBefore(t15, this.nextSibling) : t15;
}
function DF(t15) {
  return this.select(t15 ? LF : BF);
}
function FF(t15) {
  return arguments.length ? this.property("__data__", t15) : this.node().__data__;
}
function NF(t15) {
  return function(e) {
    t15.call(this, e, this.__data__);
  };
}
function IF(t15) {
  return t15.trim().split(/^|\s+/).map(function(e) {
    var r = "", n = e.indexOf(".");
    return n >= 0 && (r = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: r };
  });
}
function OF(t15) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var r = 0, n = -1, i = e.length, s; r < i; ++r)
        s = e[r], (!t15.type || s.type === t15.type) && s.name === t15.name ? this.removeEventListener(s.type, s.listener, s.options) : e[++n] = s;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function zF(t15, e, r) {
  return function() {
    var n = this.__on, i, s = NF(e);
    if (n) {
      for (var a = 0, o = n.length; a < o; ++a)
        if ((i = n[a]).type === t15.type && i.name === t15.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = r), i.value = e;
          return;
        }
    }
    this.addEventListener(t15.type, s, r), i = { type: t15.type, name: t15.name, value: e, listener: s, options: r }, n ? n.push(i) : this.__on = [i];
  };
}
function qF(t15, e, r) {
  var n = IF(t15 + ""), i, s = n.length, a;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, c = o.length, h; l < c; ++l)
        for (i = 0, h = o[l]; i < s; ++i)
          if ((a = n[i]).type === h.type && a.name === h.name)
            return h.value;
    }
    return;
  }
  for (o = e ? zF : OF, i = 0; i < s; ++i) this.each(o(n[i], e, r));
  return this;
}
function D3(t15, e, r) {
  var n = $3(t15), i = n.CustomEvent;
  typeof i == "function" ? i = new i(e, r) : (i = n.document.createEvent("Event"), r ? (i.initEvent(e, r.bubbles, r.cancelable), i.detail = r.detail) : i.initEvent(e, false, false)), t15.dispatchEvent(i);
}
function RF(t15, e) {
  return function() {
    return D3(this, t15, e);
  };
}
function PF(t15, e) {
  return function() {
    return D3(this, t15, e.apply(this, arguments));
  };
}
function jF(t15, e) {
  return this.each((typeof e == "function" ? PF : RF)(t15, e));
}
function* WF() {
  for (var t15 = this._groups, e = 0, r = t15.length; e < r; ++e)
    for (var n = t15[e], i = 0, s = n.length, a; i < s; ++i)
      (a = n[i]) && (yield a);
}
var F3 = [null];
function tn(t15, e) {
  this._groups = t15, this._parents = e;
}
function sc() {
  return new tn([[document.documentElement]], F3);
}
function HF() {
  return this;
}
tn.prototype = sc.prototype = {
  constructor: tn,
  select: gD,
  selectAll: wD,
  selectChild: _D,
  selectChildren: $D,
  filter: ED,
  data: ND,
  enter: MD,
  exit: OD,
  join: zD,
  merge: qD,
  selection: HF,
  order: RD,
  sort: PD,
  call: WD,
  nodes: HD,
  node: UD,
  size: VD,
  empty: GD,
  each: XD,
  attr: eF,
  style: sF,
  property: cF,
  classed: pF,
  text: yF,
  html: kF,
  raise: CF,
  lower: SF,
  append: AF,
  insert: $F,
  remove: MF,
  clone: DF,
  datum: FF,
  on: qF,
  dispatch: jF,
  [Symbol.iterator]: WF
};
function Zi(t15) {
  return typeof t15 == "string" ? new tn([[document.querySelector(t15)]], [document.documentElement]) : new tn([[t15]], F3);
}
function UF(t15) {
  let e;
  for (; e = t15.sourceEvent; ) t15 = e;
  return t15;
}
function Ss(t15, e) {
  if (t15 = UF(t15), e === void 0 && (e = t15.currentTarget), e) {
    var r = e.ownerSVGElement || e;
    if (r.createSVGPoint) {
      var n = r.createSVGPoint();
      return n.x = t15.clientX, n.y = t15.clientY, n = n.matrixTransform(e.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (e.getBoundingClientRect) {
      var i = e.getBoundingClientRect();
      return [t15.clientX - i.left - e.clientLeft, t15.clientY - i.top - e.clientTop];
    }
  }
  return [t15.pageX, t15.pageY];
}
var cf = { capture: true, passive: false };
function hf(t15) {
  t15.preventDefault(), t15.stopImmediatePropagation();
}
function VF(t15) {
  var e = t15.document.documentElement, r = Zi(t15).on("dragstart.drag", hf, cf);
  "onselectstart" in e ? r.on("selectstart.drag", hf, cf) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function GF(t15, e) {
  var r = t15.document.documentElement, n = Zi(t15).on("dragstart.drag", null);
  e && (n.on("click.drag", hf, cf), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in r ? n.on("selectstart.drag", null) : (r.style.MozUserSelect = r.__noselect, delete r.__noselect);
}
function pm(t15, e, r) {
  t15.prototype = e.prototype = r, r.constructor = t15;
}
function N3(t15, e) {
  var r = Object.create(t15.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function ac() {
}
var Dl = 0.7;
var o0 = 1 / Dl;
var Ia = "\\s*([+-]?\\d+)\\s*";
var Fl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var Vn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var XF = /^#([0-9a-f]{3,8})$/;
var YF = new RegExp(`^rgb\\(${Ia},${Ia},${Ia}\\)$`);
var KF = new RegExp(`^rgb\\(${Vn},${Vn},${Vn}\\)$`);
var ZF = new RegExp(`^rgba\\(${Ia},${Ia},${Ia},${Fl}\\)$`);
var JF = new RegExp(`^rgba\\(${Vn},${Vn},${Vn},${Fl}\\)$`);
var QF = new RegExp(`^hsl\\(${Fl},${Vn},${Vn}\\)$`);
var tN = new RegExp(`^hsla\\(${Fl},${Vn},${Vn},${Fl}\\)$`);
var J2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
pm(ac, Nl, {
  copy(t15) {
    return Object.assign(new this.constructor(), this, t15);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Q2,
  // Deprecated! Use color.formatHex.
  formatHex: Q2,
  formatHex8: eN,
  formatHsl: rN,
  formatRgb: tb,
  toString: tb
});
function Q2() {
  return this.rgb().formatHex();
}
function eN() {
  return this.rgb().formatHex8();
}
function rN() {
  return I3(this).formatHsl();
}
function tb() {
  return this.rgb().formatRgb();
}
function Nl(t15) {
  var e, r;
  return t15 = (t15 + "").trim().toLowerCase(), (e = XF.exec(t15)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? eb(e) : r === 3 ? new jr(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? Zc(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? Zc(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = YF.exec(t15)) ? new jr(e[1], e[2], e[3], 1) : (e = KF.exec(t15)) ? new jr(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = ZF.exec(t15)) ? Zc(e[1], e[2], e[3], e[4]) : (e = JF.exec(t15)) ? Zc(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = QF.exec(t15)) ? ib(e[1], e[2] / 100, e[3] / 100, 1) : (e = tN.exec(t15)) ? ib(e[1], e[2] / 100, e[3] / 100, e[4]) : J2.hasOwnProperty(t15) ? eb(J2[t15]) : t15 === "transparent" ? new jr(NaN, NaN, NaN, 0) : null;
}
function eb(t15) {
  return new jr(t15 >> 16 & 255, t15 >> 8 & 255, t15 & 255, 1);
}
function Zc(t15, e, r, n) {
  return n <= 0 && (t15 = e = r = NaN), new jr(t15, e, r, n);
}
function nN(t15) {
  return t15 instanceof ac || (t15 = Nl(t15)), t15 ? (t15 = t15.rgb(), new jr(t15.r, t15.g, t15.b, t15.opacity)) : new jr();
}
function uf(t15, e, r, n) {
  return arguments.length === 1 ? nN(t15) : new jr(t15, e, r, n ?? 1);
}
function jr(t15, e, r, n) {
  this.r = +t15, this.g = +e, this.b = +r, this.opacity = +n;
}
pm(jr, uf, N3(ac, {
  brighter(t15) {
    return t15 = t15 == null ? o0 : Math.pow(o0, t15), new jr(this.r * t15, this.g * t15, this.b * t15, this.opacity);
  },
  darker(t15) {
    return t15 = t15 == null ? Dl : Math.pow(Dl, t15), new jr(this.r * t15, this.g * t15, this.b * t15, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new jr(Ws(this.r), Ws(this.g), Ws(this.b), l0(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rb,
  // Deprecated! Use color.formatHex.
  formatHex: rb,
  formatHex8: iN,
  formatRgb: nb,
  toString: nb
}));
function rb() {
  return `#${Os(this.r)}${Os(this.g)}${Os(this.b)}`;
}
function iN() {
  return `#${Os(this.r)}${Os(this.g)}${Os(this.b)}${Os((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function nb() {
  const t15 = l0(this.opacity);
  return `${t15 === 1 ? "rgb(" : "rgba("}${Ws(this.r)}, ${Ws(this.g)}, ${Ws(this.b)}${t15 === 1 ? ")" : `, ${t15})`}`;
}
function l0(t15) {
  return isNaN(t15) ? 1 : Math.max(0, Math.min(1, t15));
}
function Ws(t15) {
  return Math.max(0, Math.min(255, Math.round(t15) || 0));
}
function Os(t15) {
  return t15 = Ws(t15), (t15 < 16 ? "0" : "") + t15.toString(16);
}
function ib(t15, e, r, n) {
  return n <= 0 ? t15 = e = r = NaN : r <= 0 || r >= 1 ? t15 = e = NaN : e <= 0 && (t15 = NaN), new vn(t15, e, r, n);
}
function I3(t15) {
  if (t15 instanceof vn) return new vn(t15.h, t15.s, t15.l, t15.opacity);
  if (t15 instanceof ac || (t15 = Nl(t15)), !t15) return new vn();
  if (t15 instanceof vn) return t15;
  t15 = t15.rgb();
  var e = t15.r / 255, r = t15.g / 255, n = t15.b / 255, i = Math.min(e, r, n), s = Math.max(e, r, n), a = NaN, o = s - i, l = (s + i) / 2;
  return o ? (e === s ? a = (r - n) / o + (r < n) * 6 : r === s ? a = (n - e) / o + 2 : a = (e - r) / o + 4, o /= l < 0.5 ? s + i : 2 - s - i, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new vn(a, o, l, t15.opacity);
}
function sN(t15, e, r, n) {
  return arguments.length === 1 ? I3(t15) : new vn(t15, e, r, n ?? 1);
}
function vn(t15, e, r, n) {
  this.h = +t15, this.s = +e, this.l = +r, this.opacity = +n;
}
pm(vn, sN, N3(ac, {
  brighter(t15) {
    return t15 = t15 == null ? o0 : Math.pow(o0, t15), new vn(this.h, this.s, this.l * t15, this.opacity);
  },
  darker(t15) {
    return t15 = t15 == null ? Dl : Math.pow(Dl, t15), new vn(this.h, this.s, this.l * t15, this.opacity);
  },
  rgb() {
    var t15 = this.h % 360 + (this.h < 0) * 360, e = isNaN(t15) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new jr(
      Yd(t15 >= 240 ? t15 - 240 : t15 + 120, i, n),
      Yd(t15, i, n),
      Yd(t15 < 120 ? t15 + 240 : t15 - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new vn(sb(this.h), Jc(this.s), Jc(this.l), l0(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t15 = l0(this.opacity);
    return `${t15 === 1 ? "hsl(" : "hsla("}${sb(this.h)}, ${Jc(this.s) * 100}%, ${Jc(this.l) * 100}%${t15 === 1 ? ")" : `, ${t15})`}`;
  }
}));
function sb(t15) {
  return t15 = (t15 || 0) % 360, t15 < 0 ? t15 + 360 : t15;
}
function Jc(t15) {
  return Math.max(0, Math.min(1, t15 || 0));
}
function Yd(t15, e, r) {
  return (t15 < 60 ? e + (r - e) * t15 / 60 : t15 < 180 ? r : t15 < 240 ? e + (r - e) * (240 - t15) / 60 : e) * 255;
}
var O3 = (t15) => () => t15;
function aN(t15, e) {
  return function(r) {
    return t15 + r * e;
  };
}
function oN(t15, e, r) {
  return t15 = Math.pow(t15, r), e = Math.pow(e, r) - t15, r = 1 / r, function(n) {
    return Math.pow(t15 + n * e, r);
  };
}
function lN(t15) {
  return (t15 = +t15) == 1 ? z3 : function(e, r) {
    return r - e ? oN(e, r, t15) : O3(isNaN(e) ? r : e);
  };
}
function z3(t15, e) {
  var r = e - t15;
  return r ? aN(t15, r) : O3(isNaN(t15) ? e : t15);
}
var ab = function t(e) {
  var r = lN(e);
  function n(i, s) {
    var a = r((i = uf(i)).r, (s = uf(s)).r), o = r(i.g, s.g), l = r(i.b, s.b), c = z3(i.opacity, s.opacity);
    return function(h) {
      return i.r = a(h), i.g = o(h), i.b = l(h), i.opacity = c(h), i + "";
    };
  }
  return n.gamma = t, n;
}(1);
function Xi(t15, e) {
  return t15 = +t15, e = +e, function(r) {
    return t15 * (1 - r) + e * r;
  };
}
var df = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var Kd = new RegExp(df.source, "g");
function cN(t15) {
  return function() {
    return t15;
  };
}
function hN(t15) {
  return function(e) {
    return t15(e) + "";
  };
}
function uN(t15, e) {
  var r = df.lastIndex = Kd.lastIndex = 0, n, i, s, a = -1, o = [], l = [];
  for (t15 = t15 + "", e = e + ""; (n = df.exec(t15)) && (i = Kd.exec(e)); )
    (s = i.index) > r && (s = e.slice(r, s), o[a] ? o[a] += s : o[++a] = s), (n = n[0]) === (i = i[0]) ? o[a] ? o[a] += i : o[++a] = i : (o[++a] = null, l.push({ i: a, x: Xi(n, i) })), r = Kd.lastIndex;
  return r < e.length && (s = e.slice(r), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? hN(l[0].x) : cN(e) : (e = l.length, function(c) {
    for (var h = 0, p; h < e; ++h) o[(p = l[h]).i] = p.x(c);
    return o.join("");
  });
}
var ob = 180 / Math.PI;
var q3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function R3(t15, e, r, n, i, s) {
  var a, o, l;
  return (a = Math.sqrt(t15 * t15 + e * e)) && (t15 /= a, e /= a), (l = t15 * r + e * n) && (r -= t15 * l, n -= e * l), (o = Math.sqrt(r * r + n * n)) && (r /= o, n /= o, l /= o), t15 * n < e * r && (t15 = -t15, e = -e, l = -l, a = -a), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(e, t15) * ob,
    skewX: Math.atan(l) * ob,
    scaleX: a,
    scaleY: o
  };
}
var Qc;
function dN(t15) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t15 + "");
  return e.isIdentity ? q3 : R3(e.a, e.b, e.c, e.d, e.e, e.f);
}
function pN(t15) {
  return t15 == null || (Qc || (Qc = document.createElementNS("http://www.w3.org/2000/svg", "g")), Qc.setAttribute("transform", t15), !(t15 = Qc.transform.baseVal.consolidate())) ? q3 : (t15 = t15.matrix, R3(t15.a, t15.b, t15.c, t15.d, t15.e, t15.f));
}
function P3(t15, e, r, n) {
  function i(c) {
    return c.length ? c.pop() + " " : "";
  }
  function s(c, h, p, m, g, y) {
    if (c !== p || h !== m) {
      var x = g.push("translate(", null, e, null, r);
      y.push({ i: x - 4, x: Xi(c, p) }, { i: x - 2, x: Xi(h, m) });
    } else (p || m) && g.push("translate(" + p + e + m + r);
  }
  function a(c, h, p, m) {
    c !== h ? (c - h > 180 ? h += 360 : h - c > 180 && (c += 360), m.push({ i: p.push(i(p) + "rotate(", null, n) - 2, x: Xi(c, h) })) : h && p.push(i(p) + "rotate(" + h + n);
  }
  function o(c, h, p, m) {
    c !== h ? m.push({ i: p.push(i(p) + "skewX(", null, n) - 2, x: Xi(c, h) }) : h && p.push(i(p) + "skewX(" + h + n);
  }
  function l(c, h, p, m, g, y) {
    if (c !== p || h !== m) {
      var x = g.push(i(g) + "scale(", null, ",", null, ")");
      y.push({ i: x - 4, x: Xi(c, p) }, { i: x - 2, x: Xi(h, m) });
    } else (p !== 1 || m !== 1) && g.push(i(g) + "scale(" + p + "," + m + ")");
  }
  return function(c, h) {
    var p = [], m = [];
    return c = t15(c), h = t15(h), s(c.translateX, c.translateY, h.translateX, h.translateY, p, m), a(c.rotate, h.rotate, p, m), o(c.skewX, h.skewX, p, m), l(c.scaleX, c.scaleY, h.scaleX, h.scaleY, p, m), c = h = null, function(g) {
      for (var y = -1, x = m.length, k; ++y < x; ) p[(k = m[y]).i] = k.x(g);
      return p.join("");
    };
  };
}
var fN = P3(dN, "px, ", "px)", "deg)");
var mN = P3(pN, ", ", ")", ")");
var gN = 1e-12;
function lb(t15) {
  return ((t15 = Math.exp(t15)) + 1 / t15) / 2;
}
function yN(t15) {
  return ((t15 = Math.exp(t15)) - 1 / t15) / 2;
}
function bN(t15) {
  return ((t15 = Math.exp(2 * t15)) - 1) / (t15 + 1);
}
var xN = function t4(e, r, n) {
  function i(s, a) {
    var o = s[0], l = s[1], c = s[2], h = a[0], p = a[1], m = a[2], g = h - o, y = p - l, x = g * g + y * y, k, C;
    if (x < gN)
      C = Math.log(m / c) / e, k = function(U) {
        return [
          o + U * g,
          l + U * y,
          c * Math.exp(e * U * C)
        ];
      };
    else {
      var A = Math.sqrt(x), $ = (m * m - c * c + n * x) / (2 * c * r * A), B = (m * m - c * c - n * x) / (2 * m * r * A), L = Math.log(Math.sqrt($ * $ + 1) - $), q = Math.log(Math.sqrt(B * B + 1) - B);
      C = (q - L) / e, k = function(U) {
        var G = U * C, F = lb(L), W = c / (r * A) * (F * bN(e * G + L) - yN(L));
        return [
          o + W * g,
          l + W * y,
          c * F / lb(e * G + L)
        ];
      };
    }
    return k.duration = C * 1e3 * e / Math.SQRT2, k;
  }
  return i.rho = function(s) {
    var a = Math.max(1e-3, +s), o = a * a, l = o * o;
    return t4(a, o, l);
  }, i;
}(Math.SQRT2, 2, 4);
var Xa = 0;
var rl = 0;
var Fo = 0;
var j3 = 1e3;
var c0;
var nl;
var h0 = 0;
var Ys = 0;
var mu = 0;
var Il = typeof performance == "object" && performance.now ? performance : Date;
var W3 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t15) {
  setTimeout(t15, 17);
};
function fm() {
  return Ys || (W3(wN), Ys = Il.now() + mu);
}
function wN() {
  Ys = 0;
}
function u0() {
  this._call = this._time = this._next = null;
}
u0.prototype = H3.prototype = {
  constructor: u0,
  restart: function(t15, e, r) {
    if (typeof t15 != "function") throw new TypeError("callback is not a function");
    r = (r == null ? fm() : +r) + (e == null ? 0 : +e), !this._next && nl !== this && (nl ? nl._next = this : c0 = this, nl = this), this._call = t15, this._time = r, pf();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, pf());
  }
};
function H3(t15, e, r) {
  var n = new u0();
  return n.restart(t15, e, r), n;
}
function kN() {
  fm(), ++Xa;
  for (var t15 = c0, e; t15; )
    (e = Ys - t15._time) >= 0 && t15._call.call(void 0, e), t15 = t15._next;
  --Xa;
}
function cb() {
  Ys = (h0 = Il.now()) + mu, Xa = rl = 0;
  try {
    kN();
  } finally {
    Xa = 0, CN(), Ys = 0;
  }
}
function vN() {
  var t15 = Il.now(), e = t15 - h0;
  e > j3 && (mu -= e, h0 = t15);
}
function CN() {
  for (var t15, e = c0, r, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), t15 = e, e = e._next) : (r = e._next, e._next = null, e = t15 ? t15._next = r : c0 = r);
  nl = t15, pf(n);
}
function pf(t15) {
  if (!Xa) {
    rl && (rl = clearTimeout(rl));
    var e = t15 - Ys;
    e > 24 ? (t15 < 1 / 0 && (rl = setTimeout(cb, t15 - Il.now() - mu)), Fo && (Fo = clearInterval(Fo))) : (Fo || (h0 = Il.now(), Fo = setInterval(vN, j3)), Xa = 1, W3(cb));
  }
}
function hb(t15, e, r) {
  var n = new u0();
  return e = e == null ? 0 : +e, n.restart((i) => {
    n.stop(), t15(i + e);
  }, e, r), n;
}
var _N = hm("start", "end", "cancel", "interrupt");
var SN = [];
var U3 = 0;
var ub = 1;
var ff = 2;
var Ch = 3;
var db = 4;
var mf = 5;
var _h = 6;
function gu(t15, e, r, n, i, s) {
  var a = t15.__transition;
  if (!a) t15.__transition = {};
  else if (r in a) return;
  AN(t15, r, {
    name: e,
    index: n,
    // For context during callback.
    group: i,
    // For context during callback.
    on: _N,
    tween: SN,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: U3
  });
}
function mm(t15, e) {
  var r = $n(t15, e);
  if (r.state > U3) throw new Error("too late; already scheduled");
  return r;
}
function ti(t15, e) {
  var r = $n(t15, e);
  if (r.state > Ch) throw new Error("too late; already running");
  return r;
}
function $n(t15, e) {
  var r = t15.__transition;
  if (!r || !(r = r[e])) throw new Error("transition not found");
  return r;
}
function AN(t15, e, r) {
  var n = t15.__transition, i;
  n[e] = r, r.timer = H3(s, 0, r.time);
  function s(c) {
    r.state = ub, r.timer.restart(a, r.delay, r.time), r.delay <= c && a(c - r.delay);
  }
  function a(c) {
    var h, p, m, g;
    if (r.state !== ub) return l();
    for (h in n)
      if (g = n[h], g.name === r.name) {
        if (g.state === Ch) return hb(a);
        g.state === db ? (g.state = _h, g.timer.stop(), g.on.call("interrupt", t15, t15.__data__, g.index, g.group), delete n[h]) : +h < e && (g.state = _h, g.timer.stop(), g.on.call("cancel", t15, t15.__data__, g.index, g.group), delete n[h]);
      }
    if (hb(function() {
      r.state === Ch && (r.state = db, r.timer.restart(o, r.delay, r.time), o(c));
    }), r.state = ff, r.on.call("start", t15, t15.__data__, r.index, r.group), r.state === ff) {
      for (r.state = Ch, i = new Array(m = r.tween.length), h = 0, p = -1; h < m; ++h)
        (g = r.tween[h].value.call(t15, t15.__data__, r.index, r.group)) && (i[++p] = g);
      i.length = p + 1;
    }
  }
  function o(c) {
    for (var h = c < r.duration ? r.ease.call(null, c / r.duration) : (r.timer.restart(l), r.state = mf, 1), p = -1, m = i.length; ++p < m; )
      i[p].call(t15, h);
    r.state === mf && (r.on.call("end", t15, t15.__data__, r.index, r.group), l());
  }
  function l() {
    r.state = _h, r.timer.stop(), delete n[e];
    for (var c in n) return;
    delete t15.__transition;
  }
}
function Sh(t15, e) {
  var r = t15.__transition, n, i, s = true, a;
  if (r) {
    e = e == null ? null : e + "";
    for (a in r) {
      if ((n = r[a]).name !== e) {
        s = false;
        continue;
      }
      i = n.state > ff && n.state < mf, n.state = _h, n.timer.stop(), n.on.call(i ? "interrupt" : "cancel", t15, t15.__data__, n.index, n.group), delete r[a];
    }
    s && delete t15.__transition;
  }
}
function TN(t15) {
  return this.each(function() {
    Sh(this, t15);
  });
}
function $N(t15, e) {
  var r, n;
  return function() {
    var i = ti(this, t15), s = i.tween;
    if (s !== r) {
      n = r = s;
      for (var a = 0, o = n.length; a < o; ++a)
        if (n[a].name === e) {
          n = n.slice(), n.splice(a, 1);
          break;
        }
    }
    i.tween = n;
  };
}
function EN(t15, e, r) {
  var n, i;
  if (typeof r != "function") throw new Error();
  return function() {
    var s = ti(this, t15), a = s.tween;
    if (a !== n) {
      i = (n = a).slice();
      for (var o = { name: e, value: r }, l = 0, c = i.length; l < c; ++l)
        if (i[l].name === e) {
          i[l] = o;
          break;
        }
      l === c && i.push(o);
    }
    s.tween = i;
  };
}
function MN(t15, e) {
  var r = this._id;
  if (t15 += "", arguments.length < 2) {
    for (var n = $n(this.node(), r).tween, i = 0, s = n.length, a; i < s; ++i)
      if ((a = n[i]).name === t15)
        return a.value;
    return null;
  }
  return this.each((e == null ? $N : EN)(r, t15, e));
}
function gm(t15, e, r) {
  var n = t15._id;
  return t15.each(function() {
    var i = ti(this, n);
    (i.value || (i.value = {}))[e] = r.apply(this, arguments);
  }), function(i) {
    return $n(i, n).value[e];
  };
}
function V3(t15, e) {
  var r;
  return (typeof e == "number" ? Xi : e instanceof Nl ? ab : (r = Nl(e)) ? (e = r, ab) : uN)(t15, e);
}
function BN(t15) {
  return function() {
    this.removeAttribute(t15);
  };
}
function LN(t15) {
  return function() {
    this.removeAttributeNS(t15.space, t15.local);
  };
}
function DN(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = this.getAttribute(t15);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function FN(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = this.getAttributeNS(t15.space, t15.local);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function NN(t15, e, r) {
  var n, i, s;
  return function() {
    var a, o = r(this), l;
    return o == null ? void this.removeAttribute(t15) : (a = this.getAttribute(t15), l = o + "", a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o)));
  };
}
function IN(t15, e, r) {
  var n, i, s;
  return function() {
    var a, o = r(this), l;
    return o == null ? void this.removeAttributeNS(t15.space, t15.local) : (a = this.getAttributeNS(t15.space, t15.local), l = o + "", a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o)));
  };
}
function ON(t15, e) {
  var r = fu(t15), n = r === "transform" ? mN : V3;
  return this.attrTween(t15, typeof e == "function" ? (r.local ? IN : NN)(r, n, gm(this, "attr." + t15, e)) : e == null ? (r.local ? LN : BN)(r) : (r.local ? FN : DN)(r, n, e));
}
function zN(t15, e) {
  return function(r) {
    this.setAttribute(t15, e.call(this, r));
  };
}
function qN(t15, e) {
  return function(r) {
    this.setAttributeNS(t15.space, t15.local, e.call(this, r));
  };
}
function RN(t15, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && qN(t15, s)), r;
  }
  return i._value = e, i;
}
function PN(t15, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && zN(t15, s)), r;
  }
  return i._value = e, i;
}
function jN(t15, e) {
  var r = "attr." + t15;
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (e == null) return this.tween(r, null);
  if (typeof e != "function") throw new Error();
  var n = fu(t15);
  return this.tween(r, (n.local ? RN : PN)(n, e));
}
function WN(t15, e) {
  return function() {
    mm(this, t15).delay = +e.apply(this, arguments);
  };
}
function HN(t15, e) {
  return e = +e, function() {
    mm(this, t15).delay = e;
  };
}
function UN(t15) {
  var e = this._id;
  return arguments.length ? this.each((typeof t15 == "function" ? WN : HN)(e, t15)) : $n(this.node(), e).delay;
}
function VN(t15, e) {
  return function() {
    ti(this, t15).duration = +e.apply(this, arguments);
  };
}
function GN(t15, e) {
  return e = +e, function() {
    ti(this, t15).duration = e;
  };
}
function XN(t15) {
  var e = this._id;
  return arguments.length ? this.each((typeof t15 == "function" ? VN : GN)(e, t15)) : $n(this.node(), e).duration;
}
function YN(t15, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    ti(this, t15).ease = e;
  };
}
function KN(t15) {
  var e = this._id;
  return arguments.length ? this.each(YN(e, t15)) : $n(this.node(), e).ease;
}
function ZN(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    if (typeof r != "function") throw new Error();
    ti(this, t15).ease = r;
  };
}
function JN(t15) {
  if (typeof t15 != "function") throw new Error();
  return this.each(ZN(this._id, t15));
}
function QN(t15) {
  typeof t15 != "function" && (t15 = S3(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && t15.call(l, l.__data__, c, s) && o.push(l);
  return new Ei(n, this._parents, this._name, this._id);
}
function tI(t15) {
  if (t15._id !== this._id) throw new Error();
  for (var e = this._groups, r = t15._groups, n = e.length, i = r.length, s = Math.min(n, i), a = new Array(n), o = 0; o < s; ++o)
    for (var l = e[o], c = r[o], h = l.length, p = a[o] = new Array(h), m, g = 0; g < h; ++g)
      (m = l[g] || c[g]) && (p[g] = m);
  for (; o < n; ++o)
    a[o] = e[o];
  return new Ei(a, this._parents, this._name, this._id);
}
function eI(t15) {
  return (t15 + "").trim().split(/^|\s+/).every(function(e) {
    var r = e.indexOf(".");
    return r >= 0 && (e = e.slice(0, r)), !e || e === "start";
  });
}
function rI(t15, e, r) {
  var n, i, s = eI(e) ? mm : ti;
  return function() {
    var a = s(this, t15), o = a.on;
    o !== n && (i = (n = o).copy()).on(e, r), a.on = i;
  };
}
function nI(t15, e) {
  var r = this._id;
  return arguments.length < 2 ? $n(this.node(), r).on.on(t15) : this.each(rI(r, t15, e));
}
function iI(t15) {
  return function() {
    var e = this.parentNode;
    for (var r in this.__transition) if (+r !== t15) return;
    e && e.removeChild(this);
  };
}
function sI() {
  return this.on("end.remove", iI(this._id));
}
function aI(t15) {
  var e = this._name, r = this._id;
  typeof t15 != "function" && (t15 = um(t15));
  for (var n = this._groups, i = n.length, s = new Array(i), a = 0; a < i; ++a)
    for (var o = n[a], l = o.length, c = s[a] = new Array(l), h, p, m = 0; m < l; ++m)
      (h = o[m]) && (p = t15.call(h, h.__data__, m, o)) && ("__data__" in h && (p.__data__ = h.__data__), c[m] = p, gu(c[m], e, r, m, c, $n(h, r)));
  return new Ei(s, this._parents, e, r);
}
function oI(t15) {
  var e = this._name, r = this._id;
  typeof t15 != "function" && (t15 = _3(t15));
  for (var n = this._groups, i = n.length, s = [], a = [], o = 0; o < i; ++o)
    for (var l = n[o], c = l.length, h, p = 0; p < c; ++p)
      if (h = l[p]) {
        for (var m = t15.call(h, h.__data__, p, l), g, y = $n(h, r), x = 0, k = m.length; x < k; ++x)
          (g = m[x]) && gu(g, e, r, x, m, y);
        s.push(m), a.push(h);
      }
  return new Ei(s, a, e, r);
}
var lI = sc.prototype.constructor;
function cI() {
  return new lI(this._groups, this._parents);
}
function hI(t15, e) {
  var r, n, i;
  return function() {
    var s = Ga(this, t15), a = (this.style.removeProperty(t15), Ga(this, t15));
    return s === a ? null : s === r && a === n ? i : i = e(r = s, n = a);
  };
}
function G3(t15) {
  return function() {
    this.style.removeProperty(t15);
  };
}
function uI(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = Ga(this, t15);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function dI(t15, e, r) {
  var n, i, s;
  return function() {
    var a = Ga(this, t15), o = r(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(t15), Ga(this, t15))), a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o));
  };
}
function pI(t15, e) {
  var r, n, i, s = "style." + e, a = "end." + s, o;
  return function() {
    var l = ti(this, t15), c = l.on, h = l.value[s] == null ? o || (o = G3(e)) : void 0;
    (c !== r || i !== h) && (n = (r = c).copy()).on(a, i = h), l.on = n;
  };
}
function fI(t15, e, r) {
  var n = (t15 += "") == "transform" ? fN : V3;
  return e == null ? this.styleTween(t15, hI(t15, n)).on("end.style." + t15, G3(t15)) : typeof e == "function" ? this.styleTween(t15, dI(t15, n, gm(this, "style." + t15, e))).each(pI(this._id, t15)) : this.styleTween(t15, uI(t15, n, e), r).on("end.style." + t15, null);
}
function mI(t15, e, r) {
  return function(n) {
    this.style.setProperty(t15, e.call(this, n), r);
  };
}
function gI(t15, e, r) {
  var n, i;
  function s() {
    var a = e.apply(this, arguments);
    return a !== i && (n = (i = a) && mI(t15, a, r)), n;
  }
  return s._value = e, s;
}
function yI(t15, e, r) {
  var n = "style." + (t15 += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, gI(t15, e, r ?? ""));
}
function bI(t15) {
  return function() {
    this.textContent = t15;
  };
}
function xI(t15) {
  return function() {
    var e = t15(this);
    this.textContent = e ?? "";
  };
}
function wI(t15) {
  return this.tween("text", typeof t15 == "function" ? xI(gm(this, "text", t15)) : bI(t15 == null ? "" : t15 + ""));
}
function kI(t15) {
  return function(e) {
    this.textContent = t15.call(this, e);
  };
}
function vI(t15) {
  var e, r;
  function n() {
    var i = t15.apply(this, arguments);
    return i !== r && (e = (r = i) && kI(i)), e;
  }
  return n._value = t15, n;
}
function CI(t15) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t15 == null) return this.tween(e, null);
  if (typeof t15 != "function") throw new Error();
  return this.tween(e, vI(t15));
}
function _I() {
  for (var t15 = this._name, e = this._id, r = X3(), n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var a = n[s], o = a.length, l, c = 0; c < o; ++c)
      if (l = a[c]) {
        var h = $n(l, e);
        gu(l, t15, r, c, a, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new Ei(n, this._parents, t15, r);
}
function SI() {
  var t15, e, r = this, n = r._id, i = r.size();
  return new Promise(function(s, a) {
    var o = { value: a }, l = { value: function() {
      --i === 0 && s();
    } };
    r.each(function() {
      var c = ti(this, n), h = c.on;
      h !== t15 && (e = (t15 = h).copy(), e._.cancel.push(o), e._.interrupt.push(o), e._.end.push(l)), c.on = e;
    }), i === 0 && s();
  });
}
var AI = 0;
function Ei(t15, e, r, n) {
  this._groups = t15, this._parents = e, this._name = r, this._id = n;
}
function X3() {
  return ++AI;
}
var ui = sc.prototype;
Ei.prototype = {
  constructor: Ei,
  select: aI,
  selectAll: oI,
  selectChild: ui.selectChild,
  selectChildren: ui.selectChildren,
  filter: QN,
  merge: tI,
  selection: cI,
  transition: _I,
  call: ui.call,
  nodes: ui.nodes,
  node: ui.node,
  size: ui.size,
  empty: ui.empty,
  each: ui.each,
  on: nI,
  attr: ON,
  attrTween: jN,
  style: fI,
  styleTween: yI,
  text: wI,
  textTween: CI,
  remove: sI,
  tween: MN,
  delay: UN,
  duration: XN,
  ease: KN,
  easeVarying: JN,
  end: SI,
  [Symbol.iterator]: ui[Symbol.iterator]
};
function TI(t15) {
  return ((t15 *= 2) <= 1 ? t15 * t15 * t15 : (t15 -= 2) * t15 * t15 + 2) / 2;
}
var $I = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: TI
};
function EI(t15, e) {
  for (var r; !(r = t15.__transition) || !(r = r[e]); )
    if (!(t15 = t15.parentNode))
      throw new Error(`transition ${e} not found`);
  return r;
}
function MI(t15) {
  var e, r;
  t15 instanceof Ei ? (e = t15._id, t15 = t15._name) : (e = X3(), (r = $I).time = fm(), t15 = t15 == null ? null : t15 + "");
  for (var n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var a = n[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && gu(l, t15, e, c, a, r || EI(l, e));
  return new Ei(n, this._parents, t15, e);
}
sc.prototype.interrupt = TN;
sc.prototype.transition = MI;
var gf = Math.PI;
var yf = 2 * gf;
var Ms = 1e-6;
var BI = yf - Ms;
function Y3(t15) {
  this._ += t15[0];
  for (let e = 1, r = t15.length; e < r; ++e)
    this._ += arguments[e] + t15[e];
}
function LI(t15) {
  let e = Math.floor(t15);
  if (!(e >= 0)) throw new Error(`invalid digits: ${t15}`);
  if (e > 15) return Y3;
  const r = 10 ** e;
  return function(n) {
    this._ += n[0];
    for (let i = 1, s = n.length; i < s; ++i)
      this._ += Math.round(arguments[i] * r) / r + n[i];
  };
}
var DI = class {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? Y3 : LI(e);
  }
  moveTo(e, r) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, r) {
    this._append`L${this._x1 = +e},${this._y1 = +r}`;
  }
  quadraticCurveTo(e, r, n, i) {
    this._append`Q${+e},${+r},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(e, r, n, i, s, a) {
    this._append`C${+e},${+r},${+n},${+i},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(e, r, n, i, s) {
    if (e = +e, r = +r, n = +n, i = +i, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let a = this._x1, o = this._y1, l = n - e, c = i - r, h = a - e, p = o - r, m = h * h + p * p;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = r}`;
    else if (m > Ms) if (!(Math.abs(p * l - c * h) > Ms) || !s)
      this._append`L${this._x1 = e},${this._y1 = r}`;
    else {
      let g = n - a, y = i - o, x = l * l + c * c, k = g * g + y * y, C = Math.sqrt(x), A = Math.sqrt(m), $ = s * Math.tan((gf - Math.acos((x + m - k) / (2 * C * A))) / 2), B = $ / A, L = $ / C;
      Math.abs(B - 1) > Ms && this._append`L${e + B * h},${r + B * p}`, this._append`A${s},${s},0,0,${+(p * g > h * y)},${this._x1 = e + L * l},${this._y1 = r + L * c}`;
    }
  }
  arc(e, r, n, i, s, a) {
    if (e = +e, r = +r, n = +n, a = !!a, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(i), l = n * Math.sin(i), c = e + o, h = r + l, p = 1 ^ a, m = a ? i - s : s - i;
    this._x1 === null ? this._append`M${c},${h}` : (Math.abs(this._x1 - c) > Ms || Math.abs(this._y1 - h) > Ms) && this._append`L${c},${h}`, n && (m < 0 && (m = m % yf + yf), m > BI ? this._append`A${n},${n},0,1,${p},${e - o},${r - l}A${n},${n},0,1,${p},${this._x1 = c},${this._y1 = h}` : m > Ms && this._append`A${n},${n},0,${+(m >= gf)},${p},${this._x1 = e + n * Math.cos(s)},${this._y1 = r + n * Math.sin(s)}`);
  }
  rect(e, r, n, i) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function FI(t15, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t15);
      break;
    default:
      this.range(e).domain(t15);
      break;
  }
  return this;
}
var pb = Symbol("implicit");
function K3() {
  var t15 = new V2(), e = [], r = [], n = pb;
  function i(s) {
    let a = t15.get(s);
    if (a === void 0) {
      if (n !== pb) return n;
      t15.set(s, a = e.push(s) - 1);
    }
    return r[a % r.length];
  }
  return i.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [], t15 = new V2();
    for (const a of s)
      t15.has(a) || t15.set(a, e.push(a) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (r = Array.from(s), i) : r.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (n = s, i) : n;
  }, i.copy = function() {
    return K3(e, r).unknown(n);
  }, FI.apply(i, arguments), i;
}
function NI(t15) {
  for (var e = t15.length / 6 | 0, r = new Array(e), n = 0; n < e; ) r[n] = "#" + t15.slice(n * 6, ++n * 6);
  return r;
}
var II = NI("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
function fb(t15) {
  return function() {
    return t15;
  };
}
function OI(t15) {
  let e = 3;
  return t15.digits = function(r) {
    if (!arguments.length) return e;
    if (r == null)
      e = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
      e = n;
    }
    return t15;
  }, () => new DI(e);
}
var zI = Array.prototype.slice;
function qI(t15) {
  return t15[0];
}
function RI(t15) {
  return t15[1];
}
var PI = class {
  constructor(e, r) {
    this._context = e, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, r) {
    switch (e = +e, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, r, e, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, e, this._y0, e, r);
        break;
      }
    }
    this._x0 = e, this._y0 = r;
  }
};
function jI(t15) {
  return new PI(t15, true);
}
function WI(t15) {
  return t15.source;
}
function HI(t15) {
  return t15.target;
}
function UI(t15) {
  let e = WI, r = HI, n = qI, i = RI, s = null, a = null, o = OI(l);
  function l() {
    let c;
    const h = zI.call(arguments), p = e.apply(this, h), m = r.apply(this, h);
    if (s == null && (a = t15(c = o())), a.lineStart(), h[0] = p, a.point(+n.apply(this, h), +i.apply(this, h)), h[0] = m, a.point(+n.apply(this, h), +i.apply(this, h)), a.lineEnd(), c) return a = null, c + "" || null;
  }
  return l.source = function(c) {
    return arguments.length ? (e = c, l) : e;
  }, l.target = function(c) {
    return arguments.length ? (r = c, l) : r;
  }, l.x = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : fb(+c), l) : n;
  }, l.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : fb(+c), l) : i;
  }, l.context = function(c) {
    return arguments.length ? (c == null ? s = a = null : a = t15(s = c), l) : s;
  }, l;
}
function VI() {
  return UI(jI);
}
var th = (t15) => () => t15;
function GI(t15, {
  sourceEvent: e,
  target: r,
  transform: n,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: t15, enumerable: true, configurable: true },
    sourceEvent: { value: e, enumerable: true, configurable: true },
    target: { value: r, enumerable: true, configurable: true },
    transform: { value: n, enumerable: true, configurable: true },
    _: { value: i }
  });
}
function vi(t15, e, r) {
  this.k = t15, this.x = e, this.y = r;
}
vi.prototype = {
  constructor: vi,
  scale: function(t15) {
    return t15 === 1 ? this : new vi(this.k * t15, this.x, this.y);
  },
  translate: function(t15, e) {
    return t15 === 0 & e === 0 ? this : new vi(this.k, this.x + this.k * t15, this.y + this.k * e);
  },
  apply: function(t15) {
    return [t15[0] * this.k + this.x, t15[1] * this.k + this.y];
  },
  applyX: function(t15) {
    return t15 * this.k + this.x;
  },
  applyY: function(t15) {
    return t15 * this.k + this.y;
  },
  invert: function(t15) {
    return [(t15[0] - this.x) / this.k, (t15[1] - this.y) / this.k];
  },
  invertX: function(t15) {
    return (t15 - this.x) / this.k;
  },
  invertY: function(t15) {
    return (t15 - this.y) / this.k;
  },
  rescaleX: function(t15) {
    return t15.copy().domain(t15.range().map(this.invertX, this).map(t15.invert, t15));
  },
  rescaleY: function(t15) {
    return t15.copy().domain(t15.range().map(this.invertY, this).map(t15.invert, t15));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var yu = new vi(1, 0, 0);
_a.prototype = vi.prototype;
function _a(t15) {
  for (; !t15.__zoom; ) if (!(t15 = t15.parentNode)) return yu;
  return t15.__zoom;
}
function Zd(t15) {
  t15.stopImmediatePropagation();
}
function No(t15) {
  t15.preventDefault(), t15.stopImmediatePropagation();
}
function XI(t15) {
  return (!t15.ctrlKey || t15.type === "wheel") && !t15.button;
}
function YI() {
  var t15 = this;
  return t15 instanceof SVGElement ? (t15 = t15.ownerSVGElement || t15, t15.hasAttribute("viewBox") ? (t15 = t15.viewBox.baseVal, [[t15.x, t15.y], [t15.x + t15.width, t15.y + t15.height]]) : [[0, 0], [t15.width.baseVal.value, t15.height.baseVal.value]]) : [[0, 0], [t15.clientWidth, t15.clientHeight]];
}
function mb() {
  return this.__zoom || yu;
}
function KI(t15) {
  return -t15.deltaY * (t15.deltaMode === 1 ? 0.05 : t15.deltaMode ? 1 : 2e-3) * (t15.ctrlKey ? 10 : 1);
}
function ZI() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function JI(t15, e, r) {
  var n = t15.invertX(e[0][0]) - r[0][0], i = t15.invertX(e[1][0]) - r[1][0], s = t15.invertY(e[0][1]) - r[0][1], a = t15.invertY(e[1][1]) - r[1][1];
  return t15.translate(
    i > n ? (n + i) / 2 : Math.min(0, n) || Math.max(0, i),
    a > s ? (s + a) / 2 : Math.min(0, s) || Math.max(0, a)
  );
}
function QI() {
  var t15 = XI, e = YI, r = JI, n = KI, i = ZI, s = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], o = 250, l = xN, c = hm("start", "zoom", "end"), h, p, m, g = 500, y = 150, x = 0, k = 10;
  function C(I) {
    I.property("__zoom", mb).on("wheel.zoom", G, { passive: false }).on("mousedown.zoom", F).on("dblclick.zoom", W).filter(i).on("touchstart.zoom", R).on("touchmove.zoom", Q).on("touchend.zoom touchcancel.zoom", rt).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  C.transform = function(I, j, z, K) {
    var Y = I.selection ? I.selection() : I;
    Y.property("__zoom", mb), I !== Y ? L(I, j, z, K) : Y.interrupt().each(function() {
      q(this, arguments).event(K).start().zoom(null, typeof j == "function" ? j.apply(this, arguments) : j).end();
    });
  }, C.scaleBy = function(I, j, z, K) {
    C.scaleTo(I, function() {
      var Y = this.__zoom.k, ot = typeof j == "function" ? j.apply(this, arguments) : j;
      return Y * ot;
    }, z, K);
  }, C.scaleTo = function(I, j, z, K) {
    C.transform(I, function() {
      var Y = e.apply(this, arguments), ot = this.__zoom, et = z == null ? B(Y) : typeof z == "function" ? z.apply(this, arguments) : z, ht = ot.invert(et), X = typeof j == "function" ? j.apply(this, arguments) : j;
      return r($(A(ot, X), et, ht), Y, a);
    }, z, K);
  }, C.translateBy = function(I, j, z, K) {
    C.transform(I, function() {
      return r(this.__zoom.translate(
        typeof j == "function" ? j.apply(this, arguments) : j,
        typeof z == "function" ? z.apply(this, arguments) : z
      ), e.apply(this, arguments), a);
    }, null, K);
  }, C.translateTo = function(I, j, z, K, Y) {
    C.transform(I, function() {
      var ot = e.apply(this, arguments), et = this.__zoom, ht = K == null ? B(ot) : typeof K == "function" ? K.apply(this, arguments) : K;
      return r(yu.translate(ht[0], ht[1]).scale(et.k).translate(
        typeof j == "function" ? -j.apply(this, arguments) : -j,
        typeof z == "function" ? -z.apply(this, arguments) : -z
      ), ot, a);
    }, K, Y);
  };
  function A(I, j) {
    return j = Math.max(s[0], Math.min(s[1], j)), j === I.k ? I : new vi(j, I.x, I.y);
  }
  function $(I, j, z) {
    var K = j[0] - z[0] * I.k, Y = j[1] - z[1] * I.k;
    return K === I.x && Y === I.y ? I : new vi(I.k, K, Y);
  }
  function B(I) {
    return [(+I[0][0] + +I[1][0]) / 2, (+I[0][1] + +I[1][1]) / 2];
  }
  function L(I, j, z, K) {
    I.on("start.zoom", function() {
      q(this, arguments).event(K).start();
    }).on("interrupt.zoom end.zoom", function() {
      q(this, arguments).event(K).end();
    }).tween("zoom", function() {
      var Y = this, ot = arguments, et = q(Y, ot).event(K), ht = e.apply(Y, ot), X = z == null ? B(ht) : typeof z == "function" ? z.apply(Y, ot) : z, ct = Math.max(ht[1][0] - ht[0][0], ht[1][1] - ht[0][1]), gt = Y.__zoom, xt = typeof j == "function" ? j.apply(Y, ot) : j, Xt = l(gt.invert(X).concat(ct / gt.k), xt.invert(X).concat(ct / xt.k));
      return function(H) {
        if (H === 1) H = xt;
        else {
          var mt = Xt(H), wt = ct / mt[2];
          H = new vi(wt, X[0] - mt[0] * wt, X[1] - mt[1] * wt);
        }
        et.zoom(null, H);
      };
    });
  }
  function q(I, j, z) {
    return !z && I.__zooming || new U(I, j);
  }
  function U(I, j) {
    this.that = I, this.args = j, this.active = 0, this.sourceEvent = null, this.extent = e.apply(I, j), this.taps = 0;
  }
  U.prototype = {
    event: function(I) {
      return I && (this.sourceEvent = I), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(I, j) {
      return this.mouse && I !== "mouse" && (this.mouse[1] = j.invert(this.mouse[0])), this.touch0 && I !== "touch" && (this.touch0[1] = j.invert(this.touch0[0])), this.touch1 && I !== "touch" && (this.touch1[1] = j.invert(this.touch1[0])), this.that.__zoom = j, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(I) {
      var j = Zi(this.that).datum();
      c.call(
        I,
        this.that,
        new GI(I, {
          sourceEvent: this.sourceEvent,
          target: C,
          transform: this.that.__zoom,
          dispatch: c
        }),
        j
      );
    }
  };
  function G(I, ...j) {
    if (!t15.apply(this, arguments)) return;
    var z = q(this, j).event(I), K = this.__zoom, Y = Math.max(s[0], Math.min(s[1], K.k * Math.pow(2, n.apply(this, arguments)))), ot = Ss(I);
    if (z.wheel)
      (z.mouse[0][0] !== ot[0] || z.mouse[0][1] !== ot[1]) && (z.mouse[1] = K.invert(z.mouse[0] = ot)), clearTimeout(z.wheel);
    else {
      if (K.k === Y) return;
      z.mouse = [ot, K.invert(ot)], Sh(this), z.start();
    }
    No(I), z.wheel = setTimeout(et, y), z.zoom("mouse", r($(A(K, Y), z.mouse[0], z.mouse[1]), z.extent, a));
    function et() {
      z.wheel = null, z.end();
    }
  }
  function F(I, ...j) {
    if (m || !t15.apply(this, arguments)) return;
    var z = I.currentTarget, K = q(this, j, true).event(I), Y = Zi(I.view).on("mousemove.zoom", X, true).on("mouseup.zoom", ct, true), ot = Ss(I, z), et = I.clientX, ht = I.clientY;
    VF(I.view), Zd(I), K.mouse = [ot, this.__zoom.invert(ot)], Sh(this), K.start();
    function X(gt) {
      if (No(gt), !K.moved) {
        var xt = gt.clientX - et, Xt = gt.clientY - ht;
        K.moved = xt * xt + Xt * Xt > x;
      }
      K.event(gt).zoom("mouse", r($(K.that.__zoom, K.mouse[0] = Ss(gt, z), K.mouse[1]), K.extent, a));
    }
    function ct(gt) {
      Y.on("mousemove.zoom mouseup.zoom", null), GF(gt.view, K.moved), No(gt), K.event(gt).end();
    }
  }
  function W(I, ...j) {
    if (t15.apply(this, arguments)) {
      var z = this.__zoom, K = Ss(I.changedTouches ? I.changedTouches[0] : I, this), Y = z.invert(K), ot = z.k * (I.shiftKey ? 0.5 : 2), et = r($(A(z, ot), K, Y), e.apply(this, j), a);
      No(I), o > 0 ? Zi(this).transition().duration(o).call(L, et, K, I) : Zi(this).call(C.transform, et, K, I);
    }
  }
  function R(I, ...j) {
    if (t15.apply(this, arguments)) {
      var z = I.touches, K = z.length, Y = q(this, j, I.changedTouches.length === K).event(I), ot, et, ht, X;
      for (Zd(I), et = 0; et < K; ++et)
        ht = z[et], X = Ss(ht, this), X = [X, this.__zoom.invert(X), ht.identifier], Y.touch0 ? !Y.touch1 && Y.touch0[2] !== X[2] && (Y.touch1 = X, Y.taps = 0) : (Y.touch0 = X, ot = true, Y.taps = 1 + !!h);
      h && (h = clearTimeout(h)), ot && (Y.taps < 2 && (p = X[0], h = setTimeout(function() {
        h = null;
      }, g)), Sh(this), Y.start());
    }
  }
  function Q(I, ...j) {
    if (this.__zooming) {
      var z = q(this, j).event(I), K = I.changedTouches, Y = K.length, ot, et, ht, X;
      for (No(I), ot = 0; ot < Y; ++ot)
        et = K[ot], ht = Ss(et, this), z.touch0 && z.touch0[2] === et.identifier ? z.touch0[0] = ht : z.touch1 && z.touch1[2] === et.identifier && (z.touch1[0] = ht);
      if (et = z.that.__zoom, z.touch1) {
        var ct = z.touch0[0], gt = z.touch0[1], xt = z.touch1[0], Xt = z.touch1[1], H = (H = xt[0] - ct[0]) * H + (H = xt[1] - ct[1]) * H, mt = (mt = Xt[0] - gt[0]) * mt + (mt = Xt[1] - gt[1]) * mt;
        et = A(et, Math.sqrt(H / mt)), ht = [(ct[0] + xt[0]) / 2, (ct[1] + xt[1]) / 2], X = [(gt[0] + Xt[0]) / 2, (gt[1] + Xt[1]) / 2];
      } else if (z.touch0) ht = z.touch0[0], X = z.touch0[1];
      else return;
      z.zoom("touch", r($(et, ht, X), z.extent, a));
    }
  }
  function rt(I, ...j) {
    if (this.__zooming) {
      var z = q(this, j).event(I), K = I.changedTouches, Y = K.length, ot, et;
      for (Zd(I), m && clearTimeout(m), m = setTimeout(function() {
        m = null;
      }, g), ot = 0; ot < Y; ++ot)
        et = K[ot], z.touch0 && z.touch0[2] === et.identifier ? delete z.touch0 : z.touch1 && z.touch1[2] === et.identifier && delete z.touch1;
      if (z.touch1 && !z.touch0 && (z.touch0 = z.touch1, delete z.touch1), z.touch0) z.touch0[1] = this.__zoom.invert(z.touch0[0]);
      else if (z.end(), z.taps === 2 && (et = Ss(et, this), Math.hypot(p[0] - et[0], p[1] - et[1]) < k)) {
        var ht = Zi(this).on("dblclick.zoom");
        ht && ht.apply(this, arguments);
      }
    }
  }
  return C.wheelDelta = function(I) {
    return arguments.length ? (n = typeof I == "function" ? I : th(+I), C) : n;
  }, C.filter = function(I) {
    return arguments.length ? (t15 = typeof I == "function" ? I : th(!!I), C) : t15;
  }, C.touchable = function(I) {
    return arguments.length ? (i = typeof I == "function" ? I : th(!!I), C) : i;
  }, C.extent = function(I) {
    return arguments.length ? (e = typeof I == "function" ? I : th([[+I[0][0], +I[0][1]], [+I[1][0], +I[1][1]]]), C) : e;
  }, C.scaleExtent = function(I) {
    return arguments.length ? (s[0] = +I[0], s[1] = +I[1], C) : [s[0], s[1]];
  }, C.translateExtent = function(I) {
    return arguments.length ? (a[0][0] = +I[0][0], a[1][0] = +I[1][0], a[0][1] = +I[0][1], a[1][1] = +I[1][1], C) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
  }, C.constrain = function(I) {
    return arguments.length ? (r = I, C) : r;
  }, C.duration = function(I) {
    return arguments.length ? (o = +I, C) : o;
  }, C.interpolate = function(I) {
    return arguments.length ? (l = I, C) : l;
  }, C.on = function() {
    var I = c.on.apply(c, arguments);
    return I === c ? C : I;
  }, C.clickDistance = function(I) {
    return arguments.length ? (x = (I = +I) * I, C) : Math.sqrt(x);
  }, C.tapDistance = function(I) {
    return arguments.length ? (k = +I, C) : k;
  }, C;
}
var Z3 = typeof navigator < "u" && navigator.userAgent.includes("Macintosh");
var tO = K3(II);
var eO = (t15 = 1, e = 3, r = 2) => (n) => t15 + e / r ** n.state.depth;
var rO = {
  autoFit: false,
  duration: 500,
  embedGlobalCSS: true,
  fitRatio: 0.95,
  maxInitialScale: 2,
  scrollForPan: Z3,
  initialExpandLevel: -1,
  zoom: true,
  pan: true,
  toggleRecursively: false,
  color: (t15) => {
    var e;
    return tO(`${((e = t15.state) == null ? void 0 : e.path) || ""}`);
  },
  lineWidth: eO(),
  maxWidth: 0,
  nodeMinHeight: 16,
  paddingX: 8,
  spacingHorizontal: 80,
  spacingVertical: 5
};
function nO(t15) {
  let e = 0;
  for (let r = 0; r < t15.length; r++)
    e = (e << 5) - e + t15.charCodeAt(r) | 0;
  return (e >>> 0).toString(36);
}
function Xr(t15) {
  if (typeof t15 == "string") {
    const r = t15;
    t15 = (n) => n.matches(r);
  }
  const e = t15;
  return function() {
    let r = Array.from(this.childNodes);
    return e && (r = r.filter((n) => e(n))), r;
  };
}
function iO(t15) {
  var e = 0, r = t15.children, n = r && r.length;
  if (!n) e = 1;
  else for (; --n >= 0; ) e += r[n].value;
  t15.value = e;
}
function sO() {
  return this.eachAfter(iO);
}
function aO(t15) {
  var e = this, r, n = [e], i, s, a;
  do
    for (r = n.reverse(), n = []; e = r.pop(); )
      if (t15(e), i = e.children, i) for (s = 0, a = i.length; s < a; ++s)
        n.push(i[s]);
  while (n.length);
  return this;
}
function oO(t15) {
  for (var e = this, r = [e], n, i; e = r.pop(); )
    if (t15(e), n = e.children, n) for (i = n.length - 1; i >= 0; --i)
      r.push(n[i]);
  return this;
}
function lO(t15) {
  for (var e = this, r = [e], n = [], i, s, a; e = r.pop(); )
    if (n.push(e), i = e.children, i) for (s = 0, a = i.length; s < a; ++s)
      r.push(i[s]);
  for (; e = n.pop(); )
    t15(e);
  return this;
}
function cO(t15) {
  return this.eachAfter(function(e) {
    for (var r = +t15(e.data) || 0, n = e.children, i = n && n.length; --i >= 0; ) r += n[i].value;
    e.value = r;
  });
}
function hO(t15) {
  return this.eachBefore(function(e) {
    e.children && e.children.sort(t15);
  });
}
function uO(t15) {
  for (var e = this, r = dO(e, t15), n = [e]; e !== r; )
    e = e.parent, n.push(e);
  for (var i = n.length; t15 !== r; )
    n.splice(i, 0, t15), t15 = t15.parent;
  return n;
}
function dO(t15, e) {
  if (t15 === e) return t15;
  var r = t15.ancestors(), n = e.ancestors(), i = null;
  for (t15 = r.pop(), e = n.pop(); t15 === e; )
    i = t15, t15 = r.pop(), e = n.pop();
  return i;
}
function pO() {
  for (var t15 = this, e = [t15]; t15 = t15.parent; )
    e.push(t15);
  return e;
}
function fO() {
  var t15 = [];
  return this.each(function(e) {
    t15.push(e);
  }), t15;
}
function mO() {
  var t15 = [];
  return this.eachBefore(function(e) {
    e.children || t15.push(e);
  }), t15;
}
function gO() {
  var t15 = this, e = [];
  return t15.each(function(r) {
    r !== t15 && e.push({ source: r.parent, target: r });
  }), e;
}
function ym(t15, e) {
  var r = new d0(t15), n = +t15.value && (r.value = t15.value), i, s = [r], a, o, l, c;
  for (e == null && (e = bO); i = s.pop(); )
    if (n && (i.value = +i.data.value), (o = e(i.data)) && (c = o.length))
      for (i.children = new Array(c), l = c - 1; l >= 0; --l)
        s.push(a = i.children[l] = new d0(o[l])), a.parent = i, a.depth = i.depth + 1;
  return r.eachBefore(wO);
}
function yO() {
  return ym(this).eachBefore(xO);
}
function bO(t15) {
  return t15.children;
}
function xO(t15) {
  t15.data = t15.data.data;
}
function wO(t15) {
  var e = 0;
  do
    t15.height = e;
  while ((t15 = t15.parent) && t15.height < ++e);
}
function d0(t15) {
  this.data = t15, this.depth = this.height = 0, this.parent = null;
}
d0.prototype = ym.prototype = {
  constructor: d0,
  count: sO,
  each: aO,
  eachAfter: lO,
  eachBefore: oO,
  sum: cO,
  sort: hO,
  path: uO,
  ancestors: pO,
  descendants: fO,
  leaves: mO,
  links: gO,
  copy: yO
};
var kO = "2.1.2";
var vO = {
  version: kO
};
var { version: CO } = vO;
var _O = Object.freeze({
  children: (t15) => t15.children,
  nodeSize: (t15) => t15.data.size,
  spacing: 0
});
function Q3(t15) {
  const e = Object.assign({}, _O, t15);
  function r(o) {
    const l = e[o];
    return typeof l == "function" ? l : () => l;
  }
  function n(o) {
    const l = a(s(), o, (c) => c.children);
    return l.update(), l.data;
  }
  function i() {
    const o = r("nodeSize"), l = r("spacing");
    return class J3 extends ym.prototype.constructor {
      constructor(h) {
        super(h);
      }
      copy() {
        const h = a(this.constructor, this, (p) => p.children);
        return h.each((p) => p.data = p.data.data), h;
      }
      get size() {
        return o(this);
      }
      spacing(h) {
        return l(this, h);
      }
      get nodes() {
        return this.descendants();
      }
      get xSize() {
        return this.size[0];
      }
      get ySize() {
        return this.size[1];
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.ySize;
      }
      get left() {
        return this.x - this.xSize / 2;
      }
      get right() {
        return this.x + this.xSize / 2;
      }
      get root() {
        const h = this.ancestors();
        return h[h.length - 1];
      }
      get numChildren() {
        return this.hasChildren ? this.children.length : 0;
      }
      get hasChildren() {
        return !this.noChildren;
      }
      get noChildren() {
        return this.children === null;
      }
      get firstChild() {
        return this.hasChildren ? this.children[0] : null;
      }
      get lastChild() {
        return this.hasChildren ? this.children[this.numChildren - 1] : null;
      }
      get extents() {
        return (this.children || []).reduce(
          (h, p) => J3.maxExtents(h, p.extents),
          this.nodeExtents
        );
      }
      get nodeExtents() {
        return {
          top: this.top,
          bottom: this.bottom,
          left: this.left,
          right: this.right
        };
      }
      static maxExtents(h, p) {
        return {
          top: Math.min(h.top, p.top),
          bottom: Math.max(h.bottom, p.bottom),
          left: Math.min(h.left, p.left),
          right: Math.max(h.right, p.right)
        };
      }
    };
  }
  function s() {
    const o = i(), l = r("nodeSize"), c = r("spacing");
    return class extends o {
      constructor(h) {
        super(h), Object.assign(this, {
          x: 0,
          y: 0,
          relX: 0,
          prelim: 0,
          shift: 0,
          change: 0,
          lExt: this,
          lExtRelX: 0,
          lThr: null,
          rExt: this,
          rExtRelX: 0,
          rThr: null
        });
      }
      get size() {
        return l(this.data);
      }
      spacing(h) {
        return c(this.data, h.data);
      }
      get x() {
        return this.data.x;
      }
      set x(h) {
        this.data.x = h;
      }
      get y() {
        return this.data.y;
      }
      set y(h) {
        this.data.y = h;
      }
      update() {
        return t6(this), e6(this), this;
      }
    };
  }
  function a(o, l, c) {
    const h = (p, m) => {
      const g = new o(p);
      Object.assign(g, {
        parent: m,
        depth: m === null ? 0 : m.depth + 1,
        height: 0,
        length: 1
      });
      const y = c(p) || [];
      return g.children = y.length === 0 ? null : y.map((x) => h(x, g)), g.children && Object.assign(g, g.children.reduce(
        (x, k) => ({
          height: Math.max(x.height, k.height + 1),
          length: x.length + k.length
        }),
        g
      )), g;
    };
    return h(l, null);
  }
  return Object.assign(n, {
    nodeSize(o) {
      return arguments.length ? (e.nodeSize = o, n) : e.nodeSize;
    },
    spacing(o) {
      return arguments.length ? (e.spacing = o, n) : e.spacing;
    },
    children(o) {
      return arguments.length ? (e.children = o, n) : e.children;
    },
    hierarchy(o, l) {
      const c = typeof l > "u" ? e.children : l;
      return a(i(), o, c);
    },
    dump(o) {
      const l = r("nodeSize"), c = (h) => (p) => {
        const m = h + "  ", g = h + "    ", { x: y, y: x } = p, k = l(p), C = p.children || [], A = C.length === 0 ? " " : `,${m}children: [${g}${C.map(c(g)).join(g)}${m}],${h}`;
        return `{ size: [${k.join(", ")}],${m}x: ${y}, y: ${x}${A}},`;
      };
      return c(`
`)(o);
    }
  }), n;
}
Q3.version = CO;
var t6 = (t15, e = 0) => (t15.y = e, (t15.children || []).reduce((r, n) => {
  const [i, s] = r;
  t6(n, t15.y + t15.ySize);
  const a = (i === 0 ? n.lExt : n.rExt).bottom;
  i !== 0 && AO(t15, i, s);
  const o = FO(a, i, s);
  return [i + 1, o];
}, [0, null]), SO(t15), DO(t15), t15);
var e6 = (t15, e, r) => {
  typeof e > "u" && (e = -t15.relX - t15.prelim, r = 0);
  const n = e + t15.relX;
  return t15.relX = n + t15.prelim - r, t15.prelim = 0, t15.x = r + t15.relX, (t15.children || []).forEach((i) => e6(i, n, t15.x)), t15;
};
var SO = (t15) => {
  (t15.children || []).reduce((e, r) => {
    const [n, i] = e, s = n + r.shift, a = i + s + r.change;
    return r.relX += a, [s, a];
  }, [0, 0]);
};
var AO = (t15, e, r) => {
  const n = t15.children[e - 1], i = t15.children[e];
  let s = n, a = n.relX, o = i, l = i.relX, c = true;
  for (; s && o; ) {
    s.bottom > r.lowY && (r = r.next);
    const h = a + s.prelim - (l + o.prelim) + s.xSize / 2 + o.xSize / 2 + s.spacing(o);
    (h > 0 || h < 0 && c) && (l += h, TO(i, h), $O(t15, e, r.index, h)), c = false;
    const p = s.bottom, m = o.bottom;
    p <= m && (s = MO(s), s && (a += s.relX)), p >= m && (o = EO(o), o && (l += o.relX));
  }
  !s && o ? BO(t15, e, o, l) : s && !o && LO(t15, e, s, a);
};
var TO = (t15, e) => {
  t15.relX += e, t15.lExtRelX += e, t15.rExtRelX += e;
};
var $O = (t15, e, r, n) => {
  const i = t15.children[e], s = e - r;
  if (s > 1) {
    const a = n / s;
    t15.children[r + 1].shift += a, i.shift -= a, i.change -= n - a;
  }
};
var EO = (t15) => t15.hasChildren ? t15.firstChild : t15.lThr;
var MO = (t15) => t15.hasChildren ? t15.lastChild : t15.rThr;
var BO = (t15, e, r, n) => {
  const i = t15.firstChild, s = i.lExt, a = t15.children[e];
  s.lThr = r;
  const o = n - r.relX - i.lExtRelX;
  s.relX += o, s.prelim -= o, i.lExt = a.lExt, i.lExtRelX = a.lExtRelX;
};
var LO = (t15, e, r, n) => {
  const i = t15.children[e], s = i.rExt, a = t15.children[e - 1];
  s.rThr = r;
  const o = n - r.relX - i.rExtRelX;
  s.relX += o, s.prelim -= o, i.rExt = a.rExt, i.rExtRelX = a.rExtRelX;
};
var DO = (t15) => {
  if (t15.hasChildren) {
    const e = t15.firstChild, r = t15.lastChild, n = (e.prelim + e.relX - e.xSize / 2 + r.relX + r.prelim + r.xSize / 2) / 2;
    Object.assign(t15, {
      prelim: n,
      lExt: e.lExt,
      lExtRelX: e.lExtRelX,
      rExt: r.rExt,
      rExtRelX: r.rExtRelX
    });
  }
};
var FO = (t15, e, r) => {
  for (; r !== null && t15 >= r.lowY; )
    r = r.next;
  return {
    lowY: t15,
    index: e,
    next: r
  };
};
var NO = ".markmap{--markmap-max-width: 9999px;--markmap-a-color: #0097e6;--markmap-a-hover-color: #00a8ff;--markmap-code-bg: #f0f0f0;--markmap-code-color: #555;--markmap-highlight-bg: #ffeaa7;--markmap-table-border: 1px solid currentColor;--markmap-font: 300 16px/20px sans-serif;--markmap-circle-open-bg: #fff;--markmap-text-color: #333;--markmap-highlight-node-bg: #ff02;font:var(--markmap-font);color:var(--markmap-text-color)}.markmap-link{fill:none}.markmap-node>circle{cursor:pointer}.markmap-foreign{display:inline-block}.markmap-foreign p{margin:0}.markmap-foreign a{color:var(--markmap-a-color)}.markmap-foreign a:hover{color:var(--markmap-a-hover-color)}.markmap-foreign code{padding:.25em;font-size:calc(1em - 2px);color:var(--markmap-code-color);background-color:var(--markmap-code-bg);border-radius:2px}.markmap-foreign pre{margin:0}.markmap-foreign pre>code{display:block}.markmap-foreign del{text-decoration:line-through}.markmap-foreign em{font-style:italic}.markmap-foreign strong{font-weight:700}.markmap-foreign mark{background:var(--markmap-highlight-bg)}.markmap-foreign table,.markmap-foreign th,.markmap-foreign td{border-collapse:collapse;border:var(--markmap-table-border)}.markmap-foreign img{display:inline-block}.markmap-foreign svg{fill:currentColor}.markmap-foreign>div{width:var(--markmap-max-width);text-align:left}.markmap-foreign>div>div{display:inline-block}.markmap-highlight rect{fill:var(--markmap-highlight-node-bg)}.markmap-dark .markmap{--markmap-code-bg: #1a1b26;--markmap-code-color: #ddd;--markmap-circle-open-bg: #444;--markmap-text-color: #eee}";
var Jd = "g.markmap-node";
var IO = "path.markmap-link";
var OO = "g.markmap-highlight";
var Qd = VI();
function gb(t15, e) {
  const r = cD(t15, e);
  return t15[r];
}
function tp(t15) {
  t15.stopPropagation();
}
var zO = new Zo();
var qO = class r6 {
  constructor(e, r) {
    this.options = { ...rO }, this._disposeList = [], this.handleZoom = (n) => {
      const { transform: i } = n;
      this.g.attr("transform", i);
    }, this.handlePan = (n) => {
      n.preventDefault();
      const i = _a(this.svg.node()), s = i.translate(
        -n.deltaX / i.k,
        -n.deltaY / i.k
      );
      this.svg.call(this.zoom.transform, s);
    }, this.handleClick = (n, i) => {
      let s = this.options.toggleRecursively;
      (Z3 ? n.metaKey : n.ctrlKey) && (s = !s), this.toggleNode(i, s);
    }, this.ensureView = this.ensureVisible, this.svg = e.datum ? e : Zi(e), this.styleNode = this.svg.append("style"), this.zoom = QI().filter((n) => this.options.scrollForPan && n.type === "wheel" ? n.ctrlKey && !n.button : (!n.ctrlKey || n.type === "wheel") && !n.button).on("zoom", this.handleZoom), this.setOptions(r), this.state = {
      id: this.options.id || this.svg.attr("id") || f_(),
      rect: { x1: 0, y1: 0, x2: 0, y2: 0 }
    }, this.g = this.svg.append("g"), this.g.append("g").attr("class", "markmap-highlight"), this._observer = new ResizeObserver(
      b_(() => {
        this.renderData();
      }, 100)
    ), this._disposeList.push(
      zO.tap(() => {
        this.setData();
      }),
      () => this._observer.disconnect()
    );
  }
  getStyleContent() {
    const { style: e } = this.options, { id: r } = this.state, n = typeof e == "function" ? e(r) : "";
    return [this.options.embedGlobalCSS && NO, n].filter(Boolean).join(`
`);
  }
  updateStyle() {
    this.svg.attr(
      "class",
      m_(this.svg.attr("class"), "markmap", this.state.id)
    );
    const e = this.getStyleContent();
    this.styleNode.text(e);
  }
  async toggleNode(e, r = false) {
    var n, i;
    const s = (n = e.payload) != null && n.fold ? 0 : 1;
    r ? Jo(e, (a, o) => {
      a.payload = {
        ...a.payload,
        fold: s
      }, o();
    }) : e.payload = {
      ...e.payload,
      fold: (i = e.payload) != null && i.fold ? 0 : 1
    }, await this.renderData(e);
  }
  _initializeData(e) {
    let r = 0;
    const { color: n, initialExpandLevel: i } = this.options;
    let s = 0, a = 0;
    return Jo(e, (o, l, c) => {
      var h, p, m, g;
      a += 1, o.children = (h = o.children) == null ? void 0 : h.map((x) => ({ ...x })), r += 1, o.state = {
        ...o.state,
        depth: a,
        id: r,
        rect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        size: [0, 0]
      }, o.state.key = [(p = c == null ? void 0 : c.state) == null ? void 0 : p.id, o.state.id].filter(Boolean).join(".") + nO(o.content), o.state.path = [(m = c == null ? void 0 : c.state) == null ? void 0 : m.path, o.state.id].filter(Boolean).join("."), n(o);
      const y = ((g = o.payload) == null ? void 0 : g.fold) === 2;
      y ? s += 1 : (s || i >= 0 && o.state.depth >= i) && (o.payload = { ...o.payload, fold: 1 }), l(), y && (s -= 1), a -= 1;
    }), e;
  }
  _relayout() {
    if (!this.state.data) return;
    this.g.selectAll(Xr(Jd)).selectAll(
      Xr("foreignObject")
    ).each(function(l) {
      var c;
      const h = (c = this.firstChild) == null ? void 0 : c.firstChild, p = [h.scrollWidth, h.scrollHeight];
      l.state.size = p;
    });
    const { lineWidth: e, paddingX: r, spacingHorizontal: n, spacingVertical: i } = this.options, s = Q3({}).children((l) => {
      var c;
      if (!((c = l.payload) != null && c.fold)) return l.children;
    }).nodeSize((l) => {
      const [c, h] = l.data.state.size;
      return [h, c + (c ? r * 2 : 0) + n];
    }).spacing((l, c) => (l.parent === c.parent ? i : i * 2) + e(l.data)), a = s.hierarchy(this.state.data);
    s(a);
    const o = a.descendants();
    o.forEach((l) => {
      const c = l.data;
      c.state.rect = {
        x: l.y,
        y: l.x - l.xSize / 2,
        width: l.ySize - n,
        height: l.xSize
      };
    }), this.state.rect = {
      x1: Y2(o, (l) => l.data.state.rect.x) || 0,
      y1: Y2(o, (l) => l.data.state.rect.y) || 0,
      x2: X2(
        o,
        (l) => l.data.state.rect.x + l.data.state.rect.width
      ) || 0,
      y2: X2(
        o,
        (l) => l.data.state.rect.y + l.data.state.rect.height
      ) || 0
    };
  }
  setOptions(e) {
    this.options = {
      ...this.options,
      ...e
    }, this.options.zoom ? this.svg.call(this.zoom) : this.svg.on(".zoom", null), this.options.pan ? this.svg.on("wheel", this.handlePan) : this.svg.on("wheel", null);
  }
  async setData(e, r) {
    r && this.setOptions(r), e && (this.state.data = this._initializeData(e)), this.state.data && (this.updateStyle(), await this.renderData());
  }
  async setHighlight(e) {
    this.state.highlight = e || void 0, await this.renderData();
  }
  _getHighlightRect(e) {
    const r = this.svg.node(), n = 4 / _a(r).k, i = {
      ...e.state.rect
    };
    return i.x -= n, i.y -= n, i.width += 2 * n, i.height += 2 * n, i;
  }
  async renderData(e) {
    const { paddingX: r, autoFit: n, color: i, maxWidth: s, lineWidth: a } = this.options, o = this.state.data;
    if (!o) return;
    const l = {}, c = {}, h = [];
    Jo(o, (X, ct, gt) => {
      var xt;
      (xt = X.payload) != null && xt.fold || ct(), l[X.state.id] = X, gt && (c[X.state.id] = gt.state.id), h.push(X);
    });
    const p = {}, m = {}, g = (X) => {
      !X || p[X.state.id] || Jo(X, (ct, gt) => {
        p[ct.state.id] = X.state.id, gt();
      });
    }, y = (X) => m[p[X.state.id]] || o.state.rect, x = (X) => (l[p[X.state.id]] || o).state.rect;
    m[o.state.id] = o.state.rect, e && g(e);
    let { highlight: k } = this.state;
    k && !l[k.state.id] && (k = void 0);
    let C = this.g.selectAll(Xr(OO)).selectAll(Xr("rect")).data(k ? [this._getHighlightRect(k)] : []).join("rect").attr("x", (X) => X.x).attr("y", (X) => X.y).attr("width", (X) => X.width).attr("height", (X) => X.height);
    const A = this.g.selectAll(Xr(Jd)).each((X) => {
      m[X.state.id] = X.state.rect;
    }).data(h, (X) => X.state.key), $ = A.enter().append("g").attr("data-depth", (X) => X.state.depth).attr("data-path", (X) => X.state.path).each((X) => {
      g(l[c[X.state.id]]);
    }), B = A.exit().each((X) => {
      g(l[c[X.state.id]]);
    }), L = A.merge($).attr(
      "class",
      (X) => {
        var ct;
        return ["markmap-node", ((ct = X.payload) == null ? void 0 : ct.fold) && "markmap-fold"].filter(Boolean).join(" ");
      }
    ), q = L.selectAll(Xr("line")).data(
      (X) => [X],
      (X) => X.state.key
    ), U = q.enter().append("line").attr("stroke", (X) => i(X)).attr("stroke-width", 0), G = q.merge(U), F = L.selectAll(Xr("circle")).data(
      (X) => {
        var ct;
        return (ct = X.children) != null && ct.length ? [X] : [];
      },
      (X) => X.state.key
    ), W = F.enter().append("circle").attr("stroke-width", 0).attr("r", 0).on("click", (X, ct) => this.handleClick(X, ct)).on("mousedown", tp).merge(F).attr("stroke", (X) => i(X)).attr(
      "fill",
      (X) => {
        var ct;
        return (ct = X.payload) != null && ct.fold && X.children ? i(X) : "var(--markmap-circle-open-bg)";
      }
    ), R = this._observer, Q = L.selectAll(Xr("foreignObject")).data(
      (X) => [X],
      (X) => X.state.key
    ), rt = Q.enter().append("foreignObject").attr("class", "markmap-foreign").attr("x", r).attr("y", 0).style("opacity", 0).on("mousedown", tp).on("dblclick", tp);
    rt.append("xhtml:div").append("xhtml:div").html((X) => X.content).attr("xmlns", "http://www.w3.org/1999/xhtml"), rt.each(function() {
      var X;
      const ct = (X = this.firstChild) == null ? void 0 : X.firstChild;
      R.observe(ct);
    });
    const I = B.selectAll(
      Xr("foreignObject")
    );
    I.each(function() {
      var X;
      const ct = (X = this.firstChild) == null ? void 0 : X.firstChild;
      R.unobserve(ct);
    });
    const j = rt.merge(Q), z = h.flatMap(
      (X) => {
        var ct;
        return (ct = X.payload) != null && ct.fold ? [] : X.children.map((gt) => ({ source: X, target: gt }));
      }
    ), K = this.g.selectAll(Xr(IO)).data(z, (X) => X.target.state.key), Y = K.exit(), ot = K.enter().insert("path", "g").attr("class", "markmap-link").attr("data-depth", (X) => X.target.state.depth).attr("data-path", (X) => X.target.state.path).attr("d", (X) => {
      const ct = y(X.target), gt = [
        ct.x + ct.width,
        ct.y + ct.height
      ];
      return Qd({ source: gt, target: gt });
    }).attr("stroke-width", 0).merge(K);
    this.svg.style(
      "--markmap-max-width",
      s ? `${s}px` : null
    ), await new Promise(requestAnimationFrame), this._relayout(), C = C.data(k ? [this._getHighlightRect(k)] : []).join("rect"), this.transition(C).attr("x", (X) => X.x).attr("y", (X) => X.y).attr("width", (X) => X.width).attr("height", (X) => X.height), $.attr("transform", (X) => {
      const ct = y(X);
      return `translate(${ct.x + ct.width - X.state.rect.width},${ct.y + ct.height - X.state.rect.height})`;
    }), this.transition(B).attr("transform", (X) => {
      const ct = x(X), gt = ct.x + ct.width - X.state.rect.width, xt = ct.y + ct.height - X.state.rect.height;
      return `translate(${gt},${xt})`;
    }).remove(), this.transition(L).attr(
      "transform",
      (X) => `translate(${X.state.rect.x},${X.state.rect.y})`
    );
    const et = B.selectAll(
      Xr("line")
    );
    this.transition(et).attr("x1", (X) => X.state.rect.width).attr("stroke-width", 0), U.attr("x1", (X) => X.state.rect.width).attr("x2", (X) => X.state.rect.width), G.attr("y1", (X) => X.state.rect.height + a(X) / 2).attr("y2", (X) => X.state.rect.height + a(X) / 2), this.transition(G).attr("x1", -1).attr("x2", (X) => X.state.rect.width + 2).attr("stroke", (X) => i(X)).attr("stroke-width", a);
    const ht = B.selectAll(
      Xr("circle")
    );
    this.transition(ht).attr("r", 0).attr("stroke-width", 0), W.attr("cx", (X) => X.state.rect.width).attr("cy", (X) => X.state.rect.height + a(X) / 2), this.transition(W).attr("r", 6).attr("stroke-width", "1.5"), this.transition(I).style("opacity", 0), j.attr("width", (X) => Math.max(0, X.state.rect.width - r * 2)).attr("height", (X) => X.state.rect.height), this.transition(j).style("opacity", 1), this.transition(Y).attr("d", (X) => {
      const ct = x(X.target), gt = [
        ct.x + ct.width,
        ct.y + ct.height + a(X.target) / 2
      ];
      return Qd({ source: gt, target: gt });
    }).attr("stroke-width", 0).remove(), this.transition(ot).attr("stroke", (X) => i(X.target)).attr("stroke-width", (X) => a(X.target)).attr("d", (X) => {
      const ct = X.source, gt = X.target, xt = [
        ct.state.rect.x + ct.state.rect.width,
        ct.state.rect.y + ct.state.rect.height + a(ct) / 2
      ], Xt = [
        gt.state.rect.x,
        gt.state.rect.y + gt.state.rect.height + a(gt) / 2
      ];
      return Qd({ source: xt, target: Xt });
    }), n && this.fit();
  }
  transition(e) {
    const { duration: r } = this.options;
    return e.transition().duration(r);
  }
  /**
   * Fit the content to the viewport.
   */
  async fit(e = this.options.maxInitialScale) {
    const r = this.svg.node(), { width: n, height: i } = r.getBoundingClientRect(), { fitRatio: s } = this.options, { x1: a, y1: o, x2: l, y2: c } = this.state.rect, h = l - a, p = c - o, m = Math.min(
      n / h * s,
      i / p * s,
      e
    ), g = yu.translate(
      (n - h * m) / 2 - a * m,
      (i - p * m) / 2 - o * m
    ).scale(m);
    return this.transition(this.svg).call(this.zoom.transform, g).end().catch(Ta);
  }
  findElement(e) {
    let r;
    return this.g.selectAll(Xr(Jd)).each(function(n) {
      n === e && (r = {
        data: n,
        g: this
      });
    }), r;
  }
  /**
   * Pan the content to make the provided node visible in the viewport.
   */
  async ensureVisible(e, r) {
    var n;
    const i = (n = this.findElement(e)) == null ? void 0 : n.data;
    if (!i) return;
    const s = this.svg.node(), a = s.getBoundingClientRect(), o = _a(s), [l, c] = [
      i.state.rect.x,
      i.state.rect.x + i.state.rect.width + 2
    ].map((C) => C * o.k + o.x), [h, p] = [
      i.state.rect.y,
      i.state.rect.y + i.state.rect.height
    ].map((C) => C * o.k + o.y), m = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      ...r
    }, g = [m.left - l, a.width - m.right - c], y = [m.top - h, a.height - m.bottom - p], x = g[0] * g[1] > 0 ? gb(g, Math.abs) / o.k : 0, k = y[0] * y[1] > 0 ? gb(y, Math.abs) / o.k : 0;
    if (x || k) {
      const C = o.translate(x, k);
      return this.transition(this.svg).call(this.zoom.transform, C).end().catch(Ta);
    }
  }
  async centerNode(e, r) {
    var n;
    const i = (n = this.findElement(e)) == null ? void 0 : n.data;
    if (!i) return;
    const s = this.svg.node(), a = s.getBoundingClientRect(), o = _a(s), l = (i.state.rect.x + i.state.rect.width / 2) * o.k + o.x, c = (i.state.rect.y + i.state.rect.height / 2) * o.k + o.y, h = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      ...r
    }, p = (h.left + a.width - h.right) / 2, m = (h.top + a.height - h.bottom) / 2, g = (p - l) / o.k, y = (m - c) / o.k;
    if (g || y) {
      const x = o.translate(g, y);
      return this.transition(this.svg).call(this.zoom.transform, x).end().catch(Ta);
    }
  }
  /**
   * Scale content with it pinned at the center of the viewport.
   */
  async rescale(e) {
    const r = this.svg.node(), { width: n, height: i } = r.getBoundingClientRect(), s = n / 2, a = i / 2, o = _a(r), l = o.translate(
      (s - o.x) * (1 - e) / o.k,
      (a - o.y) * (1 - e) / o.k
    ).scale(e);
    return this.transition(this.svg).call(this.zoom.transform, l).end().catch(Ta);
  }
  destroy() {
    this.svg.on(".zoom", null), this.svg.html(null), this._disposeList.forEach((e) => {
      e();
    });
  }
  static create(e, r, n = null) {
    const i = new r6(e, r);
    return n && i.setData(n).then(() => {
      i.fit();
    }), i;
  }
};
var n6 = 1;
var i6 = 2;
var RO = "http://www.w3.org/2000/svg";
var ep = "http://www.w3.org/1999/xlink";
var PO = {
  show: ep,
  actuate: ep,
  href: ep
};
var jO = (t15) => typeof t15 == "string" || typeof t15 == "number";
var WO = (t15) => (t15 == null ? void 0 : t15.vtype) === n6;
var HO = (t15) => (t15 == null ? void 0 : t15.vtype) === i6;
function Hs(t15, e) {
  let r;
  if (typeof t15 == "string") r = n6;
  else if (typeof t15 == "function") r = i6;
  else throw new Error("Invalid VNode type");
  return {
    vtype: r,
    type: t15,
    props: e
  };
}
var s6 = Hs;
function a6(t15) {
  return t15.children;
}
var UO = {
  isSvg: false
};
function yb(t15, e) {
  Array.isArray(e) || (e = [e]), e = e.filter(Boolean), e.length && t15.append(...e);
}
function VO(t15, e, r) {
  for (const n in e)
    if (!(n === "key" || n === "children" || n === "ref"))
      if (n === "dangerouslySetInnerHTML")
        t15.innerHTML = e[n].__html;
      else if (n === "innerHTML" || n === "textContent" || n === "innerText" || n === "value" && ["textarea", "select"].includes(t15.tagName)) {
        const i = e[n];
        i != null && (t15[n] = i);
      } else n.startsWith("on") ? t15[n.toLowerCase()] = e[n] : XO(t15, n, e[n], r.isSvg);
}
var GO = {
  className: "class",
  labelFor: "for"
};
function XO(t15, e, r, n) {
  if (e = GO[e] || e, r === true)
    t15.setAttribute(e, "");
  else if (r === false)
    t15.removeAttribute(e);
  else {
    const i = n ? PO[e] : void 0;
    i !== void 0 ? t15.setAttributeNS(i, e, r) : t15.setAttribute(e, r);
  }
}
function YO(t15) {
  return t15.reduce((e, r) => e.concat(r), []);
}
function bf(t15, e) {
  return Array.isArray(t15) ? YO(t15.map((r) => bf(r, e))) : bm(t15, e);
}
function bm(t15, e = UO) {
  if (t15 == null || typeof t15 == "boolean")
    return null;
  if (t15 instanceof Node)
    return t15;
  if (HO(t15)) {
    const {
      type: r,
      props: n
    } = t15;
    if (r === a6) {
      const s = document.createDocumentFragment();
      if (n.children) {
        const a = bf(n.children, e);
        yb(s, a);
      }
      return s;
    }
    const i = r(n);
    return bm(i, e);
  }
  if (jO(t15))
    return document.createTextNode(`${t15}`);
  if (WO(t15)) {
    let r;
    const {
      type: n,
      props: i
    } = t15;
    if (!e.isSvg && n === "svg" && (e = Object.assign({}, e, {
      isSvg: true
    })), e.isSvg ? r = document.createElementNS(RO, n) : r = document.createElement(n), VO(r, i, e), i.children) {
      let a = e;
      e.isSvg && n === "foreignObject" && (a = Object.assign({}, a, {
        isSvg: false
      }));
      const o = bf(i.children, a);
      o != null && yb(r, o);
    }
    const {
      ref: s
    } = i;
    return typeof s == "function" && s(r), r;
  }
  throw new Error("mount: Invalid Vnode!");
}
function bb(t15) {
  return bm(t15);
}
var o6 = "mm-toolbar-item";
var KO = "active";
function ZO() {
  return s6("a", { className: "mm-toolbar-brand", href: "https://markmap.js.org/", children: [
    Hs(
      "img",
      {
        alt: "markmap",
        src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAACoFBMVEUAAAAAAAD//wAAAACAgAD//wAAAABVVQCqqgBAQACAQACAgABmZgBtbQAAAABgQABgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaFQAAAAAAAAAAAAAAAAAHAAARBQIdGAIYEwI/OgJYUQUfHQI+OgJDPgJJRARBPQRJQgRRSwRRTQRIQQRUTgRUUARZUgRSTQRPSQRjWgZORQRfWQZsZAhTTQRNRwRWUAZkXAZOSARUTgZPRwRRSQRoYwZWUQZWTgRbUwZmXQZoXghmXwdqYwdsYwdfVwVmXQdqYgdiWgVpYAl3bgl6cgl4cAqLggw8OAOWjA2Uig1OSAR2bQihlg55cAh5cAh6cQmMgwyOhAyUjA2QhQ2Uiw2Viw2soBCflA+voxGwpRGhlg+hlg+snxGroBGjmBCpnBC0pxKyphKxpRG2qhK0qBK5rBK5rBP/7h3/8B7/8R3/8h3/8R7/8h786x397B3+7R3EtxT66Rz66hz76hz86xz96xz97Bz+7Rz45xz56Bz76hz97Bz97B3MvRX15Rv25Rv45xz66Rz76hz97B3+7R3IuxX05Bv15Bv25Rz56Bz66Ry/sxPAsxPCtRTCthTNvxbZyxfczxfi0xjl1Rnn2Bnr2xrr3Brs3Rru3Rru3xrv3hrw3xrx4Bvx4Rvy4hvz4hvz4xv04xv05Bv14xv15Bv15Rv25Bv25Rv25Rz25hv35hv35xv45xv45xz55xz56Bv56Bz66Rv66Rz76Rv76Rz76hz86hv86xz+7h3/7R3/7h3/7x3/8B3/8B7/8R3/8R4Yqhj5AAAAq3RSTlMAAQECAgIDAwMEBAQFBwgICAwQERITFRYXGBkbHB0eHyQlJyguNTg8RUZISU5PV2FiY2RlZmdqa2xubnJzc3R2d3d3eXl5eXp7fH1+gIGCgoKDg4SEhIWGh4eHiYmJjIyMjZSUlJ+sra+zt7i4uru8ztHV1tbW2d7g4OHi4uPk5ufp7Ozv9fX29/f3+Pj6+vr7+/v7+/v7+/z8/Pz8/f39/f39/f3+/v7+/v7K6J1dAAACHklEQVQ4y2NgwAoYWdi5uLm5GXHIcrLCmMzYpDmAhKCKjoGtp40MFhVsDAwSxmmVEzZu2XvqSLkchjw3g0h445Ybd24vmTN1Usd5X3R5DgaNqgN35sycP2/GxMkTMRVwMOivvtO3YsWUm3duX790EcMKdgbNNXdnnJh1+9T6ipzU+FB0RzIyiFYB5WdfaElUF8TmTQ6GwH39J2bvypMHcpg4MAKKkUGo5s6KWRfyGRh4WJClGEGBCgS8DLobliy/3abMwM8NBYwQjXDgf3ryxOspyKYyg+RFTFwdnYDAzbrw+oLFm9Ot3J3AwNHFTBykQrhg++GDh48cOXzk4P6VZy8s230MyAGCwwcP7iyRBJpiur1n8hQIWHX27NkLi6bAwOSuow5ABeY7OydOhoCFIAULe6E8YFCf8QAqEC86evniZTA4tfLsuRXHr0E4ly9ePF0uC3KnpH1MZBQQxPoVgxyZ5RMdBQaRMc6yIEcihWbQGaA3k9G8CfQoN0pAtSoxCMACihk9qGtBQZ2LHtRIkRUMiqwd2TJADiswsrjQlAGju/o+MLrPNkWo8mFN1ewMWmvBCebQ0rKMJG87QzF0FRwMRuvugpLcrXu3rp7Zs61UCtMZ2nVHbk+fMX/+jMmTp3Sf9MLiULG45q237txaPG3yxPYrYQzYMo60RWbD3E27Ll68Uq+AK+uJqOlZBiSEKGLNnMA0iDfzwrI/NKgBOivk9piPdtUAAAAASUVORK5CYII="
      }
    ),
    Hs("span", { children: "markmap" })
  ] });
}
function JO({ title: t15, content: e, onClick: r }) {
  return Hs("div", { className: o6, title: t15, onClick: r, children: e });
}
var eh;
function QO(t15) {
  return async (...e) => {
    if (!eh) {
      eh = t15(...e);
      try {
        await eh;
      } finally {
        eh = void 0;
      }
    }
  };
}
var l6 = class ji {
  constructor() {
    this.showBrand = true, this.registry = {}, this.el = bb(Hs("div", { className: "mm-toolbar" })), this.items = [...ji.defaultItems], this.register({
      id: "zoomIn",
      title: "Zoom in",
      content: ji.icon("M9 5v4h-4v2h4v4h2v-4h4v-2h-4v-4z"),
      onClick: this.getHandler((e) => e.rescale(1.25))
    }), this.register({
      id: "zoomOut",
      title: "Zoom out",
      content: ji.icon("M5 9h10v2h-10z"),
      onClick: this.getHandler((e) => e.rescale(0.8))
    }), this.register({
      id: "fit",
      title: "Fit window size",
      content: ji.icon(
        "M4 7h2v-2h2v4h-4zM4 13h2v2h2v-4h-4zM16 7h-2v-2h-2v4h4zM16 13h-2v2h-2v-4h4z"
      ),
      onClick: this.getHandler((e) => e.fit())
    }), this.register({
      id: "recurse",
      title: "Toggle recursively",
      content: ji.icon("M16 4h-12v12h12v-8h-8v4h2v-2h4v4h-8v-8h10z"),
      onClick: (e) => {
        var r;
        const n = e.target.closest(
          `.${o6}`
        ), i = n == null ? void 0 : n.classList.toggle(KO);
        (r = this.markmap) == null || r.setOptions({
          toggleRecursively: i
        });
      }
    }), this.register({
      id: "dark",
      title: "Toggle dark theme",
      content: ji.icon(
        "M10 4a6 6 0 0 0 0 12a6 6 0 0 0 0 -12v2a4 4 0 0 1 0 8z"
      ),
      onClick: () => {
        document.documentElement.classList.toggle("markmap-dark");
      }
    }), this.render();
  }
  static create(e) {
    const r = new ji();
    return r.attach(e), r;
  }
  static icon(e, r = {}) {
    return r = {
      stroke: "none",
      fill: "currentColor",
      "fill-rule": "evenodd",
      ...r
    }, Hs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", children: Hs("path", { ...r, d: e }) });
  }
  /** @deprecated Set `showBrand` instead. */
  setBrand(e) {
    return this.showBrand = e, this.render();
  }
  register(e) {
    this.registry[e.id] = e;
  }
  getHandler(e) {
    return e = QO(e), () => {
      this.markmap && e(this.markmap);
    };
  }
  setItems(e) {
    return this.items = [...e], this.render();
  }
  attach(e) {
    this.markmap = e;
  }
  render() {
    const e = this.items.map((r) => {
      if (typeof r == "string") {
        const n = this.registry[r];
        return n || console.warn(`[markmap-toolbar] ${r} not found`), n;
      }
      return r;
    }).filter(Boolean);
    for (; this.el.firstChild; )
      this.el.firstChild.remove();
    return this.el.append(
      bb(
        s6(a6, { children: [
          this.showBrand && ZO(),
          e.map(JO)
        ] })
      )
    ), this.el;
  }
};
l6.defaultItems = [
  "zoomIn",
  "zoomOut",
  "fit",
  "recurse",
  "dark"
];
var tz = l6;
var As = /* @__PURE__ */ new Map();
var rp = /* @__PURE__ */ new Map();
var Yr = /* @__PURE__ */ new Map();
var il = /* @__PURE__ */ new Map();
var np = /* @__PURE__ */ new Map();
var xb = /* @__PURE__ */ new WeakMap();
var di = /* @__PURE__ */ new Set();
function ez(t15) {
  if (il.has(t15))
    return il.get(t15);
  if ((/* @__PURE__ */ new Set(["script", "style", "meta", "link", "noscript", "template"])).has(t15)) {
    const s = {};
    return il.set(t15, s), s;
  }
  let e = document.getElementById("snapdom-sandbox");
  e || (e = document.createElement("div"), e.id = "snapdom-sandbox", e.style.position = "absolute", e.style.left = "-9999px", e.style.top = "-9999px", e.style.width = "0", e.style.height = "0", e.style.overflow = "hidden", document.body.appendChild(e));
  const r = document.createElement(t15);
  r.style.all = "initial", e.appendChild(r);
  const n = getComputedStyle(r), i = {};
  for (let s of n)
    i[s] = n.getPropertyValue(s);
  return e.removeChild(r), il.set(t15, i), i;
}
function xf(t15, e, r = false) {
  const n = [], i = ez(e);
  for (let [s, a] of Object.entries(t15))
    if (!r)
      a && n.push(`${s}:${a}`);
    else {
      const o = i[s];
      a && a !== o && n.push(`${s}:${a}`);
    }
  return n.sort().join(";");
}
function rz(t15) {
  const e = /* @__PURE__ */ new Set();
  return t15.nodeType !== Node.ELEMENT_NODE && t15.nodeType !== Node.DOCUMENT_FRAGMENT_NODE ? [] : (t15.tagName && e.add(t15.tagName.toLowerCase()), typeof t15.querySelectorAll == "function" && t15.querySelectorAll("*").forEach((r) => e.add(r.tagName.toLowerCase())), Array.from(e));
}
function nz(t15) {
  const e = /* @__PURE__ */ new Map();
  for (let n of t15) {
    const i = il.get(n);
    if (!i) continue;
    const s = Object.entries(i).map(([a, o]) => `${a}:${o};`).sort().join("");
    e.has(s) || e.set(s, []), e.get(s).push(n);
  }
  let r = "";
  for (let [n, i] of e.entries())
    r += `${i.join(",")} { ${n} }
`;
  return r;
}
function iz(t15) {
  const e = new Set(t15.values()), r = /* @__PURE__ */ new Map();
  let n = 1;
  for (const i of e)
    r.set(i, `c${n++}`);
  return r;
}
async function c6(t15, e = {}) {
  var _a3;
  const r = (_a3 = t15.match(/url\(["']?(.*?)["']?\)/)) == null ? void 0 : _a3[1];
  if (r) {
    const n = km(r);
    if (rp.has(n))
      return e.skipInline ? void 0 : `url(${rp.get(n)})`;
    {
      const i = await wm(n, { useProxy: e.useProxy });
      return rp.set(n, i), e.skipInline ? void 0 : `url("${i}")`;
    }
  }
  return t15;
}
function Io(t15, { fast: e = false } = {}) {
  if (e) return t15();
  "requestIdleCallback" in window ? requestIdleCallback(t15, { timeout: 50 }) : setTimeout(t15, 1);
}
function xm(t15, e = null) {
  if (!(t15 instanceof Element))
    return window.getComputedStyle(t15, e);
  let r = xb.get(t15);
  if (r || (r = /* @__PURE__ */ new Map(), xb.set(t15, r)), !r.has(e)) {
    const n = window.getComputedStyle(t15, e);
    r.set(e, n);
  }
  return r.get(e);
}
function sz(t15) {
  let e = t15.replace(/^['"]|['"]$/g, "");
  if (e.startsWith("\\"))
    try {
      return String.fromCharCode(parseInt(e.replace("\\", ""), 16));
    } catch {
      return e;
    }
  return e;
}
function h6(t15) {
  const e = t15.indexOf("url(");
  if (e === -1) return null;
  let r = t15.slice(e + 4).trim();
  return r.endsWith(")") && (r = r.slice(0, -1).trim()), (r.startsWith('"') && r.endsWith('"') || r.startsWith("'") && r.endsWith("'")) && (r = r.slice(1, -1)), r;
}
function wm(t15, { timeout: e = 3e3, useProxy: r = "" } = {}) {
  function n(a) {
    try {
      return new URL(a, window.location.href).origin === window.location.origin ? "use-credentials" : "anonymous";
    } catch {
      return "anonymous";
    }
  }
  async function i(a) {
    const o = (l) => fetch(l, {
      mode: "cors",
      credentials: n(l) === "use-credentials" ? "include" : "omit"
    }).then((c) => c.blob()).then((c) => new Promise((h, p) => {
      const m = new FileReader();
      m.onloadend = () => {
        const g = m.result;
        if (typeof g != "string" || !g.startsWith("data:image/")) {
          p(new Error("Invalid image data URL"));
          return;
        }
        h(g);
      }, m.onerror = () => p(new Error("FileReader error")), m.readAsDataURL(c);
    }));
    try {
      return await o(a);
    } catch {
      if (r && typeof r == "string") {
        const l = r.replace(/\/$/, "") + km(a);
        try {
          return await o(l);
        } catch {
          throw console.error(`[SnapDOM - fetchImage] Proxy fallback failed for: ${a}`), new Error("CORS restrictions prevented image capture (even via proxy)");
        }
      } else
        throw console.error(`[SnapDOM - fetchImage] No valid proxy URL provided for fallback: ${a}`), new Error("Fetch fallback failed and no proxy provided");
    }
  }
  const s = n(t15);
  return console.log(`[SnapDOM - fetchImage] Start loading image: ${t15} with crossOrigin=${s}`), As.has(t15) ? (console.log(`[SnapDOM - fetchImage] Cache hit for: ${t15}`), Promise.resolve(As.get(t15))) : t15.startsWith("data:image/") ? (As.set(t15, t15), Promise.resolve(t15)) : /\.svg(\?.*)?$/i.test(t15) ? (async () => {
    try {
      const a = await (await fetch(t15, {
        mode: "cors",
        credentials: s === "use-credentials" ? "include" : "omit"
      })).text(), o = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(a)}`;
      return As.set(t15, o), o;
    } catch {
      return i(t15);
    }
  })() : new Promise((a, o) => {
    const l = setTimeout(() => {
      console.log(`[SnapDOM - fetchImage] Timeout after ${e}ms for image: ${t15}`), o(new Error("Image load timed out"));
    }, e), c = new Image();
    c.crossOrigin = s, c.onload = async () => {
      clearTimeout(l);
      try {
        await c.decode();
        const h = document.createElement("canvas");
        h.width = c.width, h.height = c.height, h.getContext("2d").drawImage(c, 0, 0, h.width, h.height);
        const p = h.toDataURL("image/png");
        As.set(t15, p), a(p);
      } catch {
        try {
          const h = await i(t15);
          As.set(t15, h), a(h);
        } catch (h) {
          o(h);
        }
      }
    }, c.onerror = async () => {
      clearTimeout(l), console.error(`[SnapDOM - fetchImage] Image failed to load: ${t15}`);
      try {
        const h = await i(t15);
        As.set(t15, h), a(h);
      } catch (h) {
        o(h);
      }
    }, c.src = t15;
  });
}
function wb(t15) {
  const e = {};
  for (let r of t15)
    e[r] = t15.getPropertyValue(r);
  return e;
}
function u6() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function az(t15) {
  if (!t15 || t15 === "none") return "";
  let e = t15.replace(/translate[XY]?\([^)]*\)/g, "");
  return e = e.replace(/matrix\(([^)]+)\)/g, (r, n) => {
    const i = n.split(",").map((s) => s.trim());
    return i.length !== 6 ? `matrix(${n})` : (i[4] = "0", i[5] = "0", `matrix(${i.join(", ")})`);
  }), e = e.replace(/matrix3d\(([^)]+)\)/g, (r, n) => {
    const i = n.split(",").map((s) => s.trim());
    return i.length !== 16 ? `matrix3d(${n})` : (i[12] = "0", i[13] = "0", `matrix3d(${i.join(", ")})`);
  }), e.trim().replace(/\s{2,}/g, " ");
}
function km(t15) {
  if (/%[0-9A-Fa-f]{2}/.test(t15)) return t15;
  try {
    return encodeURI(t15);
  } catch {
    return t15;
  }
}
function d6(t15) {
  const e = [];
  let r = 0, n = 0;
  for (let i = 0; i < t15.length; i++) {
    const s = t15[i];
    s === "(" && r++, s === ")" && r--, s === "," && r === 0 && (e.push(t15.slice(n, i).trim()), n = i + 1);
  }
  return e.push(t15.slice(n).trim()), e;
}
var ip = /* @__PURE__ */ new WeakMap();
var sp = /* @__PURE__ */ new Map();
function oz(t15) {
  const e = {};
  for (let r = 0; r < t15.length; r++) {
    const n = t15[r];
    let i = t15.getPropertyValue(n);
    (n === "background-image" || n === "content") && i.includes("url(") && !i.includes("data:") && (i = "none"), e[n] = i;
  }
  return e;
}
function kb(t15, e, r, n, i) {
  var _a3;
  if (t15.tagName === "STYLE") return;
  n.has(t15) || n.set(t15, xm(t15));
  const s = n.get(t15);
  if (!ip.has(t15)) {
    const h = oz(s);
    ip.set(t15, h);
  }
  const a = ip.get(t15), o = Object.entries(a).sort(([h], [p]) => h.localeCompare(p)).map(([h, p]) => `${h}:${p}`).join(";");
  if (sp.has(o)) {
    r.set(e, sp.get(o));
    return;
  }
  const l = ((_a3 = t15.tagName) == null ? void 0 : _a3.toLowerCase()) || "div", c = xf(a, l, i);
  sp.set(o, c), r.set(e, c);
}
function lz(t15) {
  return t15.nodeType === Node.ELEMENT_NODE && t15.tagName === "SLOT";
}
function Ah(t15, e, r, n, i, s = {}, a) {
  var _a3, _b2;
  if (t15.nodeType === Node.TEXT_NODE || t15.nodeType !== Node.ELEMENT_NODE) return t15.cloneNode(true);
  if (t15.getAttribute("data-capture") === "exclude") {
    const l = document.createElement("div"), c = t15.getBoundingClientRect();
    return l.style.cssText = `display: inline-block; width: ${c.width}px; height: ${c.height}px; visibility: hidden;`, l;
  }
  if (s.exclude && Array.isArray(s.exclude))
    for (const l of s.exclude)
      try {
        if ((_a3 = t15.matches) == null ? void 0 : _a3.call(t15, l)) {
          const c = document.createElement("div"), h = t15.getBoundingClientRect();
          return c.style.cssText = `display: inline-block; width: ${h.width}px; height: ${h.height}px; visibility: hidden;`, c;
        }
      } catch (c) {
        console.warn(`Invalid selector in exclude option: ${l}`, c);
      }
  if (typeof s.filter == "function")
    try {
      if (!s.filter(t15, a || t15)) {
        const l = document.createElement("div"), c = t15.getBoundingClientRect();
        return l.style.cssText = `display: inline-block; width: ${c.width}px; height: ${c.height}px; visibility: hidden;`, l;
      }
    } catch (l) {
      console.warn("Error in filter function:", l);
    }
  if (t15.tagName === "IFRAME") {
    const l = document.createElement("div");
    return l.textContent = "", l.style.cssText = `width: ${t15.offsetWidth}px; height: ${t15.offsetHeight}px; background-image: repeating-linear-gradient(45deg, #ddd, #ddd 5px, #f9f9f9 5px, #f9f9f9 10px);display: flex;align-items: center;justify-content: center;font-size: 12px;color: #555; border: 1px solid #aaa;`, l;
  }
  if (t15.getAttribute("data-capture") === "placeholder") {
    const l = t15.cloneNode(false);
    n.set(l, t15), kb(t15, l, e, r, i);
    const c = document.createElement("div");
    return c.textContent = t15.getAttribute("data-placeholder-text") || "", c.style.cssText = "color: #666;font-size: 12px;text-align: center;line-height: 1.4;padding: 0.5em;box-sizing: border-box;", l.appendChild(c), l;
  }
  if (t15.tagName === "CANVAS") {
    const l = t15.toDataURL(), c = document.createElement("img");
    return c.src = l, c.width = t15.width, c.height = t15.height, c.style.display = "inline-block", c.style.width = t15.style.width || `${t15.width}px`, c.style.height = t15.style.height || `${t15.height}px`, c;
  }
  const o = t15.cloneNode(false);
  if (n.set(o, t15), t15 instanceof HTMLInputElement)
    o.value = t15.value, o.setAttribute("value", t15.value), t15.checked !== void 0 && (o.checked = t15.checked, t15.checked && o.setAttribute("checked", ""));
  else if (t15 instanceof HTMLTextAreaElement) {
    const l = t15.getBoundingClientRect();
    o.textContent = t15.value, o.style.width = `${l.width}px`, o.style.height = `${l.height}px`;
  } else t15 instanceof HTMLSelectElement && (o.value = t15.value, Array.from(o.options).forEach((l) => {
    l.value === t15.value ? l.setAttribute("selected", "") : l.removeAttribute("selected");
  }));
  if (kb(t15, o, e, r, i), lz(t15)) {
    const l = ((_b2 = t15.assignedNodes) == null ? void 0 : _b2.call(t15, { flatten: true })) || [], c = l.length > 0 ? l : Array.from(t15.childNodes), h = document.createDocumentFragment();
    for (const p of c) {
      const m = Ah(p, e, r, n, i, s, a || t15);
      m && h.appendChild(m);
    }
    return h;
  } else if (!(t15 instanceof HTMLTextAreaElement)) {
    const l = t15.shadowRoot ? t15.shadowRoot.childNodes : t15.childNodes;
    for (const c of l) {
      const h = Ah(c, e, r, n, i, s, a || t15);
      h && o.appendChild(h);
    }
    if (t15.shadowRoot && t15.childNodes.length > 0 && !t15.shadowRoot.querySelector("slot")) {
      const c = document.createDocumentFragment();
      for (const h of t15.childNodes) {
        const p = Ah(h, e, r, n, i, s, a || t15);
        p && c.appendChild(p);
      }
      o.appendChild(c);
    }
  }
  return o;
}
var cz = [
  // /uicons/i,
  /font\s*awesome/i,
  /material\s*icons/i,
  /ionicons/i,
  /glyphicons/i,
  /feather/i,
  /bootstrap\s*icons/i,
  /remix\s*icons/i,
  /heroicons/i,
  /layui/i,
  /lucide/i
];
var wf = [];
function hz(t15) {
  const e = Array.isArray(t15) ? t15 : [t15];
  for (const r of e)
    r instanceof RegExp ? wf.push(r) : typeof r == "string" ? wf.push(new RegExp(r, "i")) : console.warn("[snapdom] Ignored invalid iconFont value:", r);
}
function Wi(t15) {
  const e = typeof t15 == "string" ? t15 : "", r = [...cz, ...wf];
  for (const n of r)
    if (n instanceof RegExp && n.test(e)) return true;
  return !!(/icon/i.test(e) || /glyph/i.test(e) || /symbols/i.test(e) || /feather/i.test(e) || /fontawesome/i.test(e));
}
async function uz(t15, e, r, n = 32, i = "#000") {
  e = e.replace(/^['"]+|['"]+$/g, "");
  const s = window.devicePixelRatio || 1, a = document.createElement("canvas").getContext("2d");
  a.font = r ? `${r} ${n}px "${e}"` : `${n}px "${e}"`;
  const o = a.measureText(t15), l = o.actualBoundingBoxAscent || n * 0.8, c = o.actualBoundingBoxDescent || n * 0.2, h = l + c, p = o.width, m = document.createElement("canvas");
  m.width = Math.ceil(p * s), m.height = Math.ceil(h * s);
  const g = m.getContext("2d");
  return g.scale(s, s), g.font = a.font, g.textAlign = "left", g.textBaseline = "alphabetic", g.fillStyle = i, g.fillText(t15, 0, l), m.toDataURL();
}
function p6(t15) {
  return Array.from(document.styleSheets).some((e) => e.href === t15);
}
function dz(t15) {
  return new Promise((e) => {
    if (p6(t15)) return e(null);
    const r = document.createElement("link");
    r.rel = "stylesheet", r.href = t15, r.setAttribute("data-snapdom", "injected-import"), r.onload = () => e(r), r.onerror = () => e(null), document.head.appendChild(r);
  });
}
async function pz({ preCached: t15 = false } = {}) {
  if (Yr.has("fonts-embed-css")) {
    if (t15) {
      const s = document.createElement("style");
      s.setAttribute("data-snapdom", "embedFonts"), s.textContent = Yr.get("fonts-embed-css"), document.head.appendChild(s);
    }
    return Yr.get("fonts-embed-css");
  }
  const e = /@import\s+url\(["']?([^"')]+)["']?\)/g, r = [];
  for (const s of document.querySelectorAll("style")) {
    const a = s.textContent || "", o = Array.from(a.matchAll(e));
    for (const l of o) {
      const c = l[1];
      Wi(c) || p6(c) || r.push(c);
    }
  }
  await Promise.all(r.map(dz));
  const n = Array.from(document.querySelectorAll('link[rel="stylesheet"]')).filter((s) => s.href);
  let i = "";
  for (const s of n)
    try {
      const a = await (await fetch(s.href)).text();
      if (Wi(s.href) || Wi(a)) continue;
      const o = /url\((["']?)([^"')]+)\1\)/g, l = await Promise.all(
        Array.from(a.matchAll(o)).map(async (h) => {
          let p = h6(h[0]);
          if (!p) return null;
          let m = p;
          if (!m.startsWith("http") && !m.startsWith("data:") && (m = new URL(m, s.href).href), Wi(m)) return null;
          if (Yr.has(m))
            return di.add(m), { original: h[0], inlined: `url(${Yr.get(m)})` };
          if (di.has(m)) return null;
          try {
            const g = await (await fetch(m)).blob(), y = await new Promise((x) => {
              const k = new FileReader();
              k.onload = () => x(k.result), k.readAsDataURL(g);
            });
            return Yr.set(m, y), di.add(m), { original: h[0], inlined: `url(${y})` };
          } catch {
            return console.warn("[snapdom] Failed to fetch font resource:", m), null;
          }
        })
      );
      let c = a;
      for (const h of l)
        h && (c = c.replace(h.original, h.inlined));
      i += c + `
`;
    } catch {
      console.warn("[snapdom] Failed to fetch CSS:", s.href);
    }
  for (const s of document.styleSheets)
    try {
      if (!s.href || n.every((a) => a.href !== s.href)) {
        for (const a of s.cssRules)
          if (a.type === CSSRule.FONT_FACE_RULE) {
            const o = a.style.getPropertyValue("src"), l = a.style.getPropertyValue("font-family");
            if (!o || Wi(l)) continue;
            const c = /url\((["']?)([^"')]+)\1\)/g;
            let h = o;
            const p = Array.from(o.matchAll(c));
            for (const m of p) {
              let g = m[2].trim();
              if (!g) continue;
              let y = g;
              if (!y.startsWith("http") && !y.startsWith("data:") && (y = new URL(y, s.href || location.href).href), !Wi(y)) {
                if (Yr.has(y)) {
                  di.add(y), h = h.replace(m[0], `url(${Yr.get(y)})`);
                  continue;
                }
                if (!di.has(y))
                  try {
                    const x = await (await fetch(y)).blob(), k = await new Promise((C) => {
                      const A = new FileReader();
                      A.onload = () => C(A.result), A.readAsDataURL(x);
                    });
                    Yr.set(y, k), di.add(y), h = h.replace(m[0], `url(${k})`);
                  } catch {
                    console.warn("[snapdom] Failed to fetch font URL:", y);
                  }
              }
            }
            i += `@font-face {
  font-family: ${l};
  src: ${h};
  font-style: ${a.style.getPropertyValue("font-style") || "normal"};
  font-weight: ${a.style.getPropertyValue("font-weight") || "normal"};
}
`;
          }
      }
    } catch (a) {
      console.warn("[snapdom] Cannot access stylesheet", s.href, a);
    }
  for (const s of document.fonts)
    if (s.family && s.status === "loaded" && s._snapdomSrc) {
      if (Wi(s.family)) continue;
      let a = s._snapdomSrc;
      if (!a.startsWith("data:")) {
        if (Yr.has(s._snapdomSrc))
          a = Yr.get(s._snapdomSrc), di.add(s._snapdomSrc);
        else if (!di.has(s._snapdomSrc))
          try {
            const o = await (await fetch(s._snapdomSrc)).blob();
            a = await new Promise((l) => {
              const c = new FileReader();
              c.onload = () => l(c.result), c.readAsDataURL(o);
            }), Yr.set(s._snapdomSrc, a), di.add(s._snapdomSrc);
          } catch {
            console.warn("[snapdom] Failed to fetch dynamic font src:", s._snapdomSrc);
            continue;
          }
      }
      i += `@font-face {
  font-family: '${s.family}';
  src: url(${a});
  font-style: ${s.style || "normal"};
  font-weight: ${s.weight || "normal"};
}
`;
    }
  if (i && (Yr.set("fonts-embed-css", i), t15)) {
    const s = document.createElement("style");
    s.setAttribute("data-snapdom", "embedFonts"), s.textContent = i, document.head.appendChild(s);
  }
  return i;
}
async function f6(t15, e, r, n, i, s = false, a) {
  var _a3;
  if (!(t15 instanceof Element) || !(e instanceof Element)) return;
  for (const c of ["::before", "::after", "::first-letter"])
    try {
      const h = xm(t15, c);
      if (!h || typeof h[Symbol.iterator] != "function") continue;
      if (c === "::first-letter") {
        const C = getComputedStyle(t15);
        if (!(h.color !== C.color || h.fontSize !== C.fontSize || h.fontWeight !== C.fontWeight)) continue;
        const A = Array.from(e.childNodes).find(
          (W) => W.nodeType === Node.TEXT_NODE && W.textContent && W.textContent.trim().length > 0
        );
        if (!A) continue;
        const $ = A.textContent, B = (_a3 = $.match(/^([^\p{L}\p{N}\s]*[\p{L}\p{N}](?:['’])?)/u)) == null ? void 0 : _a3[0], L = $.slice((B == null ? void 0 : B.length) || 0);
        if (!B || /[\uD800-\uDFFF]/.test(B)) continue;
        const q = document.createElement("span");
        q.textContent = B, q.dataset.snapdomPseudo = "::first-letter";
        const U = wb(h), G = xf(U, "span", i);
        r.set(q, G);
        const F = document.createTextNode(L);
        e.replaceChild(F, A), e.insertBefore(q, F);
        continue;
      }
      const p = h.getPropertyValue("content"), m = h.getPropertyValue("background-image"), g = h.getPropertyValue("background-color"), y = p !== "none", x = m && m !== "none", k = g && g !== "transparent" && g !== "rgba(0, 0, 0, 0)";
      if (y || x || k) {
        const C = h.getPropertyValue("font-family"), A = parseInt(h.getPropertyValue("font-size")) || 32, $ = parseInt(h.getPropertyValue("font-weight")) || false, B = h.getPropertyValue("color") || "#000", L = document.createElement("span");
        L.dataset.snapdomPseudo = c;
        const q = wb(h), U = xf(q, "span", i);
        r.set(L, U);
        const G = Wi(C), F = sz(p);
        if (G && F.length === 1) {
          const W = document.createElement("img");
          W.src = await uz(F, C, $, A, B), W.style = `width:${A}px;height:auto;object-fit:contain;`, L.appendChild(W);
        } else if (F.startsWith("url(")) {
          const W = h6(F);
          if (W && W.trim() !== "")
            try {
              const R = document.createElement("img"), Q = await wm(km(W, { useProxy: a }));
              R.src = Q, R.style = `width:${A}px;height:auto;object-fit:contain;`, L.appendChild(R);
            } catch (R) {
              console.error(`[snapdom] Error in pseudo ${c} for`, t15, R);
            }
        } else !G && F && F !== "none" && (L.textContent = F);
        if (x)
          try {
            const W = d6(m), R = await Promise.all(
              W.map((Q) => c6(Q))
            );
            L.style.backgroundImage = R.join(", ");
          } catch (W) {
            console.warn(`[snapdom] Failed to inline background-image for ${c}`, W);
          }
        if (k && (L.style.backgroundColor = g), !(L.childNodes.length > 0 || L.textContent && L.textContent.trim() !== "" || x || k)) continue;
        c === "::before" ? e.insertBefore(L, e.firstChild) : e.appendChild(L);
      }
    } catch (h) {
      console.warn(`[snapdom] Failed to capture ${c} for`, t15, h);
    }
  const o = Array.from(t15.children), l = Array.from(e.children).filter((c) => !c.dataset.snapdomPseudo);
  for (let c = 0; c < Math.min(o.length, l.length); c++)
    await f6(
      o[c],
      l[c],
      r,
      n,
      i,
      s,
      a
    );
}
function fz(t15) {
  if (!t15) return;
  const e = document.querySelectorAll("svg > defs");
  e.length && t15.querySelectorAll("svg").forEach((r) => {
    const n = r.querySelectorAll("use");
    if (!n.length) return;
    const i = /* @__PURE__ */ new Set();
    if (n.forEach((a) => {
      const o = a.getAttribute("xlink:href") || a.getAttribute("href");
      o && o.startsWith("#") && i.add(o.slice(1));
    }), !i.size) return;
    const s = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    for (const a of i)
      for (const o of e) {
        const l = o.querySelector(`#${CSS.escape(a)}`);
        if (l) {
          s.appendChild(l.cloneNode(true));
          break;
        }
      }
    s.childNodes.length && r.insertBefore(s, r.firstChild);
  });
}
async function mz(t15, e = false, r = false, n = {}) {
  var _a3;
  const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new Map();
  let o;
  try {
    o = Ah(t15, i, s, a, e, n, t15);
  } catch (c) {
    throw console.warn("deepClone failed:", c), c;
  }
  try {
    await f6(t15, o, i, s, e, r, n.useProxy);
  } catch (c) {
    console.warn("inlinePseudoElements failed:", c);
  }
  try {
    fz(o);
  } catch (c) {
    console.warn("inlineExternalDef failed:", c);
  }
  let l = "";
  if (e) {
    const c = iz(i);
    l = Array.from(c.entries()).map(([h, p]) => `.${p}{${h}}`).join("");
    for (const [h, p] of i.entries()) {
      if (h.tagName === "STYLE") continue;
      const m = c.get(p);
      m && h.classList.add(m);
      const g = (_a3 = h.style) == null ? void 0 : _a3.backgroundImage;
      h.removeAttribute("style"), g && g !== "none" && (h.style.backgroundImage = g);
    }
  } else
    for (const [c, h] of i.entries())
      c.tagName !== "STYLE" && c.setAttribute("style", h.replace(/;/g, "; "));
  for (const [c, h] of a.entries()) {
    const p = h.scrollLeft, m = h.scrollTop;
    if ((p || m) && c instanceof HTMLElement) {
      c.style.overflow = "hidden", c.style.scrollbarWidth = "none", c.style.msOverflowStyle = "none";
      const g = document.createElement("div");
      for (g.style.transform = `translate(${-p}px, ${-m}px)`, g.style.willChange = "transform", g.style.display = "inline-block", g.style.width = "100%"; c.firstChild; )
        g.appendChild(c.firstChild);
      c.appendChild(g);
    }
  }
  if (t15 === a.get(o)) {
    const c = s.get(t15) || window.getComputedStyle(t15);
    s.set(t15, c);
    const h = az(c.transform);
    o.style.margin = "0", o.style.position = "static", o.style.top = "auto", o.style.left = "auto", o.style.right = "auto", o.style.bottom = "auto", o.style.zIndex = "auto", o.style.float = "none", o.style.clear = "none", o.style.transform = h || "";
  }
  for (const [c, h] of a.entries())
    h.tagName === "PRE" && (c.style.marginTop = "0", c.style.marginBlockStart = "0");
  return { clone: o, classCSS: l, styleCache: s };
}
async function gz(t15, e = {}) {
  const r = Array.from(t15.querySelectorAll("img")), n = async (i) => {
    const s = i.src;
    try {
      const a = await wm(s, { useProxy: e.useProxy });
      i.src = a, i.width || (i.width = i.naturalWidth || 100), i.height || (i.height = i.naturalHeight || 100);
    } catch {
      const a = document.createElement("div");
      a.style = `width: ${i.width || 100}px; height: ${i.height || 100}px; background: #ccc; display: inline-block; text-align: center; line-height: ${i.height || 100}px; color: #666; font-size: 12px;`, a.innerText = "img", i.replaceWith(a);
    }
  };
  for (let i = 0; i < r.length; i += 4) {
    const s = r.slice(i, i + 4).map(n);
    await Promise.allSettled(s);
  }
}
async function yz(t15, e, r, n = {}) {
  const i = [[t15, e]], s = [
    "background-image",
    "mask",
    "mask-image",
    "-webkit-mask-image",
    "mask-source",
    "mask-box-image-source",
    "mask-border-source",
    "-webkit-mask-box-image-source"
  ];
  for (; i.length; ) {
    const [a, o] = i.shift(), l = r.get(a) || xm(a);
    r.has(a) || r.set(a, l);
    for (const m of s) {
      const g = l.getPropertyValue(m);
      if (!g || g === "none") continue;
      const y = d6(g), x = await Promise.all(
        y.map((k) => c6(k, n))
      );
      x.some((k) => k && k !== "none" && !/^url\(undefined/.test(k)) && o.style.setProperty(m, x.join(", "));
    }
    const c = l.getPropertyValue("background-color");
    c && c !== "transparent" && c !== "rgba(0, 0, 0, 0)" && (o.style.backgroundColor = c);
    const h = Array.from(a.children), p = Array.from(o.children);
    for (let m = 0; m < Math.min(h.length, p.length); m++)
      i.push([h[m], p[m]]);
  }
}
async function bz(t15, e = {}) {
  if (!t15) throw new Error("Element cannot be null or undefined");
  const { compress: r = true, embedFonts: n = false, fast: i = true, scale: s = 1, useProxy: a = "" } = e;
  let o, l, c, h = "", p = "", m, g;
  if ({ clone: o, classCSS: l, styleCache: c } = await mz(t15, r, n, e), await new Promise((x) => {
    Io(async () => {
      await gz(o, e), x();
    }, { fast: i });
  }), await new Promise((x) => {
    Io(async () => {
      await yz(t15, o, c, e), x();
    }, { fast: i });
  }), n && await new Promise((x) => {
    Io(async () => {
      h = await pz(), x();
    }, { fast: i });
  }), r) {
    const x = rz(o).sort(), k = x.join(",");
    np.has(k) ? p = np.get(k) : await new Promise((C) => {
      Io(() => {
        p = nz(x), np.set(k, p), C();
      }, { fast: i });
    });
  }
  await new Promise((x) => {
    Io(() => {
      const k = t15.getBoundingClientRect();
      let C = k.width, A = k.height;
      const $ = Number.isFinite(e.width), B = Number.isFinite(e.height), L = typeof s == "number" && s !== 1;
      if (!L) {
        const W = k.width / k.height;
        $ && B ? (C = e.width, A = e.height) : $ ? (C = e.width, A = C / W) : B && (A = e.height, C = A * W);
      }
      if (C = Math.ceil(C), A = Math.ceil(A), o.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), o.style.transformOrigin = "top left", !L && ($ || B)) {
        const W = k.width, R = k.height, Q = C / W, rt = A / R, I = o.style.transform || "", j = `scale(${Q}, ${rt})`;
        o.style.transform = `${j} ${I}`.trim();
      } else L && u6() && (o.style.scale = `${s}`);
      const q = "http://www.w3.org/2000/svg", U = document.createElementNS(q, "foreignObject");
      U.setAttribute("width", "100%"), U.setAttribute("height", "100%");
      const G = document.createElement("style");
      G.textContent = p + h + "svg{overflow:visible;}" + l, U.appendChild(G), U.appendChild(o);
      const F = new XMLSerializer().serializeToString(U);
      g = `<svg xmlns="${q}" width="${C}" height="${A}" viewBox="0 0 ${C} ${A}">` + F + "</svg>", m = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(g)}`, x();
    }, { fast: i });
  });
  const y = document.getElementById("snapdom-sandbox");
  return y && y.style.position === "absolute" && y.remove(), m;
}
async function xz(t15, { dpr: e = 1, scale: r = 1 }) {
  const n = new Image();
  return n.src = t15, await n.decode(), u6 ? (n.width = n.width * r, n.height = n.height * r) : (n.width = n.width / r, n.height = n.height / r), n;
}
async function m6(t15, { dpr: e = 1, scale: r = 1 } = {}) {
  const n = new Image();
  n.src = t15, await n.decode();
  const i = document.createElement("canvas"), s = n.width * r, a = n.height * r;
  i.width = Math.ceil(s * e), i.height = Math.ceil(a * e);
  const o = i.getContext("2d");
  return o.scale(e, e), o.drawImage(n, 0, 0, s, a), i.style.width = `${s}px`, i.style.height = `${a}px`, i;
}
async function g6(t15, {
  type: e = "svg",
  scale: r = 1,
  backgroundColor: n = "#fff",
  quality: i
} = {}) {
  const s = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[e] || "image/png";
  if (e === "svg") {
    const o = decodeURIComponent(t15.split(",")[1]);
    return new Blob([o], { type: "image/svg+xml" });
  }
  const a = await vm(t15, { dpr: 1, scale: r }, n);
  return new Promise((o) => {
    a.toBlob((l) => o(l), `${s}`, i);
  });
}
async function vm(t15, { dpr: e = 1, scale: r = 1 }, n) {
  const i = await m6(t15, { dpr: e, scale: r });
  if (!n) return i;
  const s = document.createElement("canvas");
  s.width = i.width, s.height = i.height;
  const a = s.getContext("2d");
  return a.fillStyle = n, a.fillRect(0, 0, s.width, s.height), a.drawImage(i, 0, 0), s;
}
async function ap(t15, { dpr: e = 1, scale: r = 1, backgroundColor: n = "#fff", quality: i }, s = "png") {
  const a = await vm(t15, { dpr: e, scale: r }, n), o = new Image();
  return o.src = a.toDataURL(`image/${s}`, i), await o.decode(), o.style.width = `${a.width / e}px`, o.style.height = `${a.height / e}px`, o;
}
async function wz(t15, { dpr: e = 1, scale: r = 1, backgroundColor: n = "#fff", format: i = "png", filename: s = "capture" } = {}) {
  if (i === "svg") {
    const p = await g6(t15), m = URL.createObjectURL(p), g = document.createElement("a");
    g.href = m, g.download = `${s}.svg`, g.click(), URL.revokeObjectURL(m);
    return;
  }
  const a = ["jpg", "jpeg", "webp"].includes(i) ? "#fff" : void 0, o = await vm(t15, { dpr: e, scale: r }, n ?? a), l = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[i] || "image/png", c = o.toDataURL(l), h = document.createElement("a");
  h.href = c, h.download = `${s}.${i}`, h.click();
}
async function Ye(t15, e = {}) {
  if (e = { scale: 1, ...e }, !t15) throw new Error("Element cannot be null or undefined");
  return e.iconFonts && hz(e.iconFonts), await Ye.capture(t15, e);
}
Ye.capture = async (t15, e = {}) => {
  const r = await bz(t15, e), n = window.devicePixelRatio || 1, i = e.scale || 1;
  return {
    url: r,
    options: e,
    toRaw: () => r,
    toImg: () => xz(r, { dpr: n, scale: i }),
    toCanvas: () => m6(r, { dpr: n, scale: i }),
    toBlob: (s) => g6(r, { scale: i, ...s }),
    toPng: (s) => ap(r, { dpr: n, scale: i, ...s }, "png"),
    toJpg: (s) => ap(r, { dpr: n, scale: i, ...s }, "jpeg"),
    toWebp: (s) => ap(r, { dpr: n, scale: i, ...s }, "webp"),
    download: ({ format: s = "png", filename: a = "capture", backgroundColor: o } = {}) => wz(r, { dpr: n, scale: i, backgroundColor: o, format: s, filename: a })
  };
};
Ye.toRaw = async (t15, e) => (await Ye.capture(t15, e)).toRaw();
Ye.toImg = async (t15, e) => (await Ye.capture(t15, e)).toImg();
Ye.toCanvas = async (t15, e) => (await Ye.capture(t15, e)).toCanvas();
Ye.toBlob = async (t15, e) => (await Ye.capture(t15, e)).toBlob(e);
Ye.toPng = async (t15, e) => (await Ye.capture(t15, e)).toPng(e);
Ye.toJpg = async (t15, e) => (await Ye.capture(t15, e)).toJpg(e);
Ye.toWebp = async (t15, e) => (await Ye.capture(t15, e)).toWebp(e);
Ye.download = async (t15, e = {}) => {
  const {
    format: r = "png",
    filename: n = "capture",
    backgroundColor: i,
    ...s
  } = e;
  return await (await Ye.capture(t15, s)).download({ format: r, filename: n, backgroundColor: i });
};
var kf = { exports: {} };
var kz = kf.exports;
var vb;
function vz() {
  return vb || (vb = 1, function(t15, e) {
    (function(r, n) {
      t15.exports = n();
    })(kz, function() {
      var r = 1e3, n = 6e4, i = 36e5, s = "millisecond", a = "second", o = "minute", l = "hour", c = "day", h = "week", p = "month", m = "quarter", g = "year", y = "date", x = "Invalid Date", k = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, C = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, A = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(I) {
        var j = ["th", "st", "nd", "rd"], z = I % 100;
        return "[" + I + (j[(z - 20) % 10] || j[z] || j[0]) + "]";
      } }, $ = function(I, j, z) {
        var K = String(I);
        return !K || K.length >= j ? I : "" + Array(j + 1 - K.length).join(z) + I;
      }, B = { s: $, z: function(I) {
        var j = -I.utcOffset(), z = Math.abs(j), K = Math.floor(z / 60), Y = z % 60;
        return (j <= 0 ? "+" : "-") + $(K, 2, "0") + ":" + $(Y, 2, "0");
      }, m: function I(j, z) {
        if (j.date() < z.date()) return -I(z, j);
        var K = 12 * (z.year() - j.year()) + (z.month() - j.month()), Y = j.clone().add(K, p), ot = z - Y < 0, et = j.clone().add(K + (ot ? -1 : 1), p);
        return +(-(K + (z - Y) / (ot ? Y - et : et - Y)) || 0);
      }, a: function(I) {
        return I < 0 ? Math.ceil(I) || 0 : Math.floor(I);
      }, p: function(I) {
        return { M: p, y: g, w: h, d: c, D: y, h: l, m: o, s: a, ms: s, Q: m }[I] || String(I || "").toLowerCase().replace(/s$/, "");
      }, u: function(I) {
        return I === void 0;
      } }, L = "en", q = {};
      q[L] = A;
      var U = "$isDayjsObject", G = function(I) {
        return I instanceof Q || !(!I || !I[U]);
      }, F = function I(j, z, K) {
        var Y;
        if (!j) return L;
        if (typeof j == "string") {
          var ot = j.toLowerCase();
          q[ot] && (Y = ot), z && (q[ot] = z, Y = ot);
          var et = j.split("-");
          if (!Y && et.length > 1) return I(et[0]);
        } else {
          var ht = j.name;
          q[ht] = j, Y = ht;
        }
        return !K && Y && (L = Y), Y || !K && L;
      }, W = function(I, j) {
        if (G(I)) return I.clone();
        var z = typeof j == "object" ? j : {};
        return z.date = I, z.args = arguments, new Q(z);
      }, R = B;
      R.l = F, R.i = G, R.w = function(I, j) {
        return W(I, { locale: j.$L, utc: j.$u, x: j.$x, $offset: j.$offset });
      };
      var Q = function() {
        function I(z) {
          this.$L = F(z.locale, null, true), this.parse(z), this.$x = this.$x || z.x || {}, this[U] = true;
        }
        var j = I.prototype;
        return j.parse = function(z) {
          this.$d = function(K) {
            var Y = K.date, ot = K.utc;
            if (Y === null) return /* @__PURE__ */ new Date(NaN);
            if (R.u(Y)) return /* @__PURE__ */ new Date();
            if (Y instanceof Date) return new Date(Y);
            if (typeof Y == "string" && !/Z$/i.test(Y)) {
              var et = Y.match(k);
              if (et) {
                var ht = et[2] - 1 || 0, X = (et[7] || "0").substring(0, 3);
                return ot ? new Date(Date.UTC(et[1], ht, et[3] || 1, et[4] || 0, et[5] || 0, et[6] || 0, X)) : new Date(et[1], ht, et[3] || 1, et[4] || 0, et[5] || 0, et[6] || 0, X);
              }
            }
            return new Date(Y);
          }(z), this.init();
        }, j.init = function() {
          var z = this.$d;
          this.$y = z.getFullYear(), this.$M = z.getMonth(), this.$D = z.getDate(), this.$W = z.getDay(), this.$H = z.getHours(), this.$m = z.getMinutes(), this.$s = z.getSeconds(), this.$ms = z.getMilliseconds();
        }, j.$utils = function() {
          return R;
        }, j.isValid = function() {
          return this.$d.toString() !== x;
        }, j.isSame = function(z, K) {
          var Y = W(z);
          return this.startOf(K) <= Y && Y <= this.endOf(K);
        }, j.isAfter = function(z, K) {
          return W(z) < this.startOf(K);
        }, j.isBefore = function(z, K) {
          return this.endOf(K) < W(z);
        }, j.$g = function(z, K, Y) {
          return R.u(z) ? this[K] : this.set(Y, z);
        }, j.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, j.valueOf = function() {
          return this.$d.getTime();
        }, j.startOf = function(z, K) {
          var Y = this, ot = !!R.u(K) || K, et = R.p(z), ht = function(wt, At) {
            var Ht = R.w(Y.$u ? Date.UTC(Y.$y, At, wt) : new Date(Y.$y, At, wt), Y);
            return ot ? Ht : Ht.endOf(c);
          }, X = function(wt, At) {
            return R.w(Y.toDate()[wt].apply(Y.toDate("s"), (ot ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(At)), Y);
          }, ct = this.$W, gt = this.$M, xt = this.$D, Xt = "set" + (this.$u ? "UTC" : "");
          switch (et) {
            case g:
              return ot ? ht(1, 0) : ht(31, 11);
            case p:
              return ot ? ht(1, gt) : ht(0, gt + 1);
            case h:
              var H = this.$locale().weekStart || 0, mt = (ct < H ? ct + 7 : ct) - H;
              return ht(ot ? xt - mt : xt + (6 - mt), gt);
            case c:
            case y:
              return X(Xt + "Hours", 0);
            case l:
              return X(Xt + "Minutes", 1);
            case o:
              return X(Xt + "Seconds", 2);
            case a:
              return X(Xt + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, j.endOf = function(z) {
          return this.startOf(z, false);
        }, j.$set = function(z, K) {
          var Y, ot = R.p(z), et = "set" + (this.$u ? "UTC" : ""), ht = (Y = {}, Y[c] = et + "Date", Y[y] = et + "Date", Y[p] = et + "Month", Y[g] = et + "FullYear", Y[l] = et + "Hours", Y[o] = et + "Minutes", Y[a] = et + "Seconds", Y[s] = et + "Milliseconds", Y)[ot], X = ot === c ? this.$D + (K - this.$W) : K;
          if (ot === p || ot === g) {
            var ct = this.clone().set(y, 1);
            ct.$d[ht](X), ct.init(), this.$d = ct.set(y, Math.min(this.$D, ct.daysInMonth())).$d;
          } else ht && this.$d[ht](X);
          return this.init(), this;
        }, j.set = function(z, K) {
          return this.clone().$set(z, K);
        }, j.get = function(z) {
          return this[R.p(z)]();
        }, j.add = function(z, K) {
          var Y, ot = this;
          z = Number(z);
          var et = R.p(K), ht = function(gt) {
            var xt = W(ot);
            return R.w(xt.date(xt.date() + Math.round(gt * z)), ot);
          };
          if (et === p) return this.set(p, this.$M + z);
          if (et === g) return this.set(g, this.$y + z);
          if (et === c) return ht(1);
          if (et === h) return ht(7);
          var X = (Y = {}, Y[o] = n, Y[l] = i, Y[a] = r, Y)[et] || 1, ct = this.$d.getTime() + z * X;
          return R.w(ct, this);
        }, j.subtract = function(z, K) {
          return this.add(-1 * z, K);
        }, j.format = function(z) {
          var K = this, Y = this.$locale();
          if (!this.isValid()) return Y.invalidDate || x;
          var ot = z || "YYYY-MM-DDTHH:mm:ssZ", et = R.z(this), ht = this.$H, X = this.$m, ct = this.$M, gt = Y.weekdays, xt = Y.months, Xt = Y.meridiem, H = function(At, Ht, Ce, he) {
            return At && (At[Ht] || At(K, ot)) || Ce[Ht].slice(0, he);
          }, mt = function(At) {
            return R.s(ht % 12 || 12, At, "0");
          }, wt = Xt || function(At, Ht, Ce) {
            var he = At < 12 ? "AM" : "PM";
            return Ce ? he.toLowerCase() : he;
          };
          return ot.replace(C, function(At, Ht) {
            return Ht || function(Ce) {
              switch (Ce) {
                case "YY":
                  return String(K.$y).slice(-2);
                case "YYYY":
                  return R.s(K.$y, 4, "0");
                case "M":
                  return ct + 1;
                case "MM":
                  return R.s(ct + 1, 2, "0");
                case "MMM":
                  return H(Y.monthsShort, ct, xt, 3);
                case "MMMM":
                  return H(xt, ct);
                case "D":
                  return K.$D;
                case "DD":
                  return R.s(K.$D, 2, "0");
                case "d":
                  return String(K.$W);
                case "dd":
                  return H(Y.weekdaysMin, K.$W, gt, 2);
                case "ddd":
                  return H(Y.weekdaysShort, K.$W, gt, 3);
                case "dddd":
                  return gt[K.$W];
                case "H":
                  return String(ht);
                case "HH":
                  return R.s(ht, 2, "0");
                case "h":
                  return mt(1);
                case "hh":
                  return mt(2);
                case "a":
                  return wt(ht, X, true);
                case "A":
                  return wt(ht, X, false);
                case "m":
                  return String(X);
                case "mm":
                  return R.s(X, 2, "0");
                case "s":
                  return String(K.$s);
                case "ss":
                  return R.s(K.$s, 2, "0");
                case "SSS":
                  return R.s(K.$ms, 3, "0");
                case "Z":
                  return et;
              }
              return null;
            }(At) || et.replace(":", "");
          });
        }, j.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, j.diff = function(z, K, Y) {
          var ot, et = this, ht = R.p(K), X = W(z), ct = (X.utcOffset() - this.utcOffset()) * n, gt = this - X, xt = function() {
            return R.m(et, X);
          };
          switch (ht) {
            case g:
              ot = xt() / 12;
              break;
            case p:
              ot = xt();
              break;
            case m:
              ot = xt() / 3;
              break;
            case h:
              ot = (gt - ct) / 6048e5;
              break;
            case c:
              ot = (gt - ct) / 864e5;
              break;
            case l:
              ot = gt / i;
              break;
            case o:
              ot = gt / n;
              break;
            case a:
              ot = gt / r;
              break;
            default:
              ot = gt;
          }
          return Y ? ot : R.a(ot);
        }, j.daysInMonth = function() {
          return this.endOf(p).$D;
        }, j.$locale = function() {
          return q[this.$L];
        }, j.locale = function(z, K) {
          if (!z) return this.$L;
          var Y = this.clone(), ot = F(z, K, true);
          return ot && (Y.$L = ot), Y;
        }, j.clone = function() {
          return R.w(this.$d, this);
        }, j.toDate = function() {
          return new Date(this.valueOf());
        }, j.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, j.toISOString = function() {
          return this.$d.toISOString();
        }, j.toString = function() {
          return this.$d.toUTCString();
        }, I;
      }(), rt = Q.prototype;
      return W.prototype = rt, [["$ms", s], ["$s", a], ["$m", o], ["$H", l], ["$W", c], ["$M", p], ["$y", g], ["$D", y]].forEach(function(I) {
        rt[I[1]] = function(j) {
          return this.$g(j, I[0], I[1]);
        };
      }), W.extend = function(I, j) {
        return I.$i || (I(j, Q, W), I.$i = true), W;
      }, W.locale = F, W.isDayjs = G, W.unix = function(I) {
        return W(1e3 * I);
      }, W.en = q[L], W.Ls = q, W.p = {}, W;
    });
  }(kf)), kf.exports;
}
vz();
function Cz(t15) {
  navigator.clipboard.writeText(t15);
}
var vf = 1;
var _z = class {
  constructor() {
    __publicField(this, "subscribers");
    __publicField(this, "toasts");
    __publicField(this, "dismissedToasts");
    __publicField(this, "subscribe", (e) => (this.subscribers.push(e), () => {
      const r = this.subscribers.indexOf(e);
      this.subscribers.splice(r, 1);
    }));
    __publicField(this, "publish", (e) => {
      this.subscribers.forEach((r) => r(e));
    });
    __publicField(this, "addToast", (e) => {
      this.publish(e), this.toasts = [...this.toasts, e];
    });
    __publicField(this, "create", (e) => {
      var _a3;
      const { message: r, ...n } = e, i = typeof e.id == "number" || e.id && ((_a3 = e.id) == null ? void 0 : _a3.length) > 0 ? e.id : vf++, s = this.toasts.find((o) => o.id === i), a = e.dismissible === void 0 ? true : e.dismissible;
      return this.dismissedToasts.has(i) && this.dismissedToasts.delete(i), s ? this.toasts = this.toasts.map((o) => o.id === i ? (this.publish({
        ...o,
        ...e,
        id: i,
        title: r
      }), {
        ...o,
        ...e,
        id: i,
        dismissible: a,
        title: r
      }) : o) : this.addToast({
        title: r,
        ...n,
        dismissible: a,
        id: i
      }), i;
    });
    __publicField(this, "dismiss", (e) => (e ? (this.dismissedToasts.add(e), requestAnimationFrame(() => this.subscribers.forEach((r) => r({
      id: e,
      dismiss: true
    })))) : this.toasts.forEach((r) => {
      this.subscribers.forEach((n) => n({
        id: r.id,
        dismiss: true
      }));
    }), e));
    __publicField(this, "message", (e, r) => this.create({
      ...r,
      message: e,
      type: "default"
    }));
    __publicField(this, "error", (e, r) => this.create({
      ...r,
      type: "error",
      message: e
    }));
    __publicField(this, "success", (e, r) => this.create({
      ...r,
      type: "success",
      message: e
    }));
    __publicField(this, "info", (e, r) => this.create({
      ...r,
      type: "info",
      message: e
    }));
    __publicField(this, "warning", (e, r) => this.create({
      ...r,
      type: "warning",
      message: e
    }));
    __publicField(this, "loading", (e, r) => this.create({
      ...r,
      type: "loading",
      message: e
    }));
    __publicField(this, "promise", (e, r) => {
      if (!r) return;
      let n;
      r.loading !== void 0 && (n = this.create({
        ...r,
        promise: e,
        type: "loading",
        message: r.loading,
        description: typeof r.description != "function" ? r.description : void 0
      }));
      const i = Promise.resolve(e instanceof Function ? e() : e);
      let s = n !== void 0, a;
      const o = i.then(async (c) => {
        if (a = ["resolve", c], isVNode(c))
          s = false, this.create({
            id: n,
            type: "default",
            message: c
          });
        else if (Az(c) && !c.ok) {
          s = false;
          const h = typeof r.error == "function" ? await r.error(`HTTP error! status: ${c.status}`) : r.error, p = typeof r.description == "function" ? await r.description(`HTTP error! status: ${c.status}`) : r.description, m = typeof h == "object" && !isVNode(h) ? h : {
            message: h || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: p,
            ...m
          });
        } else if (c instanceof Error) {
          s = false;
          const h = typeof r.error == "function" ? await r.error(c) : r.error, p = typeof r.description == "function" ? await r.description(c) : r.description, m = typeof h == "object" && !isVNode(h) ? h : {
            message: h || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: p,
            ...m
          });
        } else if (r.success !== void 0) {
          s = false;
          const h = typeof r.success == "function" ? await r.success(c) : r.success, p = typeof r.description == "function" ? await r.description(c) : r.description, m = typeof h == "object" && !isVNode(h) ? h : {
            message: h || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "success",
            description: p,
            ...m
          });
        }
      }).catch(async (c) => {
        if (a = ["reject", c], r.error !== void 0) {
          s = false;
          const h = typeof r.error == "function" ? await r.error(c) : r.error, p = typeof r.description == "function" ? await r.description(c) : r.description, m = typeof h == "object" && !isVNode(h) ? h : {
            message: h || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: p,
            ...m
          });
        }
      }).finally(() => {
        var _a3;
        s && (this.dismiss(n), n = void 0), (_a3 = r.finally) == null ? void 0 : _a3.call(r);
      }), l = () => new Promise((c, h) => o.then(() => a[0] === "reject" ? h(a[1]) : c(a[1])).catch(h));
      return typeof n != "string" && typeof n != "number" ? { unwrap: l } : Object.assign(n, { unwrap: l });
    });
    __publicField(this, "custom", (e, r) => {
      const n = (r == null ? void 0 : r.id) || vf++;
      return this.publish({
        component: e,
        id: n,
        ...r
      }), n;
    });
    __publicField(this, "getActiveToasts", () => this.toasts.filter((e) => !this.dismissedToasts.has(e.id)));
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
};
var Nr = new _z();
function Sz(t15, e) {
  const r = (e == null ? void 0 : e.id) || vf++;
  return Nr.create({
    message: t15,
    id: r,
    type: "default",
    ...e
  }), r;
}
var Az = (t15) => t15 && typeof t15 == "object" && "ok" in t15 && typeof t15.ok == "boolean" && "status" in t15 && typeof t15.status == "number";
var Tz = Sz;
var $z = () => Nr.toasts;
var Ez = () => Nr.getActiveToasts();
var Cb = Object.assign(Tz, {
  success: Nr.success,
  info: Nr.info,
  warning: Nr.warning,
  error: Nr.error,
  custom: Nr.custom,
  message: Nr.message,
  promise: Nr.promise,
  dismiss: Nr.dismiss,
  loading: Nr.loading
}, {
  getHistory: $z,
  getToasts: Ez
});
function rh(t15) {
  return t15.label !== void 0;
}
var Mz = 3;
var y6 = "24px";
var b6 = "16px";
var _b = 4e3;
var Bz = 356;
var Lz = 14;
var Dz = 45;
var x6 = 200;
function Fz() {
  const t15 = ref(false);
  return watchEffect(() => {
    const e = () => {
      t15.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", e), () => window.removeEventListener("visibilitychange", e);
  }), { isDocumentHidden: t15 };
}
function Ri(...t15) {
  return t15.filter(Boolean).join(" ");
}
function Nz(t15) {
  const [e, r] = t15.split("-"), n = [];
  return e && n.push(e), r && n.push(r), n;
}
function Iz(t15, e) {
  const r = {};
  return [t15, e].forEach((n, i) => {
    const s = i === 1, a = s ? "--mobile-offset" : "--offset", o = s ? b6 : y6;
    function l(c) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((h) => {
        r[`${a}-${h}`] = typeof c == "number" ? `${c}px` : c;
      });
    }
    typeof n == "number" || typeof n == "string" ? l(n) : typeof n == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((c) => {
      n[c] === void 0 ? r[`${a}-${c}`] = o : r[`${a}-${c}`] = typeof n[c] == "number" ? `${n[c]}px` : n[c];
    }) : l(o);
  }), r;
}
var Oz = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded"
];
var zz = ["aria-label", "data-disabled"];
var qz = defineComponent({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(t15, { emit: e }) {
    const r = t15, n = e, i = ref(null), s = ref(null), a = ref(false), o = ref(false), l = ref(false), c = ref(false), h = ref(false), p = ref(0), m = ref(0), g = ref(r.toast.duration || r.duration || _b), y = ref(null), x = ref(null), k = computed(() => r.index === 0), C = computed(() => r.index + 1 <= r.visibleToasts), A = computed(() => r.toast.type), $ = computed(() => r.toast.dismissible !== false), B = computed(() => r.toast.class || ""), L = computed(() => r.descriptionClass || ""), q = computed(() => {
      const H = r.toast.position || r.position, mt = r.heights.filter((wt) => wt.position === H).findIndex((wt) => wt.toastId === r.toast.id);
      return mt >= 0 ? mt : 0;
    }), U = computed(() => {
      const H = r.toast.position || r.position;
      return r.heights.filter((mt) => mt.position === H).reduce((mt, wt, At) => At >= q.value ? mt : mt + wt.height, 0);
    }), G = computed(() => q.value * r.gap + U.value || 0), F = computed(() => r.toast.closeButton ?? r.closeButton), W = computed(() => r.toast.duration || r.duration || _b), R = ref(0), Q = ref(0), rt = ref(null), I = computed(() => r.position.split("-")), j = computed(() => I.value[0]), z = computed(() => I.value[1]), K = computed(() => typeof r.toast.title != "string"), Y = computed(() => typeof r.toast.description != "string"), { isDocumentHidden: ot } = Fz(), et = computed(() => A.value && A.value === "loading");
    onMounted(() => {
      a.value = true, g.value = W.value;
    }), watchEffect(async () => {
      if (!a.value || !x.value) return;
      await nextTick();
      const H = x.value, mt = H.style.height;
      H.style.height = "auto";
      const wt = H.getBoundingClientRect().height;
      H.style.height = mt, m.value = wt, n("update:height", {
        toastId: r.toast.id,
        height: wt,
        position: r.toast.position || r.position
      });
    });
    function ht() {
      o.value = true, p.value = G.value, setTimeout(() => {
        n("removeToast", r.toast);
      }, x6);
    }
    function X() {
      var _a3, _b2;
      if (et.value || !$.value) return {};
      ht(), (_b2 = (_a3 = r.toast).onDismiss) == null ? void 0 : _b2.call(_a3, r.toast);
    }
    function ct(H) {
      et.value || !$.value || (y.value = /* @__PURE__ */ new Date(), p.value = G.value, H.target.setPointerCapture(H.pointerId), H.target.tagName !== "BUTTON" && (l.value = true, rt.value = {
        x: H.clientX,
        y: H.clientY
      }));
    }
    function gt() {
      var _a3, _b2, _c, _d, _e, _f2, _g2;
      if (c.value || !$.value) return;
      rt.value = null;
      const H = Number(((_a3 = x.value) == null ? void 0 : _a3.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), mt = Number(((_b2 = x.value) == null ? void 0 : _b2.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), wt = (/* @__PURE__ */ new Date()).getTime() - (((_c = y.value) == null ? void 0 : _c.getTime()) || 0), At = i.value === "x" ? H : mt, Ht = Math.abs(At) / wt;
      if (Math.abs(At) >= Dz || Ht > 0.11) {
        p.value = G.value, (_e = (_d = r.toast).onDismiss) == null ? void 0 : _e.call(_d, r.toast), i.value === "x" ? s.value = H > 0 ? "right" : "left" : s.value = mt > 0 ? "down" : "up", ht(), c.value = true;
        return;
      } else
        (_f2 = x.value) == null ? void 0 : _f2.style.setProperty("--swipe-amount-x", "0px"), (_g2 = x.value) == null ? void 0 : _g2.style.setProperty("--swipe-amount-y", "0px");
      h.value = false, l.value = false, i.value = null;
    }
    function xt(H) {
      var _a3, _b2, _c, _d;
      if (!rt.value || !$.value || (((_b2 = (_a3 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a3.toString()) == null ? void 0 : _b2.length) ?? false)) return;
      const mt = H.clientY - rt.value.y, wt = H.clientX - rt.value.x, At = r.swipeDirections ?? Nz(r.position);
      !i.value && (Math.abs(wt) > 1 || Math.abs(mt) > 1) && (i.value = Math.abs(wt) > Math.abs(mt) ? "x" : "y");
      let Ht = {
        x: 0,
        y: 0
      };
      const Ce = (he) => 1 / (1.5 + Math.abs(he) / 20);
      if (i.value === "y") {
        if (At.includes("top") || At.includes("bottom")) if (At.includes("top") && mt < 0 || At.includes("bottom") && mt > 0) Ht.y = mt;
        else {
          const he = mt * Ce(mt);
          Ht.y = Math.abs(he) < Math.abs(mt) ? he : mt;
        }
      } else if (i.value === "x" && (At.includes("left") || At.includes("right")))
        if (At.includes("left") && wt < 0 || At.includes("right") && wt > 0) Ht.x = wt;
        else {
          const he = wt * Ce(wt);
          Ht.x = Math.abs(he) < Math.abs(wt) ? he : wt;
        }
      (Math.abs(Ht.x) > 0 || Math.abs(Ht.y) > 0) && (h.value = true), (_c = x.value) == null ? void 0 : _c.style.setProperty("--swipe-amount-x", `${Ht.x}px`), (_d = x.value) == null ? void 0 : _d.style.setProperty("--swipe-amount-y", `${Ht.y}px`);
    }
    onMounted(() => {
      if (a.value = true, !x.value) return;
      const H = x.value.getBoundingClientRect().height;
      m.value = H;
      const mt = [{
        toastId: r.toast.id,
        height: H,
        position: r.toast.position
      }, ...r.heights];
      n("update:heights", mt);
    }), onBeforeUnmount(() => {
      x.value && n("removeToast", r.toast);
    }), watchEffect((H) => {
      if (r.toast.promise && A.value === "loading" || r.toast.duration === 1 / 0 || r.toast.type === "loading") return;
      let mt;
      const wt = () => {
        if (Q.value < R.value) {
          const Ht = (/* @__PURE__ */ new Date()).getTime() - R.value;
          g.value = g.value - Ht;
        }
        Q.value = (/* @__PURE__ */ new Date()).getTime();
      }, At = () => {
        g.value !== 1 / 0 && (R.value = (/* @__PURE__ */ new Date()).getTime(), mt = setTimeout(() => {
          var _a3, _b2;
          (_b2 = (_a3 = r.toast).onAutoClose) == null ? void 0 : _b2.call(_a3, r.toast), ht();
        }, g.value));
      };
      r.expanded || r.interacting || ot.value ? wt() : At(), H(() => {
        clearTimeout(mt);
      });
    }), watch(() => r.toast.delete, (H) => {
      H !== void 0 && H && ht();
    }, { deep: true });
    function Xt() {
      l.value = false, i.value = null, rt.value = null;
    }
    return (H, mt) => {
      var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p2, _q2, _r2, _s2, _t, _u2, _v2, _w2, _x2, _y, _z2, _A2;
      return openBlock(), createElementBlock("li", {
        tabindex: "0",
        ref_key: "toastRef",
        ref: x,
        class: normalizeClass(unref(Ri)(r.class, B.value, (_a3 = H.classes) == null ? void 0 : _a3.toast, (_b2 = H.toast.classes) == null ? void 0 : _b2.toast, (_c = H.classes) == null ? void 0 : _c[A.value], (_e = (_d = H.toast) == null ? void 0 : _d.classes) == null ? void 0 : _e[A.value])),
        "data-sonner-toast": "",
        "data-rich-colors": H.toast.richColors ?? H.defaultRichColors,
        "data-styled": !(H.toast.component || ((_f2 = H.toast) == null ? void 0 : _f2.unstyled) || H.unstyled),
        "data-mounted": a.value,
        "data-promise": !!H.toast.promise,
        "data-swiped": h.value,
        "data-removed": o.value,
        "data-visible": C.value,
        "data-y-position": j.value,
        "data-x-position": z.value,
        "data-index": H.index,
        "data-front": k.value,
        "data-swiping": l.value,
        "data-dismissible": $.value,
        "data-type": A.value,
        "data-invert": H.toast.invert || H.invert,
        "data-swipe-out": c.value,
        "data-swipe-direction": s.value,
        "data-expanded": !!(H.expanded || H.expandByDefault && a.value),
        style: normalizeStyle({
          "--index": H.index,
          "--toasts-before": H.index,
          "--z-index": H.toasts.length - H.index,
          "--offset": `${o.value ? p.value : G.value}px`,
          "--initial-height": H.expandByDefault ? "auto" : `${m.value}px`,
          ...H.style,
          ...r.toast.style
        }),
        onDragend: Xt,
        onPointerdown: ct,
        onPointerup: gt,
        onPointermove: xt
      }, [F.value && !H.toast.component && A.value !== "loading" ? (openBlock(), createElementBlock("button", {
        key: 0,
        "aria-label": H.closeButtonAriaLabel || "Close toast",
        "data-disabled": et.value,
        "data-close-button": "true",
        class: normalizeClass(unref(Ri)((_g2 = H.classes) == null ? void 0 : _g2.closeButton, (_i2 = (_h2 = H.toast) == null ? void 0 : _h2.classes) == null ? void 0 : _i2.closeButton)),
        onClick: X
      }, [((_j2 = H.icons) == null ? void 0 : _j2.close) ? (openBlock(), createBlock(resolveDynamicComponent((_k2 = H.icons) == null ? void 0 : _k2.close), { key: 0 })) : renderSlot(H.$slots, "close-icon", { key: 1 })], 10, zz)) : createCommentVNode("v-if", true), H.toast.component ? (openBlock(), createBlock(resolveDynamicComponent(H.toast.component), mergeProps({ key: 1 }, H.toast.componentProps, { onCloseToast: X }), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        A.value !== "default" || H.toast.icon || H.toast.promise ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-icon": "",
          class: normalizeClass(unref(Ri)((_l2 = H.classes) == null ? void 0 : _l2.icon, (_n2 = (_m2 = H.toast) == null ? void 0 : _m2.classes) == null ? void 0 : _n2.icon))
        }, [H.toast.icon ? (openBlock(), createBlock(resolveDynamicComponent(H.toast.icon), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [A.value === "loading" ? renderSlot(H.$slots, "loading-icon", { key: 0 }) : A.value === "success" ? renderSlot(H.$slots, "success-icon", { key: 1 }) : A.value === "error" ? renderSlot(H.$slots, "error-icon", { key: 2 }) : A.value === "warning" ? renderSlot(H.$slots, "warning-icon", { key: 3 }) : A.value === "info" ? renderSlot(H.$slots, "info-icon", { key: 4 }) : createCommentVNode("v-if", true)], 64))], 2)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          "data-content": "",
          class: normalizeClass(unref(Ri)((_o = H.classes) == null ? void 0 : _o.content, (_q2 = (_p2 = H.toast) == null ? void 0 : _p2.classes) == null ? void 0 : _q2.content))
        }, [createBaseVNode("div", {
          "data-title": "",
          class: normalizeClass(unref(Ri)((_r2 = H.classes) == null ? void 0 : _r2.title, (_s2 = H.toast.classes) == null ? void 0 : _s2.title))
        }, [K.value ? (openBlock(), createBlock(resolveDynamicComponent(H.toast.title), normalizeProps(mergeProps({ key: 0 }, H.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(H.toast.title), 1)], 64))], 2), H.toast.description ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-description": "",
          class: normalizeClass(unref(Ri)(H.descriptionClass, L.value, (_t = H.classes) == null ? void 0 : _t.description, (_u2 = H.toast.classes) == null ? void 0 : _u2.description))
        }, [Y.value ? (openBlock(), createBlock(resolveDynamicComponent(H.toast.description), normalizeProps(mergeProps({ key: 0 }, H.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(H.toast.description), 1)], 64))], 2)) : createCommentVNode("v-if", true)], 2),
        H.toast.cancel ? (openBlock(), createElementBlock("button", {
          key: 1,
          style: normalizeStyle(H.toast.cancelButtonStyle || H.cancelButtonStyle),
          class: normalizeClass(unref(Ri)((_v2 = H.classes) == null ? void 0 : _v2.cancelButton, (_w2 = H.toast.classes) == null ? void 0 : _w2.cancelButton)),
          "data-button": "",
          "data-cancel": "",
          onClick: mt[0] || (mt[0] = (wt) => {
            var _a4, _b3;
            unref(rh)(H.toast.cancel) && $.value && ((_b3 = (_a4 = H.toast.cancel).onClick) == null ? void 0 : _b3.call(_a4, wt), ht());
          })
        }, toDisplayString(unref(rh)(H.toast.cancel) ? (_x2 = H.toast.cancel) == null ? void 0 : _x2.label : H.toast.cancel), 7)) : createCommentVNode("v-if", true),
        H.toast.action ? (openBlock(), createElementBlock("button", {
          key: 2,
          style: normalizeStyle(H.toast.actionButtonStyle || H.actionButtonStyle),
          class: normalizeClass(unref(Ri)((_y = H.classes) == null ? void 0 : _y.actionButton, (_z2 = H.toast.classes) == null ? void 0 : _z2.actionButton)),
          "data-button": "",
          "data-action": "",
          onClick: mt[1] || (mt[1] = (wt) => {
            var _a4, _b3;
            unref(rh)(H.toast.action) && ((_b3 = (_a4 = H.toast.action).onClick) == null ? void 0 : _b3.call(_a4, wt), !wt.defaultPrevented && ht());
          })
        }, toDisplayString(unref(rh)(H.toast.action) ? (_A2 = H.toast.action) == null ? void 0 : _A2.label : H.toast.action), 7)) : createCommentVNode("v-if", true)
      ], 64))], 46, Oz);
    };
  }
});
var Rz = qz;
var oc = (t15, e) => {
  const r = t15.__vccOpts || t15;
  for (const [n, i] of e) r[n] = i;
  return r;
};
var Pz = {};
var jz = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Wz(t15, e) {
  return openBlock(), createElementBlock("svg", jz, e[0] || (e[0] = [createBaseVNode("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), createBaseVNode("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var Hz = oc(Pz, [["render", Wz]]);
var Uz = ["data-visible"];
var Vz = { class: "sonner-spinner" };
var Gz = defineComponent({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(t15) {
    const e = Array(12).fill(0);
    return (r, n) => (openBlock(), createElementBlock("div", {
      class: "sonner-loading-wrapper",
      "data-visible": r.visible
    }, [createBaseVNode("div", Vz, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(e), (i) => (openBlock(), createElementBlock("div", {
      key: `spinner-bar-${i}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, Uz));
  }
});
var Xz = Gz;
var Yz = {};
var Kz = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function Zz(t15, e) {
  return openBlock(), createElementBlock("svg", Kz, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var Jz = oc(Yz, [["render", Zz]]);
var Qz = {};
var tq = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function eq(t15, e) {
  return openBlock(), createElementBlock("svg", tq, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var rq = oc(Qz, [["render", eq]]);
var nq = {};
var iq = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function sq(t15, e) {
  return openBlock(), createElementBlock("svg", iq, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var aq = oc(nq, [["render", sq]]);
var oq = {};
var lq = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function cq(t15, e) {
  return openBlock(), createElementBlock("svg", lq, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var hq = oc(oq, [["render", cq]]);
var uq = ["aria-label"];
var dq = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position",
  "data-lifted"
];
var pq = typeof window < "u" && typeof document < "u";
function fq() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const t15 = document.documentElement.getAttribute("dir");
  return t15 === "auto" || !t15 ? window.getComputedStyle(document.documentElement).direction : t15;
}
var mq = defineComponent({
  name: "Toaster",
  inheritAttrs: false,
  __name: "Toaster",
  props: {
    invert: {
      type: Boolean,
      default: false
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: false
    },
    expand: {
      type: Boolean,
      default: false
    },
    duration: {},
    gap: { default: Lz },
    visibleToasts: { default: Mz },
    closeButton: {
      type: Boolean,
      default: false
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: y6 },
    mobileOffset: { default: b6 },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(t15) {
    const e = t15, r = useAttrs(), n = ref([]);
    function i(F, W) {
      return n.value.filter((R) => !R.position && W === 0 || R.position === F);
    }
    const s = computed(() => {
      const F = n.value.filter((W) => W.position).map((W) => W.position);
      return F.length > 0 ? Array.from(new Set([e.position].concat(F))) : [e.position];
    }), a = computed(() => {
      const F = {};
      return s.value.forEach((W) => {
        F[W] = n.value.filter((R) => R.position === W);
      }), F;
    }), o = ref([]), l = ref(false), c = ref(false), h = ref(e.theme !== "system" ? e.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = ref(null), m = ref(null), g = ref(false), y = e.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function x(F) {
      var _a3;
      ((_a3 = n.value.find((W) => W.id === F.id)) == null ? void 0 : _a3.delete) || Nr.dismiss(F.id), n.value = n.value.filter(({ id: W }) => W !== F.id), setTimeout(() => {
        n.value.find((W) => W.id === F.id) || (o.value = o.value.filter((W) => W.toastId !== F.id));
      }, x6 + 50);
    }
    function k(F) {
      var _a3, _b2;
      g.value && !((_b2 = (_a3 = F.currentTarget) == null ? void 0 : _a3.contains) == null ? void 0 : _b2.call(_a3, F.relatedTarget)) && (g.value = false, m.value && (m.value.focus({ preventScroll: true }), m.value = null));
    }
    function C(F) {
      F.target instanceof HTMLElement && F.target.dataset.dismissible === "false" || g.value || (g.value = true, m.value = F.relatedTarget);
    }
    function A(F) {
      F.target && F.target instanceof HTMLElement && F.target.dataset.dismissible === "false" || (c.value = true);
    }
    watchEffect((F) => {
      const W = Nr.subscribe((R) => {
        if (R.dismiss) {
          requestAnimationFrame(() => {
            n.value = n.value.map((Q) => Q.id === R.id ? {
              ...Q,
              delete: true
            } : Q);
          });
          return;
        }
        nextTick(() => {
          const Q = n.value.findIndex((rt) => rt.id === R.id);
          Q !== -1 ? n.value = [
            ...n.value.slice(0, Q),
            {
              ...n.value[Q],
              ...R
            },
            ...n.value.slice(Q + 1)
          ] : n.value = [R, ...n.value];
        });
      });
      F(W);
    }), watchEffect((F) => {
      if (typeof window > "u") return;
      if (e.theme !== "system") {
        h.value = e.theme;
        return;
      }
      const W = window.matchMedia("(prefers-color-scheme: dark)"), R = (rt) => {
        h.value = rt ? "dark" : "light";
      };
      R(W.matches);
      const Q = (rt) => {
        R(rt.matches);
      };
      try {
        W.addEventListener("change", Q);
      } catch {
        W.addListener(Q);
      }
      F(() => {
        try {
          W.removeEventListener("change", Q);
        } catch {
          W.removeListener(Q);
        }
      });
    }), watchEffect(() => {
      p.value && m.value && (m.value.focus({ preventScroll: true }), m.value = null, g.value = false);
    }), watchEffect(() => {
      n.value.length <= 1 && (l.value = false);
    }), watchEffect((F) => {
      function W(R) {
        const Q = e.hotkey.every((j) => R[j] || R.code === j), rt = Array.isArray(p.value) ? p.value[0] : p.value;
        Q && (l.value = true, rt == null ? void 0 : rt.focus());
        const I = document.activeElement === p.value || (rt == null ? void 0 : rt.contains(document.activeElement));
        R.code === "Escape" && I && (l.value = false);
      }
      pq && (document.addEventListener("keydown", W), F(() => {
        document.removeEventListener("keydown", W);
      }));
    });
    function $() {
      l.value = true;
    }
    function B() {
      c.value || (l.value = false);
    }
    function L() {
      l.value = false;
    }
    function q() {
      c.value = false;
    }
    function U(F) {
      o.value = F;
    }
    function G(F) {
      const W = o.value.findIndex((R) => R.toastId === F.toastId);
      if (W !== -1) o.value[W] = F;
      else {
        const R = o.value.findIndex((Q) => Q.position === F.position);
        R !== -1 ? o.value.splice(R, 0, F) : o.value.unshift(F);
      }
    }
    return (F, W) => (openBlock(), createElementBlock(Fragment, null, [createCommentVNode(" Remove item from normal navigation flow, only available via hotkey "), createBaseVNode("section", {
      "aria-label": `${F.containerAriaLabel} ${unref(y)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (R, Q) => {
      var _a3;
      return openBlock(), createElementBlock("ol", mergeProps({
        key: R,
        ref_for: true,
        ref_key: "listRef",
        ref: p,
        "data-sonner-toaster": "",
        "data-sonner-theme": h.value,
        class: e.class,
        dir: F.dir === "auto" ? fq() : F.dir,
        tabIndex: -1,
        "data-theme": F.theme,
        "data-rich-colors": F.richColors,
        "data-y-position": R.split("-")[0],
        "data-x-position": R.split("-")[1],
        "data-lifted": l.value && n.value.length > 1 && !F.expand,
        style: {
          "--front-toast-height": `${((_a3 = o.value[0]) == null ? void 0 : _a3.height) || 0}px`,
          "--width": `${unref(Bz)}px`,
          "--gap": `${F.gap}px`,
          ...F.style,
          ...unref(r).style,
          ...unref(Iz)(F.offset, F.mobileOffset)
        }
      }, F.$attrs, {
        onBlur: k,
        onFocus: C,
        onMouseenter: $,
        onMousemove: $,
        onMouseleave: B,
        onDragend: L,
        onPointerdown: A,
        onPointerup: q
      }), [(openBlock(true), createElementBlock(Fragment, null, renderList(i(R, Q), (rt, I) => {
        var _a4, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2;
        return openBlock(), createBlock(Rz, {
          key: rt.id,
          heights: o.value,
          icons: F.icons,
          index: I,
          toast: rt,
          defaultRichColors: F.richColors,
          duration: ((_a4 = F.toastOptions) == null ? void 0 : _a4.duration) ?? F.duration,
          class: normalizeClass(((_b2 = F.toastOptions) == null ? void 0 : _b2.class) ?? ""),
          descriptionClass: (_c = F.toastOptions) == null ? void 0 : _c.descriptionClass,
          invert: F.invert,
          visibleToasts: F.visibleToasts,
          closeButton: ((_d = F.toastOptions) == null ? void 0 : _d.closeButton) ?? F.closeButton,
          interacting: c.value,
          position: R,
          style: normalizeStyle((_e = F.toastOptions) == null ? void 0 : _e.style),
          unstyled: (_f2 = F.toastOptions) == null ? void 0 : _f2.unstyled,
          classes: (_g2 = F.toastOptions) == null ? void 0 : _g2.classes,
          cancelButtonStyle: (_h2 = F.toastOptions) == null ? void 0 : _h2.cancelButtonStyle,
          actionButtonStyle: (_i2 = F.toastOptions) == null ? void 0 : _i2.actionButtonStyle,
          "close-button-aria-label": (_j2 = F.toastOptions) == null ? void 0 : _j2.closeButtonAriaLabel,
          toasts: a.value[R],
          expandByDefault: F.expand,
          gap: F.gap,
          expanded: l.value,
          swipeDirections: e.swipeDirections,
          "onUpdate:heights": U,
          "onUpdate:height": G,
          onRemoveToast: x
        }, {
          "close-icon": withCtx(() => [renderSlot(F.$slots, "close-icon", {}, () => [createVNode(Hz)])]),
          "loading-icon": withCtx(() => [renderSlot(F.$slots, "loading-icon", {}, () => [createVNode(Xz, { visible: rt.type === "loading" }, null, 8, ["visible"])])]),
          "success-icon": withCtx(() => [renderSlot(F.$slots, "success-icon", {}, () => [createVNode(Jz)])]),
          "error-icon": withCtx(() => [renderSlot(F.$slots, "error-icon", {}, () => [createVNode(hq)])]),
          "warning-icon": withCtx(() => [renderSlot(F.$slots, "warning-icon", {}, () => [createVNode(aq)])]),
          "info-icon": withCtx(() => [renderSlot(F.$slots, "info-icon", {}, () => [createVNode(rq)])]),
          _: 2
        }, 1032, [
          "heights",
          "icons",
          "index",
          "toast",
          "defaultRichColors",
          "duration",
          "class",
          "descriptionClass",
          "invert",
          "visibleToasts",
          "closeButton",
          "interacting",
          "position",
          "style",
          "unstyled",
          "classes",
          "cancelButtonStyle",
          "actionButtonStyle",
          "close-button-aria-label",
          "toasts",
          "expandByDefault",
          "gap",
          "expanded",
          "swipeDirections"
        ]);
      }), 128))], 16, dq);
    }), 128))], 8, uq)], 2112));
  }
});
var gq = mq;
var yq = defineComponent({
  __name: "MindMapRoot",
  props: {
    markdown: {},
    type: { default: "view" },
    showToolbar: { default: "0" }
  },
  setup(t15) {
    const e = t15, r = computed(() => typeof document > "u" ? false : !!(document.documentElement.classList.contains("dark") || window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches)), n = ref(), i = ref(), s = shallowRef(), a = ref(), o = ref(
      `mindmap-${Math.random().toString(36).substring(2, 15)}`
    ), l = computed(() => ({
      // autoFit: true,
      // fitRatio: 1,
      // initialExpandLevel: 3,
      // maxInitialScale: 1,
      // pan: false,
      // scrollForPan: false,
      // toggleRecursively: true,
      // zoom: true,
      // paddingX: 2,
      // spacingHorizontal: 5,
      // spacingVertical: 5,
      // duration: 200,
      // maxWidth: 600,
      color: ($) => r.value ? c($.depth, true) : c($.depth, false)
    }));
    function c($, B) {
      const L = B ? [
        "#2ecc71",
        // 亮绿色
        "#3498db",
        // 亮蓝色
        "#9b59b6",
        // 亮紫色
        "#f39c12",
        // 亮橙色
        "#e74c3c"
        // 亮红色
      ] : [
        "#2ecc71",
        // 绿色
        "#3498db",
        // 蓝色
        "#9b59b6",
        // 紫色
        "#e67e22",
        // 橙色
        "#e74c3c"
        // 红色
      ];
      return L[$ % L.length];
    }
    function h() {
      if (!i.value || !e.markdown) return;
      const $ = new sD(), { root: B } = $.transform(decodeURIComponent(e.markdown));
      s.value ? (s.value.setOptions(l.value), s.value.setData(B), s.value.fit()) : s.value = qO.create(i.value, l.value, B);
    }
    function p() {
      var _a3;
      if (!i.value || !e.markdown || !s.value) return;
      const $ = tz.create(s.value);
      $.showBrand = false;
      const { el: B } = $;
      B.id = `toolbar-${o.value}`, B.style.cursor = "pointer", B.style.position = "absolute", B.style.bottom = "0.5rem", B.style.right = "0.5rem", B.style.display = "flex", B.style.justifyContent = "flex-end", B.style.alignItems = "center", B.style.gap = "0.2rem", B.style.padding = "0.3rem", B.style.backgroundColor = "var(--vp-c-bg)", B.style.border = "1px solid var(--vp-c-divider)", B.style.borderRadius = "1.5rem", B.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.1)", B.style.backdropFilter = "blur(8px)", B.style.transition = "all 0.3s ease", B.style.opacity = "0", B.style.zIndex = "10", B.style.userSelect = "none", B.addEventListener("mouseenter", () => {
        B.style.transform = "translateY(-2px)";
      }), B.addEventListener("mouseleave", () => {
        B.style.transform = "translateY(0)";
      }), setTimeout(() => {
        B.querySelectorAll(".mm-toolbar-item").forEach((L) => {
          L.style.borderRadius = "50%", L.style.width = "2rem", L.style.height = "2rem", L.style.display = "flex", L.style.alignItems = "center", L.style.justifyContent = "center", L.style.fontSize = "1.1rem", L.style.border = "none", L.style.backgroundColor = "transparent", L.style.color = "var(--vp-c-text-1)", L.style.cursor = "pointer", L.style.padding = "0", L.style.margin = "0", L.style.transition = "all 0.2s ease", L.addEventListener("mouseenter", () => {
            L.style.transform = "scale(1.1)";
          }), L.addEventListener("mouseleave", () => {
            L.style.transform = "scale(1)";
          });
        });
      }, 10), $.attach(s.value), $.register({
        id: "zoomIn",
        title: "放大",
        content: "🔍",
        onClick: () => {
          s.value && s.value.rescale(1.25);
        }
      }), $.register({
        id: "zoomOut",
        title: "缩小",
        content: "🔎",
        onClick: () => {
          s.value && s.value.rescale(0.8);
        }
      }), $.register({
        id: "fit",
        title: "适应屏幕",
        content: "🔁",
        onClick: () => {
          s.value && s.value.fit();
        }
      }), $.register({
        id: "copy",
        title: "复制Markdown内容",
        content: "📋",
        onClick: () => g()
      }), $.register({
        id: "download",
        title: "下载为PNG图片",
        content: "⬇️",
        onClick: () => m()
      }), $.setItems(["zoomIn", "zoomOut", "fit", "copy", "download"]), (_a3 = n.value) == null ? void 0 : _a3.append(B);
    }
    async function m() {
      if (!s.value || !i.value || !n.value) return;
      const $ = n.value.querySelector(
        `#toolbar-${o.value}`
      );
      try {
        $ && ($.style.display = "none"), s.value.fit(), await (await Ye(n.value, {
          scale: 2,
          quality: 1,
          backgroundColor: getComputedStyle(
            document.documentElement
          ).getPropertyValue("--vp-c-bg-soft")
        })).download({ format: "png", filename: "mindmap" });
      } catch (B) {
        console.error("下载图片失败:", B), alert("下载图片失败，请检查浏览器安全设置或尝试其他浏览器");
      } finally {
        $ && ($.style.display = "flex");
      }
    }
    async function g() {
      if (e.markdown)
        try {
          const $ = decodeURIComponent(e.markdown);
          Cz($), Cb.success("复制成功！");
        } catch ($) {
          console.error("复制失败:", $), Cb.error("复制失败，请重试");
        }
    }
    function y() {
      s.value && setTimeout(() => {
        var _a3;
        (_a3 = s.value) == null ? void 0 : _a3.fit();
      }, 100);
    }
    watch(
      () => e.markdown,
      () => {
        h();
      }
    ), watch(
      () => r.value,
      () => {
        s.value && (s.value.setOptions(l.value), s.value.renderData());
      }
    );
    const x = ref(null);
    function k() {
      s.value && (s.value.setOptions(l.value), s.value.renderData());
    }
    onMounted(() => {
      h(), Number(e.showToolbar) === 1 && p(), window.ResizeObserver && (a.value = new ResizeObserver(y), i.value.parentElement && a.value.observe(i.value.parentElement)), window.addEventListener("resize", y), typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", k), typeof window < "u" && window.MutationObserver && (x.value = new MutationObserver(($) => {
        for (const B of $)
          if (B.attributeName === "class" && B.target === document.documentElement) {
            s.value && (s.value.setOptions(l.value), s.value.renderData());
            break;
          }
      }), x.value.observe(document.documentElement, {
        attributes: true
      }));
    }), onBeforeUnmount(() => {
      if (a.value && a.value.disconnect(), window.removeEventListener("resize", y), typeof window < "u" && window.matchMedia) {
        const $ = window.matchMedia(
          "(prefers-color-scheme: dark)"
        );
        $.removeEventListener("change", k), $.removeListener(() => {
        });
      }
      x.value && x.value.disconnect();
    });
    const C = () => {
      const $ = window.document.querySelector(
        `#toolbar-${o.value}`
      );
      $.style.opacity = "1";
    }, A = () => {
      const $ = window.document.querySelector(
        `#toolbar-${o.value}`
      );
      $.style.opacity = "0";
    };
    return ($, B) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", {
        ref_key: "mindmapContainerRef",
        ref: n,
        class: "mindmap-container",
        onMouseenter: C,
        onMouseleave: A
      }, [
        (openBlock(), createElementBlock("svg", {
          ref_key: "svgRef",
          ref: i,
          style: { "min-height": "400px" }
        }, null, 512))
      ], 544),
      createVNode(unref(gq), {
        position: "top-right",
        "rich-colors": ""
      })
    ], 64));
  }
});
var w6 = (t15, e) => {
  const r = t15.__vccOpts || t15;
  for (const [n, i] of e)
    r[n] = i;
  return r;
};
var k6 = w6(yq, [["__scopeId", "data-v-4e8e0f8f"]]);
var bq = { class: "vitepress-markmap-preview" };
var xq = defineComponent({
  __name: "PreviewMarkmapPath",
  props: {
    path: {}
  },
  setup(t15) {
    const e = ref("");
    return (r, n) => {
      const i = resolveComponent("ClientOnly");
      return openBlock(), createElementBlock("div", bq, [
        createVNode(i, null, {
          default: withCtx(() => [
            e.value ? (openBlock(), createBlock(k6, {
              key: 0,
              type: "view",
              markdown: e.value
            }, null, 8, ["markdown"])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});
var wq = w6(xq, [["__scopeId", "data-v-cc0e544b"]]);
function kq(t15) {
  t15.component("MindMapRoot", k6), t15.component("PreviewMarkmapPath", wq);
}
function vq(t15) {
  return t15 && t15.__esModule && Object.prototype.hasOwnProperty.call(t15, "default") ? t15.default : t15;
}
var Cf = { exports: {} };
var Cq = Cf.exports;
var Sb;
function _q() {
  return Sb || (Sb = 1, function(t15, e) {
    (function(r, n) {
      t15.exports = n();
    })(Cq, function() {
      var r = 1e3, n = 6e4, i = 36e5, s = "millisecond", a = "second", o = "minute", l = "hour", c = "day", h = "week", p = "month", m = "quarter", g = "year", y = "date", x = "Invalid Date", k = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, C = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, A = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(I) {
        var j = ["th", "st", "nd", "rd"], z = I % 100;
        return "[" + I + (j[(z - 20) % 10] || j[z] || j[0]) + "]";
      } }, $ = function(I, j, z) {
        var K = String(I);
        return !K || K.length >= j ? I : "" + Array(j + 1 - K.length).join(z) + I;
      }, B = { s: $, z: function(I) {
        var j = -I.utcOffset(), z = Math.abs(j), K = Math.floor(z / 60), Y = z % 60;
        return (j <= 0 ? "+" : "-") + $(K, 2, "0") + ":" + $(Y, 2, "0");
      }, m: function I(j, z) {
        if (j.date() < z.date()) return -I(z, j);
        var K = 12 * (z.year() - j.year()) + (z.month() - j.month()), Y = j.clone().add(K, p), ot = z - Y < 0, et = j.clone().add(K + (ot ? -1 : 1), p);
        return +(-(K + (z - Y) / (ot ? Y - et : et - Y)) || 0);
      }, a: function(I) {
        return I < 0 ? Math.ceil(I) || 0 : Math.floor(I);
      }, p: function(I) {
        return { M: p, y: g, w: h, d: c, D: y, h: l, m: o, s: a, ms: s, Q: m }[I] || String(I || "").toLowerCase().replace(/s$/, "");
      }, u: function(I) {
        return I === void 0;
      } }, L = "en", q = {};
      q[L] = A;
      var U = "$isDayjsObject", G = function(I) {
        return I instanceof Q || !(!I || !I[U]);
      }, F = function I(j, z, K) {
        var Y;
        if (!j) return L;
        if (typeof j == "string") {
          var ot = j.toLowerCase();
          q[ot] && (Y = ot), z && (q[ot] = z, Y = ot);
          var et = j.split("-");
          if (!Y && et.length > 1) return I(et[0]);
        } else {
          var ht = j.name;
          q[ht] = j, Y = ht;
        }
        return !K && Y && (L = Y), Y || !K && L;
      }, W = function(I, j) {
        if (G(I)) return I.clone();
        var z = typeof j == "object" ? j : {};
        return z.date = I, z.args = arguments, new Q(z);
      }, R = B;
      R.l = F, R.i = G, R.w = function(I, j) {
        return W(I, { locale: j.$L, utc: j.$u, x: j.$x, $offset: j.$offset });
      };
      var Q = function() {
        function I(z) {
          this.$L = F(z.locale, null, true), this.parse(z), this.$x = this.$x || z.x || {}, this[U] = true;
        }
        var j = I.prototype;
        return j.parse = function(z) {
          this.$d = function(K) {
            var Y = K.date, ot = K.utc;
            if (Y === null) return /* @__PURE__ */ new Date(NaN);
            if (R.u(Y)) return /* @__PURE__ */ new Date();
            if (Y instanceof Date) return new Date(Y);
            if (typeof Y == "string" && !/Z$/i.test(Y)) {
              var et = Y.match(k);
              if (et) {
                var ht = et[2] - 1 || 0, X = (et[7] || "0").substring(0, 3);
                return ot ? new Date(Date.UTC(et[1], ht, et[3] || 1, et[4] || 0, et[5] || 0, et[6] || 0, X)) : new Date(et[1], ht, et[3] || 1, et[4] || 0, et[5] || 0, et[6] || 0, X);
              }
            }
            return new Date(Y);
          }(z), this.init();
        }, j.init = function() {
          var z = this.$d;
          this.$y = z.getFullYear(), this.$M = z.getMonth(), this.$D = z.getDate(), this.$W = z.getDay(), this.$H = z.getHours(), this.$m = z.getMinutes(), this.$s = z.getSeconds(), this.$ms = z.getMilliseconds();
        }, j.$utils = function() {
          return R;
        }, j.isValid = function() {
          return this.$d.toString() !== x;
        }, j.isSame = function(z, K) {
          var Y = W(z);
          return this.startOf(K) <= Y && Y <= this.endOf(K);
        }, j.isAfter = function(z, K) {
          return W(z) < this.startOf(K);
        }, j.isBefore = function(z, K) {
          return this.endOf(K) < W(z);
        }, j.$g = function(z, K, Y) {
          return R.u(z) ? this[K] : this.set(Y, z);
        }, j.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, j.valueOf = function() {
          return this.$d.getTime();
        }, j.startOf = function(z, K) {
          var Y = this, ot = !!R.u(K) || K, et = R.p(z), ht = function(wt, At) {
            var Ht = R.w(Y.$u ? Date.UTC(Y.$y, At, wt) : new Date(Y.$y, At, wt), Y);
            return ot ? Ht : Ht.endOf(c);
          }, X = function(wt, At) {
            return R.w(Y.toDate()[wt].apply(Y.toDate("s"), (ot ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(At)), Y);
          }, ct = this.$W, gt = this.$M, xt = this.$D, Xt = "set" + (this.$u ? "UTC" : "");
          switch (et) {
            case g:
              return ot ? ht(1, 0) : ht(31, 11);
            case p:
              return ot ? ht(1, gt) : ht(0, gt + 1);
            case h:
              var H = this.$locale().weekStart || 0, mt = (ct < H ? ct + 7 : ct) - H;
              return ht(ot ? xt - mt : xt + (6 - mt), gt);
            case c:
            case y:
              return X(Xt + "Hours", 0);
            case l:
              return X(Xt + "Minutes", 1);
            case o:
              return X(Xt + "Seconds", 2);
            case a:
              return X(Xt + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, j.endOf = function(z) {
          return this.startOf(z, false);
        }, j.$set = function(z, K) {
          var Y, ot = R.p(z), et = "set" + (this.$u ? "UTC" : ""), ht = (Y = {}, Y[c] = et + "Date", Y[y] = et + "Date", Y[p] = et + "Month", Y[g] = et + "FullYear", Y[l] = et + "Hours", Y[o] = et + "Minutes", Y[a] = et + "Seconds", Y[s] = et + "Milliseconds", Y)[ot], X = ot === c ? this.$D + (K - this.$W) : K;
          if (ot === p || ot === g) {
            var ct = this.clone().set(y, 1);
            ct.$d[ht](X), ct.init(), this.$d = ct.set(y, Math.min(this.$D, ct.daysInMonth())).$d;
          } else ht && this.$d[ht](X);
          return this.init(), this;
        }, j.set = function(z, K) {
          return this.clone().$set(z, K);
        }, j.get = function(z) {
          return this[R.p(z)]();
        }, j.add = function(z, K) {
          var Y, ot = this;
          z = Number(z);
          var et = R.p(K), ht = function(gt) {
            var xt = W(ot);
            return R.w(xt.date(xt.date() + Math.round(gt * z)), ot);
          };
          if (et === p) return this.set(p, this.$M + z);
          if (et === g) return this.set(g, this.$y + z);
          if (et === c) return ht(1);
          if (et === h) return ht(7);
          var X = (Y = {}, Y[o] = n, Y[l] = i, Y[a] = r, Y)[et] || 1, ct = this.$d.getTime() + z * X;
          return R.w(ct, this);
        }, j.subtract = function(z, K) {
          return this.add(-1 * z, K);
        }, j.format = function(z) {
          var K = this, Y = this.$locale();
          if (!this.isValid()) return Y.invalidDate || x;
          var ot = z || "YYYY-MM-DDTHH:mm:ssZ", et = R.z(this), ht = this.$H, X = this.$m, ct = this.$M, gt = Y.weekdays, xt = Y.months, Xt = Y.meridiem, H = function(At, Ht, Ce, he) {
            return At && (At[Ht] || At(K, ot)) || Ce[Ht].slice(0, he);
          }, mt = function(At) {
            return R.s(ht % 12 || 12, At, "0");
          }, wt = Xt || function(At, Ht, Ce) {
            var he = At < 12 ? "AM" : "PM";
            return Ce ? he.toLowerCase() : he;
          };
          return ot.replace(C, function(At, Ht) {
            return Ht || function(Ce) {
              switch (Ce) {
                case "YY":
                  return String(K.$y).slice(-2);
                case "YYYY":
                  return R.s(K.$y, 4, "0");
                case "M":
                  return ct + 1;
                case "MM":
                  return R.s(ct + 1, 2, "0");
                case "MMM":
                  return H(Y.monthsShort, ct, xt, 3);
                case "MMMM":
                  return H(xt, ct);
                case "D":
                  return K.$D;
                case "DD":
                  return R.s(K.$D, 2, "0");
                case "d":
                  return String(K.$W);
                case "dd":
                  return H(Y.weekdaysMin, K.$W, gt, 2);
                case "ddd":
                  return H(Y.weekdaysShort, K.$W, gt, 3);
                case "dddd":
                  return gt[K.$W];
                case "H":
                  return String(ht);
                case "HH":
                  return R.s(ht, 2, "0");
                case "h":
                  return mt(1);
                case "hh":
                  return mt(2);
                case "a":
                  return wt(ht, X, true);
                case "A":
                  return wt(ht, X, false);
                case "m":
                  return String(X);
                case "mm":
                  return R.s(X, 2, "0");
                case "s":
                  return String(K.$s);
                case "ss":
                  return R.s(K.$s, 2, "0");
                case "SSS":
                  return R.s(K.$ms, 3, "0");
                case "Z":
                  return et;
              }
              return null;
            }(At) || et.replace(":", "");
          });
        }, j.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, j.diff = function(z, K, Y) {
          var ot, et = this, ht = R.p(K), X = W(z), ct = (X.utcOffset() - this.utcOffset()) * n, gt = this - X, xt = function() {
            return R.m(et, X);
          };
          switch (ht) {
            case g:
              ot = xt() / 12;
              break;
            case p:
              ot = xt();
              break;
            case m:
              ot = xt() / 3;
              break;
            case h:
              ot = (gt - ct) / 6048e5;
              break;
            case c:
              ot = (gt - ct) / 864e5;
              break;
            case l:
              ot = gt / i;
              break;
            case o:
              ot = gt / n;
              break;
            case a:
              ot = gt / r;
              break;
            default:
              ot = gt;
          }
          return Y ? ot : R.a(ot);
        }, j.daysInMonth = function() {
          return this.endOf(p).$D;
        }, j.$locale = function() {
          return q[this.$L];
        }, j.locale = function(z, K) {
          if (!z) return this.$L;
          var Y = this.clone(), ot = F(z, K, true);
          return ot && (Y.$L = ot), Y;
        }, j.clone = function() {
          return R.w(this.$d, this);
        }, j.toDate = function() {
          return new Date(this.valueOf());
        }, j.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, j.toISOString = function() {
          return this.$d.toISOString();
        }, j.toString = function() {
          return this.$d.toUTCString();
        }, I;
      }(), rt = Q.prototype;
      return W.prototype = rt, [["$ms", s], ["$s", a], ["$m", o], ["$H", l], ["$W", c], ["$M", p], ["$y", g], ["$D", y]].forEach(function(I) {
        rt[I[1]] = function(j) {
          return this.$g(j, I[0], I[1]);
        };
      }), W.extend = function(I, j) {
        return I.$i || (I(j, Q, W), I.$i = true), W;
      }, W.locale = F, W.isDayjs = G, W.unix = function(I) {
        return W(1e3 * I);
      }, W.en = q[L], W.Ls = q, W.p = {}, W;
    });
  }(Cf)), Cf.exports;
}
var Sq = _q();
var Aq = vq(Sq);
var Th = {
  /* CLAMP */
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (t15) => t15 >= 255 ? 255 : t15 < 0 ? 0 : t15,
    g: (t15) => t15 >= 255 ? 255 : t15 < 0 ? 0 : t15,
    b: (t15) => t15 >= 255 ? 255 : t15 < 0 ? 0 : t15,
    h: (t15) => t15 % 360,
    s: (t15) => t15 >= 100 ? 100 : t15 < 0 ? 0 : t15,
    l: (t15) => t15 >= 100 ? 100 : t15 < 0 ? 0 : t15,
    a: (t15) => t15 >= 1 ? 1 : t15 < 0 ? 0 : t15
  },
  /* CONVERSION */
  //SOURCE: https://planetcalc.com/7779
  toLinear: (t15) => {
    const e = t15 / 255;
    return t15 > 0.03928 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92;
  },
  //SOURCE: https://gist.github.com/mjackson/5311256
  hue2rgb: (t15, e, r) => (r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t15 + (e - t15) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t15 + (e - t15) * (2 / 3 - r) * 6 : t15),
  hsl2rgb: ({ h: t15, s: e, l: r }, n) => {
    if (!e)
      return r * 2.55;
    t15 /= 360, e /= 100, r /= 100;
    const i = r < 0.5 ? r * (1 + e) : r + e - r * e, s = 2 * r - i;
    switch (n) {
      case "r":
        return Th.hue2rgb(s, i, t15 + 1 / 3) * 255;
      case "g":
        return Th.hue2rgb(s, i, t15) * 255;
      case "b":
        return Th.hue2rgb(s, i, t15 - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: t15, g: e, b: r }, n) => {
    t15 /= 255, e /= 255, r /= 255;
    const i = Math.max(t15, e, r), s = Math.min(t15, e, r), a = (i + s) / 2;
    if (n === "l")
      return a * 100;
    if (i === s)
      return 0;
    const o = i - s, l = a > 0.5 ? o / (2 - i - s) : o / (i + s);
    if (n === "s")
      return l * 100;
    switch (i) {
      case t15:
        return ((e - r) / o + (e < r ? 6 : 0)) * 60;
      case e:
        return ((r - t15) / o + 2) * 60;
      case r:
        return ((t15 - e) / o + 4) * 60;
      default:
        return -1;
    }
  }
};
var Tq = {
  /* API */
  clamp: (t15, e, r) => e > r ? Math.min(e, Math.max(r, t15)) : Math.min(r, Math.max(e, t15)),
  round: (t15) => Math.round(t15 * 1e10) / 1e10
};
var $q = {
  /* API */
  dec2hex: (t15) => {
    const e = Math.round(t15).toString(16);
    return e.length > 1 ? e : `0${e}`;
  }
};
var Ut = {
  channel: Th,
  lang: Tq,
  unit: $q
};
var Hi = {};
for (let t15 = 0; t15 <= 255; t15++)
  Hi[t15] = Ut.unit.dec2hex(t15);
var dr = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
var Eq = class {
  constructor() {
    this.type = dr.ALL;
  }
  /* API */
  get() {
    return this.type;
  }
  set(e) {
    if (this.type && this.type !== e)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = e;
  }
  reset() {
    this.type = dr.ALL;
  }
  is(e) {
    return this.type === e;
  }
};
var Mq = class {
  /* CONSTRUCTOR */
  constructor(e, r) {
    this.color = r, this.changed = false, this.data = e, this.type = new Eq();
  }
  /* API */
  set(e, r) {
    return this.color = r, this.changed = false, this.data = e, this.type.type = dr.ALL, this;
  }
  /* HELPERS */
  _ensureHSL() {
    const e = this.data, { h: r, s: n, l: i } = e;
    r === void 0 && (e.h = Ut.channel.rgb2hsl(e, "h")), n === void 0 && (e.s = Ut.channel.rgb2hsl(e, "s")), i === void 0 && (e.l = Ut.channel.rgb2hsl(e, "l"));
  }
  _ensureRGB() {
    const e = this.data, { r, g: n, b: i } = e;
    r === void 0 && (e.r = Ut.channel.hsl2rgb(e, "r")), n === void 0 && (e.g = Ut.channel.hsl2rgb(e, "g")), i === void 0 && (e.b = Ut.channel.hsl2rgb(e, "b"));
  }
  /* GETTERS */
  get r() {
    const e = this.data, r = e.r;
    return !this.type.is(dr.HSL) && r !== void 0 ? r : (this._ensureHSL(), Ut.channel.hsl2rgb(e, "r"));
  }
  get g() {
    const e = this.data, r = e.g;
    return !this.type.is(dr.HSL) && r !== void 0 ? r : (this._ensureHSL(), Ut.channel.hsl2rgb(e, "g"));
  }
  get b() {
    const e = this.data, r = e.b;
    return !this.type.is(dr.HSL) && r !== void 0 ? r : (this._ensureHSL(), Ut.channel.hsl2rgb(e, "b"));
  }
  get h() {
    const e = this.data, r = e.h;
    return !this.type.is(dr.RGB) && r !== void 0 ? r : (this._ensureRGB(), Ut.channel.rgb2hsl(e, "h"));
  }
  get s() {
    const e = this.data, r = e.s;
    return !this.type.is(dr.RGB) && r !== void 0 ? r : (this._ensureRGB(), Ut.channel.rgb2hsl(e, "s"));
  }
  get l() {
    const e = this.data, r = e.l;
    return !this.type.is(dr.RGB) && r !== void 0 ? r : (this._ensureRGB(), Ut.channel.rgb2hsl(e, "l"));
  }
  get a() {
    return this.data.a;
  }
  /* SETTERS */
  set r(e) {
    this.type.set(dr.RGB), this.changed = true, this.data.r = e;
  }
  set g(e) {
    this.type.set(dr.RGB), this.changed = true, this.data.g = e;
  }
  set b(e) {
    this.type.set(dr.RGB), this.changed = true, this.data.b = e;
  }
  set h(e) {
    this.type.set(dr.HSL), this.changed = true, this.data.h = e;
  }
  set s(e) {
    this.type.set(dr.HSL), this.changed = true, this.data.s = e;
  }
  set l(e) {
    this.type.set(dr.HSL), this.changed = true, this.data.l = e;
  }
  set a(e) {
    this.changed = true, this.data.a = e;
  }
};
var bu = new Mq({ r: 0, g: 0, b: 0, a: 0 }, "transparent");
var Oa = {
  /* VARIABLES */
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  /* API */
  parse: (t15) => {
    if (t15.charCodeAt(0) !== 35)
      return;
    const e = t15.match(Oa.re);
    if (!e)
      return;
    const r = e[1], n = parseInt(r, 16), i = r.length, s = i % 4 === 0, a = i > 4, o = a ? 1 : 17, l = a ? 8 : 4, c = s ? 0 : -1, h = a ? 255 : 15;
    return bu.set({
      r: (n >> l * (c + 3) & h) * o,
      g: (n >> l * (c + 2) & h) * o,
      b: (n >> l * (c + 1) & h) * o,
      a: s ? (n & h) * o / 255 : 1
    }, t15);
  },
  stringify: (t15) => {
    const { r: e, g: r, b: n, a: i } = t15;
    return i < 1 ? `#${Hi[Math.round(e)]}${Hi[Math.round(r)]}${Hi[Math.round(n)]}${Hi[Math.round(i * 255)]}` : `#${Hi[Math.round(e)]}${Hi[Math.round(r)]}${Hi[Math.round(n)]}`;
  }
};
var zs = {
  /* VARIABLES */
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  /* HELPERS */
  _hue2deg: (t15) => {
    const e = t15.match(zs.hueRe);
    if (e) {
      const [, r, n] = e;
      switch (n) {
        case "grad":
          return Ut.channel.clamp.h(parseFloat(r) * 0.9);
        case "rad":
          return Ut.channel.clamp.h(parseFloat(r) * 180 / Math.PI);
        case "turn":
          return Ut.channel.clamp.h(parseFloat(r) * 360);
      }
    }
    return Ut.channel.clamp.h(parseFloat(t15));
  },
  /* API */
  parse: (t15) => {
    const e = t15.charCodeAt(0);
    if (e !== 104 && e !== 72)
      return;
    const r = t15.match(zs.re);
    if (!r)
      return;
    const [, n, i, s, a, o] = r;
    return bu.set({
      h: zs._hue2deg(n),
      s: Ut.channel.clamp.s(parseFloat(i)),
      l: Ut.channel.clamp.l(parseFloat(s)),
      a: a ? Ut.channel.clamp.a(o ? parseFloat(a) / 100 : parseFloat(a)) : 1
    }, t15);
  },
  stringify: (t15) => {
    const { h: e, s: r, l: n, a: i } = t15;
    return i < 1 ? `hsla(${Ut.lang.round(e)}, ${Ut.lang.round(r)}%, ${Ut.lang.round(n)}%, ${i})` : `hsl(${Ut.lang.round(e)}, ${Ut.lang.round(r)}%, ${Ut.lang.round(n)}%)`;
  }
};
var gl = {
  /* VARIABLES */
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  /* API */
  parse: (t15) => {
    t15 = t15.toLowerCase();
    const e = gl.colors[t15];
    if (e)
      return Oa.parse(e);
  },
  stringify: (t15) => {
    const e = Oa.stringify(t15);
    for (const r in gl.colors)
      if (gl.colors[r] === e)
        return r;
  }
};
var sl = {
  /* VARIABLES */
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  /* API */
  parse: (t15) => {
    const e = t15.charCodeAt(0);
    if (e !== 114 && e !== 82)
      return;
    const r = t15.match(sl.re);
    if (!r)
      return;
    const [, n, i, s, a, o, l, c, h] = r;
    return bu.set({
      r: Ut.channel.clamp.r(i ? parseFloat(n) * 2.55 : parseFloat(n)),
      g: Ut.channel.clamp.g(a ? parseFloat(s) * 2.55 : parseFloat(s)),
      b: Ut.channel.clamp.b(l ? parseFloat(o) * 2.55 : parseFloat(o)),
      a: c ? Ut.channel.clamp.a(h ? parseFloat(c) / 100 : parseFloat(c)) : 1
    }, t15);
  },
  stringify: (t15) => {
    const { r: e, g: r, b: n, a: i } = t15;
    return i < 1 ? `rgba(${Ut.lang.round(e)}, ${Ut.lang.round(r)}, ${Ut.lang.round(n)}, ${Ut.lang.round(i)})` : `rgb(${Ut.lang.round(e)}, ${Ut.lang.round(r)}, ${Ut.lang.round(n)})`;
  }
};
var Yn = {
  /* VARIABLES */
  format: {
    keyword: gl,
    hex: Oa,
    rgb: sl,
    rgba: sl,
    hsl: zs,
    hsla: zs
  },
  /* API */
  parse: (t15) => {
    if (typeof t15 != "string")
      return t15;
    const e = Oa.parse(t15) || sl.parse(t15) || zs.parse(t15) || gl.parse(t15);
    if (e)
      return e;
    throw new Error(`Unsupported color format: "${t15}"`);
  },
  stringify: (t15) => !t15.changed && t15.color ? t15.color : t15.type.is(dr.HSL) || t15.data.r === void 0 ? zs.stringify(t15) : t15.a < 1 || !Number.isInteger(t15.r) || !Number.isInteger(t15.g) || !Number.isInteger(t15.b) ? sl.stringify(t15) : Oa.stringify(t15)
};
var v6 = (t15, e) => {
  const r = Yn.parse(t15);
  for (const n in e)
    r[n] = Ut.channel.clamp[n](e[n]);
  return Yn.stringify(r);
};
var yl = (t15, e, r = 0, n = 1) => {
  if (typeof t15 != "number")
    return v6(t15, { a: e });
  const i = bu.set({
    r: Ut.channel.clamp.r(t15),
    g: Ut.channel.clamp.g(e),
    b: Ut.channel.clamp.b(r),
    a: Ut.channel.clamp.a(n)
  });
  return Yn.stringify(i);
};
var Bq = (t15) => {
  const { r: e, g: r, b: n } = Yn.parse(t15), i = 0.2126 * Ut.channel.toLinear(e) + 0.7152 * Ut.channel.toLinear(r) + 0.0722 * Ut.channel.toLinear(n);
  return Ut.lang.round(i);
};
var Lq = (t15) => Bq(t15) >= 0.5;
var lc = (t15) => !Lq(t15);
var C6 = (t15, e, r) => {
  const n = Yn.parse(t15), i = n[e], s = Ut.channel.clamp[e](i + r);
  return i !== s && (n[e] = s), Yn.stringify(n);
};
var Tt = (t15, e) => C6(t15, "l", e);
var Ot = (t15, e) => C6(t15, "l", -e);
var st = (t15, e) => {
  const r = Yn.parse(t15), n = {};
  for (const i in e)
    e[i] && (n[i] = r[i] + e[i]);
  return v6(t15, n);
};
var Dq = (t15, e, r = 50) => {
  const { r: n, g: i, b: s, a } = Yn.parse(t15), { r: o, g: l, b: c, a: h } = Yn.parse(e), p = r / 100, m = p * 2 - 1, g = a - h, y = ((m * g === -1 ? m : (m + g) / (1 + m * g)) + 1) / 2, x = 1 - y, k = n * y + o * x, C = i * y + l * x, A = s * y + c * x, $ = a * p + h * (1 - p);
  return yl(k, C, A, $);
};
var vt = (t15, e = 100) => {
  const r = Yn.parse(t15);
  return r.r = 255 - r.r, r.g = 255 - r.g, r.b = 255 - r.b, Dq(r, t15, e);
};
var {
  entries: _6,
  setPrototypeOf: Ab,
  isFrozen: Fq,
  getPrototypeOf: Nq,
  getOwnPropertyDescriptor: Iq
} = Object;
var {
  freeze: $r,
  seal: yn,
  create: S6
} = Object;
var {
  apply: _f,
  construct: Sf
} = typeof Reflect < "u" && Reflect;
$r || ($r = function(t15) {
  return t15;
});
yn || (yn = function(t15) {
  return t15;
});
_f || (_f = function(t15, e, r) {
  return t15.apply(e, r);
});
Sf || (Sf = function(t15, e) {
  return new t15(...e);
});
var nh = Er(Array.prototype.forEach);
var Oq = Er(Array.prototype.lastIndexOf);
var Tb = Er(Array.prototype.pop);
var Oo = Er(Array.prototype.push);
var zq = Er(Array.prototype.splice);
var $h = Er(String.prototype.toLowerCase);
var op = Er(String.prototype.toString);
var $b = Er(String.prototype.match);
var zo = Er(String.prototype.replace);
var qq = Er(String.prototype.indexOf);
var Rq = Er(String.prototype.trim);
var kn = Er(Object.prototype.hasOwnProperty);
var Cr = Er(RegExp.prototype.test);
var qo = Pq(TypeError);
function Er(t15) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      n[i - 1] = arguments[i];
    return _f(t15, e, n);
  };
}
function Pq(t15) {
  return function() {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return Sf(t15, r);
  };
}
function re(t15, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : $h;
  Ab && Ab(t15, null);
  let n = e.length;
  for (; n--; ) {
    let i = e[n];
    if (typeof i == "string") {
      const s = r(i);
      s !== i && (Fq(e) || (e[n] = s), i = s);
    }
    t15[i] = true;
  }
  return t15;
}
function jq(t15) {
  for (let e = 0; e < t15.length; e++)
    kn(t15, e) || (t15[e] = null);
  return t15;
}
function bi(t15) {
  const e = S6(null);
  for (const [r, n] of _6(t15))
    kn(t15, r) && (Array.isArray(n) ? e[r] = jq(n) : n && typeof n == "object" && n.constructor === Object ? e[r] = bi(n) : e[r] = n);
  return e;
}
function Ro(t15, e) {
  for (; t15 !== null; ) {
    const n = Iq(t15, e);
    if (n) {
      if (n.get)
        return Er(n.get);
      if (typeof n.value == "function")
        return Er(n.value);
    }
    t15 = Nq(t15);
  }
  function r() {
    return null;
  }
  return r;
}
var Eb = $r(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var lp = $r(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var cp = $r(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var Wq = $r(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var hp = $r(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var Hq = $r(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var Mb = $r(["#text"]);
var Bb = $r(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var up = $r(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var Lb = $r(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var ih = $r(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var Uq = yn(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var Vq = yn(/<%[\w\W]*|[\w\W]*%>/gm);
var Gq = yn(/\$\{[\w\W]*/gm);
var Xq = yn(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var Yq = yn(/^aria-[\-\w]+$/);
var A6 = yn(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var Kq = yn(/^(?:\w+script|data):/i);
var Zq = yn(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var T6 = yn(/^html$/i);
var Jq = yn(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Db = Object.freeze({
  __proto__: null,
  ARIA_ATTR: Yq,
  ATTR_WHITESPACE: Zq,
  CUSTOM_ELEMENT: Jq,
  DATA_ATTR: Xq,
  DOCTYPE_NAME: T6,
  ERB_EXPR: Vq,
  IS_ALLOWED_URI: A6,
  IS_SCRIPT_OR_DATA: Kq,
  MUSTACHE_EXPR: Uq,
  TMPLIT_EXPR: Gq
});
var Po = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
};
var Qq = function() {
  return typeof window > "u" ? null : window;
};
var tR = function(t15, e) {
  if (typeof t15 != "object" || typeof t15.createPolicy != "function")
    return null;
  let r = null;
  const n = "data-tt-policy-suffix";
  e && e.hasAttribute(n) && (r = e.getAttribute(n));
  const i = "dompurify" + (r ? "#" + r : "");
  try {
    return t15.createPolicy(i, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + i + " could not be created."), null;
  }
};
var Fb = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function $6() {
  let t15 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Qq();
  const e = (Z) => $6(Z);
  if (e.version = "3.2.6", e.removed = [], !t15 || !t15.document || t15.document.nodeType !== Po.document || !t15.Element)
    return e.isSupported = false, e;
  let {
    document: r
  } = t15;
  const n = r, i = n.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: a,
    Node: o,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: h = t15.NamedNodeMap || t15.MozNamedAttrMap,
    HTMLFormElement: p,
    DOMParser: m,
    trustedTypes: g
  } = t15, y = l.prototype, x = Ro(y, "cloneNode"), k = Ro(y, "remove"), C = Ro(y, "nextSibling"), A = Ro(y, "childNodes"), $ = Ro(y, "parentNode");
  if (typeof a == "function") {
    const Z = r.createElement("template");
    Z.content && Z.content.ownerDocument && (r = Z.content.ownerDocument);
  }
  let B, L = "";
  const {
    implementation: q,
    createNodeIterator: U,
    createDocumentFragment: G,
    getElementsByTagName: F
  } = r, {
    importNode: W
  } = n;
  let R = Fb();
  e.isSupported = typeof _6 == "function" && typeof $ == "function" && q && q.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: Q,
    ERB_EXPR: rt,
    TMPLIT_EXPR: I,
    DATA_ATTR: j,
    ARIA_ATTR: z,
    IS_SCRIPT_OR_DATA: K,
    ATTR_WHITESPACE: Y,
    CUSTOM_ELEMENT: ot
  } = Db;
  let {
    IS_ALLOWED_URI: et
  } = Db, ht = null;
  const X = re({}, [...Eb, ...lp, ...cp, ...hp, ...Mb]);
  let ct = null;
  const gt = re({}, [...Bb, ...up, ...Lb, ...ih]);
  let xt = Object.seal(S6(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  })), Xt = null, H = null, mt = true, wt = true, At = false, Ht = true, Ce = false, he = true, ni = false, ua = false, wo = false, rn = false, br = false, ii = false, ko = true, wc = false;
  const vo = "user-content-";
  let ms = true, gs = false, Ii = {}, si = null;
  const Co = re({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let nn = null;
  const kc = re({}, ["audio", "video", "img", "source", "image", "track"]);
  let ys = null;
  const vc = re({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), bs = "http://www.w3.org/1998/Math/MathML", xe = "http://www.w3.org/2000/svg", bt = "http://www.w3.org/1999/xhtml";
  let xr = bt, da = false, pa = null;
  const Uu = re({}, [bs, xe, bt], op);
  let xs = re({}, ["mi", "mo", "mn", "ms", "mtext"]), Mn = re({}, ["annotation-xml"]);
  const _o = re({}, ["title", "style", "font", "a", "script"]);
  let ws = null;
  const Vu = ["application/xhtml+xml", "text/html"], Mr = "text/html";
  let we = null, wr = null;
  const So = r.createElement("form"), Ao = function(Z) {
    return Z instanceof RegExp || Z instanceof Function;
  }, To = function() {
    let Z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(wr && wr === Z)) {
      if ((!Z || typeof Z != "object") && (Z = {}), Z = bi(Z), ws = // eslint-disable-next-line unicorn/prefer-includes
      Vu.indexOf(Z.PARSER_MEDIA_TYPE) === -1 ? Mr : Z.PARSER_MEDIA_TYPE, we = ws === "application/xhtml+xml" ? op : $h, ht = kn(Z, "ALLOWED_TAGS") ? re({}, Z.ALLOWED_TAGS, we) : X, ct = kn(Z, "ALLOWED_ATTR") ? re({}, Z.ALLOWED_ATTR, we) : gt, pa = kn(Z, "ALLOWED_NAMESPACES") ? re({}, Z.ALLOWED_NAMESPACES, op) : Uu, ys = kn(Z, "ADD_URI_SAFE_ATTR") ? re(bi(vc), Z.ADD_URI_SAFE_ATTR, we) : vc, nn = kn(Z, "ADD_DATA_URI_TAGS") ? re(bi(kc), Z.ADD_DATA_URI_TAGS, we) : kc, si = kn(Z, "FORBID_CONTENTS") ? re({}, Z.FORBID_CONTENTS, we) : Co, Xt = kn(Z, "FORBID_TAGS") ? re({}, Z.FORBID_TAGS, we) : bi({}), H = kn(Z, "FORBID_ATTR") ? re({}, Z.FORBID_ATTR, we) : bi({}), Ii = kn(Z, "USE_PROFILES") ? Z.USE_PROFILES : false, mt = Z.ALLOW_ARIA_ATTR !== false, wt = Z.ALLOW_DATA_ATTR !== false, At = Z.ALLOW_UNKNOWN_PROTOCOLS || false, Ht = Z.ALLOW_SELF_CLOSE_IN_ATTR !== false, Ce = Z.SAFE_FOR_TEMPLATES || false, he = Z.SAFE_FOR_XML !== false, ni = Z.WHOLE_DOCUMENT || false, rn = Z.RETURN_DOM || false, br = Z.RETURN_DOM_FRAGMENT || false, ii = Z.RETURN_TRUSTED_TYPE || false, wo = Z.FORCE_BODY || false, ko = Z.SANITIZE_DOM !== false, wc = Z.SANITIZE_NAMED_PROPS || false, ms = Z.KEEP_CONTENT !== false, gs = Z.IN_PLACE || false, et = Z.ALLOWED_URI_REGEXP || A6, xr = Z.NAMESPACE || bt, xs = Z.MATHML_TEXT_INTEGRATION_POINTS || xs, Mn = Z.HTML_INTEGRATION_POINTS || Mn, xt = Z.CUSTOM_ELEMENT_HANDLING || {}, Z.CUSTOM_ELEMENT_HANDLING && Ao(Z.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (xt.tagNameCheck = Z.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Z.CUSTOM_ELEMENT_HANDLING && Ao(Z.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (xt.attributeNameCheck = Z.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Z.CUSTOM_ELEMENT_HANDLING && typeof Z.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (xt.allowCustomizedBuiltInElements = Z.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ce && (wt = false), br && (rn = true), Ii && (ht = re({}, Mb), ct = [], Ii.html === true && (re(ht, Eb), re(ct, Bb)), Ii.svg === true && (re(ht, lp), re(ct, up), re(ct, ih)), Ii.svgFilters === true && (re(ht, cp), re(ct, up), re(ct, ih)), Ii.mathMl === true && (re(ht, hp), re(ct, Lb), re(ct, ih))), Z.ADD_TAGS && (ht === X && (ht = bi(ht)), re(ht, Z.ADD_TAGS, we)), Z.ADD_ATTR && (ct === gt && (ct = bi(ct)), re(ct, Z.ADD_ATTR, we)), Z.ADD_URI_SAFE_ATTR && re(ys, Z.ADD_URI_SAFE_ATTR, we), Z.FORBID_CONTENTS && (si === Co && (si = bi(si)), re(si, Z.FORBID_CONTENTS, we)), ms && (ht["#text"] = true), ni && re(ht, ["html", "head", "body"]), ht.table && (re(ht, ["tbody"]), delete Xt.tbody), Z.TRUSTED_TYPES_POLICY) {
        if (typeof Z.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw qo('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof Z.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw qo('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        B = Z.TRUSTED_TYPES_POLICY, L = B.createHTML("");
      } else
        B === void 0 && (B = tR(g, i)), B !== null && typeof L == "string" && (L = B.createHTML(""));
      $r && $r(Z), wr = Z;
    }
  }, Cc = re({}, [...lp, ...cp, ...Wq]), _c = re({}, [...hp, ...Hq]), fa = function(Z) {
    let Ct = $(Z);
    (!Ct || !Ct.tagName) && (Ct = {
      namespaceURI: xr,
      tagName: "template"
    });
    const O = $h(Z.tagName), Qt = $h(Ct.tagName);
    return pa[Z.namespaceURI] ? Z.namespaceURI === xe ? Ct.namespaceURI === bt ? O === "svg" : Ct.namespaceURI === bs ? O === "svg" && (Qt === "annotation-xml" || xs[Qt]) : !!Cc[O] : Z.namespaceURI === bs ? Ct.namespaceURI === bt ? O === "math" : Ct.namespaceURI === xe ? O === "math" && Mn[Qt] : !!_c[O] : Z.namespaceURI === bt ? Ct.namespaceURI === xe && !Mn[Qt] || Ct.namespaceURI === bs && !xs[Qt] ? false : !_c[O] && (_o[O] || !Cc[O]) : !!(ws === "application/xhtml+xml" && pa[Z.namespaceURI]) : false;
  }, pe = function(Z) {
    Oo(e.removed, {
      element: Z
    });
    try {
      $(Z).removeChild(Z);
    } catch {
      k(Z);
    }
  }, v = function(Z, Ct) {
    try {
      Oo(e.removed, {
        attribute: Ct.getAttributeNode(Z),
        from: Ct
      });
    } catch {
      Oo(e.removed, {
        attribute: null,
        from: Ct
      });
    }
    if (Ct.removeAttribute(Z), Z === "is")
      if (rn || br)
        try {
          pe(Ct);
        } catch {
        }
      else
        try {
          Ct.setAttribute(Z, "");
        } catch {
        }
  }, T = function(Z) {
    let Ct = null, O = null;
    if (wo)
      Z = "<remove></remove>" + Z;
    else {
      const Te = $b(Z, /^[\r\n\t ]+/);
      O = Te && Te[0];
    }
    ws === "application/xhtml+xml" && xr === bt && (Z = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Z + "</body></html>");
    const Qt = B ? B.createHTML(Z) : Z;
    if (xr === bt)
      try {
        Ct = new m().parseFromString(Qt, ws);
      } catch {
      }
    if (!Ct || !Ct.documentElement) {
      Ct = q.createDocument(xr, "template", null);
      try {
        Ct.documentElement.innerHTML = da ? L : Qt;
      } catch {
      }
    }
    const tt = Ct.body || Ct.documentElement;
    return Z && O && tt.insertBefore(r.createTextNode(O), tt.childNodes[0] || null), xr === bt ? F.call(Ct, ni ? "html" : "body")[0] : ni ? Ct.documentElement : tt;
  }, dt = function(Z) {
    return U.call(
      Z.ownerDocument || Z,
      Z,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, M = function(Z) {
    return Z instanceof p && (typeof Z.nodeName != "string" || typeof Z.textContent != "string" || typeof Z.removeChild != "function" || !(Z.attributes instanceof h) || typeof Z.removeAttribute != "function" || typeof Z.setAttribute != "function" || typeof Z.namespaceURI != "string" || typeof Z.insertBefore != "function" || typeof Z.hasChildNodes != "function");
  }, V = function(Z) {
    return typeof o == "function" && Z instanceof o;
  };
  function se(Z, Ct, O) {
    nh(Z, (Qt) => {
      Qt.call(e, Ct, O, wr);
    });
  }
  const St = function(Z) {
    let Ct = null;
    if (se(R.beforeSanitizeElements, Z, null), M(Z))
      return pe(Z), true;
    const O = we(Z.nodeName);
    if (se(R.uponSanitizeElement, Z, {
      tagName: O,
      allowedTags: ht
    }), he && Z.hasChildNodes() && !V(Z.firstElementChild) && Cr(/<[/\w!]/g, Z.innerHTML) && Cr(/<[/\w!]/g, Z.textContent) || Z.nodeType === Po.progressingInstruction || he && Z.nodeType === Po.comment && Cr(/<[/\w]/g, Z.data))
      return pe(Z), true;
    if (!ht[O] || Xt[O]) {
      if (!Xt[O] && ai(O) && (xt.tagNameCheck instanceof RegExp && Cr(xt.tagNameCheck, O) || xt.tagNameCheck instanceof Function && xt.tagNameCheck(O)))
        return false;
      if (ms && !si[O]) {
        const Qt = $(Z) || Z.parentNode, tt = A(Z) || Z.childNodes;
        if (tt && Qt) {
          const Te = tt.length;
          for (let sn = Te - 1; sn >= 0; --sn) {
            const Br = x(tt[sn], true);
            Br.__removalCount = (Z.__removalCount || 0) + 1, Qt.insertBefore(Br, C(Z));
          }
        }
      }
      return pe(Z), true;
    }
    return Z instanceof l && !fa(Z) || (O === "noscript" || O === "noembed" || O === "noframes") && Cr(/<\/no(script|embed|frames)/i, Z.innerHTML) ? (pe(Z), true) : (Ce && Z.nodeType === Po.text && (Ct = Z.textContent, nh([Q, rt, I], (Qt) => {
      Ct = zo(Ct, Qt, " ");
    }), Z.textContent !== Ct && (Oo(e.removed, {
      element: Z.cloneNode()
    }), Z.textContent = Ct)), se(R.afterSanitizeElements, Z, null), false);
  }, Je = function(Z, Ct, O) {
    if (ko && (Ct === "id" || Ct === "name") && (O in r || O in So))
      return false;
    if (!(wt && !H[Ct] && Cr(j, Ct)) && !(mt && Cr(z, Ct))) {
      if (!ct[Ct] || H[Ct]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          !(ai(Z) && (xt.tagNameCheck instanceof RegExp && Cr(xt.tagNameCheck, Z) || xt.tagNameCheck instanceof Function && xt.tagNameCheck(Z)) && (xt.attributeNameCheck instanceof RegExp && Cr(xt.attributeNameCheck, Ct) || xt.attributeNameCheck instanceof Function && xt.attributeNameCheck(Ct)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          Ct === "is" && xt.allowCustomizedBuiltInElements && (xt.tagNameCheck instanceof RegExp && Cr(xt.tagNameCheck, O) || xt.tagNameCheck instanceof Function && xt.tagNameCheck(O)))
        ) return false;
      } else if (!ys[Ct] && !Cr(et, zo(O, Y, "")) && !((Ct === "src" || Ct === "xlink:href" || Ct === "href") && Z !== "script" && qq(O, "data:") === 0 && nn[Z]) && !(At && !Cr(K, zo(O, Y, ""))) && O)
        return false;
    }
    return true;
  }, ai = function(Z) {
    return Z !== "annotation-xml" && $b(Z, ot);
  }, It = function(Z) {
    se(R.beforeSanitizeAttributes, Z, null);
    const {
      attributes: Ct
    } = Z;
    if (!Ct || M(Z))
      return;
    const O = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ct,
      forceKeepAttr: void 0
    };
    let Qt = Ct.length;
    for (; Qt--; ) {
      const tt = Ct[Qt], {
        name: Te,
        namespaceURI: sn,
        value: Br
      } = tt, kr = we(Te), zt = Br;
      let He = Te === "value" ? zt : Rq(zt);
      if (O.attrName = kr, O.attrValue = He, O.keepAttr = true, O.forceKeepAttr = void 0, se(R.uponSanitizeAttribute, Z, O), He = O.attrValue, wc && (kr === "id" || kr === "name") && (v(Te, Z), He = vo + He), he && Cr(/((--!?|])>)|<\/(style|title)/i, He)) {
        v(Te, Z);
        continue;
      }
      if (O.forceKeepAttr)
        continue;
      if (!O.keepAttr) {
        v(Te, Z);
        continue;
      }
      if (!Ht && Cr(/\/>/i, He)) {
        v(Te, Z);
        continue;
      }
      Ce && nh([Q, rt, I], (Sc) => {
        He = zo(He, Sc, " ");
      });
      const ks = we(Z.nodeName);
      if (!Je(ks, kr, He)) {
        v(Te, Z);
        continue;
      }
      if (B && typeof g == "object" && typeof g.getAttributeType == "function" && !sn)
        switch (g.getAttributeType(ks, kr)) {
          case "TrustedHTML": {
            He = B.createHTML(He);
            break;
          }
          case "TrustedScriptURL": {
            He = B.createScriptURL(He);
            break;
          }
        }
      if (He !== zt)
        try {
          sn ? Z.setAttributeNS(sn, Te, He) : Z.setAttribute(Te, He), M(Z) ? pe(Z) : Tb(e.removed);
        } catch {
          v(Te, Z);
        }
    }
    se(R.afterSanitizeAttributes, Z, null);
  }, Oe = function Z(Ct) {
    let O = null;
    const Qt = dt(Ct);
    for (se(R.beforeSanitizeShadowDOM, Ct, null); O = Qt.nextNode(); )
      se(R.uponSanitizeShadowNode, O, null), St(O), It(O), O.content instanceof s && Z(O.content);
    se(R.afterSanitizeShadowDOM, Ct, null);
  };
  return e.sanitize = function(Z) {
    let Ct = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, O = null, Qt = null, tt = null, Te = null;
    if (da = !Z, da && (Z = "<!-->"), typeof Z != "string" && !V(Z))
      if (typeof Z.toString == "function") {
        if (Z = Z.toString(), typeof Z != "string")
          throw qo("dirty is not a string, aborting");
      } else
        throw qo("toString is not a function");
    if (!e.isSupported)
      return Z;
    if (ua || To(Ct), e.removed = [], typeof Z == "string" && (gs = false), gs) {
      if (Z.nodeName) {
        const kr = we(Z.nodeName);
        if (!ht[kr] || Xt[kr])
          throw qo("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Z instanceof o)
      O = T("<!---->"), Qt = O.ownerDocument.importNode(Z, true), Qt.nodeType === Po.element && Qt.nodeName === "BODY" || Qt.nodeName === "HTML" ? O = Qt : O.appendChild(Qt);
    else {
      if (!rn && !Ce && !ni && // eslint-disable-next-line unicorn/prefer-includes
      Z.indexOf("<") === -1)
        return B && ii ? B.createHTML(Z) : Z;
      if (O = T(Z), !O)
        return rn ? null : ii ? L : "";
    }
    O && wo && pe(O.firstChild);
    const sn = dt(gs ? Z : O);
    for (; tt = sn.nextNode(); )
      St(tt), It(tt), tt.content instanceof s && Oe(tt.content);
    if (gs)
      return Z;
    if (rn) {
      if (br)
        for (Te = G.call(O.ownerDocument); O.firstChild; )
          Te.appendChild(O.firstChild);
      else
        Te = O;
      return (ct.shadowroot || ct.shadowrootmode) && (Te = W.call(n, Te, true)), Te;
    }
    let Br = ni ? O.outerHTML : O.innerHTML;
    return ni && ht["!doctype"] && O.ownerDocument && O.ownerDocument.doctype && O.ownerDocument.doctype.name && Cr(T6, O.ownerDocument.doctype.name) && (Br = "<!DOCTYPE " + O.ownerDocument.doctype.name + `>
` + Br), Ce && nh([Q, rt, I], (kr) => {
      Br = zo(Br, kr, " ");
    }), B && ii ? B.createHTML(Br) : Br;
  }, e.setConfig = function() {
    let Z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    To(Z), ua = true;
  }, e.clearConfig = function() {
    wr = null, ua = false;
  }, e.isValidAttribute = function(Z, Ct, O) {
    wr || To({});
    const Qt = we(Z), tt = we(Ct);
    return Je(Qt, tt, O);
  }, e.addHook = function(Z, Ct) {
    typeof Ct == "function" && Oo(R[Z], Ct);
  }, e.removeHook = function(Z, Ct) {
    if (Ct !== void 0) {
      const O = Oq(R[Z], Ct);
      return O === -1 ? void 0 : zq(R[Z], O, 1)[0];
    }
    return Tb(R[Z]);
  }, e.removeHooks = function(Z) {
    R[Z] = [];
  }, e.removeAllHooks = function() {
    R = Fb();
  }, e;
}
var Ya = $6();
var E6 = Object.defineProperty;
var _ = (t15, e) => E6(t15, "name", { value: e, configurable: true });
var eR = (t15, e) => {
  for (var r in e)
    E6(t15, r, { get: e[r], enumerable: true });
};
var pi = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
};
var ut = {
  trace: _((...t15) => {
  }, "trace"),
  debug: _((...t15) => {
  }, "debug"),
  info: _((...t15) => {
  }, "info"),
  warn: _((...t15) => {
  }, "warn"),
  error: _((...t15) => {
  }, "error"),
  fatal: _((...t15) => {
  }, "fatal")
};
var Cm = _(function(t15 = "fatal") {
  let e = pi.fatal;
  typeof t15 == "string" ? t15.toLowerCase() in pi && (e = pi[t15]) : typeof t15 == "number" && (e = t15), ut.trace = () => {
  }, ut.debug = () => {
  }, ut.info = () => {
  }, ut.warn = () => {
  }, ut.error = () => {
  }, ut.fatal = () => {
  }, e <= pi.fatal && (ut.fatal = console.error ? console.error.bind(console, hn("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", hn("FATAL"))), e <= pi.error && (ut.error = console.error ? console.error.bind(console, hn("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", hn("ERROR"))), e <= pi.warn && (ut.warn = console.warn ? console.warn.bind(console, hn("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", hn("WARN"))), e <= pi.info && (ut.info = console.info ? console.info.bind(console, hn("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", hn("INFO"))), e <= pi.debug && (ut.debug = console.debug ? console.debug.bind(console, hn("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", hn("DEBUG"))), e <= pi.trace && (ut.trace = console.debug ? console.debug.bind(console, hn("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", hn("TRACE")));
}, "setLogLevel");
var hn = _((t15) => `%c${Aq().format("ss.SSS")} : ${t15} : `, "format");
var M6 = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s;
var bl = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
var rR = /\s*%%.*\n/gm;
var dp;
var B6 = (dp = class extends Error {
  constructor(t15) {
    super(t15), this.name = "UnknownDiagramError";
  }
}, _(dp, "UnknownDiagramError"), dp);
var Ks = {};
var _m = _(function(t15, e) {
  t15 = t15.replace(M6, "").replace(bl, "").replace(rR, `
`);
  for (const [r, { detector: n }] of Object.entries(Ks))
    if (n(t15, e))
      return r;
  throw new B6(
    `No diagram type detected matching given configuration for text: ${t15}`
  );
}, "detectType");
var Af = _((...t15) => {
  for (const { id: e, detector: r, loader: n } of t15)
    L6(e, r, n);
}, "registerLazyLoadedDiagrams");
var L6 = _((t15, e, r) => {
  Ks[t15] && ut.warn(`Detector with key ${t15} already exists. Overwriting.`), Ks[t15] = { detector: e, loader: r }, ut.debug(`Detector with key ${t15} added${r ? " with loader" : ""}`);
}, "addDetector");
var nR = _((t15) => Ks[t15].loader, "getDiagramLoader");
var Tf = _((t15, e, { depth: r = 2, clobber: n = false } = {}) => {
  const i = { depth: r, clobber: n };
  return Array.isArray(e) && !Array.isArray(t15) ? (e.forEach((s) => Tf(t15, s, i)), t15) : Array.isArray(e) && Array.isArray(t15) ? (e.forEach((s) => {
    t15.includes(s) || t15.push(s);
  }), t15) : t15 === void 0 || r <= 0 ? t15 != null && typeof t15 == "object" && typeof e == "object" ? Object.assign(t15, e) : e : (e !== void 0 && typeof t15 == "object" && typeof e == "object" && Object.keys(e).forEach((s) => {
    typeof e[s] == "object" && (t15[s] === void 0 || typeof t15[s] == "object") ? (t15[s] === void 0 && (t15[s] = Array.isArray(e[s]) ? [] : {}), t15[s] = Tf(t15[s], e[s], { depth: r - 1, clobber: n })) : (n || typeof t15[s] != "object" && typeof e[s] != "object") && (t15[s] = e[s]);
  }), t15);
}, "assignWithDepth");
var ur = Tf;
var xu = "#ffffff";
var wu = "#f2f2f2";
var _r = _((t15, e) => e ? st(t15, { s: -40, l: 10 }) : st(t15, { s: -40, l: -10 }), "mkBorder");
var pp;
var iR = (pp = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px";
  }
  updateColors() {
    var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p2, _q2, _r2, _s2, _t, _u2;
    if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || st(this.primaryColor, { h: -120 }), this.tertiaryColor = this.tertiaryColor || st(this.primaryColor, { h: 180, l: 5 }), this.primaryBorderColor = this.primaryBorderColor || _r(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || _r(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || _r(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || _r(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || vt(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || vt(this.tertiaryColor), this.lineColor = this.lineColor || vt(this.background), this.arrowheadColor = this.arrowheadColor || vt(this.background), this.textColor = this.textColor || this.primaryTextColor, this.border2 = this.border2 || this.tertiaryBorderColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? Ot(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || this.actorBorder, this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || Ot(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || vt(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || Tt(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.vertLineColor = this.vertLineColor || "navy", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.darkMode ? (this.rowOdd = this.rowOdd || Ot(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || Ot(this.mainBkg, 10)) : (this.rowOdd = this.rowOdd || Tt(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || Tt(this.mainBkg, 5)), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210, l: 150 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.darkMode)
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
        this["cScale" + e] = Ot(this["cScale" + e], 75);
    else
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
        this["cScale" + e] = Ot(this["cScale" + e], 25);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || vt(this["cScale" + e]);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this.darkMode ? this["cScalePeer" + e] = this["cScalePeer" + e] || Tt(this["cScale" + e], 10) : this["cScalePeer" + e] = this["cScalePeer" + e] || Ot(this["cScale" + e], 10);
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    const t15 = this.darkMode ? -4 : -1;
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || st(this.mainBkg, { h: 180, s: -15, l: t15 * (5 + e * 3) }), this["surfacePeer" + e] = this["surfacePeer" + e] || st(this.mainBkg, { h: 180, s: -15, l: t15 * (8 + e * 3) });
    this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || st(this.primaryColor, { h: 64 }), this.fillType3 = this.fillType3 || st(this.secondaryColor, { h: 64 }), this.fillType4 = this.fillType4 || st(this.primaryColor, { h: -64 }), this.fillType5 = this.fillType5 || st(this.secondaryColor, { h: -64 }), this.fillType6 = this.fillType6 || st(this.primaryColor, { h: 128 }), this.fillType7 = this.fillType7 || st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || st(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -10 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { l: -10 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -20 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -60, l: -20 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -10 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.radar = {
      axisColor: ((_a3 = this.radar) == null ? void 0 : _a3.axisColor) || this.lineColor,
      axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_c = this.radar) == null ? void 0 : _c.axisLabelFontSize) || 12,
      curveOpacity: ((_d = this.radar) == null ? void 0 : _d.curveOpacity) || 0.5,
      curveStrokeWidth: ((_e = this.radar) == null ? void 0 : _e.curveStrokeWidth) || 2,
      graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_g2 = this.radar) == null ? void 0 : _g2.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_h2 = this.radar) == null ? void 0 : _h2.graticuleOpacity) || 0.3,
      legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
      legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
    }, this.archEdgeColor = this.archEdgeColor || "#777", this.archEdgeArrowColor = this.archEdgeArrowColor || "#777", this.archEdgeWidth = this.archEdgeWidth || "3", this.archGroupBorderColor = this.archGroupBorderColor || "#000", this.archGroupBorderWidth = this.archGroupBorderWidth || "2px", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || lc(this.quadrant1Fill) ? Tt(this.quadrant1Fill) : Ot(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((_k2 = this.xyChart) == null ? void 0 : _k2.backgroundColor) || this.background,
      titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_m2 = this.xyChart) == null ? void 0 : _m2.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_o = this.xyChart) == null ? void 0 : _o.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_q2 = this.xyChart) == null ? void 0 : _q2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_r2 = this.xyChart) == null ? void 0 : _r2.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_s2 = this.xyChart) == null ? void 0 : _s2.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Ot(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = Tt(this.git0, 25), this.git1 = Tt(this.git1, 25), this.git2 = Tt(this.git2, 25), this.git3 = Tt(this.git3, 25), this.git4 = Tt(this.git4, 25), this.git5 = Tt(this.git5, 25), this.git6 = Tt(this.git6, 25), this.git7 = Tt(this.git7, 25)) : (this.git0 = Ot(this.git0, 25), this.git1 = Ot(this.git1, 25), this.git2 = Ot(this.git2, 25), this.git3 = Ot(this.git3, 25), this.git4 = Ot(this.git4, 25), this.git5 = Ot(this.git5, 25), this.git6 = Ot(this.git6, 25), this.git7 = Ot(this.git7, 25)), this.gitInv0 = this.gitInv0 || vt(this.git0), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || xu, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || wu;
  }
  calculate(t15) {
    if (typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, _(pp, "Theme"), pp);
var sR = _((t15) => {
  const e = new iR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var fp;
var aR = (fp = class {
  constructor() {
    this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = Tt(this.primaryColor, 16), this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = vt(this.background), this.secondaryBorderColor = _r(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = _r(this.tertiaryColor, this.darkMode), this.primaryTextColor = vt(this.primaryColor), this.secondaryTextColor = vt(this.secondaryColor), this.tertiaryTextColor = vt(this.tertiaryColor), this.lineColor = vt(this.background), this.textColor = vt(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = Tt(vt("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#ccc", this.border2 = yl(255, 255, 255, 0.25), this.arrowheadColor = "calculated", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = Ot("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.excludeBkgColor = Ot(this.sectionBkgColor, 10), this.taskBorderColor = yl(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = yl(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || Tt(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || Ot(this.mainBkg, 10), this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
  }
  updateColors() {
    var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p2, _q2, _r2, _s2, _t, _u2;
    this.secondBkg = Tt(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = Tt(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.actorBorder, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = Tt(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 });
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleInv" + t15] = this["cScaleInv" + t15] || vt(this["cScale" + t15]);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScalePeer" + t15] = this["cScalePeer" + t15] || Tt(this["cScale" + t15], 10);
    for (let t15 = 0; t15 < 5; t15++)
      this["surface" + t15] = this["surface" + t15] || st(this.mainBkg, { h: 30, s: -30, l: -(-10 + t15 * 4) }), this["surfacePeer" + t15] = this["surfacePeer" + t15] || st(this.mainBkg, { h: 30, s: -30, l: -(-7 + t15 * 4) });
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleLabel" + t15] = this["cScaleLabel" + t15] || this.scaleLabelColor;
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["pie" + t15] = this["cScale" + t15];
    this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || lc(this.quadrant1Fill) ? Tt(this.quadrant1Fill) : Ot(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((_a3 = this.xyChart) == null ? void 0 : _a3.backgroundColor) || this.background,
      titleColor: ((_b2 = this.xyChart) == null ? void 0 : _b2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_c = this.xyChart) == null ? void 0 : _c.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_d = this.xyChart) == null ? void 0 : _d.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_e = this.xyChart) == null ? void 0 : _e.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_f2 = this.xyChart) == null ? void 0 : _f2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_g2 = this.xyChart) == null ? void 0 : _g2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_h2 = this.xyChart) == null ? void 0 : _h2.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_i2 = this.xyChart) == null ? void 0 : _i2.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_j2 = this.xyChart) == null ? void 0 : _j2.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_k2 = this.xyChart) == null ? void 0 : _k2.plotColorPalette) || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
    }, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.background
    }, this.radar = {
      axisColor: ((_l2 = this.radar) == null ? void 0 : _l2.axisColor) || this.lineColor,
      axisStrokeWidth: ((_m2 = this.radar) == null ? void 0 : _m2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_n2 = this.radar) == null ? void 0 : _n2.axisLabelFontSize) || 12,
      curveOpacity: ((_o = this.radar) == null ? void 0 : _o.curveOpacity) || 0.5,
      curveStrokeWidth: ((_p2 = this.radar) == null ? void 0 : _p2.curveStrokeWidth) || 2,
      graticuleColor: ((_q2 = this.radar) == null ? void 0 : _q2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_r2 = this.radar) == null ? void 0 : _r2.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_s2 = this.radar) == null ? void 0 : _s2.graticuleOpacity) || 0.3,
      legendBoxSize: ((_t = this.radar) == null ? void 0 : _t.legendBoxSize) || 12,
      legendFontSize: ((_u2 = this.radar) == null ? void 0 : _u2.legendFontSize) || 12
    }, this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Ot(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = Tt(this.secondaryColor, 20), this.git1 = Tt(this.pie2 || this.secondaryColor, 20), this.git2 = Tt(this.pie3 || this.tertiaryColor, 20), this.git3 = Tt(this.pie4 || st(this.primaryColor, { h: -30 }), 20), this.git4 = Tt(this.pie5 || st(this.primaryColor, { h: -60 }), 20), this.git5 = Tt(this.pie6 || st(this.primaryColor, { h: -90 }), 10), this.git6 = Tt(this.pie7 || st(this.primaryColor, { h: 60 }), 10), this.git7 = Tt(this.pie8 || st(this.primaryColor, { h: 120 }), 20), this.gitInv0 = this.gitInv0 || vt(this.git0), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || vt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || vt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Tt(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Tt(this.background, 2), this.nodeBorder = this.nodeBorder || "#999";
  }
  calculate(t15) {
    if (typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, _(fp, "Theme"), fp);
var oR = _((t15) => {
  const e = new aR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var mp;
var lR = (mp = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = st(this.primaryColor, { h: 120 }), this.secondaryColor = "#ffffde", this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = _r(this.primaryColor, this.darkMode), this.secondaryBorderColor = _r(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = _r(this.tertiaryColor, this.darkMode), this.primaryTextColor = vt(this.primaryColor), this.secondaryTextColor = vt(this.secondaryColor), this.tertiaryTextColor = vt(this.tertiaryColor), this.lineColor = vt(this.background), this.textColor = vt(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "rgba(232,232,232, 0.8)", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.sectionBkgColor = yl(102, 102, 255, 0.49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "navy", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = "calculated", this.rowEven = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
  }
  updateColors() {
    var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p2, _q2, _r2, _s2, _t, _u2;
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || Ot(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || Ot(this.tertiaryColor, 40);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScale" + t15] = Ot(this["cScale" + t15], 10), this["cScalePeer" + t15] = this["cScalePeer" + t15] || Ot(this["cScale" + t15], 25);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleInv" + t15] = this["cScaleInv" + t15] || st(this["cScale" + t15], { h: 180 });
    for (let t15 = 0; t15 < 5; t15++)
      this["surface" + t15] = this["surface" + t15] || st(this.mainBkg, { h: 30, l: -(5 + t15 * 5) }), this["surfacePeer" + t15] = this["surfacePeer" + t15] || st(this.mainBkg, { h: 30, l: -(7 + t15 * 5) });
    if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || vt(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || vt(this.labelTextColor);
      for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
        this["cScaleLabel" + t15] = this["cScaleLabel" + t15] || this.labelTextColor;
    }
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = Tt(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || Tt(this.primaryColor, 75) || "#ffffff", this.rowEven = this.rowEven || Tt(this.primaryColor, 1), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || st(this.tertiaryColor, { l: -40 }), this.pie4 = this.pie4 || st(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { l: -20 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -20 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -40 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: -40 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -40 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -90, l: -40 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -30 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || lc(this.quadrant1Fill) ? Tt(this.quadrant1Fill) : Ot(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.radar = {
      axisColor: ((_a3 = this.radar) == null ? void 0 : _a3.axisColor) || this.lineColor,
      axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_c = this.radar) == null ? void 0 : _c.axisLabelFontSize) || 12,
      curveOpacity: ((_d = this.radar) == null ? void 0 : _d.curveOpacity) || 0.5,
      curveStrokeWidth: ((_e = this.radar) == null ? void 0 : _e.curveStrokeWidth) || 2,
      graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_g2 = this.radar) == null ? void 0 : _g2.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_h2 = this.radar) == null ? void 0 : _h2.graticuleOpacity) || 0.3,
      legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
      legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
    }, this.xyChart = {
      backgroundColor: ((_k2 = this.xyChart) == null ? void 0 : _k2.backgroundColor) || this.background,
      titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_m2 = this.xyChart) == null ? void 0 : _m2.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_o = this.xyChart) == null ? void 0 : _o.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_q2 = this.xyChart) == null ? void 0 : _q2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_r2 = this.xyChart) == null ? void 0 : _r2.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_s2 = this.xyChart) == null ? void 0 : _s2.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = Tt(this.git0, 25), this.git1 = Tt(this.git1, 25), this.git2 = Tt(this.git2, 25), this.git3 = Tt(this.git3, 25), this.git4 = Tt(this.git4, 25), this.git5 = Tt(this.git5, 25), this.git6 = Tt(this.git6, 25), this.git7 = Tt(this.git7, 25)) : (this.git0 = Ot(this.git0, 25), this.git1 = Ot(this.git1, 25), this.git2 = Ot(this.git2, 25), this.git3 = Ot(this.git3, 25), this.git4 = Ot(this.git4, 25), this.git5 = Ot(this.git5, 25), this.git6 = Ot(this.git6, 25), this.git7 = Ot(this.git7, 25)), this.gitInv0 = this.gitInv0 || Ot(vt(this.git0), 25), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || vt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || vt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || xu, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || wu;
  }
  calculate(t15) {
    if (Object.keys(this).forEach((r) => {
      this[r] === "calculated" && (this[r] = void 0);
    }), typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, _(mp, "Theme"), mp);
var cR = _((t15) => {
  const e = new lR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var gp;
var hR = (gp = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.tertiaryColor = Tt("#cde498", 10), this.primaryBorderColor = _r(this.primaryColor, this.darkMode), this.secondaryBorderColor = _r(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = _r(this.tertiaryColor, this.darkMode), this.primaryTextColor = vt(this.primaryColor), this.secondaryTextColor = vt(this.secondaryColor), this.tertiaryTextColor = vt(this.primaryColor), this.lineColor = vt(this.background), this.textColor = vt(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p2, _q2, _r2, _s2, _t, _u2;
    this.actorBorder = Ot(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || Ot(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || Ot(this.tertiaryColor, 40);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScale" + t15] = Ot(this["cScale" + t15], 10), this["cScalePeer" + t15] = this["cScalePeer" + t15] || Ot(this["cScale" + t15], 25);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleInv" + t15] = this["cScaleInv" + t15] || st(this["cScale" + t15], { h: 180 });
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleLabel" + t15] = this["cScaleLabel" + t15] || this.scaleLabelColor;
    for (let t15 = 0; t15 < 5; t15++)
      this["surface" + t15] = this["surface" + t15] || st(this.mainBkg, { h: 30, s: -30, l: -(5 + t15 * 5) }), this["surfacePeer" + t15] = this["surfacePeer" + t15] || st(this.mainBkg, { h: 30, s: -30, l: -(8 + t15 * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || Tt(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || Tt(this.mainBkg, 20), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || st(this.primaryColor, { l: -30 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { h: 40, l: -40 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -50 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -60, l: -50 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -50 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || lc(this.quadrant1Fill) ? Tt(this.quadrant1Fill) : Ot(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.mainBkg
    }, this.radar = {
      axisColor: ((_a3 = this.radar) == null ? void 0 : _a3.axisColor) || this.lineColor,
      axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_c = this.radar) == null ? void 0 : _c.axisLabelFontSize) || 12,
      curveOpacity: ((_d = this.radar) == null ? void 0 : _d.curveOpacity) || 0.5,
      curveStrokeWidth: ((_e = this.radar) == null ? void 0 : _e.curveStrokeWidth) || 2,
      graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_g2 = this.radar) == null ? void 0 : _g2.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_h2 = this.radar) == null ? void 0 : _h2.graticuleOpacity) || 0.3,
      legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
      legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
    }, this.xyChart = {
      backgroundColor: ((_k2 = this.xyChart) == null ? void 0 : _k2.backgroundColor) || this.background,
      titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_m2 = this.xyChart) == null ? void 0 : _m2.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_o = this.xyChart) == null ? void 0 : _o.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_q2 = this.xyChart) == null ? void 0 : _q2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_r2 = this.xyChart) == null ? void 0 : _r2.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_s2 = this.xyChart) == null ? void 0 : _s2.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = Tt(this.git0, 25), this.git1 = Tt(this.git1, 25), this.git2 = Tt(this.git2, 25), this.git3 = Tt(this.git3, 25), this.git4 = Tt(this.git4, 25), this.git5 = Tt(this.git5, 25), this.git6 = Tt(this.git6, 25), this.git7 = Tt(this.git7, 25)) : (this.git0 = Ot(this.git0, 25), this.git1 = Ot(this.git1, 25), this.git2 = Ot(this.git2, 25), this.git3 = Ot(this.git3, 25), this.git4 = Ot(this.git4, 25), this.git5 = Ot(this.git5, 25), this.git6 = Ot(this.git6, 25), this.git7 = Ot(this.git7, 25)), this.gitInv0 = this.gitInv0 || vt(this.git0), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || vt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || vt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || xu, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || wu;
  }
  calculate(t15) {
    if (typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, _(gp, "Theme"), gp);
var uR = _((t15) => {
  const e = new hR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var yp;
var dR = (yp = class {
  constructor() {
    this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = Tt(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = _r(this.primaryColor, this.darkMode), this.secondaryBorderColor = _r(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = _r(this.tertiaryColor, this.darkMode), this.primaryTextColor = vt(this.primaryColor), this.secondaryTextColor = vt(this.secondaryColor), this.tertiaryTextColor = vt(this.tertiaryColor), this.lineColor = vt(this.background), this.textColor = vt(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = this.actorBorder, this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || Tt(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || "#f4f4f4", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p2, _q2, _r2, _s2, _t, _u2;
    this.secondBkg = Tt(this.contrast, 55), this.border2 = this.contrast, this.actorBorder = Tt(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.actorBorder, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleInv" + t15] = this["cScaleInv" + t15] || vt(this["cScale" + t15]);
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this.darkMode ? this["cScalePeer" + t15] = this["cScalePeer" + t15] || Tt(this["cScale" + t15], 10) : this["cScalePeer" + t15] = this["cScalePeer" + t15] || Ot(this["cScale" + t15], 10);
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["cScaleLabel" + t15] = this["cScaleLabel" + t15] || this.scaleLabelColor;
    for (let t15 = 0; t15 < 5; t15++)
      this["surface" + t15] = this["surface" + t15] || st(this.mainBkg, { l: -(5 + t15 * 5) }), this["surfacePeer" + t15] = this["surfacePeer" + t15] || st(this.mainBkg, { l: -(8 + t15 * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.sectionBkgColor = Tt(this.contrast, 30), this.sectionBkgColor2 = Tt(this.contrast, 30), this.taskBorderColor = Ot(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = Tt(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = Ot(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.vertLineColor = this.critBkgColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 });
    for (let t15 = 0; t15 < this.THEME_COLOR_LIMIT; t15++)
      this["pie" + t15] = this["cScale" + t15];
    this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || lc(this.quadrant1Fill) ? Tt(this.quadrant1Fill) : Ot(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((_a3 = this.xyChart) == null ? void 0 : _a3.backgroundColor) || this.background,
      titleColor: ((_b2 = this.xyChart) == null ? void 0 : _b2.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((_c = this.xyChart) == null ? void 0 : _c.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((_d = this.xyChart) == null ? void 0 : _d.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((_e = this.xyChart) == null ? void 0 : _e.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((_f2 = this.xyChart) == null ? void 0 : _f2.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((_g2 = this.xyChart) == null ? void 0 : _g2.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_h2 = this.xyChart) == null ? void 0 : _h2.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_i2 = this.xyChart) == null ? void 0 : _i2.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((_j2 = this.xyChart) == null ? void 0 : _j2.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((_k2 = this.xyChart) == null ? void 0 : _k2.plotColorPalette) || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
    }, this.radar = {
      axisColor: ((_l2 = this.radar) == null ? void 0 : _l2.axisColor) || this.lineColor,
      axisStrokeWidth: ((_m2 = this.radar) == null ? void 0 : _m2.axisStrokeWidth) || 2,
      axisLabelFontSize: ((_n2 = this.radar) == null ? void 0 : _n2.axisLabelFontSize) || 12,
      curveOpacity: ((_o = this.radar) == null ? void 0 : _o.curveOpacity) || 0.5,
      curveStrokeWidth: ((_p2 = this.radar) == null ? void 0 : _p2.curveStrokeWidth) || 2,
      graticuleColor: ((_q2 = this.radar) == null ? void 0 : _q2.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((_r2 = this.radar) == null ? void 0 : _r2.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_s2 = this.radar) == null ? void 0 : _s2.graticuleOpacity) || 0.3,
      legendBoxSize: ((_t = this.radar) == null ? void 0 : _t.legendBoxSize) || 12,
      legendFontSize: ((_u2 = this.radar) == null ? void 0 : _u2.legendFontSize) || 12
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = Ot(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || st(this.primaryColor, { h: -30 }), this.git4 = this.pie5 || st(this.primaryColor, { h: -60 }), this.git5 = this.pie6 || st(this.primaryColor, { h: -90 }), this.git6 = this.pie7 || st(this.primaryColor, { h: 60 }), this.git7 = this.pie8 || st(this.primaryColor, { h: 120 }), this.gitInv0 = this.gitInv0 || vt(this.git0), this.gitInv1 = this.gitInv1 || vt(this.git1), this.gitInv2 = this.gitInv2 || vt(this.git2), this.gitInv3 = this.gitInv3 || vt(this.git3), this.gitInv4 = this.gitInv4 || vt(this.git4), this.gitInv5 = this.gitInv5 || vt(this.git5), this.gitInv6 = this.gitInv6 || vt(this.git6), this.gitInv7 = this.gitInv7 || vt(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || xu, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || wu;
  }
  calculate(t15) {
    if (typeof t15 != "object") {
      this.updateColors();
      return;
    }
    const e = Object.keys(t15);
    e.forEach((r) => {
      this[r] = t15[r];
    }), this.updateColors(), e.forEach((r) => {
      this[r] = t15[r];
    });
  }
}, _(yp, "Theme"), yp);
var pR = _((t15) => {
  const e = new dR();
  return e.calculate(t15), e;
}, "getThemeVariables");
var Ti = {
  base: {
    getThemeVariables: sR
  },
  dark: {
    getThemeVariables: oR
  },
  default: {
    getThemeVariables: cR
  },
  forest: {
    getThemeVariables: uR
  },
  neutral: {
    getThemeVariables: pR
  }
};
var Nn = {
  flowchart: {
    useMaxWidth: true,
    titleTopMargin: 25,
    subGraphTitleMargin: {
      top: 0,
      bottom: 0
    },
    diagramPadding: 8,
    htmlLabels: true,
    nodeSpacing: 50,
    rankSpacing: 50,
    curve: "basis",
    padding: 15,
    defaultRenderer: "dagre-wrapper",
    wrappingWidth: 200,
    inheritDir: false
  },
  sequence: {
    useMaxWidth: true,
    hideUnusedParticipants: false,
    activationWidth: 10,
    diagramMarginX: 50,
    diagramMarginY: 10,
    actorMargin: 50,
    width: 150,
    height: 65,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    mirrorActors: true,
    forceMenus: false,
    bottomMarginAdj: 1,
    rightAngles: false,
    showSequenceNumbers: false,
    actorFontSize: 14,
    actorFontFamily: '"Open Sans", sans-serif',
    actorFontWeight: 400,
    noteFontSize: 14,
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    noteFontWeight: 400,
    noteAlign: "center",
    messageFontSize: 16,
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    messageFontWeight: 400,
    wrap: false,
    wrapPadding: 10,
    labelBoxWidth: 50,
    labelBoxHeight: 20
  },
  gantt: {
    useMaxWidth: true,
    titleTopMargin: 25,
    barHeight: 20,
    barGap: 4,
    topPadding: 50,
    rightPadding: 75,
    leftPadding: 75,
    gridLineStartPadding: 35,
    fontSize: 11,
    sectionFontSize: 11,
    numberSectionStyles: 4,
    axisFormat: "%Y-%m-%d",
    topAxis: false,
    displayMode: "",
    weekday: "sunday"
  },
  journey: {
    useMaxWidth: true,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    maxLabelWidth: 360,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: false,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    titleColor: "",
    titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    titleFontSize: "4ex"
  },
  class: {
    useMaxWidth: true,
    titleTopMargin: 25,
    arrowMarkerAbsolute: false,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    defaultRenderer: "dagre-wrapper",
    htmlLabels: false,
    hideEmptyMembersBox: false
  },
  state: {
    useMaxWidth: true,
    titleTopMargin: 25,
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    miniPadding: 2,
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    defaultRenderer: "dagre-wrapper"
  },
  er: {
    useMaxWidth: true,
    titleTopMargin: 25,
    diagramPadding: 20,
    layoutDirection: "TB",
    minEntityWidth: 100,
    minEntityHeight: 75,
    entityPadding: 15,
    nodeSpacing: 140,
    rankSpacing: 80,
    stroke: "gray",
    fill: "honeydew",
    fontSize: 12
  },
  pie: {
    useMaxWidth: true,
    textPosition: 0.75
  },
  quadrantChart: {
    useMaxWidth: true,
    chartWidth: 500,
    chartHeight: 500,
    titleFontSize: 20,
    titlePadding: 10,
    quadrantPadding: 5,
    xAxisLabelPadding: 5,
    yAxisLabelPadding: 5,
    xAxisLabelFontSize: 16,
    yAxisLabelFontSize: 16,
    quadrantLabelFontSize: 16,
    quadrantTextTopPadding: 5,
    pointTextPadding: 5,
    pointLabelFontSize: 12,
    pointRadius: 5,
    xAxisPosition: "top",
    yAxisPosition: "left",
    quadrantInternalBorderStrokeWidth: 1,
    quadrantExternalBorderStrokeWidth: 2
  },
  xyChart: {
    useMaxWidth: true,
    width: 700,
    height: 500,
    titleFontSize: 20,
    titlePadding: 10,
    showDataLabel: false,
    showTitle: true,
    xAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: true,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: true,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: true,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: true,
      axisLineWidth: 2
    },
    yAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: true,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: true,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: true,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: true,
      axisLineWidth: 2
    },
    chartOrientation: "vertical",
    plotReservedSpacePercent: 50
  },
  requirement: {
    useMaxWidth: true,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  mindmap: {
    useMaxWidth: true,
    padding: 10,
    maxNodeWidth: 200
  },
  kanban: {
    useMaxWidth: true,
    padding: 8,
    sectionWidth: 200,
    ticketBaseUrl: ""
  },
  timeline: {
    useMaxWidth: true,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: false,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    disableMulticolor: false
  },
  gitGraph: {
    useMaxWidth: true,
    titleTopMargin: 25,
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: true,
    showBranches: true,
    rotateCommitLabel: true,
    parallelCommits: false,
    arrowMarkerAbsolute: false
  },
  c4: {
    useMaxWidth: true,
    diagramMarginX: 50,
    diagramMarginY: 10,
    c4ShapeMargin: 50,
    c4ShapePadding: 20,
    width: 216,
    height: 60,
    boxMargin: 10,
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    c4BoundaryInRow: 2,
    personFontSize: 14,
    personFontFamily: '"Open Sans", sans-serif',
    personFontWeight: "normal",
    external_personFontSize: 14,
    external_personFontFamily: '"Open Sans", sans-serif',
    external_personFontWeight: "normal",
    systemFontSize: 14,
    systemFontFamily: '"Open Sans", sans-serif',
    systemFontWeight: "normal",
    external_systemFontSize: 14,
    external_systemFontFamily: '"Open Sans", sans-serif',
    external_systemFontWeight: "normal",
    system_dbFontSize: 14,
    system_dbFontFamily: '"Open Sans", sans-serif',
    system_dbFontWeight: "normal",
    external_system_dbFontSize: 14,
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    external_system_dbFontWeight: "normal",
    system_queueFontSize: 14,
    system_queueFontFamily: '"Open Sans", sans-serif',
    system_queueFontWeight: "normal",
    external_system_queueFontSize: 14,
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    external_system_queueFontWeight: "normal",
    boundaryFontSize: 14,
    boundaryFontFamily: '"Open Sans", sans-serif',
    boundaryFontWeight: "normal",
    messageFontSize: 12,
    messageFontFamily: '"Open Sans", sans-serif',
    messageFontWeight: "normal",
    containerFontSize: 14,
    containerFontFamily: '"Open Sans", sans-serif',
    containerFontWeight: "normal",
    external_containerFontSize: 14,
    external_containerFontFamily: '"Open Sans", sans-serif',
    external_containerFontWeight: "normal",
    container_dbFontSize: 14,
    container_dbFontFamily: '"Open Sans", sans-serif',
    container_dbFontWeight: "normal",
    external_container_dbFontSize: 14,
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    external_container_dbFontWeight: "normal",
    container_queueFontSize: 14,
    container_queueFontFamily: '"Open Sans", sans-serif',
    container_queueFontWeight: "normal",
    external_container_queueFontSize: 14,
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    external_container_queueFontWeight: "normal",
    componentFontSize: 14,
    componentFontFamily: '"Open Sans", sans-serif',
    componentFontWeight: "normal",
    external_componentFontSize: 14,
    external_componentFontFamily: '"Open Sans", sans-serif',
    external_componentFontWeight: "normal",
    component_dbFontSize: 14,
    component_dbFontFamily: '"Open Sans", sans-serif',
    component_dbFontWeight: "normal",
    external_component_dbFontSize: 14,
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    external_component_dbFontWeight: "normal",
    component_queueFontSize: 14,
    component_queueFontFamily: '"Open Sans", sans-serif',
    component_queueFontWeight: "normal",
    external_component_queueFontSize: 14,
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    external_component_queueFontWeight: "normal",
    wrap: true,
    wrapPadding: 10,
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  sankey: {
    useMaxWidth: true,
    width: 600,
    height: 400,
    linkColor: "gradient",
    nodeAlignment: "justify",
    showValues: true,
    prefix: "",
    suffix: ""
  },
  block: {
    useMaxWidth: true,
    padding: 8
  },
  packet: {
    useMaxWidth: true,
    rowHeight: 32,
    bitWidth: 32,
    bitsPerRow: 32,
    showBits: true,
    paddingX: 5,
    paddingY: 5
  },
  architecture: {
    useMaxWidth: true,
    padding: 40,
    iconSize: 80,
    fontSize: 16
  },
  radar: {
    useMaxWidth: true,
    width: 600,
    height: 600,
    marginTop: 50,
    marginRight: 50,
    marginBottom: 50,
    marginLeft: 50,
    axisScaleFactor: 1,
    axisLabelFactor: 1.05,
    curveTension: 0.17
  },
  theme: "default",
  look: "classic",
  handDrawnSeed: 0,
  layout: "dagre",
  maxTextSize: 5e4,
  maxEdges: 500,
  darkMode: false,
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  logLevel: 5,
  securityLevel: "strict",
  startOnLoad: true,
  arrowMarkerAbsolute: false,
  secure: [
    "secure",
    "securityLevel",
    "startOnLoad",
    "maxTextSize",
    "suppressErrorRendering",
    "maxEdges"
  ],
  legacyMathML: false,
  forceLegacyMathML: false,
  deterministicIds: false,
  fontSize: 16,
  markdownAutoWrap: true,
  suppressErrorRendering: false
};
var D6 = {
  ...Nn,
  // Set, even though they're `undefined` so that `configKeys` finds these keys
  // TODO: Should we replace these with `null` so that they can go in the JSON Schema?
  deterministicIDSeed: void 0,
  elk: {
    // mergeEdges is needed here to be considered
    mergeEdges: false,
    nodePlacementStrategy: "BRANDES_KOEPF"
  },
  themeCSS: void 0,
  // add non-JSON default config values
  themeVariables: Ti.default.getThemeVariables(),
  sequence: {
    ...Nn.sequence,
    messageFont: _(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont"),
    noteFont: _(function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    }, "noteFont"),
    actorFont: _(function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }, "actorFont")
  },
  class: {
    hideEmptyMembersBox: false
  },
  gantt: {
    ...Nn.gantt,
    tickInterval: void 0,
    useWidth: void 0
    // can probably be removed since `configKeys` already includes this
  },
  c4: {
    ...Nn.c4,
    useWidth: void 0,
    personFont: _(function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    }, "personFont"),
    flowchart: {
      ...Nn.flowchart,
      inheritDir: false
      // default to legacy behavior
    },
    external_personFont: _(function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    }, "external_personFont"),
    systemFont: _(function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    }, "systemFont"),
    external_systemFont: _(function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    }, "external_systemFont"),
    system_dbFont: _(function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    }, "system_dbFont"),
    external_system_dbFont: _(function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    }, "external_system_dbFont"),
    system_queueFont: _(function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    }, "system_queueFont"),
    external_system_queueFont: _(function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    }, "external_system_queueFont"),
    containerFont: _(function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    }, "containerFont"),
    external_containerFont: _(function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    }, "external_containerFont"),
    container_dbFont: _(function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    }, "container_dbFont"),
    external_container_dbFont: _(function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    }, "external_container_dbFont"),
    container_queueFont: _(function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    }, "container_queueFont"),
    external_container_queueFont: _(function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    }, "external_container_queueFont"),
    componentFont: _(function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    }, "componentFont"),
    external_componentFont: _(function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    }, "external_componentFont"),
    component_dbFont: _(function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    }, "component_dbFont"),
    external_component_dbFont: _(function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    }, "external_component_dbFont"),
    component_queueFont: _(function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    }, "component_queueFont"),
    external_component_queueFont: _(function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    }, "external_component_queueFont"),
    boundaryFont: _(function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    }, "boundaryFont"),
    messageFont: _(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont")
  },
  pie: {
    ...Nn.pie,
    useWidth: 984
  },
  xyChart: {
    ...Nn.xyChart,
    useWidth: void 0
  },
  requirement: {
    ...Nn.requirement,
    useWidth: void 0
  },
  packet: {
    ...Nn.packet
  },
  radar: {
    ...Nn.radar
  },
  treemap: {
    useMaxWidth: true,
    padding: 10,
    diagramPadding: 8,
    showValues: true,
    nodeWidth: 100,
    nodeHeight: 40,
    borderWidth: 1,
    valueFontSize: 12,
    labelFontSize: 14,
    valueFormat: ","
  }
};
var F6 = _((t15, e = "") => Object.keys(t15).reduce((r, n) => Array.isArray(t15[n]) ? r : typeof t15[n] == "object" && t15[n] !== null ? [...r, e + n, ...F6(t15[n], "")] : [...r, e + n], []), "keyify");
var fR = new Set(F6(D6, ""));
var N6 = D6;
var p0 = _((t15) => {
  if (ut.debug("sanitizeDirective called with", t15), !(typeof t15 != "object" || t15 == null)) {
    if (Array.isArray(t15)) {
      t15.forEach((e) => p0(e));
      return;
    }
    for (const e of Object.keys(t15)) {
      if (ut.debug("Checking key", e), e.startsWith("__") || e.includes("proto") || e.includes("constr") || !fR.has(e) || t15[e] == null) {
        ut.debug("sanitize deleting key: ", e), delete t15[e];
        continue;
      }
      if (typeof t15[e] == "object") {
        ut.debug("sanitizing object", e), p0(t15[e]);
        continue;
      }
      const r = ["themeCSS", "fontFamily", "altFontFamily"];
      for (const n of r)
        e.includes(n) && (ut.debug("sanitizing css option", e), t15[e] = mR(t15[e]));
    }
    if (t15.themeVariables)
      for (const e of Object.keys(t15.themeVariables)) {
        const r = t15.themeVariables[e];
        (r == null ? void 0 : r.match) && !r.match(/^[\d "#%(),.;A-Za-z]+$/) && (t15.themeVariables[e] = "");
      }
    ut.debug("After sanitization", t15);
  }
}, "sanitizeDirective");
var mR = _((t15) => {
  let e = 0, r = 0;
  for (const n of t15) {
    if (e < r)
      return "{ /* ERROR: Unbalanced CSS */ }";
    n === "{" ? e++ : n === "}" && r++;
  }
  return e !== r ? "{ /* ERROR: Unbalanced CSS */ }" : t15;
}, "sanitizeCss");
var Ka = Object.freeze(N6);
var qr = ur({}, Ka);
var I6;
var Za = [];
var xl = ur({}, Ka);
var ku = _((t15, e) => {
  let r = ur({}, t15), n = {};
  for (const i of e)
    q6(i), n = ur(n, i);
  if (r = ur(r, n), n.theme && n.theme in Ti) {
    const i = ur({}, I6), s = ur(
      i.themeVariables || {},
      n.themeVariables
    );
    r.theme && r.theme in Ti && (r.themeVariables = Ti[r.theme].getThemeVariables(s));
  }
  return xl = r, R6(xl), xl;
}, "updateCurrentConfig");
var gR = _((t15) => (qr = ur({}, Ka), qr = ur(qr, t15), t15.theme && Ti[t15.theme] && (qr.themeVariables = Ti[t15.theme].getThemeVariables(t15.themeVariables)), ku(qr, Za), qr), "setSiteConfig");
var yR = _((t15) => {
  I6 = ur({}, t15);
}, "saveConfigFromInitialize");
var bR = _((t15) => (qr = ur(qr, t15), ku(qr, Za), qr), "updateSiteConfig");
var O6 = _(() => ur({}, qr), "getSiteConfig");
var z6 = _((t15) => (R6(t15), ur(xl, t15), Hr()), "setConfig");
var Hr = _(() => ur({}, xl), "getConfig");
var q6 = _((t15) => {
  t15 && (["secure", ...qr.secure ?? []].forEach((e) => {
    Object.hasOwn(t15, e) && (ut.debug(`Denied attempt to modify a secure key ${e}`, t15[e]), delete t15[e]);
  }), Object.keys(t15).forEach((e) => {
    e.startsWith("__") && delete t15[e];
  }), Object.keys(t15).forEach((e) => {
    typeof t15[e] == "string" && (t15[e].includes("<") || t15[e].includes(">") || t15[e].includes("url(data:")) && delete t15[e], typeof t15[e] == "object" && q6(t15[e]);
  }));
}, "sanitize");
var xR = _((t15) => {
  var _a3;
  p0(t15), t15.fontFamily && !((_a3 = t15.themeVariables) == null ? void 0 : _a3.fontFamily) && (t15.themeVariables = {
    ...t15.themeVariables,
    fontFamily: t15.fontFamily
  }), Za.push(t15), ku(qr, Za);
}, "addDirective");
var f0 = _((t15 = qr) => {
  Za = [], ku(t15, Za);
}, "reset");
var wR = {
  LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
};
var Nb = {};
var kR = _((t15) => {
  Nb[t15] || (ut.warn(wR[t15]), Nb[t15] = true);
}, "issueWarning");
var R6 = _((t15) => {
  t15 && (t15.lazyLoadedDiagrams || t15.loadExternalDiagramsAtStartup) && kR("LAZY_LOAD_DEPRECATED");
}, "checkConfig");
var cc = /<br\s*\/?>/gi;
var vR = _((t15) => t15 ? W6(t15).replace(/\\n/g, "#br#").split("#br#") : [""], "getRows");
var CR = /* @__PURE__ */ (() => {
  let t15 = false;
  return () => {
    t15 || (P6(), t15 = true);
  };
})();
function P6() {
  const t15 = "data-temp-href-target";
  Ya.addHook("beforeSanitizeAttributes", (e) => {
    e instanceof Element && e.tagName === "A" && e.hasAttribute("target") && e.setAttribute(t15, e.getAttribute("target") ?? "");
  }), Ya.addHook("afterSanitizeAttributes", (e) => {
    e instanceof Element && e.tagName === "A" && e.hasAttribute(t15) && (e.setAttribute("target", e.getAttribute(t15) ?? ""), e.removeAttribute(t15), e.getAttribute("target") === "_blank" && e.setAttribute("rel", "noopener"));
  });
}
_(P6, "setupDompurifyHooks");
var j6 = _((t15) => (CR(), Ya.sanitize(t15)), "removeScript");
var Ib = _((t15, e) => {
  var _a3;
  if (((_a3 = e.flowchart) == null ? void 0 : _a3.htmlLabels) !== false) {
    const r = e.securityLevel;
    r === "antiscript" || r === "strict" ? t15 = j6(t15) : r !== "loose" && (t15 = W6(t15), t15 = t15.replace(/</g, "&lt;").replace(/>/g, "&gt;"), t15 = t15.replace(/=/g, "&equals;"), t15 = TR(t15));
  }
  return t15;
}, "sanitizeMore");
var Zs = _((t15, e) => t15 && (e.dompurifyConfig ? t15 = Ya.sanitize(Ib(t15, e), e.dompurifyConfig).toString() : t15 = Ya.sanitize(Ib(t15, e), {
  FORBID_TAGS: ["style"]
}).toString(), t15), "sanitizeText");
var _R = _((t15, e) => typeof t15 == "string" ? Zs(t15, e) : t15.flat().map((r) => Zs(r, e)), "sanitizeTextOrArray");
var SR = _((t15) => cc.test(t15), "hasBreaks");
var AR = _((t15) => t15.split(cc), "splitBreaks");
var TR = _((t15) => t15.replace(/#br#/g, "<br/>"), "placeholderToBreak");
var W6 = _((t15) => t15.replace(cc, "#br#"), "breakToPlaceholder");
var H6 = _((t15) => {
  let e = "";
  return t15 && (e = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, e = CSS.escape(e)), e;
}, "getUrl");
var Ke = _((t15) => !(t15 === false || ["false", "null", "0"].includes(String(t15).trim().toLowerCase())), "evaluate");
var $R = _(function(...t15) {
  const e = t15.filter((r) => !isNaN(r));
  return Math.max(...e);
}, "getMax");
var ER = _(function(...t15) {
  const e = t15.filter((r) => !isNaN(r));
  return Math.min(...e);
}, "getMin");
var Ob = _(function(t15) {
  const e = t15.split(/(,)/), r = [];
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (i === "," && n > 0 && n + 1 < e.length) {
      const s = e[n - 1], a = e[n + 1];
      MR(s, a) && (i = s + "," + a, n++, r.pop());
    }
    r.push(BR(i));
  }
  return r.join("");
}, "parseGenericTypes");
var $f = _((t15, e) => Math.max(0, t15.split(e).length - 1), "countOccurrence");
var MR = _((t15, e) => {
  const r = $f(t15, "~"), n = $f(e, "~");
  return r === 1 && n === 1;
}, "shouldCombineSets");
var BR = _((t15) => {
  const e = $f(t15, "~");
  let r = false;
  if (e <= 1)
    return t15;
  e % 2 !== 0 && t15.startsWith("~") && (t15 = t15.substring(1), r = true);
  const n = [...t15];
  let i = n.indexOf("~"), s = n.lastIndexOf("~");
  for (; i !== -1 && s !== -1 && i !== s; )
    n[i] = "<", n[s] = ">", i = n.indexOf("~"), s = n.lastIndexOf("~");
  return r && n.unshift("~"), n.join("");
}, "processSet");
var zb = _(() => window.MathMLElement !== void 0, "isMathMLSupported");
var Ef = /\$\$(.*)\$\$/g;
var Ja = _((t15) => {
  var _a3;
  return (((_a3 = t15.match(Ef)) == null ? void 0 : _a3.length) ?? 0) > 0;
}, "hasKatex");
var lrt = _(async (t15, e) => {
  var _a3;
  t15 = await Sm(t15, e);
  const r = document.createElement("div");
  r.innerHTML = t15, r.id = "katex-temp", r.style.visibility = "hidden", r.style.position = "absolute", r.style.top = "0", (_a3 = document.querySelector("body")) == null ? void 0 : _a3.insertAdjacentElement("beforeend", r);
  const n = { width: r.clientWidth, height: r.clientHeight };
  return r.remove(), n;
}, "calculateMathMLDimensions");
var Sm = _(async (t15, e) => {
  if (!Ja(t15))
    return t15;
  if (!(zb() || e.legacyMathML || e.forceLegacyMathML))
    return t15.replace(Ef, "MathML is unsupported in this environment.");
  {
    const { default: r } = await import("./katex-CUSbq6rG-DCyV1FlS-2CUMXT6W.js"), n = e.forceLegacyMathML || !zb() && e.legacyMathML ? "htmlAndMathml" : "mathml";
    return t15.split(cc).map(
      (i) => Ja(i) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${i}</div>` : `<div>${i}</div>`
    ).join("").replace(
      Ef,
      (i, s) => r.renderToString(s, {
        throwOnError: true,
        displayMode: true,
        output: n
      }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, "")
    );
  }
}, "renderKatex");
var fo = {
  getRows: vR,
  sanitizeText: Zs,
  sanitizeTextOrArray: _R,
  hasBreaks: SR,
  splitBreaks: AR,
  lineBreakRegex: cc,
  removeScript: j6,
  getUrl: H6,
  evaluate: Ke,
  getMax: $R,
  getMin: ER
};
var LR = _(function(t15, e) {
  for (let r of e)
    t15.attr(r[0], r[1]);
}, "d3Attrs");
var DR = _(function(t15, e, r) {
  let n = /* @__PURE__ */ new Map();
  return r ? (n.set("width", "100%"), n.set("style", `max-width: ${e}px;`)) : (n.set("height", t15), n.set("width", e)), n;
}, "calculateSvgSizeAttrs");
var U6 = _(function(t15, e, r, n) {
  const i = DR(e, r, n);
  LR(t15, i);
}, "configureSvgSize");
var FR = _(function(t15, e, r, n) {
  const i = e.node().getBBox(), s = i.width, a = i.height;
  ut.info(`SVG bounds: ${s}x${a}`, i);
  let o = 0, l = 0;
  ut.info(`Graph bounds: ${o}x${l}`, t15), o = s + r * 2, l = a + r * 2, ut.info(`Calculated bounds: ${o}x${l}`), U6(e, l, o, n);
  const c = `${i.x - r} ${i.y - r} ${i.width + 2 * r} ${i.height + 2 * r}`;
  e.attr("viewBox", c);
}, "setupGraphViewbox");
var Eh = {};
var NR = _((t15, e, r) => {
  let n = "";
  return t15 in Eh && Eh[t15] ? n = Eh[t15](r) : ut.warn(`No theme found for ${t15}`), ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }
   & p {
    margin: 0
   }

  ${n}

  ${e}
`;
}, "getStyles");
var IR = _((t15, e) => {
  e !== void 0 && (Eh[t15] = e);
}, "addStylesForDiagram");
var OR = NR;
var V6 = {};
eR(V6, {
  clear: () => zR,
  getAccDescription: () => jR,
  getAccTitle: () => RR,
  getDiagramTitle: () => HR,
  setAccDescription: () => PR,
  setAccTitle: () => qR,
  setDiagramTitle: () => WR
});
var Am = "";
var Tm = "";
var $m = "";
var Em = _((t15) => Zs(t15, Hr()), "sanitizeText");
var zR = _(() => {
  Am = "", $m = "", Tm = "";
}, "clear");
var qR = _((t15) => {
  Am = Em(t15).replace(/^\s+/g, "");
}, "setAccTitle");
var RR = _(() => Am, "getAccTitle");
var PR = _((t15) => {
  $m = Em(t15).replace(/\n\s+/g, `
`);
}, "setAccDescription");
var jR = _(() => $m, "getAccDescription");
var WR = _((t15) => {
  Tm = Em(t15);
}, "setDiagramTitle");
var HR = _(() => Tm, "getDiagramTitle");
var qb = ut;
var UR = Cm;
var fe = Hr;
var crt = z6;
var hrt = Ka;
var vu = _((t15) => Zs(t15, fe()), "sanitizeText");
var VR = FR;
var GR = _(() => V6, "getCommonDb");
var m0 = {};
var g0 = _((t15, e, r) => {
  var _a3;
  m0[t15] && qb.warn(`Diagram with id ${t15} already registered. Overwriting.`), m0[t15] = e, r && L6(t15, r), IR(t15, e.styles), (_a3 = e.injectUtils) == null ? void 0 : _a3.call(
    e,
    qb,
    UR,
    fe,
    vu,
    VR,
    GR(),
    () => {
    }
  );
}, "registerDiagram");
var Mf = _((t15) => {
  if (t15 in m0)
    return m0[t15];
  throw new XR(t15);
}, "getDiagram");
var bp;
var XR = (bp = class extends Error {
  constructor(t15) {
    super(`Diagram ${t15} not found.`);
  }
}, _(bp, "DiagramNotFoundError"), bp);
function Mm(t15) {
  return typeof t15 > "u" || t15 === null;
}
_(Mm, "isNothing");
function G6(t15) {
  return typeof t15 == "object" && t15 !== null;
}
_(G6, "isObject");
function X6(t15) {
  return Array.isArray(t15) ? t15 : Mm(t15) ? [] : [t15];
}
_(X6, "toArray");
function Y6(t15, e) {
  var r, n, i, s;
  if (e)
    for (s = Object.keys(e), r = 0, n = s.length; r < n; r += 1)
      i = s[r], t15[i] = e[i];
  return t15;
}
_(Y6, "extend");
function K6(t15, e) {
  var r = "", n;
  for (n = 0; n < e; n += 1)
    r += t15;
  return r;
}
_(K6, "repeat");
function Z6(t15) {
  return t15 === 0 && Number.NEGATIVE_INFINITY === 1 / t15;
}
_(Z6, "isNegativeZero");
var YR = Mm;
var KR = G6;
var ZR = X6;
var JR = K6;
var QR = Z6;
var tP = Y6;
var Xe = {
  isNothing: YR,
  isObject: KR,
  toArray: ZR,
  repeat: JR,
  isNegativeZero: QR,
  extend: tP
};
function Bm(t15, e) {
  var r = "", n = t15.reason || "(unknown reason)";
  return t15.mark ? (t15.mark.name && (r += 'in "' + t15.mark.name + '" '), r += "(" + (t15.mark.line + 1) + ":" + (t15.mark.column + 1) + ")", !e && t15.mark.snippet && (r += `

` + t15.mark.snippet), n + " " + r) : n;
}
_(Bm, "formatError");
function Qa(t15, e) {
  Error.call(this), this.name = "YAMLException", this.reason = t15, this.mark = e, this.message = Bm(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
_(Qa, "YAMLException$1");
Qa.prototype = Object.create(Error.prototype);
Qa.prototype.constructor = Qa;
Qa.prototype.toString = _(function(t15) {
  return this.name + ": " + Bm(this, t15);
}, "toString");
var Pr = Qa;
function Mh(t15, e, r, n, i) {
  var s = "", a = "", o = Math.floor(i / 2) - 1;
  return n - e > o && (s = " ... ", e = n - o + s.length), r - n > o && (a = " ...", r = n + o - a.length), {
    str: s + t15.slice(e, r).replace(/\t/g, "→") + a,
    pos: n - e + s.length
    // relative position
  };
}
_(Mh, "getLine");
function Bh(t15, e) {
  return Xe.repeat(" ", e - t15.length) + t15;
}
_(Bh, "padStart");
function J6(t15, e) {
  if (e = Object.create(e || null), !t15.buffer) return null;
  e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, n = [0], i = [], s, a = -1; s = r.exec(t15.buffer); )
    i.push(s.index), n.push(s.index + s[0].length), t15.position <= s.index && a < 0 && (a = n.length - 2);
  a < 0 && (a = n.length - 1);
  var o = "", l, c, h = Math.min(t15.line + e.linesAfter, i.length).toString().length, p = e.maxLength - (e.indent + h + 3);
  for (l = 1; l <= e.linesBefore && !(a - l < 0); l++)
    c = Mh(
      t15.buffer,
      n[a - l],
      i[a - l],
      t15.position - (n[a] - n[a - l]),
      p
    ), o = Xe.repeat(" ", e.indent) + Bh((t15.line - l + 1).toString(), h) + " | " + c.str + `
` + o;
  for (c = Mh(t15.buffer, n[a], i[a], t15.position, p), o += Xe.repeat(" ", e.indent) + Bh((t15.line + 1).toString(), h) + " | " + c.str + `
`, o += Xe.repeat("-", e.indent + h + 3 + c.pos) + `^
`, l = 1; l <= e.linesAfter && !(a + l >= i.length); l++)
    c = Mh(
      t15.buffer,
      n[a + l],
      i[a + l],
      t15.position - (n[a] - n[a + l]),
      p
    ), o += Xe.repeat(" ", e.indent) + Bh((t15.line + l + 1).toString(), h) + " | " + c.str + `
`;
  return o.replace(/\n$/, "");
}
_(J6, "makeSnippet");
var eP = J6;
var rP = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var nP = [
  "scalar",
  "sequence",
  "mapping"
];
function Q6(t15) {
  var e = {};
  return t15 !== null && Object.keys(t15).forEach(function(r) {
    t15[r].forEach(function(n) {
      e[String(n)] = r;
    });
  }), e;
}
_(Q6, "compileStyleAliases");
function tw(t15, e) {
  if (e = e || {}, Object.keys(e).forEach(function(r) {
    if (rP.indexOf(r) === -1)
      throw new Pr('Unknown option "' + r + '" is met in definition of "' + t15 + '" YAML type.');
  }), this.options = e, this.tag = t15, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return true;
  }, this.construct = e.construct || function(r) {
    return r;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || false, this.styleAliases = Q6(e.styleAliases || null), nP.indexOf(this.kind) === -1)
    throw new Pr('Unknown kind "' + this.kind + '" is specified for "' + t15 + '" YAML type.');
}
_(tw, "Type$1");
var gr = tw;
function Bf(t15, e) {
  var r = [];
  return t15[e].forEach(function(n) {
    var i = r.length;
    r.forEach(function(s, a) {
      s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = a);
    }), r[i] = n;
  }), r;
}
_(Bf, "compileList");
function ew() {
  var t15 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e, r;
  function n(i) {
    i.multi ? (t15.multi[i.kind].push(i), t15.multi.fallback.push(i)) : t15[i.kind][i.tag] = t15.fallback[i.tag] = i;
  }
  for (_(n, "collectType"), e = 0, r = arguments.length; e < r; e += 1)
    arguments[e].forEach(n);
  return t15;
}
_(ew, "compileMap");
function y0(t15) {
  return this.extend(t15);
}
_(y0, "Schema$1");
y0.prototype.extend = _(function(t15) {
  var e = [], r = [];
  if (t15 instanceof gr)
    r.push(t15);
  else if (Array.isArray(t15))
    r = r.concat(t15);
  else if (t15 && (Array.isArray(t15.implicit) || Array.isArray(t15.explicit)))
    t15.implicit && (e = e.concat(t15.implicit)), t15.explicit && (r = r.concat(t15.explicit));
  else
    throw new Pr("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  e.forEach(function(i) {
    if (!(i instanceof gr))
      throw new Pr("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (i.loadKind && i.loadKind !== "scalar")
      throw new Pr("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (i.multi)
      throw new Pr("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(i) {
    if (!(i instanceof gr))
      throw new Pr("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var n = Object.create(y0.prototype);
  return n.implicit = (this.implicit || []).concat(e), n.explicit = (this.explicit || []).concat(r), n.compiledImplicit = Bf(n, "implicit"), n.compiledExplicit = Bf(n, "explicit"), n.compiledTypeMap = ew(n.compiledImplicit, n.compiledExplicit), n;
}, "extend");
var iP = y0;
var sP = new gr("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: _(function(t15) {
    return t15 !== null ? t15 : "";
  }, "construct")
});
var aP = new gr("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: _(function(t15) {
    return t15 !== null ? t15 : [];
  }, "construct")
});
var oP = new gr("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: _(function(t15) {
    return t15 !== null ? t15 : {};
  }, "construct")
});
var lP = new iP({
  explicit: [
    sP,
    aP,
    oP
  ]
});
function rw(t15) {
  if (t15 === null) return true;
  var e = t15.length;
  return e === 1 && t15 === "~" || e === 4 && (t15 === "null" || t15 === "Null" || t15 === "NULL");
}
_(rw, "resolveYamlNull");
function nw() {
  return null;
}
_(nw, "constructYamlNull");
function iw(t15) {
  return t15 === null;
}
_(iw, "isNull");
var cP = new gr("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: rw,
  construct: nw,
  predicate: iw,
  represent: {
    canonical: _(function() {
      return "~";
    }, "canonical"),
    lowercase: _(function() {
      return "null";
    }, "lowercase"),
    uppercase: _(function() {
      return "NULL";
    }, "uppercase"),
    camelcase: _(function() {
      return "Null";
    }, "camelcase"),
    empty: _(function() {
      return "";
    }, "empty")
  },
  defaultStyle: "lowercase"
});
function sw(t15) {
  if (t15 === null) return false;
  var e = t15.length;
  return e === 4 && (t15 === "true" || t15 === "True" || t15 === "TRUE") || e === 5 && (t15 === "false" || t15 === "False" || t15 === "FALSE");
}
_(sw, "resolveYamlBoolean");
function aw(t15) {
  return t15 === "true" || t15 === "True" || t15 === "TRUE";
}
_(aw, "constructYamlBoolean");
function ow(t15) {
  return Object.prototype.toString.call(t15) === "[object Boolean]";
}
_(ow, "isBoolean");
var hP = new gr("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: sw,
  construct: aw,
  predicate: ow,
  represent: {
    lowercase: _(function(t15) {
      return t15 ? "true" : "false";
    }, "lowercase"),
    uppercase: _(function(t15) {
      return t15 ? "TRUE" : "FALSE";
    }, "uppercase"),
    camelcase: _(function(t15) {
      return t15 ? "True" : "False";
    }, "camelcase")
  },
  defaultStyle: "lowercase"
});
function lw(t15) {
  return 48 <= t15 && t15 <= 57 || 65 <= t15 && t15 <= 70 || 97 <= t15 && t15 <= 102;
}
_(lw, "isHexCode");
function cw(t15) {
  return 48 <= t15 && t15 <= 55;
}
_(cw, "isOctCode");
function hw(t15) {
  return 48 <= t15 && t15 <= 57;
}
_(hw, "isDecCode");
function uw(t15) {
  if (t15 === null) return false;
  var e = t15.length, r = 0, n = false, i;
  if (!e) return false;
  if (i = t15[r], (i === "-" || i === "+") && (i = t15[++r]), i === "0") {
    if (r + 1 === e) return true;
    if (i = t15[++r], i === "b") {
      for (r++; r < e; r++)
        if (i = t15[r], i !== "_") {
          if (i !== "0" && i !== "1") return false;
          n = true;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < e; r++)
        if (i = t15[r], i !== "_") {
          if (!lw(t15.charCodeAt(r))) return false;
          n = true;
        }
      return n && i !== "_";
    }
    if (i === "o") {
      for (r++; r < e; r++)
        if (i = t15[r], i !== "_") {
          if (!cw(t15.charCodeAt(r))) return false;
          n = true;
        }
      return n && i !== "_";
    }
  }
  if (i === "_") return false;
  for (; r < e; r++)
    if (i = t15[r], i !== "_") {
      if (!hw(t15.charCodeAt(r)))
        return false;
      n = true;
    }
  return !(!n || i === "_");
}
_(uw, "resolveYamlInteger");
function dw(t15) {
  var e = t15, r = 1, n;
  if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (r = -1), e = e.slice(1), n = e[0]), e === "0") return 0;
  if (n === "0") {
    if (e[1] === "b") return r * parseInt(e.slice(2), 2);
    if (e[1] === "x") return r * parseInt(e.slice(2), 16);
    if (e[1] === "o") return r * parseInt(e.slice(2), 8);
  }
  return r * parseInt(e, 10);
}
_(dw, "constructYamlInteger");
function pw(t15) {
  return Object.prototype.toString.call(t15) === "[object Number]" && t15 % 1 === 0 && !Xe.isNegativeZero(t15);
}
_(pw, "isInteger");
var uP = new gr("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: uw,
  construct: dw,
  predicate: pw,
  represent: {
    binary: _(function(t15) {
      return t15 >= 0 ? "0b" + t15.toString(2) : "-0b" + t15.toString(2).slice(1);
    }, "binary"),
    octal: _(function(t15) {
      return t15 >= 0 ? "0o" + t15.toString(8) : "-0o" + t15.toString(8).slice(1);
    }, "octal"),
    decimal: _(function(t15) {
      return t15.toString(10);
    }, "decimal"),
    /* eslint-disable max-len */
    hexadecimal: _(function(t15) {
      return t15 >= 0 ? "0x" + t15.toString(16).toUpperCase() : "-0x" + t15.toString(16).toUpperCase().slice(1);
    }, "hexadecimal")
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var dP = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function fw(t15) {
  return !(t15 === null || !dP.test(t15) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t15[t15.length - 1] === "_");
}
_(fw, "resolveYamlFloat");
function mw(t15) {
  var e, r;
  return e = t15.replace(/_/g, "").toLowerCase(), r = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : r * parseFloat(e, 10);
}
_(mw, "constructYamlFloat");
var pP = /^[-+]?[0-9]+e/;
function gw(t15, e) {
  var r;
  if (isNaN(t15))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t15)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t15)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Xe.isNegativeZero(t15))
    return "-0.0";
  return r = t15.toString(10), pP.test(r) ? r.replace("e", ".e") : r;
}
_(gw, "representYamlFloat");
function yw(t15) {
  return Object.prototype.toString.call(t15) === "[object Number]" && (t15 % 1 !== 0 || Xe.isNegativeZero(t15));
}
_(yw, "isFloat");
var fP = new gr("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: fw,
  construct: mw,
  predicate: yw,
  represent: gw,
  defaultStyle: "lowercase"
});
var bw = lP.extend({
  implicit: [
    cP,
    hP,
    uP,
    fP
  ]
});
var mP = bw;
var xw = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var ww = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function kw(t15) {
  return t15 === null ? false : xw.exec(t15) !== null || ww.exec(t15) !== null;
}
_(kw, "resolveYamlTimestamp");
function vw(t15) {
  var e, r, n, i, s, a, o, l = 0, c = null, h, p, m;
  if (e = xw.exec(t15), e === null && (e = ww.exec(t15)), e === null) throw new Error("Date resolve error");
  if (r = +e[1], n = +e[2] - 1, i = +e[3], !e[4])
    return new Date(Date.UTC(r, n, i));
  if (s = +e[4], a = +e[5], o = +e[6], e[7]) {
    for (l = e[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return e[9] && (h = +e[10], p = +(e[11] || 0), c = (h * 60 + p) * 6e4, e[9] === "-" && (c = -c)), m = new Date(Date.UTC(r, n, i, s, a, o, l)), c && m.setTime(m.getTime() - c), m;
}
_(vw, "constructYamlTimestamp");
function Cw(t15) {
  return t15.toISOString();
}
_(Cw, "representYamlTimestamp");
var gP = new gr("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: kw,
  construct: vw,
  instanceOf: Date,
  represent: Cw
});
function _w(t15) {
  return t15 === "<<" || t15 === null;
}
_(_w, "resolveYamlMerge");
var yP = new gr("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: _w
});
var Lm = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function Sw(t15) {
  if (t15 === null) return false;
  var e, r, n = 0, i = t15.length, s = Lm;
  for (r = 0; r < i; r++)
    if (e = s.indexOf(t15.charAt(r)), !(e > 64)) {
      if (e < 0) return false;
      n += 6;
    }
  return n % 8 === 0;
}
_(Sw, "resolveYamlBinary");
function Aw(t15) {
  var e, r, n = t15.replace(/[\r\n=]/g, ""), i = n.length, s = Lm, a = 0, o = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (o.push(a >> 16 & 255), o.push(a >> 8 & 255), o.push(a & 255)), a = a << 6 | s.indexOf(n.charAt(e));
  return r = i % 4 * 6, r === 0 ? (o.push(a >> 16 & 255), o.push(a >> 8 & 255), o.push(a & 255)) : r === 18 ? (o.push(a >> 10 & 255), o.push(a >> 2 & 255)) : r === 12 && o.push(a >> 4 & 255), new Uint8Array(o);
}
_(Aw, "constructYamlBinary");
function Tw(t15) {
  var e = "", r = 0, n, i, s = t15.length, a = Lm;
  for (n = 0; n < s; n++)
    n % 3 === 0 && n && (e += a[r >> 18 & 63], e += a[r >> 12 & 63], e += a[r >> 6 & 63], e += a[r & 63]), r = (r << 8) + t15[n];
  return i = s % 3, i === 0 ? (e += a[r >> 18 & 63], e += a[r >> 12 & 63], e += a[r >> 6 & 63], e += a[r & 63]) : i === 2 ? (e += a[r >> 10 & 63], e += a[r >> 4 & 63], e += a[r << 2 & 63], e += a[64]) : i === 1 && (e += a[r >> 2 & 63], e += a[r << 4 & 63], e += a[64], e += a[64]), e;
}
_(Tw, "representYamlBinary");
function $w(t15) {
  return Object.prototype.toString.call(t15) === "[object Uint8Array]";
}
_($w, "isBinary");
var bP = new gr("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: Sw,
  construct: Aw,
  predicate: $w,
  represent: Tw
});
var xP = Object.prototype.hasOwnProperty;
var wP = Object.prototype.toString;
function Ew(t15) {
  if (t15 === null) return true;
  var e = [], r, n, i, s, a, o = t15;
  for (r = 0, n = o.length; r < n; r += 1) {
    if (i = o[r], a = false, wP.call(i) !== "[object Object]") return false;
    for (s in i)
      if (xP.call(i, s))
        if (!a) a = true;
        else return false;
    if (!a) return false;
    if (e.indexOf(s) === -1) e.push(s);
    else return false;
  }
  return true;
}
_(Ew, "resolveYamlOmap");
function Mw(t15) {
  return t15 !== null ? t15 : [];
}
_(Mw, "constructYamlOmap");
var kP = new gr("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: Ew,
  construct: Mw
});
var vP = Object.prototype.toString;
function Bw(t15) {
  if (t15 === null) return true;
  var e, r, n, i, s, a = t15;
  for (s = new Array(a.length), e = 0, r = a.length; e < r; e += 1) {
    if (n = a[e], vP.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1)) return false;
    s[e] = [i[0], n[i[0]]];
  }
  return true;
}
_(Bw, "resolveYamlPairs");
function Lw(t15) {
  if (t15 === null) return [];
  var e, r, n, i, s, a = t15;
  for (s = new Array(a.length), e = 0, r = a.length; e < r; e += 1)
    n = a[e], i = Object.keys(n), s[e] = [i[0], n[i[0]]];
  return s;
}
_(Lw, "constructYamlPairs");
var CP = new gr("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: Bw,
  construct: Lw
});
var _P = Object.prototype.hasOwnProperty;
function Dw(t15) {
  if (t15 === null) return true;
  var e, r = t15;
  for (e in r)
    if (_P.call(r, e) && r[e] !== null)
      return false;
  return true;
}
_(Dw, "resolveYamlSet");
function Fw(t15) {
  return t15 !== null ? t15 : {};
}
_(Fw, "constructYamlSet");
var SP = new gr("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: Dw,
  construct: Fw
});
var Nw = mP.extend({
  implicit: [
    gP,
    yP
  ],
  explicit: [
    bP,
    kP,
    CP,
    SP
  ]
});
var ls = Object.prototype.hasOwnProperty;
var b0 = 1;
var Iw = 2;
var Ow = 3;
var x0 = 4;
var xp = 1;
var AP = 2;
var Rb = 3;
var TP = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var $P = /[\x85\u2028\u2029]/;
var EP = /[,\[\]\{\}]/;
var zw = /^(?:!|!!|![a-z\-]+!)$/i;
var qw = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function Lf(t15) {
  return Object.prototype.toString.call(t15);
}
_(Lf, "_class");
function _n(t15) {
  return t15 === 10 || t15 === 13;
}
_(_n, "is_EOL");
function as(t15) {
  return t15 === 9 || t15 === 32;
}
_(as, "is_WHITE_SPACE");
function Sr(t15) {
  return t15 === 9 || t15 === 32 || t15 === 10 || t15 === 13;
}
_(Sr, "is_WS_OR_EOL");
function qs(t15) {
  return t15 === 44 || t15 === 91 || t15 === 93 || t15 === 123 || t15 === 125;
}
_(qs, "is_FLOW_INDICATOR");
function Rw(t15) {
  var e;
  return 48 <= t15 && t15 <= 57 ? t15 - 48 : (e = t15 | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
_(Rw, "fromHexCode");
function Pw(t15) {
  return t15 === 120 ? 2 : t15 === 117 ? 4 : t15 === 85 ? 8 : 0;
}
_(Pw, "escapedHexLen");
function jw(t15) {
  return 48 <= t15 && t15 <= 57 ? t15 - 48 : -1;
}
_(jw, "fromDecimalCode");
function Df(t15) {
  return t15 === 48 ? "\0" : t15 === 97 ? "\x07" : t15 === 98 ? "\b" : t15 === 116 || t15 === 9 ? "	" : t15 === 110 ? `
` : t15 === 118 ? "\v" : t15 === 102 ? "\f" : t15 === 114 ? "\r" : t15 === 101 ? "\x1B" : t15 === 32 ? " " : t15 === 34 ? '"' : t15 === 47 ? "/" : t15 === 92 ? "\\" : t15 === 78 ? "" : t15 === 95 ? " " : t15 === 76 ? "\u2028" : t15 === 80 ? "\u2029" : "";
}
_(Df, "simpleEscapeSequence");
function Ww(t15) {
  return t15 <= 65535 ? String.fromCharCode(t15) : String.fromCharCode(
    (t15 - 65536 >> 10) + 55296,
    (t15 - 65536 & 1023) + 56320
  );
}
_(Ww, "charFromCodepoint");
var Hw = new Array(256);
var Uw = new Array(256);
for (Ts = 0; Ts < 256; Ts++)
  Hw[Ts] = Df(Ts) ? 1 : 0, Uw[Ts] = Df(Ts);
var Ts;
function Vw(t15, e) {
  this.input = t15, this.filename = e.filename || null, this.schema = e.schema || Nw, this.onWarning = e.onWarning || null, this.legacy = e.legacy || false, this.json = e.json || false, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t15.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
_(Vw, "State$1");
function Dm(t15, e) {
  var r = {
    name: t15.filename,
    buffer: t15.input.slice(0, -1),
    // omit trailing \0
    position: t15.position,
    line: t15.line,
    column: t15.position - t15.lineStart
  };
  return r.snippet = eP(r), new Pr(e, r);
}
_(Dm, "generateError");
function Nt(t15, e) {
  throw Dm(t15, e);
}
_(Nt, "throwError");
function Ol(t15, e) {
  t15.onWarning && t15.onWarning.call(null, Dm(t15, e));
}
_(Ol, "throwWarning");
var Pb = {
  YAML: _(function(t15, e, r) {
    var n, i, s;
    t15.version !== null && Nt(t15, "duplication of %YAML directive"), r.length !== 1 && Nt(t15, "YAML directive accepts exactly one argument"), n = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), n === null && Nt(t15, "ill-formed argument of the YAML directive"), i = parseInt(n[1], 10), s = parseInt(n[2], 10), i !== 1 && Nt(t15, "unacceptable YAML version of the document"), t15.version = r[0], t15.checkLineBreaks = s < 2, s !== 1 && s !== 2 && Ol(t15, "unsupported YAML version of the document");
  }, "handleYamlDirective"),
  TAG: _(function(t15, e, r) {
    var n, i;
    r.length !== 2 && Nt(t15, "TAG directive accepts exactly two arguments"), n = r[0], i = r[1], zw.test(n) || Nt(t15, "ill-formed tag handle (first argument) of the TAG directive"), ls.call(t15.tagMap, n) && Nt(t15, 'there is a previously declared suffix for "' + n + '" tag handle'), qw.test(i) || Nt(t15, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      i = decodeURIComponent(i);
    } catch {
      Nt(t15, "tag prefix is malformed: " + i);
    }
    t15.tagMap[n] = i;
  }, "handleTagDirective")
};
function $i(t15, e, r, n) {
  var i, s, a, o;
  if (e < r) {
    if (o = t15.input.slice(e, r), n)
      for (i = 0, s = o.length; i < s; i += 1)
        a = o.charCodeAt(i), a === 9 || 32 <= a && a <= 1114111 || Nt(t15, "expected valid JSON character");
    else TP.test(o) && Nt(t15, "the stream contains non-printable characters");
    t15.result += o;
  }
}
_($i, "captureSegment");
function Ff(t15, e, r, n) {
  var i, s, a, o;
  for (Xe.isObject(r) || Nt(t15, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), a = 0, o = i.length; a < o; a += 1)
    s = i[a], ls.call(e, s) || (e[s] = r[s], n[s] = true);
}
_(Ff, "mergeMappings");
function Rs(t15, e, r, n, i, s, a, o, l) {
  var c, h;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), c = 0, h = i.length; c < h; c += 1)
      Array.isArray(i[c]) && Nt(t15, "nested arrays are not supported inside keys"), typeof i == "object" && Lf(i[c]) === "[object Object]" && (i[c] = "[object Object]");
  if (typeof i == "object" && Lf(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (c = 0, h = s.length; c < h; c += 1)
        Ff(t15, e, s[c], r);
    else
      Ff(t15, e, s, r);
  else
    !t15.json && !ls.call(r, i) && ls.call(e, i) && (t15.line = a || t15.line, t15.lineStart = o || t15.lineStart, t15.position = l || t15.position, Nt(t15, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: s
    }) : e[i] = s, delete r[i];
  return e;
}
_(Rs, "storeMappingPair");
function Cu(t15) {
  var e;
  e = t15.input.charCodeAt(t15.position), e === 10 ? t15.position++ : e === 13 ? (t15.position++, t15.input.charCodeAt(t15.position) === 10 && t15.position++) : Nt(t15, "a line break is expected"), t15.line += 1, t15.lineStart = t15.position, t15.firstTabInLine = -1;
}
_(Cu, "readLineBreak");
function Pe(t15, e, r) {
  for (var n = 0, i = t15.input.charCodeAt(t15.position); i !== 0; ) {
    for (; as(i); )
      i === 9 && t15.firstTabInLine === -1 && (t15.firstTabInLine = t15.position), i = t15.input.charCodeAt(++t15.position);
    if (e && i === 35)
      do
        i = t15.input.charCodeAt(++t15.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (_n(i))
      for (Cu(t15), i = t15.input.charCodeAt(t15.position), n++, t15.lineIndent = 0; i === 32; )
        t15.lineIndent++, i = t15.input.charCodeAt(++t15.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && t15.lineIndent < r && Ol(t15, "deficient indentation"), n;
}
_(Pe, "skipSeparationSpace");
function hc(t15) {
  var e = t15.position, r;
  return r = t15.input.charCodeAt(e), !!((r === 45 || r === 46) && r === t15.input.charCodeAt(e + 1) && r === t15.input.charCodeAt(e + 2) && (e += 3, r = t15.input.charCodeAt(e), r === 0 || Sr(r)));
}
_(hc, "testDocumentSeparator");
function _u(t15, e) {
  e === 1 ? t15.result += " " : e > 1 && (t15.result += Xe.repeat(`
`, e - 1));
}
_(_u, "writeFoldedLines");
function Gw(t15, e, r) {
  var n, i, s, a, o, l, c, h, p = t15.kind, m = t15.result, g;
  if (g = t15.input.charCodeAt(t15.position), Sr(g) || qs(g) || g === 35 || g === 38 || g === 42 || g === 33 || g === 124 || g === 62 || g === 39 || g === 34 || g === 37 || g === 64 || g === 96 || (g === 63 || g === 45) && (i = t15.input.charCodeAt(t15.position + 1), Sr(i) || r && qs(i)))
    return false;
  for (t15.kind = "scalar", t15.result = "", s = a = t15.position, o = false; g !== 0; ) {
    if (g === 58) {
      if (i = t15.input.charCodeAt(t15.position + 1), Sr(i) || r && qs(i))
        break;
    } else if (g === 35) {
      if (n = t15.input.charCodeAt(t15.position - 1), Sr(n))
        break;
    } else {
      if (t15.position === t15.lineStart && hc(t15) || r && qs(g))
        break;
      if (_n(g))
        if (l = t15.line, c = t15.lineStart, h = t15.lineIndent, Pe(t15, false, -1), t15.lineIndent >= e) {
          o = true, g = t15.input.charCodeAt(t15.position);
          continue;
        } else {
          t15.position = a, t15.line = l, t15.lineStart = c, t15.lineIndent = h;
          break;
        }
    }
    o && ($i(t15, s, a, false), _u(t15, t15.line - l), s = a = t15.position, o = false), as(g) || (a = t15.position + 1), g = t15.input.charCodeAt(++t15.position);
  }
  return $i(t15, s, a, false), t15.result ? true : (t15.kind = p, t15.result = m, false);
}
_(Gw, "readPlainScalar");
function Xw(t15, e) {
  var r, n, i;
  if (r = t15.input.charCodeAt(t15.position), r !== 39)
    return false;
  for (t15.kind = "scalar", t15.result = "", t15.position++, n = i = t15.position; (r = t15.input.charCodeAt(t15.position)) !== 0; )
    if (r === 39)
      if ($i(t15, n, t15.position, true), r = t15.input.charCodeAt(++t15.position), r === 39)
        n = t15.position, t15.position++, i = t15.position;
      else
        return true;
    else _n(r) ? ($i(t15, n, i, true), _u(t15, Pe(t15, false, e)), n = i = t15.position) : t15.position === t15.lineStart && hc(t15) ? Nt(t15, "unexpected end of the document within a single quoted scalar") : (t15.position++, i = t15.position);
  Nt(t15, "unexpected end of the stream within a single quoted scalar");
}
_(Xw, "readSingleQuotedScalar");
function Yw(t15, e) {
  var r, n, i, s, a, o;
  if (o = t15.input.charCodeAt(t15.position), o !== 34)
    return false;
  for (t15.kind = "scalar", t15.result = "", t15.position++, r = n = t15.position; (o = t15.input.charCodeAt(t15.position)) !== 0; ) {
    if (o === 34)
      return $i(t15, r, t15.position, true), t15.position++, true;
    if (o === 92) {
      if ($i(t15, r, t15.position, true), o = t15.input.charCodeAt(++t15.position), _n(o))
        Pe(t15, false, e);
      else if (o < 256 && Hw[o])
        t15.result += Uw[o], t15.position++;
      else if ((a = Pw(o)) > 0) {
        for (i = a, s = 0; i > 0; i--)
          o = t15.input.charCodeAt(++t15.position), (a = Rw(o)) >= 0 ? s = (s << 4) + a : Nt(t15, "expected hexadecimal character");
        t15.result += Ww(s), t15.position++;
      } else
        Nt(t15, "unknown escape sequence");
      r = n = t15.position;
    } else _n(o) ? ($i(t15, r, n, true), _u(t15, Pe(t15, false, e)), r = n = t15.position) : t15.position === t15.lineStart && hc(t15) ? Nt(t15, "unexpected end of the document within a double quoted scalar") : (t15.position++, n = t15.position);
  }
  Nt(t15, "unexpected end of the stream within a double quoted scalar");
}
_(Yw, "readDoubleQuotedScalar");
function Kw(t15, e) {
  var r = true, n, i, s, a = t15.tag, o, l = t15.anchor, c, h, p, m, g, y = /* @__PURE__ */ Object.create(null), x, k, C, A;
  if (A = t15.input.charCodeAt(t15.position), A === 91)
    h = 93, g = false, o = [];
  else if (A === 123)
    h = 125, g = true, o = {};
  else
    return false;
  for (t15.anchor !== null && (t15.anchorMap[t15.anchor] = o), A = t15.input.charCodeAt(++t15.position); A !== 0; ) {
    if (Pe(t15, true, e), A = t15.input.charCodeAt(t15.position), A === h)
      return t15.position++, t15.tag = a, t15.anchor = l, t15.kind = g ? "mapping" : "sequence", t15.result = o, true;
    r ? A === 44 && Nt(t15, "expected the node content, but found ','") : Nt(t15, "missed comma between flow collection entries"), k = x = C = null, p = m = false, A === 63 && (c = t15.input.charCodeAt(t15.position + 1), Sr(c) && (p = m = true, t15.position++, Pe(t15, true, e))), n = t15.line, i = t15.lineStart, s = t15.position, Js(t15, e, b0, false, true), k = t15.tag, x = t15.result, Pe(t15, true, e), A = t15.input.charCodeAt(t15.position), (m || t15.line === n) && A === 58 && (p = true, A = t15.input.charCodeAt(++t15.position), Pe(t15, true, e), Js(t15, e, b0, false, true), C = t15.result), g ? Rs(t15, o, y, k, x, C, n, i, s) : p ? o.push(Rs(t15, null, y, k, x, C, n, i, s)) : o.push(x), Pe(t15, true, e), A = t15.input.charCodeAt(t15.position), A === 44 ? (r = true, A = t15.input.charCodeAt(++t15.position)) : r = false;
  }
  Nt(t15, "unexpected end of the stream within a flow collection");
}
_(Kw, "readFlowCollection");
function Zw(t15, e) {
  var r, n, i = xp, s = false, a = false, o = e, l = 0, c = false, h, p;
  if (p = t15.input.charCodeAt(t15.position), p === 124)
    n = false;
  else if (p === 62)
    n = true;
  else
    return false;
  for (t15.kind = "scalar", t15.result = ""; p !== 0; )
    if (p = t15.input.charCodeAt(++t15.position), p === 43 || p === 45)
      xp === i ? i = p === 43 ? Rb : AP : Nt(t15, "repeat of a chomping mode identifier");
    else if ((h = jw(p)) >= 0)
      h === 0 ? Nt(t15, "bad explicit indentation width of a block scalar; it cannot be less than one") : a ? Nt(t15, "repeat of an indentation width identifier") : (o = e + h - 1, a = true);
    else
      break;
  if (as(p)) {
    do
      p = t15.input.charCodeAt(++t15.position);
    while (as(p));
    if (p === 35)
      do
        p = t15.input.charCodeAt(++t15.position);
      while (!_n(p) && p !== 0);
  }
  for (; p !== 0; ) {
    for (Cu(t15), t15.lineIndent = 0, p = t15.input.charCodeAt(t15.position); (!a || t15.lineIndent < o) && p === 32; )
      t15.lineIndent++, p = t15.input.charCodeAt(++t15.position);
    if (!a && t15.lineIndent > o && (o = t15.lineIndent), _n(p)) {
      l++;
      continue;
    }
    if (t15.lineIndent < o) {
      i === Rb ? t15.result += Xe.repeat(`
`, s ? 1 + l : l) : i === xp && s && (t15.result += `
`);
      break;
    }
    for (n ? as(p) ? (c = true, t15.result += Xe.repeat(`
`, s ? 1 + l : l)) : c ? (c = false, t15.result += Xe.repeat(`
`, l + 1)) : l === 0 ? s && (t15.result += " ") : t15.result += Xe.repeat(`
`, l) : t15.result += Xe.repeat(`
`, s ? 1 + l : l), s = true, a = true, l = 0, r = t15.position; !_n(p) && p !== 0; )
      p = t15.input.charCodeAt(++t15.position);
    $i(t15, r, t15.position, false);
  }
  return true;
}
_(Zw, "readBlockScalar");
function Nf(t15, e) {
  var r, n = t15.tag, i = t15.anchor, s = [], a, o = false, l;
  if (t15.firstTabInLine !== -1) return false;
  for (t15.anchor !== null && (t15.anchorMap[t15.anchor] = s), l = t15.input.charCodeAt(t15.position); l !== 0 && (t15.firstTabInLine !== -1 && (t15.position = t15.firstTabInLine, Nt(t15, "tab characters must not be used in indentation")), !(l !== 45 || (a = t15.input.charCodeAt(t15.position + 1), !Sr(a)))); ) {
    if (o = true, t15.position++, Pe(t15, true, -1) && t15.lineIndent <= e) {
      s.push(null), l = t15.input.charCodeAt(t15.position);
      continue;
    }
    if (r = t15.line, Js(t15, e, Ow, false, true), s.push(t15.result), Pe(t15, true, -1), l = t15.input.charCodeAt(t15.position), (t15.line === r || t15.lineIndent > e) && l !== 0)
      Nt(t15, "bad indentation of a sequence entry");
    else if (t15.lineIndent < e)
      break;
  }
  return o ? (t15.tag = n, t15.anchor = i, t15.kind = "sequence", t15.result = s, true) : false;
}
_(Nf, "readBlockSequence");
function Jw(t15, e, r) {
  var n, i, s, a, o, l, c = t15.tag, h = t15.anchor, p = {}, m = /* @__PURE__ */ Object.create(null), g = null, y = null, x = null, k = false, C = false, A;
  if (t15.firstTabInLine !== -1) return false;
  for (t15.anchor !== null && (t15.anchorMap[t15.anchor] = p), A = t15.input.charCodeAt(t15.position); A !== 0; ) {
    if (!k && t15.firstTabInLine !== -1 && (t15.position = t15.firstTabInLine, Nt(t15, "tab characters must not be used in indentation")), n = t15.input.charCodeAt(t15.position + 1), s = t15.line, (A === 63 || A === 58) && Sr(n))
      A === 63 ? (k && (Rs(t15, p, m, g, y, null, a, o, l), g = y = x = null), C = true, k = true, i = true) : k ? (k = false, i = true) : Nt(t15, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t15.position += 1, A = n;
    else {
      if (a = t15.line, o = t15.lineStart, l = t15.position, !Js(t15, r, Iw, false, true))
        break;
      if (t15.line === s) {
        for (A = t15.input.charCodeAt(t15.position); as(A); )
          A = t15.input.charCodeAt(++t15.position);
        if (A === 58)
          A = t15.input.charCodeAt(++t15.position), Sr(A) || Nt(t15, "a whitespace character is expected after the key-value separator within a block mapping"), k && (Rs(t15, p, m, g, y, null, a, o, l), g = y = x = null), C = true, k = false, i = false, g = t15.tag, y = t15.result;
        else if (C)
          Nt(t15, "can not read an implicit mapping pair; a colon is missed");
        else
          return t15.tag = c, t15.anchor = h, true;
      } else if (C)
        Nt(t15, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t15.tag = c, t15.anchor = h, true;
    }
    if ((t15.line === s || t15.lineIndent > e) && (k && (a = t15.line, o = t15.lineStart, l = t15.position), Js(t15, e, x0, true, i) && (k ? y = t15.result : x = t15.result), k || (Rs(t15, p, m, g, y, x, a, o, l), g = y = x = null), Pe(t15, true, -1), A = t15.input.charCodeAt(t15.position)), (t15.line === s || t15.lineIndent > e) && A !== 0)
      Nt(t15, "bad indentation of a mapping entry");
    else if (t15.lineIndent < e)
      break;
  }
  return k && Rs(t15, p, m, g, y, null, a, o, l), C && (t15.tag = c, t15.anchor = h, t15.kind = "mapping", t15.result = p), C;
}
_(Jw, "readBlockMapping");
function Qw(t15) {
  var e, r = false, n = false, i, s, a;
  if (a = t15.input.charCodeAt(t15.position), a !== 33) return false;
  if (t15.tag !== null && Nt(t15, "duplication of a tag property"), a = t15.input.charCodeAt(++t15.position), a === 60 ? (r = true, a = t15.input.charCodeAt(++t15.position)) : a === 33 ? (n = true, i = "!!", a = t15.input.charCodeAt(++t15.position)) : i = "!", e = t15.position, r) {
    do
      a = t15.input.charCodeAt(++t15.position);
    while (a !== 0 && a !== 62);
    t15.position < t15.length ? (s = t15.input.slice(e, t15.position), a = t15.input.charCodeAt(++t15.position)) : Nt(t15, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; a !== 0 && !Sr(a); )
      a === 33 && (n ? Nt(t15, "tag suffix cannot contain exclamation marks") : (i = t15.input.slice(e - 1, t15.position + 1), zw.test(i) || Nt(t15, "named tag handle cannot contain such characters"), n = true, e = t15.position + 1)), a = t15.input.charCodeAt(++t15.position);
    s = t15.input.slice(e, t15.position), EP.test(s) && Nt(t15, "tag suffix cannot contain flow indicator characters");
  }
  s && !qw.test(s) && Nt(t15, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    Nt(t15, "tag name is malformed: " + s);
  }
  return r ? t15.tag = s : ls.call(t15.tagMap, i) ? t15.tag = t15.tagMap[i] + s : i === "!" ? t15.tag = "!" + s : i === "!!" ? t15.tag = "tag:yaml.org,2002:" + s : Nt(t15, 'undeclared tag handle "' + i + '"'), true;
}
_(Qw, "readTagProperty");
function t7(t15) {
  var e, r;
  if (r = t15.input.charCodeAt(t15.position), r !== 38) return false;
  for (t15.anchor !== null && Nt(t15, "duplication of an anchor property"), r = t15.input.charCodeAt(++t15.position), e = t15.position; r !== 0 && !Sr(r) && !qs(r); )
    r = t15.input.charCodeAt(++t15.position);
  return t15.position === e && Nt(t15, "name of an anchor node must contain at least one character"), t15.anchor = t15.input.slice(e, t15.position), true;
}
_(t7, "readAnchorProperty");
function e7(t15) {
  var e, r, n;
  if (n = t15.input.charCodeAt(t15.position), n !== 42) return false;
  for (n = t15.input.charCodeAt(++t15.position), e = t15.position; n !== 0 && !Sr(n) && !qs(n); )
    n = t15.input.charCodeAt(++t15.position);
  return t15.position === e && Nt(t15, "name of an alias node must contain at least one character"), r = t15.input.slice(e, t15.position), ls.call(t15.anchorMap, r) || Nt(t15, 'unidentified alias "' + r + '"'), t15.result = t15.anchorMap[r], Pe(t15, true, -1), true;
}
_(e7, "readAlias");
function Js(t15, e, r, n, i) {
  var s, a, o, l = 1, c = false, h = false, p, m, g, y, x, k;
  if (t15.listener !== null && t15.listener("open", t15), t15.tag = null, t15.anchor = null, t15.kind = null, t15.result = null, s = a = o = x0 === r || Ow === r, n && Pe(t15, true, -1) && (c = true, t15.lineIndent > e ? l = 1 : t15.lineIndent === e ? l = 0 : t15.lineIndent < e && (l = -1)), l === 1)
    for (; Qw(t15) || t7(t15); )
      Pe(t15, true, -1) ? (c = true, o = s, t15.lineIndent > e ? l = 1 : t15.lineIndent === e ? l = 0 : t15.lineIndent < e && (l = -1)) : o = false;
  if (o && (o = c || i), (l === 1 || x0 === r) && (b0 === r || Iw === r ? x = e : x = e + 1, k = t15.position - t15.lineStart, l === 1 ? o && (Nf(t15, k) || Jw(t15, k, x)) || Kw(t15, x) ? h = true : (a && Zw(t15, x) || Xw(t15, x) || Yw(t15, x) ? h = true : e7(t15) ? (h = true, (t15.tag !== null || t15.anchor !== null) && Nt(t15, "alias node should not have any properties")) : Gw(t15, x, b0 === r) && (h = true, t15.tag === null && (t15.tag = "?")), t15.anchor !== null && (t15.anchorMap[t15.anchor] = t15.result)) : l === 0 && (h = o && Nf(t15, k))), t15.tag === null)
    t15.anchor !== null && (t15.anchorMap[t15.anchor] = t15.result);
  else if (t15.tag === "?") {
    for (t15.result !== null && t15.kind !== "scalar" && Nt(t15, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t15.kind + '"'), p = 0, m = t15.implicitTypes.length; p < m; p += 1)
      if (y = t15.implicitTypes[p], y.resolve(t15.result)) {
        t15.result = y.construct(t15.result), t15.tag = y.tag, t15.anchor !== null && (t15.anchorMap[t15.anchor] = t15.result);
        break;
      }
  } else if (t15.tag !== "!") {
    if (ls.call(t15.typeMap[t15.kind || "fallback"], t15.tag))
      y = t15.typeMap[t15.kind || "fallback"][t15.tag];
    else
      for (y = null, g = t15.typeMap.multi[t15.kind || "fallback"], p = 0, m = g.length; p < m; p += 1)
        if (t15.tag.slice(0, g[p].tag.length) === g[p].tag) {
          y = g[p];
          break;
        }
    y || Nt(t15, "unknown tag !<" + t15.tag + ">"), t15.result !== null && y.kind !== t15.kind && Nt(t15, "unacceptable node kind for !<" + t15.tag + '> tag; it should be "' + y.kind + '", not "' + t15.kind + '"'), y.resolve(t15.result, t15.tag) ? (t15.result = y.construct(t15.result, t15.tag), t15.anchor !== null && (t15.anchorMap[t15.anchor] = t15.result)) : Nt(t15, "cannot resolve a node with !<" + t15.tag + "> explicit tag");
  }
  return t15.listener !== null && t15.listener("close", t15), t15.tag !== null || t15.anchor !== null || h;
}
_(Js, "composeNode");
function r7(t15) {
  var e = t15.position, r, n, i, s = false, a;
  for (t15.version = null, t15.checkLineBreaks = t15.legacy, t15.tagMap = /* @__PURE__ */ Object.create(null), t15.anchorMap = /* @__PURE__ */ Object.create(null); (a = t15.input.charCodeAt(t15.position)) !== 0 && (Pe(t15, true, -1), a = t15.input.charCodeAt(t15.position), !(t15.lineIndent > 0 || a !== 37)); ) {
    for (s = true, a = t15.input.charCodeAt(++t15.position), r = t15.position; a !== 0 && !Sr(a); )
      a = t15.input.charCodeAt(++t15.position);
    for (n = t15.input.slice(r, t15.position), i = [], n.length < 1 && Nt(t15, "directive name must not be less than one character in length"); a !== 0; ) {
      for (; as(a); )
        a = t15.input.charCodeAt(++t15.position);
      if (a === 35) {
        do
          a = t15.input.charCodeAt(++t15.position);
        while (a !== 0 && !_n(a));
        break;
      }
      if (_n(a)) break;
      for (r = t15.position; a !== 0 && !Sr(a); )
        a = t15.input.charCodeAt(++t15.position);
      i.push(t15.input.slice(r, t15.position));
    }
    a !== 0 && Cu(t15), ls.call(Pb, n) ? Pb[n](t15, n, i) : Ol(t15, 'unknown document directive "' + n + '"');
  }
  if (Pe(t15, true, -1), t15.lineIndent === 0 && t15.input.charCodeAt(t15.position) === 45 && t15.input.charCodeAt(t15.position + 1) === 45 && t15.input.charCodeAt(t15.position + 2) === 45 ? (t15.position += 3, Pe(t15, true, -1)) : s && Nt(t15, "directives end mark is expected"), Js(t15, t15.lineIndent - 1, x0, false, true), Pe(t15, true, -1), t15.checkLineBreaks && $P.test(t15.input.slice(e, t15.position)) && Ol(t15, "non-ASCII line breaks are interpreted as content"), t15.documents.push(t15.result), t15.position === t15.lineStart && hc(t15)) {
    t15.input.charCodeAt(t15.position) === 46 && (t15.position += 3, Pe(t15, true, -1));
    return;
  }
  if (t15.position < t15.length - 1)
    Nt(t15, "end of the stream or a document separator is expected");
  else
    return;
}
_(r7, "readDocument");
function Fm(t15, e) {
  t15 = String(t15), e = e || {}, t15.length !== 0 && (t15.charCodeAt(t15.length - 1) !== 10 && t15.charCodeAt(t15.length - 1) !== 13 && (t15 += `
`), t15.charCodeAt(0) === 65279 && (t15 = t15.slice(1)));
  var r = new Vw(t15, e), n = t15.indexOf("\0");
  for (n !== -1 && (r.position = n, Nt(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    r7(r);
  return r.documents;
}
_(Fm, "loadDocuments");
function MP(t15, e, r) {
  e !== null && typeof e == "object" && typeof r > "u" && (r = e, e = null);
  var n = Fm(t15, r);
  if (typeof e != "function")
    return n;
  for (var i = 0, s = n.length; i < s; i += 1)
    e(n[i]);
}
_(MP, "loadAll$1");
function n7(t15, e) {
  var r = Fm(t15, e);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new Pr("expected a single document in the stream, but found more");
  }
}
_(n7, "load$1");
var BP = n7;
var LP = {
  load: BP
};
var i7 = Object.prototype.toString;
var s7 = Object.prototype.hasOwnProperty;
var Nm = 65279;
var DP = 9;
var zl = 10;
var FP = 13;
var NP = 32;
var IP = 33;
var OP = 34;
var If = 35;
var zP = 37;
var qP = 38;
var RP = 39;
var PP = 42;
var a7 = 44;
var jP = 45;
var w0 = 58;
var WP = 61;
var HP = 62;
var UP = 63;
var VP = 64;
var o7 = 91;
var l7 = 93;
var GP = 96;
var c7 = 123;
var XP = 124;
var h7 = 125;
var yr = {};
yr[0] = "\\0";
yr[7] = "\\a";
yr[8] = "\\b";
yr[9] = "\\t";
yr[10] = "\\n";
yr[11] = "\\v";
yr[12] = "\\f";
yr[13] = "\\r";
yr[27] = "\\e";
yr[34] = '\\"';
yr[92] = "\\\\";
yr[133] = "\\N";
yr[160] = "\\_";
yr[8232] = "\\L";
yr[8233] = "\\P";
var YP = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var KP = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function u7(t15, e) {
  var r, n, i, s, a, o, l;
  if (e === null) return {};
  for (r = {}, n = Object.keys(e), i = 0, s = n.length; i < s; i += 1)
    a = n[i], o = String(e[a]), a.slice(0, 2) === "!!" && (a = "tag:yaml.org,2002:" + a.slice(2)), l = t15.compiledTypeMap.fallback[a], l && s7.call(l.styleAliases, o) && (o = l.styleAliases[o]), r[a] = o;
  return r;
}
_(u7, "compileStyleMap");
function d7(t15) {
  var e, r, n;
  if (e = t15.toString(16).toUpperCase(), t15 <= 255)
    r = "x", n = 2;
  else if (t15 <= 65535)
    r = "u", n = 4;
  else if (t15 <= 4294967295)
    r = "U", n = 8;
  else
    throw new Pr("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + Xe.repeat("0", n - e.length) + e;
}
_(d7, "encodeHex");
var ZP = 1;
var ql = 2;
function p7(t15) {
  this.schema = t15.schema || Nw, this.indent = Math.max(1, t15.indent || 2), this.noArrayIndent = t15.noArrayIndent || false, this.skipInvalid = t15.skipInvalid || false, this.flowLevel = Xe.isNothing(t15.flowLevel) ? -1 : t15.flowLevel, this.styleMap = u7(this.schema, t15.styles || null), this.sortKeys = t15.sortKeys || false, this.lineWidth = t15.lineWidth || 80, this.noRefs = t15.noRefs || false, this.noCompatMode = t15.noCompatMode || false, this.condenseFlow = t15.condenseFlow || false, this.quotingType = t15.quotingType === '"' ? ql : ZP, this.forceQuotes = t15.forceQuotes || false, this.replacer = typeof t15.replacer == "function" ? t15.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
_(p7, "State");
function Of(t15, e) {
  for (var r = Xe.repeat(" ", e), n = 0, i = -1, s = "", a, o = t15.length; n < o; )
    i = t15.indexOf(`
`, n), i === -1 ? (a = t15.slice(n), n = o) : (a = t15.slice(n, i + 1), n = i + 1), a.length && a !== `
` && (s += r), s += a;
  return s;
}
_(Of, "indentString");
function k0(t15, e) {
  return `
` + Xe.repeat(" ", t15.indent * e);
}
_(k0, "generateNextLine");
function f7(t15, e) {
  var r, n, i;
  for (r = 0, n = t15.implicitTypes.length; r < n; r += 1)
    if (i = t15.implicitTypes[r], i.resolve(e))
      return true;
  return false;
}
_(f7, "testImplicitResolving");
function Rl(t15) {
  return t15 === NP || t15 === DP;
}
_(Rl, "isWhitespace");
function to(t15) {
  return 32 <= t15 && t15 <= 126 || 161 <= t15 && t15 <= 55295 && t15 !== 8232 && t15 !== 8233 || 57344 <= t15 && t15 <= 65533 && t15 !== Nm || 65536 <= t15 && t15 <= 1114111;
}
_(to, "isPrintable");
function zf(t15) {
  return to(t15) && t15 !== Nm && t15 !== FP && t15 !== zl;
}
_(zf, "isNsCharOrWhitespace");
function qf(t15, e, r) {
  var n = zf(t15), i = n && !Rl(t15);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      n
    ) : n && t15 !== a7 && t15 !== o7 && t15 !== l7 && t15 !== c7 && t15 !== h7) && t15 !== If && !(e === w0 && !i) || zf(e) && !Rl(e) && t15 === If || e === w0 && i
  );
}
_(qf, "isPlainSafe");
function m7(t15) {
  return to(t15) && t15 !== Nm && !Rl(t15) && t15 !== jP && t15 !== UP && t15 !== w0 && t15 !== a7 && t15 !== o7 && t15 !== l7 && t15 !== c7 && t15 !== h7 && t15 !== If && t15 !== qP && t15 !== PP && t15 !== IP && t15 !== XP && t15 !== WP && t15 !== HP && t15 !== RP && t15 !== OP && t15 !== zP && t15 !== VP && t15 !== GP;
}
_(m7, "isPlainSafeFirst");
function g7(t15) {
  return !Rl(t15) && t15 !== w0;
}
_(g7, "isPlainSafeLast");
function Ba(t15, e) {
  var r = t15.charCodeAt(e), n;
  return r >= 55296 && r <= 56319 && e + 1 < t15.length && (n = t15.charCodeAt(e + 1), n >= 56320 && n <= 57343) ? (r - 55296) * 1024 + n - 56320 + 65536 : r;
}
_(Ba, "codePointAt");
function Im(t15) {
  var e = /^\n* /;
  return e.test(t15);
}
_(Im, "needIndentIndicator");
var y7 = 1;
var Rf = 2;
var b7 = 3;
var x7 = 4;
var Sa = 5;
function w7(t15, e, r, n, i, s, a, o) {
  var l, c = 0, h = null, p = false, m = false, g = n !== -1, y = -1, x = m7(Ba(t15, 0)) && g7(Ba(t15, t15.length - 1));
  if (e || a)
    for (l = 0; l < t15.length; c >= 65536 ? l += 2 : l++) {
      if (c = Ba(t15, l), !to(c))
        return Sa;
      x = x && qf(c, h, o), h = c;
    }
  else {
    for (l = 0; l < t15.length; c >= 65536 ? l += 2 : l++) {
      if (c = Ba(t15, l), c === zl)
        p = true, g && (m = m || // Foldable line = too long, and not more-indented.
        l - y - 1 > n && t15[y + 1] !== " ", y = l);
      else if (!to(c))
        return Sa;
      x = x && qf(c, h, o), h = c;
    }
    m = m || g && l - y - 1 > n && t15[y + 1] !== " ";
  }
  return !p && !m ? x && !a && !i(t15) ? y7 : s === ql ? Sa : Rf : r > 9 && Im(t15) ? Sa : a ? s === ql ? Sa : Rf : m ? x7 : b7;
}
_(w7, "chooseScalarStyle");
function k7(t15, e, r, n, i) {
  t15.dump = function() {
    if (e.length === 0)
      return t15.quotingType === ql ? '""' : "''";
    if (!t15.noCompatMode && (YP.indexOf(e) !== -1 || KP.test(e)))
      return t15.quotingType === ql ? '"' + e + '"' : "'" + e + "'";
    var s = t15.indent * Math.max(1, r), a = t15.lineWidth === -1 ? -1 : Math.max(Math.min(t15.lineWidth, 40), t15.lineWidth - s), o = n || t15.flowLevel > -1 && r >= t15.flowLevel;
    function l(c) {
      return f7(t15, c);
    }
    switch (_(l, "testAmbiguity"), w7(
      e,
      o,
      t15.indent,
      a,
      l,
      t15.quotingType,
      t15.forceQuotes && !n,
      i
    )) {
      case y7:
        return e;
      case Rf:
        return "'" + e.replace(/'/g, "''") + "'";
      case b7:
        return "|" + Pf(e, t15.indent) + jf(Of(e, s));
      case x7:
        return ">" + Pf(e, t15.indent) + jf(Of(v7(e, a), s));
      case Sa:
        return '"' + C7(e) + '"';
      default:
        throw new Pr("impossible error: invalid scalar style");
    }
  }();
}
_(k7, "writeScalar");
function Pf(t15, e) {
  var r = Im(t15) ? String(e) : "", n = t15[t15.length - 1] === `
`, i = n && (t15[t15.length - 2] === `
` || t15 === `
`), s = i ? "+" : n ? "" : "-";
  return r + s + `
`;
}
_(Pf, "blockHeader");
function jf(t15) {
  return t15[t15.length - 1] === `
` ? t15.slice(0, -1) : t15;
}
_(jf, "dropEndingNewline");
function v7(t15, e) {
  for (var r = /(\n+)([^\n]*)/g, n = function() {
    var c = t15.indexOf(`
`);
    return c = c !== -1 ? c : t15.length, r.lastIndex = c, Wf(t15.slice(0, c), e);
  }(), i = t15[0] === `
` || t15[0] === " ", s, a; a = r.exec(t15); ) {
    var o = a[1], l = a[2];
    s = l[0] === " ", n += o + (!i && !s && l !== "" ? `
` : "") + Wf(l, e), i = s;
  }
  return n;
}
_(v7, "foldString");
function Wf(t15, e) {
  if (t15 === "" || t15[0] === " ") return t15;
  for (var r = / [^ ]/g, n, i = 0, s, a = 0, o = 0, l = ""; n = r.exec(t15); )
    o = n.index, o - i > e && (s = a > i ? a : o, l += `
` + t15.slice(i, s), i = s + 1), a = o;
  return l += `
`, t15.length - i > e && a > i ? l += t15.slice(i, a) + `
` + t15.slice(a + 1) : l += t15.slice(i), l.slice(1);
}
_(Wf, "foldLine");
function C7(t15) {
  for (var e = "", r = 0, n, i = 0; i < t15.length; r >= 65536 ? i += 2 : i++)
    r = Ba(t15, i), n = yr[r], !n && to(r) ? (e += t15[i], r >= 65536 && (e += t15[i + 1])) : e += n || d7(r);
  return e;
}
_(C7, "escapeString");
function _7(t15, e, r) {
  var n = "", i = t15.tag, s, a, o;
  for (s = 0, a = r.length; s < a; s += 1)
    o = r[s], t15.replacer && (o = t15.replacer.call(r, String(s), o)), (Kn(t15, e, o, false, false) || typeof o > "u" && Kn(t15, e, null, false, false)) && (n !== "" && (n += "," + (t15.condenseFlow ? "" : " ")), n += t15.dump);
  t15.tag = i, t15.dump = "[" + n + "]";
}
_(_7, "writeFlowSequence");
function Hf(t15, e, r, n) {
  var i = "", s = t15.tag, a, o, l;
  for (a = 0, o = r.length; a < o; a += 1)
    l = r[a], t15.replacer && (l = t15.replacer.call(r, String(a), l)), (Kn(t15, e + 1, l, true, true, false, true) || typeof l > "u" && Kn(t15, e + 1, null, true, true, false, true)) && ((!n || i !== "") && (i += k0(t15, e)), t15.dump && zl === t15.dump.charCodeAt(0) ? i += "-" : i += "- ", i += t15.dump);
  t15.tag = s, t15.dump = i || "[]";
}
_(Hf, "writeBlockSequence");
function S7(t15, e, r) {
  var n = "", i = t15.tag, s = Object.keys(r), a, o, l, c, h;
  for (a = 0, o = s.length; a < o; a += 1)
    h = "", n !== "" && (h += ", "), t15.condenseFlow && (h += '"'), l = s[a], c = r[l], t15.replacer && (c = t15.replacer.call(r, l, c)), Kn(t15, e, l, false, false) && (t15.dump.length > 1024 && (h += "? "), h += t15.dump + (t15.condenseFlow ? '"' : "") + ":" + (t15.condenseFlow ? "" : " "), Kn(t15, e, c, false, false) && (h += t15.dump, n += h));
  t15.tag = i, t15.dump = "{" + n + "}";
}
_(S7, "writeFlowMapping");
function A7(t15, e, r, n) {
  var i = "", s = t15.tag, a = Object.keys(r), o, l, c, h, p, m;
  if (t15.sortKeys === true)
    a.sort();
  else if (typeof t15.sortKeys == "function")
    a.sort(t15.sortKeys);
  else if (t15.sortKeys)
    throw new Pr("sortKeys must be a boolean or a function");
  for (o = 0, l = a.length; o < l; o += 1)
    m = "", (!n || i !== "") && (m += k0(t15, e)), c = a[o], h = r[c], t15.replacer && (h = t15.replacer.call(r, c, h)), Kn(t15, e + 1, c, true, true, true) && (p = t15.tag !== null && t15.tag !== "?" || t15.dump && t15.dump.length > 1024, p && (t15.dump && zl === t15.dump.charCodeAt(0) ? m += "?" : m += "? "), m += t15.dump, p && (m += k0(t15, e)), Kn(t15, e + 1, h, true, p) && (t15.dump && zl === t15.dump.charCodeAt(0) ? m += ":" : m += ": ", m += t15.dump, i += m));
  t15.tag = s, t15.dump = i || "{}";
}
_(A7, "writeBlockMapping");
function Uf(t15, e, r) {
  var n, i, s, a, o, l;
  for (i = r ? t15.explicitTypes : t15.implicitTypes, s = 0, a = i.length; s < a; s += 1)
    if (o = i[s], (o.instanceOf || o.predicate) && (!o.instanceOf || typeof e == "object" && e instanceof o.instanceOf) && (!o.predicate || o.predicate(e))) {
      if (r ? o.multi && o.representName ? t15.tag = o.representName(e) : t15.tag = o.tag : t15.tag = "?", o.represent) {
        if (l = t15.styleMap[o.tag] || o.defaultStyle, i7.call(o.represent) === "[object Function]")
          n = o.represent(e, l);
        else if (s7.call(o.represent, l))
          n = o.represent[l](e, l);
        else
          throw new Pr("!<" + o.tag + '> tag resolver accepts not "' + l + '" style');
        t15.dump = n;
      }
      return true;
    }
  return false;
}
_(Uf, "detectType");
function Kn(t15, e, r, n, i, s, a) {
  t15.tag = null, t15.dump = r, Uf(t15, r, false) || Uf(t15, r, true);
  var o = i7.call(t15.dump), l = n, c;
  n && (n = t15.flowLevel < 0 || t15.flowLevel > e);
  var h = o === "[object Object]" || o === "[object Array]", p, m;
  if (h && (p = t15.duplicates.indexOf(r), m = p !== -1), (t15.tag !== null && t15.tag !== "?" || m || t15.indent !== 2 && e > 0) && (i = false), m && t15.usedDuplicates[p])
    t15.dump = "*ref_" + p;
  else {
    if (h && m && !t15.usedDuplicates[p] && (t15.usedDuplicates[p] = true), o === "[object Object]")
      n && Object.keys(t15.dump).length !== 0 ? (A7(t15, e, t15.dump, i), m && (t15.dump = "&ref_" + p + t15.dump)) : (S7(t15, e, t15.dump), m && (t15.dump = "&ref_" + p + " " + t15.dump));
    else if (o === "[object Array]")
      n && t15.dump.length !== 0 ? (t15.noArrayIndent && !a && e > 0 ? Hf(t15, e - 1, t15.dump, i) : Hf(t15, e, t15.dump, i), m && (t15.dump = "&ref_" + p + t15.dump)) : (_7(t15, e, t15.dump), m && (t15.dump = "&ref_" + p + " " + t15.dump));
    else if (o === "[object String]")
      t15.tag !== "?" && k7(t15, t15.dump, e, s, l);
    else {
      if (o === "[object Undefined]" || t15.skipInvalid) return false;
      throw new Pr("unacceptable kind of an object to dump " + o);
    }
    t15.tag !== null && t15.tag !== "?" && (c = encodeURI(
      t15.tag[0] === "!" ? t15.tag.slice(1) : t15.tag
    ).replace(/!/g, "%21"), t15.tag[0] === "!" ? c = "!" + c : c.slice(0, 18) === "tag:yaml.org,2002:" ? c = "!!" + c.slice(18) : c = "!<" + c + ">", t15.dump = c + " " + t15.dump);
  }
  return true;
}
_(Kn, "writeNode");
function T7(t15, e) {
  var r = [], n = [], i, s;
  for (v0(t15, r, n), i = 0, s = n.length; i < s; i += 1)
    e.duplicates.push(r[n[i]]);
  e.usedDuplicates = new Array(s);
}
_(T7, "getDuplicateReferences");
function v0(t15, e, r) {
  var n, i, s;
  if (t15 !== null && typeof t15 == "object")
    if (i = e.indexOf(t15), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (e.push(t15), Array.isArray(t15))
      for (i = 0, s = t15.length; i < s; i += 1)
        v0(t15[i], e, r);
    else
      for (n = Object.keys(t15), i = 0, s = n.length; i < s; i += 1)
        v0(t15[n[i]], e, r);
}
_(v0, "inspectNode");
function JP(t15, e) {
  e = e || {};
  var r = new p7(e);
  r.noRefs || T7(t15, r);
  var n = t15;
  return r.replacer && (n = r.replacer.call({ "": n }, "", n)), Kn(r, 0, n, true, true) ? r.dump + `
` : "";
}
_(JP, "dump$1");
function QP(t15, e) {
  return function() {
    throw new Error("Function yaml." + t15 + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
_(QP, "renamed");
var tj = bw;
var ej = LP.load;
var un = {
  aggregation: 18,
  extension: 18,
  composition: 18,
  dependency: 6,
  lollipop: 13.5,
  arrow_point: 4
};
function al(t15, e) {
  if (t15 === void 0 || e === void 0)
    return { angle: 0, deltaX: 0, deltaY: 0 };
  t15 = Le(t15), e = Le(e);
  const [r, n] = [t15.x, t15.y], [i, s] = [e.x, e.y], a = i - r, o = s - n;
  return { angle: Math.atan(o / a), deltaX: a, deltaY: o };
}
_(al, "calculateDeltaAndAngle");
var Le = _((t15) => Array.isArray(t15) ? { x: t15[0], y: t15[1] } : t15, "pointTransformer");
var rj = _((t15) => ({
  x: _(function(e, r, n) {
    let i = 0;
    const s = Le(n[0]).x < Le(n[n.length - 1]).x ? "left" : "right";
    if (r === 0 && Object.hasOwn(un, t15.arrowTypeStart)) {
      const { angle: g, deltaX: y } = al(n[0], n[1]);
      i = un[t15.arrowTypeStart] * Math.cos(g) * (y >= 0 ? 1 : -1);
    } else if (r === n.length - 1 && Object.hasOwn(un, t15.arrowTypeEnd)) {
      const { angle: g, deltaX: y } = al(
        n[n.length - 1],
        n[n.length - 2]
      );
      i = un[t15.arrowTypeEnd] * Math.cos(g) * (y >= 0 ? 1 : -1);
    }
    const a = Math.abs(
      Le(e).x - Le(n[n.length - 1]).x
    ), o = Math.abs(
      Le(e).y - Le(n[n.length - 1]).y
    ), l = Math.abs(Le(e).x - Le(n[0]).x), c = Math.abs(Le(e).y - Le(n[0]).y), h = un[t15.arrowTypeStart], p = un[t15.arrowTypeEnd], m = 1;
    if (a < p && a > 0 && o < p) {
      let g = p + m - a;
      g *= s === "right" ? -1 : 1, i -= g;
    }
    if (l < h && l > 0 && c < h) {
      let g = h + m - l;
      g *= s === "right" ? -1 : 1, i += g;
    }
    return Le(e).x + i;
  }, "x"),
  y: _(function(e, r, n) {
    let i = 0;
    const s = Le(n[0]).y < Le(n[n.length - 1]).y ? "down" : "up";
    if (r === 0 && Object.hasOwn(un, t15.arrowTypeStart)) {
      const { angle: g, deltaY: y } = al(n[0], n[1]);
      i = un[t15.arrowTypeStart] * Math.abs(Math.sin(g)) * (y >= 0 ? 1 : -1);
    } else if (r === n.length - 1 && Object.hasOwn(un, t15.arrowTypeEnd)) {
      const { angle: g, deltaY: y } = al(
        n[n.length - 1],
        n[n.length - 2]
      );
      i = un[t15.arrowTypeEnd] * Math.abs(Math.sin(g)) * (y >= 0 ? 1 : -1);
    }
    const a = Math.abs(
      Le(e).y - Le(n[n.length - 1]).y
    ), o = Math.abs(
      Le(e).x - Le(n[n.length - 1]).x
    ), l = Math.abs(Le(e).y - Le(n[0]).y), c = Math.abs(Le(e).x - Le(n[0]).x), h = un[t15.arrowTypeStart], p = un[t15.arrowTypeEnd], m = 1;
    if (a < p && a > 0 && o < p) {
      let g = p + m - a;
      g *= s === "up" ? -1 : 1, i -= g;
    }
    if (l < h && l > 0 && c < h) {
      let g = h + m - l;
      g *= s === "up" ? -1 : 1, i += g;
    }
    return Le(e).y + i;
  }, "y")
}), "getLineFunctionsWithOffset");
var Om = _(({
  flowchart: t15
}) => {
  var _a3, _b2;
  const e = ((_a3 = t15 == null ? void 0 : t15.subGraphTitleMargin) == null ? void 0 : _a3.top) ?? 0, r = ((_b2 = t15 == null ? void 0 : t15.subGraphTitleMargin) == null ? void 0 : _b2.bottom) ?? 0, n = e + r;
  return {
    subGraphTitleTopMargin: e,
    subGraphTitleBottomMargin: r,
    subGraphTitleTotalMargin: n
  };
}, "getSubGraphTitleMargins");
var nj = _((t15) => {
  const { handDrawnSeed: e } = fe();
  return {
    fill: t15,
    hachureAngle: 120,
    // angle of hachure,
    hachureGap: 4,
    fillWeight: 2,
    roughness: 0.7,
    stroke: t15,
    seed: e
  };
}, "solidStateFill");
var mo = _((t15) => {
  const e = ij([...t15.cssCompiledStyles || [], ...t15.cssStyles || []]);
  return { stylesMap: e, stylesArray: [...e] };
}, "compileStyles");
var ij = _((t15) => {
  const e = /* @__PURE__ */ new Map();
  return t15.forEach((r) => {
    const [n, i] = r.split(":");
    e.set(n.trim(), i == null ? void 0 : i.trim());
  }), e;
}, "styles2Map");
var $7 = _((t15) => t15 === "color" || t15 === "font-size" || t15 === "font-family" || t15 === "font-weight" || t15 === "font-style" || t15 === "text-decoration" || t15 === "text-align" || t15 === "text-transform" || t15 === "line-height" || t15 === "letter-spacing" || t15 === "word-spacing" || t15 === "text-shadow" || t15 === "text-overflow" || t15 === "white-space" || t15 === "word-wrap" || t15 === "word-break" || t15 === "overflow-wrap" || t15 === "hyphens", "isLabelStyle");
var Ft = _((t15) => {
  const { stylesArray: e } = mo(t15), r = [], n = [], i = [], s = [];
  return e.forEach((a) => {
    const o = a[0];
    $7(o) ? r.push(a.join(":") + " !important") : (n.push(a.join(":") + " !important"), o.includes("stroke") && i.push(a.join(":") + " !important"), o === "fill" && s.push(a.join(":") + " !important"));
  }), {
    labelStyles: r.join(";"),
    nodeStyles: n.join(";"),
    stylesArray: e,
    borderStyles: i,
    backgroundStyles: s
  };
}, "styles2String");
var Lt = _((t15, e) => {
  var _a3;
  const { themeVariables: r, handDrawnSeed: n } = fe(), { nodeBorder: i, mainBkg: s } = r, { stylesMap: a } = mo(t15);
  return Object.assign(
    {
      roughness: 0.7,
      fill: a.get("fill") || s,
      fillStyle: "hachure",
      // solid fill
      fillWeight: 4,
      hachureGap: 5.2,
      stroke: a.get("stroke") || i,
      seed: n,
      strokeWidth: ((_a3 = a.get("stroke-width")) == null ? void 0 : _a3.replace("px", "")) || 1.3,
      fillLineDash: [0, 0]
    },
    e
  );
}, "userNodeOverrides");
var jo = {};
var Qe = {};
var jb;
function sj() {
  return jb || (jb = 1, Object.defineProperty(Qe, "__esModule", { value: true }), Qe.BLANK_URL = Qe.relativeFirstCharacters = Qe.whitespaceEscapeCharsRegex = Qe.urlSchemeRegex = Qe.ctrlCharactersRegex = Qe.htmlCtrlEntityRegex = Qe.htmlEntitiesRegex = Qe.invalidProtocolRegex = void 0, Qe.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im, Qe.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g, Qe.htmlCtrlEntityRegex = /&(newline|tab);/gi, Qe.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, Qe.urlSchemeRegex = /^.+(:|&colon;)/gim, Qe.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g, Qe.relativeFirstCharacters = [".", "/"], Qe.BLANK_URL = "about:blank"), Qe;
}
var Wb;
function aj() {
  if (Wb) return jo;
  Wb = 1, Object.defineProperty(jo, "__esModule", { value: true }), jo.sanitizeUrl = void 0;
  var t15 = sj();
  function e(a) {
    return t15.relativeFirstCharacters.indexOf(a[0]) > -1;
  }
  function r(a) {
    var o = a.replace(t15.ctrlCharactersRegex, "");
    return o.replace(t15.htmlEntitiesRegex, function(l, c) {
      return String.fromCharCode(c);
    });
  }
  function n(a) {
    return URL.canParse(a);
  }
  function i(a) {
    try {
      return decodeURIComponent(a);
    } catch {
      return a;
    }
  }
  function s(a) {
    if (!a)
      return t15.BLANK_URL;
    var o, l = i(a.trim());
    do
      l = r(l).replace(t15.htmlCtrlEntityRegex, "").replace(t15.ctrlCharactersRegex, "").replace(t15.whitespaceEscapeCharsRegex, "").trim(), l = i(l), o = l.match(t15.ctrlCharactersRegex) || l.match(t15.htmlEntitiesRegex) || l.match(t15.htmlCtrlEntityRegex) || l.match(t15.whitespaceEscapeCharsRegex);
    while (o && o.length > 0);
    var c = l;
    if (!c)
      return t15.BLANK_URL;
    if (e(c))
      return c;
    var h = c.trimStart(), p = h.match(t15.urlSchemeRegex);
    if (!p)
      return c;
    var m = p[0].toLowerCase().trim();
    if (t15.invalidProtocolRegex.test(m))
      return t15.BLANK_URL;
    var g = h.replace(/\\/g, "/");
    if (m === "mailto:" || m.includes("://"))
      return g;
    if (m === "http:" || m === "https:") {
      if (!n(g))
        return t15.BLANK_URL;
      var y = new URL(g);
      return y.protocol = y.protocol.toLowerCase(), y.hostname = y.hostname.toLowerCase(), y.toString();
    }
    return g;
  }
  return jo.sanitizeUrl = s, jo;
}
var oj = aj();
var lj = { value: () => {
} };
function E7() {
  for (var t15 = 0, e = arguments.length, r = {}, n; t15 < e; ++t15) {
    if (!(n = arguments[t15] + "") || n in r || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new Lh(r);
}
function Lh(t15) {
  this._ = t15;
}
function cj(t15, e) {
  return t15.trim().split(/^|\s+/).map(function(r) {
    var n = "", i = r.indexOf(".");
    if (i >= 0 && (n = r.slice(i + 1), r = r.slice(0, i)), r && !e.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
Lh.prototype = E7.prototype = {
  constructor: Lh,
  on: function(t15, e) {
    var r = this._, n = cj(t15 + "", r), i, s = -1, a = n.length;
    if (arguments.length < 2) {
      for (; ++s < a; ) if ((i = (t15 = n[s]).type) && (i = hj(r[i], t15.name))) return i;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++s < a; )
      if (i = (t15 = n[s]).type) r[i] = Hb(r[i], t15.name, e);
      else if (e == null) for (i in r) r[i] = Hb(r[i], t15.name, null);
    return this;
  },
  copy: function() {
    var t15 = {}, e = this._;
    for (var r in e) t15[r] = e[r].slice();
    return new Lh(t15);
  },
  call: function(t15, e) {
    if ((i = arguments.length - 2) > 0) for (var r = new Array(i), n = 0, i, s; n < i; ++n) r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(t15)) throw new Error("unknown type: " + t15);
    for (s = this._[t15], n = 0, i = s.length; n < i; ++n) s[n].value.apply(e, r);
  },
  apply: function(t15, e, r) {
    if (!this._.hasOwnProperty(t15)) throw new Error("unknown type: " + t15);
    for (var n = this._[t15], i = 0, s = n.length; i < s; ++i) n[i].value.apply(e, r);
  }
};
function hj(t15, e) {
  for (var r = 0, n = t15.length, i; r < n; ++r)
    if ((i = t15[r]).name === e)
      return i.value;
}
function Hb(t15, e, r) {
  for (var n = 0, i = t15.length; n < i; ++n)
    if (t15[n].name === e) {
      t15[n] = lj, t15 = t15.slice(0, n).concat(t15.slice(n + 1));
      break;
    }
  return r != null && t15.push({ name: e, value: r }), t15;
}
var Vf = "http://www.w3.org/1999/xhtml";
var Ub = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Vf,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Su(t15) {
  var e = t15 += "", r = e.indexOf(":");
  return r >= 0 && (e = t15.slice(0, r)) !== "xmlns" && (t15 = t15.slice(r + 1)), Ub.hasOwnProperty(e) ? { space: Ub[e], local: t15 } : t15;
}
function uj(t15) {
  return function() {
    var e = this.ownerDocument, r = this.namespaceURI;
    return r === Vf && e.documentElement.namespaceURI === Vf ? e.createElement(t15) : e.createElementNS(r, t15);
  };
}
function dj(t15) {
  return function() {
    return this.ownerDocument.createElementNS(t15.space, t15.local);
  };
}
function M7(t15) {
  var e = Su(t15);
  return (e.local ? dj : uj)(e);
}
function pj() {
}
function zm(t15) {
  return t15 == null ? pj : function() {
    return this.querySelector(t15);
  };
}
function fj(t15) {
  typeof t15 != "function" && (t15 = zm(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = new Array(a), l, c, h = 0; h < a; ++h)
      (l = s[h]) && (c = t15.call(l, l.__data__, h, s)) && ("__data__" in l && (c.__data__ = l.__data__), o[h] = c);
  return new en(n, this._parents);
}
function mj(t15) {
  return t15 == null ? [] : Array.isArray(t15) ? t15 : Array.from(t15);
}
function gj() {
  return [];
}
function B7(t15) {
  return t15 == null ? gj : function() {
    return this.querySelectorAll(t15);
  };
}
function yj(t15) {
  return function() {
    return mj(t15.apply(this, arguments));
  };
}
function bj(t15) {
  typeof t15 == "function" ? t15 = yj(t15) : t15 = B7(t15);
  for (var e = this._groups, r = e.length, n = [], i = [], s = 0; s < r; ++s)
    for (var a = e[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && (n.push(t15.call(l, l.__data__, c, a)), i.push(l));
  return new en(n, i);
}
function L7(t15) {
  return function() {
    return this.matches(t15);
  };
}
function D7(t15) {
  return function(e) {
    return e.matches(t15);
  };
}
var xj = Array.prototype.find;
function wj(t15) {
  return function() {
    return xj.call(this.children, t15);
  };
}
function kj() {
  return this.firstElementChild;
}
function vj(t15) {
  return this.select(t15 == null ? kj : wj(typeof t15 == "function" ? t15 : D7(t15)));
}
var Cj = Array.prototype.filter;
function _j() {
  return Array.from(this.children);
}
function Sj(t15) {
  return function() {
    return Cj.call(this.children, t15);
  };
}
function Aj(t15) {
  return this.selectAll(t15 == null ? _j : Sj(typeof t15 == "function" ? t15 : D7(t15)));
}
function Tj(t15) {
  typeof t15 != "function" && (t15 = L7(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && t15.call(l, l.__data__, c, s) && o.push(l);
  return new en(n, this._parents);
}
function F7(t15) {
  return new Array(t15.length);
}
function $j() {
  return new en(this._enter || this._groups.map(F7), this._parents);
}
function C0(t15, e) {
  this.ownerDocument = t15.ownerDocument, this.namespaceURI = t15.namespaceURI, this._next = null, this._parent = t15, this.__data__ = e;
}
C0.prototype = {
  constructor: C0,
  appendChild: function(t15) {
    return this._parent.insertBefore(t15, this._next);
  },
  insertBefore: function(t15, e) {
    return this._parent.insertBefore(t15, e);
  },
  querySelector: function(t15) {
    return this._parent.querySelector(t15);
  },
  querySelectorAll: function(t15) {
    return this._parent.querySelectorAll(t15);
  }
};
function Ej(t15) {
  return function() {
    return t15;
  };
}
function Mj(t15, e, r, n, i, s) {
  for (var a = 0, o, l = e.length, c = s.length; a < c; ++a)
    (o = e[a]) ? (o.__data__ = s[a], n[a] = o) : r[a] = new C0(t15, s[a]);
  for (; a < l; ++a)
    (o = e[a]) && (i[a] = o);
}
function Bj(t15, e, r, n, i, s, a) {
  var o, l, c = /* @__PURE__ */ new Map(), h = e.length, p = s.length, m = new Array(h), g;
  for (o = 0; o < h; ++o)
    (l = e[o]) && (m[o] = g = a.call(l, l.__data__, o, e) + "", c.has(g) ? i[o] = l : c.set(g, l));
  for (o = 0; o < p; ++o)
    g = a.call(t15, s[o], o, s) + "", (l = c.get(g)) ? (n[o] = l, l.__data__ = s[o], c.delete(g)) : r[o] = new C0(t15, s[o]);
  for (o = 0; o < h; ++o)
    (l = e[o]) && c.get(m[o]) === l && (i[o] = l);
}
function Lj(t15) {
  return t15.__data__;
}
function Dj(t15, e) {
  if (!arguments.length) return Array.from(this, Lj);
  var r = e ? Bj : Mj, n = this._parents, i = this._groups;
  typeof t15 != "function" && (t15 = Ej(t15));
  for (var s = i.length, a = new Array(s), o = new Array(s), l = new Array(s), c = 0; c < s; ++c) {
    var h = n[c], p = i[c], m = p.length, g = Fj(t15.call(h, h && h.__data__, c, n)), y = g.length, x = o[c] = new Array(y), k = a[c] = new Array(y), C = l[c] = new Array(m);
    r(h, p, x, k, C, g, e);
    for (var A = 0, $ = 0, B, L; A < y; ++A)
      if (B = x[A]) {
        for (A >= $ && ($ = A + 1); !(L = k[$]) && ++$ < y; ) ;
        B._next = L || null;
      }
  }
  return a = new en(a, n), a._enter = o, a._exit = l, a;
}
function Fj(t15) {
  return typeof t15 == "object" && "length" in t15 ? t15 : Array.from(t15);
}
function Nj() {
  return new en(this._exit || this._groups.map(F7), this._parents);
}
function Ij(t15, e, r) {
  var n = this.enter(), i = this, s = this.exit();
  return typeof t15 == "function" ? (n = t15(n), n && (n = n.selection())) : n = n.append(t15 + ""), e != null && (i = e(i), i && (i = i.selection())), r == null ? s.remove() : r(s), n && i ? n.merge(i).order() : i;
}
function Oj(t15) {
  for (var e = t15.selection ? t15.selection() : t15, r = this._groups, n = e._groups, i = r.length, s = n.length, a = Math.min(i, s), o = new Array(i), l = 0; l < a; ++l)
    for (var c = r[l], h = n[l], p = c.length, m = o[l] = new Array(p), g, y = 0; y < p; ++y)
      (g = c[y] || h[y]) && (m[y] = g);
  for (; l < i; ++l)
    o[l] = r[l];
  return new en(o, this._parents);
}
function zj() {
  for (var t15 = this._groups, e = -1, r = t15.length; ++e < r; )
    for (var n = t15[e], i = n.length - 1, s = n[i], a; --i >= 0; )
      (a = n[i]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function qj(t15) {
  t15 || (t15 = Rj);
  function e(p, m) {
    return p && m ? t15(p.__data__, m.__data__) : !p - !m;
  }
  for (var r = this._groups, n = r.length, i = new Array(n), s = 0; s < n; ++s) {
    for (var a = r[s], o = a.length, l = i[s] = new Array(o), c, h = 0; h < o; ++h)
      (c = a[h]) && (l[h] = c);
    l.sort(e);
  }
  return new en(i, this._parents).order();
}
function Rj(t15, e) {
  return t15 < e ? -1 : t15 > e ? 1 : t15 >= e ? 0 : NaN;
}
function Pj() {
  var t15 = arguments[0];
  return arguments[0] = this, t15.apply(null, arguments), this;
}
function jj() {
  return Array.from(this);
}
function Wj() {
  for (var t15 = this._groups, e = 0, r = t15.length; e < r; ++e)
    for (var n = t15[e], i = 0, s = n.length; i < s; ++i) {
      var a = n[i];
      if (a) return a;
    }
  return null;
}
function Hj() {
  let t15 = 0;
  for (const e of this) ++t15;
  return t15;
}
function Uj() {
  return !this.node();
}
function Vj(t15) {
  for (var e = this._groups, r = 0, n = e.length; r < n; ++r)
    for (var i = e[r], s = 0, a = i.length, o; s < a; ++s)
      (o = i[s]) && t15.call(o, o.__data__, s, i);
  return this;
}
function Gj(t15) {
  return function() {
    this.removeAttribute(t15);
  };
}
function Xj(t15) {
  return function() {
    this.removeAttributeNS(t15.space, t15.local);
  };
}
function Yj(t15, e) {
  return function() {
    this.setAttribute(t15, e);
  };
}
function Kj(t15, e) {
  return function() {
    this.setAttributeNS(t15.space, t15.local, e);
  };
}
function Zj(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttribute(t15) : this.setAttribute(t15, r);
  };
}
function Jj(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttributeNS(t15.space, t15.local) : this.setAttributeNS(t15.space, t15.local, r);
  };
}
function Qj(t15, e) {
  var r = Su(t15);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((e == null ? r.local ? Xj : Gj : typeof e == "function" ? r.local ? Jj : Zj : r.local ? Kj : Yj)(r, e));
}
function N7(t15) {
  return t15.ownerDocument && t15.ownerDocument.defaultView || t15.document && t15 || t15.defaultView;
}
function tW(t15) {
  return function() {
    this.style.removeProperty(t15);
  };
}
function eW(t15, e, r) {
  return function() {
    this.style.setProperty(t15, e, r);
  };
}
function rW(t15, e, r) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(t15) : this.style.setProperty(t15, n, r);
  };
}
function nW(t15, e, r) {
  return arguments.length > 1 ? this.each((e == null ? tW : typeof e == "function" ? rW : eW)(t15, e, r ?? "")) : eo(this.node(), t15);
}
function eo(t15, e) {
  return t15.style.getPropertyValue(e) || N7(t15).getComputedStyle(t15, null).getPropertyValue(e);
}
function iW(t15) {
  return function() {
    delete this[t15];
  };
}
function sW(t15, e) {
  return function() {
    this[t15] = e;
  };
}
function aW(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? delete this[t15] : this[t15] = r;
  };
}
function oW(t15, e) {
  return arguments.length > 1 ? this.each((e == null ? iW : typeof e == "function" ? aW : sW)(t15, e)) : this.node()[t15];
}
function I7(t15) {
  return t15.trim().split(/^|\s+/);
}
function qm(t15) {
  return t15.classList || new O7(t15);
}
function O7(t15) {
  this._node = t15, this._names = I7(t15.getAttribute("class") || "");
}
O7.prototype = {
  add: function(t15) {
    var e = this._names.indexOf(t15);
    e < 0 && (this._names.push(t15), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t15) {
    var e = this._names.indexOf(t15);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t15) {
    return this._names.indexOf(t15) >= 0;
  }
};
function z7(t15, e) {
  for (var r = qm(t15), n = -1, i = e.length; ++n < i; ) r.add(e[n]);
}
function q7(t15, e) {
  for (var r = qm(t15), n = -1, i = e.length; ++n < i; ) r.remove(e[n]);
}
function lW(t15) {
  return function() {
    z7(this, t15);
  };
}
function cW(t15) {
  return function() {
    q7(this, t15);
  };
}
function hW(t15, e) {
  return function() {
    (e.apply(this, arguments) ? z7 : q7)(this, t15);
  };
}
function uW(t15, e) {
  var r = I7(t15 + "");
  if (arguments.length < 2) {
    for (var n = qm(this.node()), i = -1, s = r.length; ++i < s; ) if (!n.contains(r[i])) return false;
    return true;
  }
  return this.each((typeof e == "function" ? hW : e ? lW : cW)(r, e));
}
function dW() {
  this.textContent = "";
}
function pW(t15) {
  return function() {
    this.textContent = t15;
  };
}
function fW(t15) {
  return function() {
    var e = t15.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function mW(t15) {
  return arguments.length ? this.each(t15 == null ? dW : (typeof t15 == "function" ? fW : pW)(t15)) : this.node().textContent;
}
function gW() {
  this.innerHTML = "";
}
function yW(t15) {
  return function() {
    this.innerHTML = t15;
  };
}
function bW(t15) {
  return function() {
    var e = t15.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function xW(t15) {
  return arguments.length ? this.each(t15 == null ? gW : (typeof t15 == "function" ? bW : yW)(t15)) : this.node().innerHTML;
}
function wW() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function kW() {
  return this.each(wW);
}
function vW() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function CW() {
  return this.each(vW);
}
function _W(t15) {
  var e = typeof t15 == "function" ? t15 : M7(t15);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function SW() {
  return null;
}
function AW(t15, e) {
  var r = typeof t15 == "function" ? t15 : M7(t15), n = e == null ? SW : typeof e == "function" ? e : zm(e);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function TW() {
  var t15 = this.parentNode;
  t15 && t15.removeChild(this);
}
function $W() {
  return this.each(TW);
}
function EW() {
  var t15 = this.cloneNode(false), e = this.parentNode;
  return e ? e.insertBefore(t15, this.nextSibling) : t15;
}
function MW() {
  var t15 = this.cloneNode(true), e = this.parentNode;
  return e ? e.insertBefore(t15, this.nextSibling) : t15;
}
function BW(t15) {
  return this.select(t15 ? MW : EW);
}
function LW(t15) {
  return arguments.length ? this.property("__data__", t15) : this.node().__data__;
}
function DW(t15) {
  return function(e) {
    t15.call(this, e, this.__data__);
  };
}
function FW(t15) {
  return t15.trim().split(/^|\s+/).map(function(e) {
    var r = "", n = e.indexOf(".");
    return n >= 0 && (r = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: r };
  });
}
function NW(t15) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var r = 0, n = -1, i = e.length, s; r < i; ++r)
        s = e[r], (!t15.type || s.type === t15.type) && s.name === t15.name ? this.removeEventListener(s.type, s.listener, s.options) : e[++n] = s;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function IW(t15, e, r) {
  return function() {
    var n = this.__on, i, s = DW(e);
    if (n) {
      for (var a = 0, o = n.length; a < o; ++a)
        if ((i = n[a]).type === t15.type && i.name === t15.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = r), i.value = e;
          return;
        }
    }
    this.addEventListener(t15.type, s, r), i = { type: t15.type, name: t15.name, value: e, listener: s, options: r }, n ? n.push(i) : this.__on = [i];
  };
}
function OW(t15, e, r) {
  var n = FW(t15 + ""), i, s = n.length, a;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, c = o.length, h; l < c; ++l)
        for (i = 0, h = o[l]; i < s; ++i)
          if ((a = n[i]).type === h.type && a.name === h.name)
            return h.value;
    }
    return;
  }
  for (o = e ? IW : NW, i = 0; i < s; ++i) this.each(o(n[i], e, r));
  return this;
}
function R7(t15, e, r) {
  var n = N7(t15), i = n.CustomEvent;
  typeof i == "function" ? i = new i(e, r) : (i = n.document.createEvent("Event"), r ? (i.initEvent(e, r.bubbles, r.cancelable), i.detail = r.detail) : i.initEvent(e, false, false)), t15.dispatchEvent(i);
}
function zW(t15, e) {
  return function() {
    return R7(this, t15, e);
  };
}
function qW(t15, e) {
  return function() {
    return R7(this, t15, e.apply(this, arguments));
  };
}
function RW(t15, e) {
  return this.each((typeof e == "function" ? qW : zW)(t15, e));
}
function* PW() {
  for (var t15 = this._groups, e = 0, r = t15.length; e < r; ++e)
    for (var n = t15[e], i = 0, s = n.length, a; i < s; ++i)
      (a = n[i]) && (yield a);
}
var P7 = [null];
function en(t15, e) {
  this._groups = t15, this._parents = e;
}
function uc() {
  return new en([[document.documentElement]], P7);
}
function jW() {
  return this;
}
en.prototype = uc.prototype = {
  constructor: en,
  select: fj,
  selectAll: bj,
  selectChild: vj,
  selectChildren: Aj,
  filter: Tj,
  data: Dj,
  enter: $j,
  exit: Nj,
  join: Ij,
  merge: Oj,
  selection: jW,
  order: zj,
  sort: qj,
  call: Pj,
  nodes: jj,
  node: Wj,
  size: Hj,
  empty: Uj,
  each: Vj,
  attr: Qj,
  style: nW,
  property: oW,
  classed: uW,
  text: mW,
  html: xW,
  raise: kW,
  lower: CW,
  append: _W,
  insert: AW,
  remove: $W,
  clone: BW,
  datum: LW,
  on: OW,
  dispatch: RW,
  [Symbol.iterator]: PW
};
function ae(t15) {
  return typeof t15 == "string" ? new en([[document.querySelector(t15)]], [document.documentElement]) : new en([[t15]], P7);
}
function Rm(t15, e, r) {
  t15.prototype = e.prototype = r, r.constructor = t15;
}
function j7(t15, e) {
  var r = Object.create(t15.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function dc() {
}
var Pl = 0.7;
var _0 = 1 / Pl;
var za = "\\s*([+-]?\\d+)\\s*";
var jl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var Gn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var WW = /^#([0-9a-f]{3,8})$/;
var HW = new RegExp(`^rgb\\(${za},${za},${za}\\)$`);
var UW = new RegExp(`^rgb\\(${Gn},${Gn},${Gn}\\)$`);
var VW = new RegExp(`^rgba\\(${za},${za},${za},${jl}\\)$`);
var GW = new RegExp(`^rgba\\(${Gn},${Gn},${Gn},${jl}\\)$`);
var XW = new RegExp(`^hsl\\(${jl},${Gn},${Gn}\\)$`);
var YW = new RegExp(`^hsla\\(${jl},${Gn},${Gn},${jl}\\)$`);
var Vb = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Rm(dc, Wl, {
  copy(t15) {
    return Object.assign(new this.constructor(), this, t15);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Gb,
  // Deprecated! Use color.formatHex.
  formatHex: Gb,
  formatHex8: KW,
  formatHsl: ZW,
  formatRgb: Xb,
  toString: Xb
});
function Gb() {
  return this.rgb().formatHex();
}
function KW() {
  return this.rgb().formatHex8();
}
function ZW() {
  return W7(this).formatHsl();
}
function Xb() {
  return this.rgb().formatRgb();
}
function Wl(t15) {
  var e, r;
  return t15 = (t15 + "").trim().toLowerCase(), (e = WW.exec(t15)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? Yb(e) : r === 3 ? new Wr(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? sh(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? sh(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = HW.exec(t15)) ? new Wr(e[1], e[2], e[3], 1) : (e = UW.exec(t15)) ? new Wr(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = VW.exec(t15)) ? sh(e[1], e[2], e[3], e[4]) : (e = GW.exec(t15)) ? sh(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = XW.exec(t15)) ? Jb(e[1], e[2] / 100, e[3] / 100, 1) : (e = YW.exec(t15)) ? Jb(e[1], e[2] / 100, e[3] / 100, e[4]) : Vb.hasOwnProperty(t15) ? Yb(Vb[t15]) : t15 === "transparent" ? new Wr(NaN, NaN, NaN, 0) : null;
}
function Yb(t15) {
  return new Wr(t15 >> 16 & 255, t15 >> 8 & 255, t15 & 255, 1);
}
function sh(t15, e, r, n) {
  return n <= 0 && (t15 = e = r = NaN), new Wr(t15, e, r, n);
}
function JW(t15) {
  return t15 instanceof dc || (t15 = Wl(t15)), t15 ? (t15 = t15.rgb(), new Wr(t15.r, t15.g, t15.b, t15.opacity)) : new Wr();
}
function Gf(t15, e, r, n) {
  return arguments.length === 1 ? JW(t15) : new Wr(t15, e, r, n ?? 1);
}
function Wr(t15, e, r, n) {
  this.r = +t15, this.g = +e, this.b = +r, this.opacity = +n;
}
Rm(Wr, Gf, j7(dc, {
  brighter(t15) {
    return t15 = t15 == null ? _0 : Math.pow(_0, t15), new Wr(this.r * t15, this.g * t15, this.b * t15, this.opacity);
  },
  darker(t15) {
    return t15 = t15 == null ? Pl : Math.pow(Pl, t15), new Wr(this.r * t15, this.g * t15, this.b * t15, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Wr(Us(this.r), Us(this.g), Us(this.b), S0(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Kb,
  // Deprecated! Use color.formatHex.
  formatHex: Kb,
  formatHex8: QW,
  formatRgb: Zb,
  toString: Zb
}));
function Kb() {
  return `#${Ps(this.r)}${Ps(this.g)}${Ps(this.b)}`;
}
function QW() {
  return `#${Ps(this.r)}${Ps(this.g)}${Ps(this.b)}${Ps((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Zb() {
  const t15 = S0(this.opacity);
  return `${t15 === 1 ? "rgb(" : "rgba("}${Us(this.r)}, ${Us(this.g)}, ${Us(this.b)}${t15 === 1 ? ")" : `, ${t15})`}`;
}
function S0(t15) {
  return isNaN(t15) ? 1 : Math.max(0, Math.min(1, t15));
}
function Us(t15) {
  return Math.max(0, Math.min(255, Math.round(t15) || 0));
}
function Ps(t15) {
  return t15 = Us(t15), (t15 < 16 ? "0" : "") + t15.toString(16);
}
function Jb(t15, e, r, n) {
  return n <= 0 ? t15 = e = r = NaN : r <= 0 || r >= 1 ? t15 = e = NaN : e <= 0 && (t15 = NaN), new Cn(t15, e, r, n);
}
function W7(t15) {
  if (t15 instanceof Cn) return new Cn(t15.h, t15.s, t15.l, t15.opacity);
  if (t15 instanceof dc || (t15 = Wl(t15)), !t15) return new Cn();
  if (t15 instanceof Cn) return t15;
  t15 = t15.rgb();
  var e = t15.r / 255, r = t15.g / 255, n = t15.b / 255, i = Math.min(e, r, n), s = Math.max(e, r, n), a = NaN, o = s - i, l = (s + i) / 2;
  return o ? (e === s ? a = (r - n) / o + (r < n) * 6 : r === s ? a = (n - e) / o + 2 : a = (e - r) / o + 4, o /= l < 0.5 ? s + i : 2 - s - i, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new Cn(a, o, l, t15.opacity);
}
function tH(t15, e, r, n) {
  return arguments.length === 1 ? W7(t15) : new Cn(t15, e, r, n ?? 1);
}
function Cn(t15, e, r, n) {
  this.h = +t15, this.s = +e, this.l = +r, this.opacity = +n;
}
Rm(Cn, tH, j7(dc, {
  brighter(t15) {
    return t15 = t15 == null ? _0 : Math.pow(_0, t15), new Cn(this.h, this.s, this.l * t15, this.opacity);
  },
  darker(t15) {
    return t15 = t15 == null ? Pl : Math.pow(Pl, t15), new Cn(this.h, this.s, this.l * t15, this.opacity);
  },
  rgb() {
    var t15 = this.h % 360 + (this.h < 0) * 360, e = isNaN(t15) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new Wr(
      wp(t15 >= 240 ? t15 - 240 : t15 + 120, i, n),
      wp(t15, i, n),
      wp(t15 < 120 ? t15 + 240 : t15 - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new Cn(Qb(this.h), ah(this.s), ah(this.l), S0(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t15 = S0(this.opacity);
    return `${t15 === 1 ? "hsl(" : "hsla("}${Qb(this.h)}, ${ah(this.s) * 100}%, ${ah(this.l) * 100}%${t15 === 1 ? ")" : `, ${t15})`}`;
  }
}));
function Qb(t15) {
  return t15 = (t15 || 0) % 360, t15 < 0 ? t15 + 360 : t15;
}
function ah(t15) {
  return Math.max(0, Math.min(1, t15 || 0));
}
function wp(t15, e, r) {
  return (t15 < 60 ? e + (r - e) * t15 / 60 : t15 < 180 ? r : t15 < 240 ? e + (r - e) * (240 - t15) / 60 : e) * 255;
}
var Pm = (t15) => () => t15;
function H7(t15, e) {
  return function(r) {
    return t15 + r * e;
  };
}
function eH(t15, e, r) {
  return t15 = Math.pow(t15, r), e = Math.pow(e, r) - t15, r = 1 / r, function(n) {
    return Math.pow(t15 + n * e, r);
  };
}
function urt(t15, e) {
  var r = e - t15;
  return r ? H7(t15, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) : Pm(isNaN(t15) ? e : t15);
}
function rH(t15) {
  return (t15 = +t15) == 1 ? U7 : function(e, r) {
    return r - e ? eH(e, r, t15) : Pm(isNaN(e) ? r : e);
  };
}
function U7(t15, e) {
  var r = e - t15;
  return r ? H7(t15, r) : Pm(isNaN(t15) ? e : t15);
}
var t42 = function t5(e) {
  var r = rH(e);
  function n(i, s) {
    var a = r((i = Gf(i)).r, (s = Gf(s)).r), o = r(i.g, s.g), l = r(i.b, s.b), c = U7(i.opacity, s.opacity);
    return function(h) {
      return i.r = a(h), i.g = o(h), i.b = l(h), i.opacity = c(h), i + "";
    };
  }
  return n.gamma = t5, n;
}(1);
function Yi(t15, e) {
  return t15 = +t15, e = +e, function(r) {
    return t15 * (1 - r) + e * r;
  };
}
var Xf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var kp = new RegExp(Xf.source, "g");
function nH(t15) {
  return function() {
    return t15;
  };
}
function iH(t15) {
  return function(e) {
    return t15(e) + "";
  };
}
function sH(t15, e) {
  var r = Xf.lastIndex = kp.lastIndex = 0, n, i, s, a = -1, o = [], l = [];
  for (t15 = t15 + "", e = e + ""; (n = Xf.exec(t15)) && (i = kp.exec(e)); )
    (s = i.index) > r && (s = e.slice(r, s), o[a] ? o[a] += s : o[++a] = s), (n = n[0]) === (i = i[0]) ? o[a] ? o[a] += i : o[++a] = i : (o[++a] = null, l.push({ i: a, x: Yi(n, i) })), r = kp.lastIndex;
  return r < e.length && (s = e.slice(r), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? iH(l[0].x) : nH(e) : (e = l.length, function(c) {
    for (var h = 0, p; h < e; ++h) o[(p = l[h]).i] = p.x(c);
    return o.join("");
  });
}
var e4 = 180 / Math.PI;
var V7 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function G7(t15, e, r, n, i, s) {
  var a, o, l;
  return (a = Math.sqrt(t15 * t15 + e * e)) && (t15 /= a, e /= a), (l = t15 * r + e * n) && (r -= t15 * l, n -= e * l), (o = Math.sqrt(r * r + n * n)) && (r /= o, n /= o, l /= o), t15 * n < e * r && (t15 = -t15, e = -e, l = -l, a = -a), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(e, t15) * e4,
    skewX: Math.atan(l) * e4,
    scaleX: a,
    scaleY: o
  };
}
var oh;
function aH(t15) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t15 + "");
  return e.isIdentity ? V7 : G7(e.a, e.b, e.c, e.d, e.e, e.f);
}
function oH(t15) {
  return t15 == null || (oh || (oh = document.createElementNS("http://www.w3.org/2000/svg", "g")), oh.setAttribute("transform", t15), !(t15 = oh.transform.baseVal.consolidate())) ? V7 : (t15 = t15.matrix, G7(t15.a, t15.b, t15.c, t15.d, t15.e, t15.f));
}
function X7(t15, e, r, n) {
  function i(c) {
    return c.length ? c.pop() + " " : "";
  }
  function s(c, h, p, m, g, y) {
    if (c !== p || h !== m) {
      var x = g.push("translate(", null, e, null, r);
      y.push({ i: x - 4, x: Yi(c, p) }, { i: x - 2, x: Yi(h, m) });
    } else (p || m) && g.push("translate(" + p + e + m + r);
  }
  function a(c, h, p, m) {
    c !== h ? (c - h > 180 ? h += 360 : h - c > 180 && (c += 360), m.push({ i: p.push(i(p) + "rotate(", null, n) - 2, x: Yi(c, h) })) : h && p.push(i(p) + "rotate(" + h + n);
  }
  function o(c, h, p, m) {
    c !== h ? m.push({ i: p.push(i(p) + "skewX(", null, n) - 2, x: Yi(c, h) }) : h && p.push(i(p) + "skewX(" + h + n);
  }
  function l(c, h, p, m, g, y) {
    if (c !== p || h !== m) {
      var x = g.push(i(g) + "scale(", null, ",", null, ")");
      y.push({ i: x - 4, x: Yi(c, p) }, { i: x - 2, x: Yi(h, m) });
    } else (p !== 1 || m !== 1) && g.push(i(g) + "scale(" + p + "," + m + ")");
  }
  return function(c, h) {
    var p = [], m = [];
    return c = t15(c), h = t15(h), s(c.translateX, c.translateY, h.translateX, h.translateY, p, m), a(c.rotate, h.rotate, p, m), o(c.skewX, h.skewX, p, m), l(c.scaleX, c.scaleY, h.scaleX, h.scaleY, p, m), c = h = null, function(g) {
      for (var y = -1, x = m.length, k; ++y < x; ) p[(k = m[y]).i] = k.x(g);
      return p.join("");
    };
  };
}
var lH = X7(aH, "px, ", "px)", "deg)");
var cH = X7(oH, ", ", ")", ")");
var ro = 0;
var ol = 0;
var Wo = 0;
var Y7 = 1e3;
var A0;
var ll;
var T0 = 0;
var Qs = 0;
var Au = 0;
var Hl = typeof performance == "object" && performance.now ? performance : Date;
var K7 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t15) {
  setTimeout(t15, 17);
};
function jm() {
  return Qs || (K7(hH), Qs = Hl.now() + Au);
}
function hH() {
  Qs = 0;
}
function $0() {
  this._call = this._time = this._next = null;
}
$0.prototype = Z7.prototype = {
  constructor: $0,
  restart: function(t15, e, r) {
    if (typeof t15 != "function") throw new TypeError("callback is not a function");
    r = (r == null ? jm() : +r) + (e == null ? 0 : +e), !this._next && ll !== this && (ll ? ll._next = this : A0 = this, ll = this), this._call = t15, this._time = r, Yf();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Yf());
  }
};
function Z7(t15, e, r) {
  var n = new $0();
  return n.restart(t15, e, r), n;
}
function uH() {
  jm(), ++ro;
  for (var t15 = A0, e; t15; )
    (e = Qs - t15._time) >= 0 && t15._call.call(void 0, e), t15 = t15._next;
  --ro;
}
function r4() {
  Qs = (T0 = Hl.now()) + Au, ro = ol = 0;
  try {
    uH();
  } finally {
    ro = 0, pH(), Qs = 0;
  }
}
function dH() {
  var t15 = Hl.now(), e = t15 - T0;
  e > Y7 && (Au -= e, T0 = t15);
}
function pH() {
  for (var t15, e = A0, r, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), t15 = e, e = e._next) : (r = e._next, e._next = null, e = t15 ? t15._next = r : A0 = r);
  ll = t15, Yf(n);
}
function Yf(t15) {
  if (!ro) {
    ol && (ol = clearTimeout(ol));
    var e = t15 - Qs;
    e > 24 ? (t15 < 1 / 0 && (ol = setTimeout(r4, t15 - Hl.now() - Au)), Wo && (Wo = clearInterval(Wo))) : (Wo || (T0 = Hl.now(), Wo = setInterval(dH, Y7)), ro = 1, K7(r4));
  }
}
function n4(t15, e, r) {
  var n = new $0();
  return e = e == null ? 0 : +e, n.restart((i) => {
    n.stop(), t15(i + e);
  }, e, r), n;
}
var fH = E7("start", "end", "cancel", "interrupt");
var mH = [];
var J7 = 0;
var i4 = 1;
var Kf = 2;
var Dh = 3;
var s4 = 4;
var Zf = 5;
var Fh = 6;
function Tu(t15, e, r, n, i, s) {
  var a = t15.__transition;
  if (!a) t15.__transition = {};
  else if (r in a) return;
  gH(t15, r, {
    name: e,
    index: n,
    // For context during callback.
    group: i,
    // For context during callback.
    on: fH,
    tween: mH,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: J7
  });
}
function Wm(t15, e) {
  var r = En(t15, e);
  if (r.state > J7) throw new Error("too late; already scheduled");
  return r;
}
function ei(t15, e) {
  var r = En(t15, e);
  if (r.state > Dh) throw new Error("too late; already running");
  return r;
}
function En(t15, e) {
  var r = t15.__transition;
  if (!r || !(r = r[e])) throw new Error("transition not found");
  return r;
}
function gH(t15, e, r) {
  var n = t15.__transition, i;
  n[e] = r, r.timer = Z7(s, 0, r.time);
  function s(c) {
    r.state = i4, r.timer.restart(a, r.delay, r.time), r.delay <= c && a(c - r.delay);
  }
  function a(c) {
    var h, p, m, g;
    if (r.state !== i4) return l();
    for (h in n)
      if (g = n[h], g.name === r.name) {
        if (g.state === Dh) return n4(a);
        g.state === s4 ? (g.state = Fh, g.timer.stop(), g.on.call("interrupt", t15, t15.__data__, g.index, g.group), delete n[h]) : +h < e && (g.state = Fh, g.timer.stop(), g.on.call("cancel", t15, t15.__data__, g.index, g.group), delete n[h]);
      }
    if (n4(function() {
      r.state === Dh && (r.state = s4, r.timer.restart(o, r.delay, r.time), o(c));
    }), r.state = Kf, r.on.call("start", t15, t15.__data__, r.index, r.group), r.state === Kf) {
      for (r.state = Dh, i = new Array(m = r.tween.length), h = 0, p = -1; h < m; ++h)
        (g = r.tween[h].value.call(t15, t15.__data__, r.index, r.group)) && (i[++p] = g);
      i.length = p + 1;
    }
  }
  function o(c) {
    for (var h = c < r.duration ? r.ease.call(null, c / r.duration) : (r.timer.restart(l), r.state = Zf, 1), p = -1, m = i.length; ++p < m; )
      i[p].call(t15, h);
    r.state === Zf && (r.on.call("end", t15, t15.__data__, r.index, r.group), l());
  }
  function l() {
    r.state = Fh, r.timer.stop(), delete n[e];
    for (var c in n) return;
    delete t15.__transition;
  }
}
function yH(t15, e) {
  var r = t15.__transition, n, i, s = true, a;
  if (r) {
    e = e == null ? null : e + "";
    for (a in r) {
      if ((n = r[a]).name !== e) {
        s = false;
        continue;
      }
      i = n.state > Kf && n.state < Zf, n.state = Fh, n.timer.stop(), n.on.call(i ? "interrupt" : "cancel", t15, t15.__data__, n.index, n.group), delete r[a];
    }
    s && delete t15.__transition;
  }
}
function bH(t15) {
  return this.each(function() {
    yH(this, t15);
  });
}
function xH(t15, e) {
  var r, n;
  return function() {
    var i = ei(this, t15), s = i.tween;
    if (s !== r) {
      n = r = s;
      for (var a = 0, o = n.length; a < o; ++a)
        if (n[a].name === e) {
          n = n.slice(), n.splice(a, 1);
          break;
        }
    }
    i.tween = n;
  };
}
function wH(t15, e, r) {
  var n, i;
  if (typeof r != "function") throw new Error();
  return function() {
    var s = ei(this, t15), a = s.tween;
    if (a !== n) {
      i = (n = a).slice();
      for (var o = { name: e, value: r }, l = 0, c = i.length; l < c; ++l)
        if (i[l].name === e) {
          i[l] = o;
          break;
        }
      l === c && i.push(o);
    }
    s.tween = i;
  };
}
function kH(t15, e) {
  var r = this._id;
  if (t15 += "", arguments.length < 2) {
    for (var n = En(this.node(), r).tween, i = 0, s = n.length, a; i < s; ++i)
      if ((a = n[i]).name === t15)
        return a.value;
    return null;
  }
  return this.each((e == null ? xH : wH)(r, t15, e));
}
function Hm(t15, e, r) {
  var n = t15._id;
  return t15.each(function() {
    var i = ei(this, n);
    (i.value || (i.value = {}))[e] = r.apply(this, arguments);
  }), function(i) {
    return En(i, n).value[e];
  };
}
function Q7(t15, e) {
  var r;
  return (typeof e == "number" ? Yi : e instanceof Wl ? t42 : (r = Wl(e)) ? (e = r, t42) : sH)(t15, e);
}
function vH(t15) {
  return function() {
    this.removeAttribute(t15);
  };
}
function CH(t15) {
  return function() {
    this.removeAttributeNS(t15.space, t15.local);
  };
}
function _H(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = this.getAttribute(t15);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function SH(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = this.getAttributeNS(t15.space, t15.local);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function AH(t15, e, r) {
  var n, i, s;
  return function() {
    var a, o = r(this), l;
    return o == null ? void this.removeAttribute(t15) : (a = this.getAttribute(t15), l = o + "", a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o)));
  };
}
function TH(t15, e, r) {
  var n, i, s;
  return function() {
    var a, o = r(this), l;
    return o == null ? void this.removeAttributeNS(t15.space, t15.local) : (a = this.getAttributeNS(t15.space, t15.local), l = o + "", a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o)));
  };
}
function $H(t15, e) {
  var r = Su(t15), n = r === "transform" ? cH : Q7;
  return this.attrTween(t15, typeof e == "function" ? (r.local ? TH : AH)(r, n, Hm(this, "attr." + t15, e)) : e == null ? (r.local ? CH : vH)(r) : (r.local ? SH : _H)(r, n, e));
}
function EH(t15, e) {
  return function(r) {
    this.setAttribute(t15, e.call(this, r));
  };
}
function MH(t15, e) {
  return function(r) {
    this.setAttributeNS(t15.space, t15.local, e.call(this, r));
  };
}
function BH(t15, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && MH(t15, s)), r;
  }
  return i._value = e, i;
}
function LH(t15, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && EH(t15, s)), r;
  }
  return i._value = e, i;
}
function DH(t15, e) {
  var r = "attr." + t15;
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (e == null) return this.tween(r, null);
  if (typeof e != "function") throw new Error();
  var n = Su(t15);
  return this.tween(r, (n.local ? BH : LH)(n, e));
}
function FH(t15, e) {
  return function() {
    Wm(this, t15).delay = +e.apply(this, arguments);
  };
}
function NH(t15, e) {
  return e = +e, function() {
    Wm(this, t15).delay = e;
  };
}
function IH(t15) {
  var e = this._id;
  return arguments.length ? this.each((typeof t15 == "function" ? FH : NH)(e, t15)) : En(this.node(), e).delay;
}
function OH(t15, e) {
  return function() {
    ei(this, t15).duration = +e.apply(this, arguments);
  };
}
function zH(t15, e) {
  return e = +e, function() {
    ei(this, t15).duration = e;
  };
}
function qH(t15) {
  var e = this._id;
  return arguments.length ? this.each((typeof t15 == "function" ? OH : zH)(e, t15)) : En(this.node(), e).duration;
}
function RH(t15, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    ei(this, t15).ease = e;
  };
}
function PH(t15) {
  var e = this._id;
  return arguments.length ? this.each(RH(e, t15)) : En(this.node(), e).ease;
}
function jH(t15, e) {
  return function() {
    var r = e.apply(this, arguments);
    if (typeof r != "function") throw new Error();
    ei(this, t15).ease = r;
  };
}
function WH(t15) {
  if (typeof t15 != "function") throw new Error();
  return this.each(jH(this._id, t15));
}
function HH(t15) {
  typeof t15 != "function" && (t15 = L7(t15));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && t15.call(l, l.__data__, c, s) && o.push(l);
  return new Mi(n, this._parents, this._name, this._id);
}
function UH(t15) {
  if (t15._id !== this._id) throw new Error();
  for (var e = this._groups, r = t15._groups, n = e.length, i = r.length, s = Math.min(n, i), a = new Array(n), o = 0; o < s; ++o)
    for (var l = e[o], c = r[o], h = l.length, p = a[o] = new Array(h), m, g = 0; g < h; ++g)
      (m = l[g] || c[g]) && (p[g] = m);
  for (; o < n; ++o)
    a[o] = e[o];
  return new Mi(a, this._parents, this._name, this._id);
}
function VH(t15) {
  return (t15 + "").trim().split(/^|\s+/).every(function(e) {
    var r = e.indexOf(".");
    return r >= 0 && (e = e.slice(0, r)), !e || e === "start";
  });
}
function GH(t15, e, r) {
  var n, i, s = VH(e) ? Wm : ei;
  return function() {
    var a = s(this, t15), o = a.on;
    o !== n && (i = (n = o).copy()).on(e, r), a.on = i;
  };
}
function XH(t15, e) {
  var r = this._id;
  return arguments.length < 2 ? En(this.node(), r).on.on(t15) : this.each(GH(r, t15, e));
}
function YH(t15) {
  return function() {
    var e = this.parentNode;
    for (var r in this.__transition) if (+r !== t15) return;
    e && e.removeChild(this);
  };
}
function KH() {
  return this.on("end.remove", YH(this._id));
}
function ZH(t15) {
  var e = this._name, r = this._id;
  typeof t15 != "function" && (t15 = zm(t15));
  for (var n = this._groups, i = n.length, s = new Array(i), a = 0; a < i; ++a)
    for (var o = n[a], l = o.length, c = s[a] = new Array(l), h, p, m = 0; m < l; ++m)
      (h = o[m]) && (p = t15.call(h, h.__data__, m, o)) && ("__data__" in h && (p.__data__ = h.__data__), c[m] = p, Tu(c[m], e, r, m, c, En(h, r)));
  return new Mi(s, this._parents, e, r);
}
function JH(t15) {
  var e = this._name, r = this._id;
  typeof t15 != "function" && (t15 = B7(t15));
  for (var n = this._groups, i = n.length, s = [], a = [], o = 0; o < i; ++o)
    for (var l = n[o], c = l.length, h, p = 0; p < c; ++p)
      if (h = l[p]) {
        for (var m = t15.call(h, h.__data__, p, l), g, y = En(h, r), x = 0, k = m.length; x < k; ++x)
          (g = m[x]) && Tu(g, e, r, x, m, y);
        s.push(m), a.push(h);
      }
  return new Mi(s, a, e, r);
}
var QH = uc.prototype.constructor;
function tU() {
  return new QH(this._groups, this._parents);
}
function eU(t15, e) {
  var r, n, i;
  return function() {
    var s = eo(this, t15), a = (this.style.removeProperty(t15), eo(this, t15));
    return s === a ? null : s === r && a === n ? i : i = e(r = s, n = a);
  };
}
function tk(t15) {
  return function() {
    this.style.removeProperty(t15);
  };
}
function rU(t15, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = eo(this, t15);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function nU(t15, e, r) {
  var n, i, s;
  return function() {
    var a = eo(this, t15), o = r(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(t15), eo(this, t15))), a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o));
  };
}
function iU(t15, e) {
  var r, n, i, s = "style." + e, a = "end." + s, o;
  return function() {
    var l = ei(this, t15), c = l.on, h = l.value[s] == null ? o || (o = tk(e)) : void 0;
    (c !== r || i !== h) && (n = (r = c).copy()).on(a, i = h), l.on = n;
  };
}
function sU(t15, e, r) {
  var n = (t15 += "") == "transform" ? lH : Q7;
  return e == null ? this.styleTween(t15, eU(t15, n)).on("end.style." + t15, tk(t15)) : typeof e == "function" ? this.styleTween(t15, nU(t15, n, Hm(this, "style." + t15, e))).each(iU(this._id, t15)) : this.styleTween(t15, rU(t15, n, e), r).on("end.style." + t15, null);
}
function aU(t15, e, r) {
  return function(n) {
    this.style.setProperty(t15, e.call(this, n), r);
  };
}
function oU(t15, e, r) {
  var n, i;
  function s() {
    var a = e.apply(this, arguments);
    return a !== i && (n = (i = a) && aU(t15, a, r)), n;
  }
  return s._value = e, s;
}
function lU(t15, e, r) {
  var n = "style." + (t15 += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, oU(t15, e, r ?? ""));
}
function cU(t15) {
  return function() {
    this.textContent = t15;
  };
}
function hU(t15) {
  return function() {
    var e = t15(this);
    this.textContent = e ?? "";
  };
}
function uU(t15) {
  return this.tween("text", typeof t15 == "function" ? hU(Hm(this, "text", t15)) : cU(t15 == null ? "" : t15 + ""));
}
function dU(t15) {
  return function(e) {
    this.textContent = t15.call(this, e);
  };
}
function pU(t15) {
  var e, r;
  function n() {
    var i = t15.apply(this, arguments);
    return i !== r && (e = (r = i) && dU(i)), e;
  }
  return n._value = t15, n;
}
function fU(t15) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t15 == null) return this.tween(e, null);
  if (typeof t15 != "function") throw new Error();
  return this.tween(e, pU(t15));
}
function mU() {
  for (var t15 = this._name, e = this._id, r = ek(), n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var a = n[s], o = a.length, l, c = 0; c < o; ++c)
      if (l = a[c]) {
        var h = En(l, e);
        Tu(l, t15, r, c, a, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new Mi(n, this._parents, t15, r);
}
function gU() {
  var t15, e, r = this, n = r._id, i = r.size();
  return new Promise(function(s, a) {
    var o = { value: a }, l = { value: function() {
      --i === 0 && s();
    } };
    r.each(function() {
      var c = ei(this, n), h = c.on;
      h !== t15 && (e = (t15 = h).copy(), e._.cancel.push(o), e._.interrupt.push(o), e._.end.push(l)), c.on = e;
    }), i === 0 && s();
  });
}
var yU = 0;
function Mi(t15, e, r, n) {
  this._groups = t15, this._parents = e, this._name = r, this._id = n;
}
function ek() {
  return ++yU;
}
var fi = uc.prototype;
Mi.prototype = {
  constructor: Mi,
  select: ZH,
  selectAll: JH,
  selectChild: fi.selectChild,
  selectChildren: fi.selectChildren,
  filter: HH,
  merge: UH,
  selection: tU,
  transition: mU,
  call: fi.call,
  nodes: fi.nodes,
  node: fi.node,
  size: fi.size,
  empty: fi.empty,
  each: fi.each,
  on: XH,
  attr: $H,
  attrTween: DH,
  style: sU,
  styleTween: lU,
  text: uU,
  textTween: fU,
  remove: KH,
  tween: kH,
  delay: IH,
  duration: qH,
  ease: PH,
  easeVarying: WH,
  end: gU,
  [Symbol.iterator]: fi[Symbol.iterator]
};
function bU(t15) {
  return ((t15 *= 2) <= 1 ? t15 * t15 * t15 : (t15 -= 2) * t15 * t15 + 2) / 2;
}
var xU = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: bU
};
function wU(t15, e) {
  for (var r; !(r = t15.__transition) || !(r = r[e]); )
    if (!(t15 = t15.parentNode))
      throw new Error(`transition ${e} not found`);
  return r;
}
function kU(t15) {
  var e, r;
  t15 instanceof Mi ? (e = t15._id, t15 = t15._name) : (e = ek(), (r = xU).time = jm(), t15 = t15 == null ? null : t15 + "");
  for (var n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var a = n[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && Tu(l, t15, e, c, a, r || wU(l, e));
  return new Mi(n, this._parents, t15, e);
}
uc.prototype.interrupt = bH;
uc.prototype.transition = kU;
var Jf = Math.PI;
var Qf = 2 * Jf;
var Bs = 1e-6;
var vU = Qf - Bs;
function rk(t15) {
  this._ += t15[0];
  for (let e = 1, r = t15.length; e < r; ++e)
    this._ += arguments[e] + t15[e];
}
function CU(t15) {
  let e = Math.floor(t15);
  if (!(e >= 0)) throw new Error(`invalid digits: ${t15}`);
  if (e > 15) return rk;
  const r = 10 ** e;
  return function(n) {
    this._ += n[0];
    for (let i = 1, s = n.length; i < s; ++i)
      this._ += Math.round(arguments[i] * r) / r + n[i];
  };
}
var _U = class {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? rk : CU(e);
  }
  moveTo(e, r) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, r) {
    this._append`L${this._x1 = +e},${this._y1 = +r}`;
  }
  quadraticCurveTo(e, r, n, i) {
    this._append`Q${+e},${+r},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(e, r, n, i, s, a) {
    this._append`C${+e},${+r},${+n},${+i},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(e, r, n, i, s) {
    if (e = +e, r = +r, n = +n, i = +i, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let a = this._x1, o = this._y1, l = n - e, c = i - r, h = a - e, p = o - r, m = h * h + p * p;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = r}`;
    else if (m > Bs) if (!(Math.abs(p * l - c * h) > Bs) || !s)
      this._append`L${this._x1 = e},${this._y1 = r}`;
    else {
      let g = n - a, y = i - o, x = l * l + c * c, k = g * g + y * y, C = Math.sqrt(x), A = Math.sqrt(m), $ = s * Math.tan((Jf - Math.acos((x + m - k) / (2 * C * A))) / 2), B = $ / A, L = $ / C;
      Math.abs(B - 1) > Bs && this._append`L${e + B * h},${r + B * p}`, this._append`A${s},${s},0,0,${+(p * g > h * y)},${this._x1 = e + L * l},${this._y1 = r + L * c}`;
    }
  }
  arc(e, r, n, i, s, a) {
    if (e = +e, r = +r, n = +n, a = !!a, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(i), l = n * Math.sin(i), c = e + o, h = r + l, p = 1 ^ a, m = a ? i - s : s - i;
    this._x1 === null ? this._append`M${c},${h}` : (Math.abs(this._x1 - c) > Bs || Math.abs(this._y1 - h) > Bs) && this._append`L${c},${h}`, n && (m < 0 && (m = m % Qf + Qf), m > vU ? this._append`A${n},${n},0,1,${p},${e - o},${r - l}A${n},${n},0,1,${p},${this._x1 = c},${this._y1 = h}` : m > Bs && this._append`A${n},${n},0,${+(m >= Jf)},${p},${this._x1 = e + n * Math.cos(s)},${this._y1 = r + n * Math.sin(s)}`);
  }
  rect(e, r, n, i) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function va(t15) {
  return function() {
    return t15;
  };
}
var drt = Math.abs;
var prt = Math.atan2;
var frt = Math.cos;
var mrt = Math.max;
var grt = Math.min;
var yrt = Math.sin;
var brt = Math.sqrt;
var a4 = 1e-12;
var Um = Math.PI;
var o4 = Um / 2;
var xrt = 2 * Um;
function wrt(t15) {
  return t15 > 1 ? 0 : t15 < -1 ? Um : Math.acos(t15);
}
function krt(t15) {
  return t15 >= 1 ? o4 : t15 <= -1 ? -o4 : Math.asin(t15);
}
function SU(t15) {
  let e = 3;
  return t15.digits = function(r) {
    if (!arguments.length) return e;
    if (r == null)
      e = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
      e = n;
    }
    return t15;
  }, () => new _U(e);
}
function AU(t15) {
  return typeof t15 == "object" && "length" in t15 ? t15 : Array.from(t15);
}
function nk(t15) {
  this._context = t15;
}
nk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(t15, e);
        break;
    }
  }
};
function E0(t15) {
  return new nk(t15);
}
function TU(t15) {
  return t15[0];
}
function $U(t15) {
  return t15[1];
}
function EU(t15, e) {
  var r = va(true), n = null, i = E0, s = null, a = SU(o);
  t15 = typeof t15 == "function" ? t15 : t15 === void 0 ? TU : va(t15), e = typeof e == "function" ? e : e === void 0 ? $U : va(e);
  function o(l) {
    var c, h = (l = AU(l)).length, p, m = false, g;
    for (n == null && (s = i(g = a())), c = 0; c <= h; ++c)
      !(c < h && r(p = l[c], c, l)) === m && ((m = !m) ? s.lineStart() : s.lineEnd()), m && s.point(+t15(p, c, l), +e(p, c, l));
    if (g) return s = null, g + "" || null;
  }
  return o.x = function(l) {
    return arguments.length ? (t15 = typeof l == "function" ? l : va(+l), o) : t15;
  }, o.y = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : va(+l), o) : e;
  }, o.defined = function(l) {
    return arguments.length ? (r = typeof l == "function" ? l : va(!!l), o) : r;
  }, o.curve = function(l) {
    return arguments.length ? (i = l, n != null && (s = i(n)), o) : i;
  }, o.context = function(l) {
    return arguments.length ? (l == null ? n = s = null : s = i(n = l), o) : n;
  }, o;
}
var ik = class {
  constructor(e, r) {
    this._context = e, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, r) {
    switch (e = +e, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, r, e, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, e, this._y0, e, r);
        break;
      }
    }
    this._x0 = e, this._y0 = r;
  }
};
function sk(t15) {
  return new ik(t15, true);
}
function ak(t15) {
  return new ik(t15, false);
}
function cs() {
}
function M0(t15, e, r) {
  t15._context.bezierCurveTo(
    (2 * t15._x0 + t15._x1) / 3,
    (2 * t15._y0 + t15._y1) / 3,
    (t15._x0 + 2 * t15._x1) / 3,
    (t15._y0 + 2 * t15._y1) / 3,
    (t15._x0 + 4 * t15._x1 + e) / 6,
    (t15._y0 + 4 * t15._y1 + r) / 6
  );
}
function $u(t15) {
  this._context = t15;
}
$u.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        M0(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        M0(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t15, this._y0 = this._y1, this._y1 = e;
  }
};
function Nh(t15) {
  return new $u(t15);
}
function ok(t15) {
  this._context = t15;
}
ok.prototype = {
  areaStart: cs,
  areaEnd: cs,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._x2 = t15, this._y2 = e;
        break;
      case 1:
        this._point = 2, this._x3 = t15, this._y3 = e;
        break;
      case 2:
        this._point = 3, this._x4 = t15, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t15) / 6, (this._y0 + 4 * this._y1 + e) / 6);
        break;
      default:
        M0(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t15, this._y0 = this._y1, this._y1 = e;
  }
};
function MU(t15) {
  return new ok(t15);
}
function lk(t15) {
  this._context = t15;
}
lk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + t15) / 6, n = (this._y0 + 4 * this._y1 + e) / 6;
        this._line ? this._context.lineTo(r, n) : this._context.moveTo(r, n);
        break;
      case 3:
        this._point = 4;
      default:
        M0(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t15, this._y0 = this._y1, this._y1 = e;
  }
};
function BU(t15) {
  return new lk(t15);
}
function ck(t15, e) {
  this._basis = new $u(t15), this._beta = e;
}
ck.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var t15 = this._x, e = this._y, r = t15.length - 1;
    if (r > 0)
      for (var n = t15[0], i = e[0], s = t15[r] - n, a = e[r] - i, o = -1, l; ++o <= r; )
        l = o / r, this._basis.point(
          this._beta * t15[o] + (1 - this._beta) * (n + l * s),
          this._beta * e[o] + (1 - this._beta) * (i + l * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(t15, e) {
    this._x.push(+t15), this._y.push(+e);
  }
};
var LU = function t8(e) {
  function r(n) {
    return e === 1 ? new $u(n) : new ck(n, e);
  }
  return r.beta = function(n) {
    return t8(+n);
  }, r;
}(0.85);
function B0(t15, e, r) {
  t15._context.bezierCurveTo(
    t15._x1 + t15._k * (t15._x2 - t15._x0),
    t15._y1 + t15._k * (t15._y2 - t15._y0),
    t15._x2 + t15._k * (t15._x1 - e),
    t15._y2 + t15._k * (t15._y1 - r),
    t15._x2,
    t15._y2
  );
}
function Vm(t15, e) {
  this._context = t15, this._k = (1 - e) / 6;
}
Vm.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        B0(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2, this._x1 = t15, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      default:
        B0(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var hk = function t9(e) {
  function r(n) {
    return new Vm(n, e);
  }
  return r.tension = function(n) {
    return t9(+n);
  }, r;
}(0);
function Gm(t15, e) {
  this._context = t15, this._k = (1 - e) / 6;
}
Gm.prototype = {
  areaStart: cs,
  areaEnd: cs,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._x3 = t15, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t15, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t15, this._y5 = e;
        break;
      default:
        B0(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var DU = function t10(e) {
  function r(n) {
    return new Gm(n, e);
  }
  return r.tension = function(n) {
    return t10(+n);
  }, r;
}(0);
function Xm(t15, e) {
  this._context = t15, this._k = (1 - e) / 6;
}
Xm.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        B0(this, t15, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var FU = function t11(e) {
  function r(n) {
    return new Xm(n, e);
  }
  return r.tension = function(n) {
    return t11(+n);
  }, r;
}(0);
function Ym(t15, e, r) {
  var n = t15._x1, i = t15._y1, s = t15._x2, a = t15._y2;
  if (t15._l01_a > a4) {
    var o = 2 * t15._l01_2a + 3 * t15._l01_a * t15._l12_a + t15._l12_2a, l = 3 * t15._l01_a * (t15._l01_a + t15._l12_a);
    n = (n * o - t15._x0 * t15._l12_2a + t15._x2 * t15._l01_2a) / l, i = (i * o - t15._y0 * t15._l12_2a + t15._y2 * t15._l01_2a) / l;
  }
  if (t15._l23_a > a4) {
    var c = 2 * t15._l23_2a + 3 * t15._l23_a * t15._l12_a + t15._l12_2a, h = 3 * t15._l23_a * (t15._l23_a + t15._l12_a);
    s = (s * c + t15._x1 * t15._l23_2a - e * t15._l12_2a) / h, a = (a * c + t15._y1 * t15._l23_2a - r * t15._l12_2a) / h;
  }
  t15._context.bezierCurveTo(n, i, s, a, t15._x2, t15._y2);
}
function uk(t15, e) {
  this._context = t15, this._alpha = e;
}
uk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    if (t15 = +t15, e = +e, this._point) {
      var r = this._x2 - t15, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        Ym(this, t15, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var dk = function t12(e) {
  function r(n) {
    return e ? new uk(n, e) : new Vm(n, 0);
  }
  return r.alpha = function(n) {
    return t12(+n);
  }, r;
}(0.5);
function pk(t15, e) {
  this._context = t15, this._alpha = e;
}
pk.prototype = {
  areaStart: cs,
  areaEnd: cs,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t15, e) {
    if (t15 = +t15, e = +e, this._point) {
      var r = this._x2 - t15, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = t15, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t15, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t15, this._y5 = e;
        break;
      default:
        Ym(this, t15, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var NU = function t13(e) {
  function r(n) {
    return e ? new pk(n, e) : new Gm(n, 0);
  }
  return r.alpha = function(n) {
    return t13(+n);
  }, r;
}(0.5);
function fk(t15, e) {
  this._context = t15, this._alpha = e;
}
fk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    if (t15 = +t15, e = +e, this._point) {
      var r = this._x2 - t15, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Ym(this, t15, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t15, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
var IU = function t14(e) {
  function r(n) {
    return e ? new fk(n, e) : new Xm(n, 0);
  }
  return r.alpha = function(n) {
    return t14(+n);
  }, r;
}(0.5);
function mk(t15) {
  this._context = t15;
}
mk.prototype = {
  areaStart: cs,
  areaEnd: cs,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(t15, e) {
    t15 = +t15, e = +e, this._point ? this._context.lineTo(t15, e) : (this._point = 1, this._context.moveTo(t15, e));
  }
};
function OU(t15) {
  return new mk(t15);
}
function l4(t15) {
  return t15 < 0 ? -1 : 1;
}
function c4(t15, e, r) {
  var n = t15._x1 - t15._x0, i = e - t15._x1, s = (t15._y1 - t15._y0) / (n || i < 0 && -0), a = (r - t15._y1) / (i || n < 0 && -0), o = (s * i + a * n) / (n + i);
  return (l4(s) + l4(a)) * Math.min(Math.abs(s), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function h4(t15, e) {
  var r = t15._x1 - t15._x0;
  return r ? (3 * (t15._y1 - t15._y0) / r - e) / 2 : e;
}
function vp(t15, e, r) {
  var n = t15._x0, i = t15._y0, s = t15._x1, a = t15._y1, o = (s - n) / 3;
  t15._context.bezierCurveTo(n + o, i + o * e, s - o, a - o * r, s, a);
}
function L0(t15) {
  this._context = t15;
}
L0.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        vp(this, this._t0, h4(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t15, e) {
    var r = NaN;
    if (t15 = +t15, e = +e, !(t15 === this._x1 && e === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, vp(this, h4(this, r = c4(this, t15, e)), r);
          break;
        default:
          vp(this, this._t0, r = c4(this, t15, e));
          break;
      }
      this._x0 = this._x1, this._x1 = t15, this._y0 = this._y1, this._y1 = e, this._t0 = r;
    }
  }
};
function gk(t15) {
  this._context = new yk(t15);
}
(gk.prototype = Object.create(L0.prototype)).point = function(t15, e) {
  L0.prototype.point.call(this, e, t15);
};
function yk(t15) {
  this._context = t15;
}
yk.prototype = {
  moveTo: function(t15, e) {
    this._context.moveTo(e, t15);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(t15, e) {
    this._context.lineTo(e, t15);
  },
  bezierCurveTo: function(t15, e, r, n, i, s) {
    this._context.bezierCurveTo(e, t15, n, r, s, i);
  }
};
function bk(t15) {
  return new L0(t15);
}
function xk(t15) {
  return new gk(t15);
}
function wk(t15) {
  this._context = t15;
}
wk.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var t15 = this._x, e = this._y, r = t15.length;
    if (r)
      if (this._line ? this._context.lineTo(t15[0], e[0]) : this._context.moveTo(t15[0], e[0]), r === 2)
        this._context.lineTo(t15[1], e[1]);
      else
        for (var n = u4(t15), i = u4(e), s = 0, a = 1; a < r; ++s, ++a)
          this._context.bezierCurveTo(n[0][s], i[0][s], n[1][s], i[1][s], t15[a], e[a]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(t15, e) {
    this._x.push(+t15), this._y.push(+e);
  }
};
function u4(t15) {
  var e, r = t15.length - 1, n, i = new Array(r), s = new Array(r), a = new Array(r);
  for (i[0] = 0, s[0] = 2, a[0] = t15[0] + 2 * t15[1], e = 1; e < r - 1; ++e) i[e] = 1, s[e] = 4, a[e] = 4 * t15[e] + 2 * t15[e + 1];
  for (i[r - 1] = 2, s[r - 1] = 7, a[r - 1] = 8 * t15[r - 1] + t15[r], e = 1; e < r; ++e) n = i[e] / s[e - 1], s[e] -= n, a[e] -= n * a[e - 1];
  for (i[r - 1] = a[r - 1] / s[r - 1], e = r - 2; e >= 0; --e) i[e] = (a[e] - i[e + 1]) / s[e];
  for (s[r - 1] = (t15[r] + i[r - 1]) / 2, e = 0; e < r - 1; ++e) s[e] = 2 * t15[e + 1] - i[e + 1];
  return [i, s];
}
function kk(t15) {
  return new wk(t15);
}
function Eu(t15, e) {
  this._context = t15, this._t = e;
}
Eu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(t15, e) {
    switch (t15 = +t15, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t15, e) : this._context.moveTo(t15, e);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(t15, e);
        else {
          var r = this._x * (1 - this._t) + t15 * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, e);
        }
        break;
      }
    }
    this._x = t15, this._y = e;
  }
};
function vk(t15) {
  return new Eu(t15, 0.5);
}
function Ck(t15) {
  return new Eu(t15, 0);
}
function _k(t15) {
  return new Eu(t15, 1);
}
function cl(t15, e, r) {
  this.k = t15, this.x = e, this.y = r;
}
cl.prototype = {
  constructor: cl,
  scale: function(t15) {
    return t15 === 1 ? this : new cl(this.k * t15, this.x, this.y);
  },
  translate: function(t15, e) {
    return t15 === 0 & e === 0 ? this : new cl(this.k, this.x + this.k * t15, this.y + this.k * e);
  },
  apply: function(t15) {
    return [t15[0] * this.k + this.x, t15[1] * this.k + this.y];
  },
  applyX: function(t15) {
    return t15 * this.k + this.x;
  },
  applyY: function(t15) {
    return t15 * this.k + this.y;
  },
  invert: function(t15) {
    return [(t15[0] - this.x) / this.k, (t15[1] - this.y) / this.k];
  },
  invertX: function(t15) {
    return (t15 - this.x) / this.k;
  },
  invertY: function(t15) {
    return (t15 - this.y) / this.k;
  },
  rescaleX: function(t15) {
    return t15.copy().domain(t15.range().map(this.invertX, this).map(t15.invert, t15));
  },
  rescaleY: function(t15) {
    return t15.copy().domain(t15.range().map(this.invertY, this).map(t15.invert, t15));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
cl.prototype;
var Sk = typeof global == "object" && global && global.Object === Object && global;
var zU = typeof self == "object" && self && self.Object === Object && self;
var ri = Sk || zU || Function("return this")();
var D0 = ri.Symbol;
var Ak = Object.prototype;
var qU = Ak.hasOwnProperty;
var RU = Ak.toString;
var Ho = D0 ? D0.toStringTag : void 0;
function PU(t15) {
  var e = qU.call(t15, Ho), r = t15[Ho];
  try {
    t15[Ho] = void 0;
    var n = true;
  } catch {
  }
  var i = RU.call(t15);
  return n && (e ? t15[Ho] = r : delete t15[Ho]), i;
}
var jU = Object.prototype;
var WU = jU.toString;
function HU(t15) {
  return WU.call(t15);
}
var UU = "[object Null]";
var VU = "[object Undefined]";
var d4 = D0 ? D0.toStringTag : void 0;
function go(t15) {
  return t15 == null ? t15 === void 0 ? VU : UU : d4 && d4 in Object(t15) ? PU(t15) : HU(t15);
}
function aa(t15) {
  var e = typeof t15;
  return t15 != null && (e == "object" || e == "function");
}
var GU = "[object AsyncFunction]";
var XU = "[object Function]";
var YU = "[object GeneratorFunction]";
var KU = "[object Proxy]";
function Km(t15) {
  if (!aa(t15))
    return false;
  var e = go(t15);
  return e == XU || e == YU || e == GU || e == KU;
}
var Cp = ri["__core-js_shared__"];
var p4 = function() {
  var t15 = /[^.]+$/.exec(Cp && Cp.keys && Cp.keys.IE_PROTO || "");
  return t15 ? "Symbol(src)_1." + t15 : "";
}();
function ZU(t15) {
  return !!p4 && p4 in t15;
}
var JU = Function.prototype;
var QU = JU.toString;
function oa(t15) {
  if (t15 != null) {
    try {
      return QU.call(t15);
    } catch {
    }
    try {
      return t15 + "";
    } catch {
    }
  }
  return "";
}
var tV = /[\\^$.*+?()[\]{}|]/g;
var eV = /^\[object .+?Constructor\]$/;
var rV = Function.prototype;
var nV = Object.prototype;
var iV = rV.toString;
var sV = nV.hasOwnProperty;
var aV = RegExp(
  "^" + iV.call(sV).replace(tV, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function oV(t15) {
  if (!aa(t15) || ZU(t15))
    return false;
  var e = Km(t15) ? aV : eV;
  return e.test(oa(t15));
}
function lV(t15, e) {
  return t15 == null ? void 0 : t15[e];
}
function la(t15, e) {
  var r = lV(t15, e);
  return oV(r) ? r : void 0;
}
var Ul = la(Object, "create");
function cV() {
  this.__data__ = Ul ? Ul(null) : {}, this.size = 0;
}
function hV(t15) {
  var e = this.has(t15) && delete this.__data__[t15];
  return this.size -= e ? 1 : 0, e;
}
var uV = "__lodash_hash_undefined__";
var dV = Object.prototype;
var pV = dV.hasOwnProperty;
function fV(t15) {
  var e = this.__data__;
  if (Ul) {
    var r = e[t15];
    return r === uV ? void 0 : r;
  }
  return pV.call(e, t15) ? e[t15] : void 0;
}
var mV = Object.prototype;
var gV = mV.hasOwnProperty;
function yV(t15) {
  var e = this.__data__;
  return Ul ? e[t15] !== void 0 : gV.call(e, t15);
}
var bV = "__lodash_hash_undefined__";
function xV(t15, e) {
  var r = this.__data__;
  return this.size += this.has(t15) ? 0 : 1, r[t15] = Ul && e === void 0 ? bV : e, this;
}
function ta(t15) {
  var e = -1, r = t15 == null ? 0 : t15.length;
  for (this.clear(); ++e < r; ) {
    var n = t15[e];
    this.set(n[0], n[1]);
  }
}
ta.prototype.clear = cV;
ta.prototype.delete = hV;
ta.prototype.get = fV;
ta.prototype.has = yV;
ta.prototype.set = xV;
function wV() {
  this.__data__ = [], this.size = 0;
}
function Mu(t15, e) {
  return t15 === e || t15 !== t15 && e !== e;
}
function Bu(t15, e) {
  for (var r = t15.length; r--; )
    if (Mu(t15[r][0], e))
      return r;
  return -1;
}
var kV = Array.prototype;
var vV = kV.splice;
function CV(t15) {
  var e = this.__data__, r = Bu(e, t15);
  if (r < 0)
    return false;
  var n = e.length - 1;
  return r == n ? e.pop() : vV.call(e, r, 1), --this.size, true;
}
function _V(t15) {
  var e = this.__data__, r = Bu(e, t15);
  return r < 0 ? void 0 : e[r][1];
}
function SV(t15) {
  return Bu(this.__data__, t15) > -1;
}
function AV(t15, e) {
  var r = this.__data__, n = Bu(r, t15);
  return n < 0 ? (++this.size, r.push([t15, e])) : r[n][1] = e, this;
}
function Di(t15) {
  var e = -1, r = t15 == null ? 0 : t15.length;
  for (this.clear(); ++e < r; ) {
    var n = t15[e];
    this.set(n[0], n[1]);
  }
}
Di.prototype.clear = wV;
Di.prototype.delete = CV;
Di.prototype.get = _V;
Di.prototype.has = SV;
Di.prototype.set = AV;
var Vl = la(ri, "Map");
function TV() {
  this.size = 0, this.__data__ = {
    hash: new ta(),
    map: new (Vl || Di)(),
    string: new ta()
  };
}
function $V(t15) {
  var e = typeof t15;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t15 !== "__proto__" : t15 === null;
}
function Lu(t15, e) {
  var r = t15.__data__;
  return $V(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function EV(t15) {
  var e = Lu(this, t15).delete(t15);
  return this.size -= e ? 1 : 0, e;
}
function MV(t15) {
  return Lu(this, t15).get(t15);
}
function BV(t15) {
  return Lu(this, t15).has(t15);
}
function LV(t15, e) {
  var r = Lu(this, t15), n = r.size;
  return r.set(t15, e), this.size += r.size == n ? 0 : 1, this;
}
function ps(t15) {
  var e = -1, r = t15 == null ? 0 : t15.length;
  for (this.clear(); ++e < r; ) {
    var n = t15[e];
    this.set(n[0], n[1]);
  }
}
ps.prototype.clear = TV;
ps.prototype.delete = EV;
ps.prototype.get = MV;
ps.prototype.has = BV;
ps.prototype.set = LV;
var DV = "Expected a function";
function pc(t15, e) {
  if (typeof t15 != "function" || e != null && typeof e != "function")
    throw new TypeError(DV);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], s = r.cache;
    if (s.has(i))
      return s.get(i);
    var a = t15.apply(this, n);
    return r.cache = s.set(i, a) || s, a;
  };
  return r.cache = new (pc.Cache || ps)(), r;
}
pc.Cache = ps;
function FV() {
  this.__data__ = new Di(), this.size = 0;
}
function NV(t15) {
  var e = this.__data__, r = e.delete(t15);
  return this.size = e.size, r;
}
function IV(t15) {
  return this.__data__.get(t15);
}
function OV(t15) {
  return this.__data__.has(t15);
}
var zV = 200;
function qV(t15, e) {
  var r = this.__data__;
  if (r instanceof Di) {
    var n = r.__data__;
    if (!Vl || n.length < zV - 1)
      return n.push([t15, e]), this.size = ++r.size, this;
    r = this.__data__ = new ps(n);
  }
  return r.set(t15, e), this.size = r.size, this;
}
function yo(t15) {
  var e = this.__data__ = new Di(t15);
  this.size = e.size;
}
yo.prototype.clear = FV;
yo.prototype.delete = NV;
yo.prototype.get = IV;
yo.prototype.has = OV;
yo.prototype.set = qV;
var F0 = function() {
  try {
    var t15 = la(Object, "defineProperty");
    return t15({}, "", {}), t15;
  } catch {
  }
}();
function Zm(t15, e, r) {
  e == "__proto__" && F0 ? F0(t15, e, {
    configurable: true,
    enumerable: true,
    value: r,
    writable: true
  }) : t15[e] = r;
}
function t1(t15, e, r) {
  (r !== void 0 && !Mu(t15[e], r) || r === void 0 && !(e in t15)) && Zm(t15, e, r);
}
function RV(t15) {
  return function(e, r, n) {
    for (var i = -1, s = Object(e), a = n(e), o = a.length; o--; ) {
      var l = a[++i];
      if (r(s[l], l, s) === false)
        break;
    }
    return e;
  };
}
var PV = RV();
var Tk = typeof exports == "object" && exports && !exports.nodeType && exports;
var f4 = Tk && typeof module == "object" && module && !module.nodeType && module;
var jV = f4 && f4.exports === Tk;
var m4 = jV ? ri.Buffer : void 0;
var g4 = m4 ? m4.allocUnsafe : void 0;
function WV(t15, e) {
  if (e)
    return t15.slice();
  var r = t15.length, n = g4 ? g4(r) : new t15.constructor(r);
  return t15.copy(n), n;
}
var y4 = ri.Uint8Array;
function HV(t15) {
  var e = new t15.constructor(t15.byteLength);
  return new y4(e).set(new y4(t15)), e;
}
function UV(t15, e) {
  var r = e ? HV(t15.buffer) : t15.buffer;
  return new t15.constructor(r, t15.byteOffset, t15.length);
}
function VV(t15, e) {
  var r = -1, n = t15.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t15[r];
  return e;
}
var b4 = Object.create;
var GV = /* @__PURE__ */ function() {
  function t15() {
  }
  return function(e) {
    if (!aa(e))
      return {};
    if (b4)
      return b4(e);
    t15.prototype = e;
    var r = new t15();
    return t15.prototype = void 0, r;
  };
}();
function $k(t15, e) {
  return function(r) {
    return t15(e(r));
  };
}
var Ek = $k(Object.getPrototypeOf, Object);
var XV = Object.prototype;
function Du(t15) {
  var e = t15 && t15.constructor, r = typeof e == "function" && e.prototype || XV;
  return t15 === r;
}
function YV(t15) {
  return typeof t15.constructor == "function" && !Du(t15) ? GV(Ek(t15)) : {};
}
function fc(t15) {
  return t15 != null && typeof t15 == "object";
}
var KV = "[object Arguments]";
function x4(t15) {
  return fc(t15) && go(t15) == KV;
}
var Mk = Object.prototype;
var ZV = Mk.hasOwnProperty;
var JV = Mk.propertyIsEnumerable;
var N0 = x4(/* @__PURE__ */ function() {
  return arguments;
}()) ? x4 : function(t15) {
  return fc(t15) && ZV.call(t15, "callee") && !JV.call(t15, "callee");
};
var I0 = Array.isArray;
var QV = 9007199254740991;
function Bk(t15) {
  return typeof t15 == "number" && t15 > -1 && t15 % 1 == 0 && t15 <= QV;
}
function Fu(t15) {
  return t15 != null && Bk(t15.length) && !Km(t15);
}
function tG(t15) {
  return fc(t15) && Fu(t15);
}
function eG() {
  return false;
}
var Lk = typeof exports == "object" && exports && !exports.nodeType && exports;
var w4 = Lk && typeof module == "object" && module && !module.nodeType && module;
var rG = w4 && w4.exports === Lk;
var k4 = rG ? ri.Buffer : void 0;
var nG = k4 ? k4.isBuffer : void 0;
var Jm = nG || eG;
var iG = "[object Object]";
var sG = Function.prototype;
var aG = Object.prototype;
var Dk = sG.toString;
var oG = aG.hasOwnProperty;
var lG = Dk.call(Object);
function cG(t15) {
  if (!fc(t15) || go(t15) != iG)
    return false;
  var e = Ek(t15);
  if (e === null)
    return true;
  var r = oG.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && Dk.call(r) == lG;
}
var hG = "[object Arguments]";
var uG = "[object Array]";
var dG = "[object Boolean]";
var pG = "[object Date]";
var fG = "[object Error]";
var mG = "[object Function]";
var gG = "[object Map]";
var yG = "[object Number]";
var bG = "[object Object]";
var xG = "[object RegExp]";
var wG = "[object Set]";
var kG = "[object String]";
var vG = "[object WeakMap]";
var CG = "[object ArrayBuffer]";
var _G = "[object DataView]";
var SG = "[object Float32Array]";
var AG = "[object Float64Array]";
var TG = "[object Int8Array]";
var $G = "[object Int16Array]";
var EG = "[object Int32Array]";
var MG = "[object Uint8Array]";
var BG = "[object Uint8ClampedArray]";
var LG = "[object Uint16Array]";
var DG = "[object Uint32Array]";
var Me = {};
Me[SG] = Me[AG] = Me[TG] = Me[$G] = Me[EG] = Me[MG] = Me[BG] = Me[LG] = Me[DG] = true;
Me[hG] = Me[uG] = Me[CG] = Me[dG] = Me[_G] = Me[pG] = Me[fG] = Me[mG] = Me[gG] = Me[yG] = Me[bG] = Me[xG] = Me[wG] = Me[kG] = Me[vG] = false;
function FG(t15) {
  return fc(t15) && Bk(t15.length) && !!Me[go(t15)];
}
function NG(t15) {
  return function(e) {
    return t15(e);
  };
}
var Fk = typeof exports == "object" && exports && !exports.nodeType && exports;
var wl = Fk && typeof module == "object" && module && !module.nodeType && module;
var IG = wl && wl.exports === Fk;
var _p = IG && Sk.process;
var v4 = function() {
  try {
    var t15 = wl && wl.require && wl.require("util").types;
    return t15 || _p && _p.binding && _p.binding("util");
  } catch {
  }
}();
var C4 = v4 && v4.isTypedArray;
var Qm = C4 ? NG(C4) : FG;
function e1(t15, e) {
  if (!(e === "constructor" && typeof t15[e] == "function") && e != "__proto__")
    return t15[e];
}
var OG = Object.prototype;
var zG = OG.hasOwnProperty;
function qG(t15, e, r) {
  var n = t15[e];
  (!(zG.call(t15, e) && Mu(n, r)) || r === void 0 && !(e in t15)) && Zm(t15, e, r);
}
function RG(t15, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var s = -1, a = e.length; ++s < a; ) {
    var o = e[s], l = void 0;
    l === void 0 && (l = t15[o]), i ? Zm(r, o, l) : qG(r, o, l);
  }
  return r;
}
function PG(t15, e) {
  for (var r = -1, n = Array(t15); ++r < t15; )
    n[r] = e(r);
  return n;
}
var jG = 9007199254740991;
var WG = /^(?:0|[1-9]\d*)$/;
function Nk(t15, e) {
  var r = typeof t15;
  return e = e ?? jG, !!e && (r == "number" || r != "symbol" && WG.test(t15)) && t15 > -1 && t15 % 1 == 0 && t15 < e;
}
var HG = Object.prototype;
var UG = HG.hasOwnProperty;
function VG(t15, e) {
  var r = I0(t15), n = !r && N0(t15), i = !r && !n && Jm(t15), s = !r && !n && !i && Qm(t15), a = r || n || i || s, o = a ? PG(t15.length, String) : [], l = o.length;
  for (var c in t15)
    (e || UG.call(t15, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    Nk(c, l))) && o.push(c);
  return o;
}
function GG(t15) {
  var e = [];
  if (t15 != null)
    for (var r in Object(t15))
      e.push(r);
  return e;
}
var XG = Object.prototype;
var YG = XG.hasOwnProperty;
function KG(t15) {
  if (!aa(t15))
    return GG(t15);
  var e = Du(t15), r = [];
  for (var n in t15)
    n == "constructor" && (e || !YG.call(t15, n)) || r.push(n);
  return r;
}
function Ik(t15) {
  return Fu(t15) ? VG(t15, true) : KG(t15);
}
function ZG(t15) {
  return RG(t15, Ik(t15));
}
function JG(t15, e, r, n, i, s, a) {
  var o = e1(t15, r), l = e1(e, r), c = a.get(l);
  if (c) {
    t1(t15, r, c);
    return;
  }
  var h = s ? s(o, l, r + "", t15, e, a) : void 0, p = h === void 0;
  if (p) {
    var m = I0(l), g = !m && Jm(l), y = !m && !g && Qm(l);
    h = l, m || g || y ? I0(o) ? h = o : tG(o) ? h = VV(o) : g ? (p = false, h = WV(l, true)) : y ? (p = false, h = UV(l, true)) : h = [] : cG(l) || N0(l) ? (h = o, N0(o) ? h = ZG(o) : (!aa(o) || Km(o)) && (h = YV(l))) : p = false;
  }
  p && (a.set(l, h), i(h, l, n, s, a), a.delete(l)), t1(t15, r, h);
}
function Ok(t15, e, r, n, i) {
  t15 !== e && PV(e, function(s, a) {
    if (i || (i = new yo()), aa(s))
      JG(t15, e, a, r, Ok, n, i);
    else {
      var o = n ? n(e1(t15, a), s, a + "", t15, e, i) : void 0;
      o === void 0 && (o = s), t1(t15, a, o);
    }
  }, Ik);
}
function zk(t15) {
  return t15;
}
function QG(t15, e, r) {
  switch (r.length) {
    case 0:
      return t15.call(e);
    case 1:
      return t15.call(e, r[0]);
    case 2:
      return t15.call(e, r[0], r[1]);
    case 3:
      return t15.call(e, r[0], r[1], r[2]);
  }
  return t15.apply(e, r);
}
var _4 = Math.max;
function tX(t15, e, r) {
  return e = _4(e === void 0 ? t15.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, s = _4(n.length - e, 0), a = Array(s); ++i < s; )
      a[i] = n[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = n[i];
    return o[e] = r(a), QG(t15, this, o);
  };
}
function eX(t15) {
  return function() {
    return t15;
  };
}
var rX = F0 ? function(t15, e) {
  return F0(t15, "toString", {
    configurable: true,
    enumerable: false,
    value: eX(e),
    writable: true
  });
} : zk;
var nX = 800;
var iX = 16;
var sX = Date.now;
function aX(t15) {
  var e = 0, r = 0;
  return function() {
    var n = sX(), i = iX - (n - r);
    if (r = n, i > 0) {
      if (++e >= nX)
        return arguments[0];
    } else
      e = 0;
    return t15.apply(void 0, arguments);
  };
}
var oX = aX(rX);
function lX(t15, e) {
  return oX(tX(t15, e, zk), t15 + "");
}
function cX(t15, e, r) {
  if (!aa(r))
    return false;
  var n = typeof e;
  return (n == "number" ? Fu(r) && Nk(e, r.length) : n == "string" && e in r) ? Mu(r[e], t15) : false;
}
function hX(t15) {
  return lX(function(e, r) {
    var n = -1, i = r.length, s = i > 1 ? r[i - 1] : void 0, a = i > 2 ? r[2] : void 0;
    for (s = t15.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && cX(r[0], r[1], a) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++n < i; ) {
      var o = r[n];
      o && t15(e, o, n, s);
    }
    return e;
  });
}
var uX = hX(function(t15, e, r) {
  Ok(t15, e, r);
});
var dX = "​";
var pX = {
  curveBasis: Nh,
  curveBasisClosed: MU,
  curveBasisOpen: BU,
  curveBumpX: sk,
  curveBumpY: ak,
  curveBundle: LU,
  curveCardinalClosed: DU,
  curveCardinalOpen: FU,
  curveCardinal: hk,
  curveCatmullRomClosed: NU,
  curveCatmullRomOpen: IU,
  curveCatmullRom: dk,
  curveLinear: E0,
  curveLinearClosed: OU,
  curveMonotoneX: bk,
  curveMonotoneY: xk,
  curveNatural: kk,
  curveStep: vk,
  curveStepAfter: _k,
  curveStepBefore: Ck
};
var fX = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
var mX = _(function(t15, e) {
  const r = qk(t15, /(?:init\b)|(?:initialize\b)/);
  let n = {};
  if (Array.isArray(r)) {
    const a = r.map((o) => o.args);
    p0(a), n = ur(n, [...a]);
  } else
    n = r.args;
  if (!n)
    return;
  let i = _m(t15, e);
  const s = "config";
  return n[s] !== void 0 && (i === "flowchart-v2" && (i = "flowchart"), n[i] = n[s], delete n[s]), n;
}, "detectInit");
var qk = _(function(t15, e = null) {
  var _a3, _b2;
  try {
    const r = new RegExp(
      `[%]{2}(?![{]${fX.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    t15 = t15.trim().replace(r, "").replace(/'/gm, '"'), ut.debug(
      `Detecting diagram directive${e !== null ? " type:" + e : ""} based on the text:${t15}`
    );
    let n;
    const i = [];
    for (; (n = bl.exec(t15)) !== null; )
      if (n.index === bl.lastIndex && bl.lastIndex++, n && !e || e && ((_a3 = n[1]) == null ? void 0 : _a3.match(e)) || e && ((_b2 = n[2]) == null ? void 0 : _b2.match(e))) {
        const s = n[1] ? n[1] : n[2], a = n[3] ? n[3].trim() : n[4] ? JSON.parse(n[4].trim()) : null;
        i.push({ type: s, args: a });
      }
    return i.length === 0 ? { type: t15, args: null } : i.length === 1 ? i[0] : i;
  } catch (r) {
    return ut.error(
      `ERROR: ${r.message} - Unable to parse directive type: '${e}' based on the text: '${t15}'`
    ), { type: void 0, args: null };
  }
}, "detectDirective");
var gX = _(function(t15) {
  return t15.replace(bl, "");
}, "removeDirectives");
var yX = _(function(t15, e) {
  for (const [r, n] of e.entries())
    if (n.match(t15))
      return r;
  return -1;
}, "isSubstringInArray");
function tg(t15, e) {
  if (!t15)
    return e;
  const r = `curve${t15.charAt(0).toUpperCase() + t15.slice(1)}`;
  return pX[r] ?? e;
}
_(tg, "interpolateToCurve");
function Rk(t15, e) {
  const r = t15.trim();
  if (r)
    return e.securityLevel !== "loose" ? oj.sanitizeUrl(r) : r;
}
_(Rk, "formatUrl");
var bX = _((t15, ...e) => {
  const r = t15.split("."), n = r.length - 1, i = r[n];
  let s = window;
  for (let a = 0; a < n; a++)
    if (s = s[r[a]], !s) {
      ut.error(`Function name: ${t15} not found in window`);
      return;
    }
  s[i](...e);
}, "runFunc");
function eg(t15, e) {
  return !t15 || !e ? 0 : Math.sqrt(Math.pow(e.x - t15.x, 2) + Math.pow(e.y - t15.y, 2));
}
_(eg, "distance");
function Pk(t15) {
  let e, r = 0;
  t15.forEach((i) => {
    r += eg(i, e), e = i;
  });
  const n = r / 2;
  return rg(t15, n);
}
_(Pk, "traverseEdge");
function jk(t15) {
  return t15.length === 1 ? t15[0] : Pk(t15);
}
_(jk, "calcLabelPosition");
var S4 = _((t15, e = 2) => {
  const r = Math.pow(10, e);
  return Math.round(t15 * r) / r;
}, "roundNumber");
var rg = _((t15, e) => {
  let r, n = e;
  for (const i of t15) {
    if (r) {
      const s = eg(i, r);
      if (s === 0)
        return r;
      if (s < n)
        n -= s;
      else {
        const a = n / s;
        if (a <= 0)
          return r;
        if (a >= 1)
          return { x: i.x, y: i.y };
        if (a > 0 && a < 1)
          return {
            x: S4((1 - a) * r.x + a * i.x, 5),
            y: S4((1 - a) * r.y + a * i.y, 5)
          };
      }
    }
    r = i;
  }
  throw new Error("Could not find a suitable point for the given distance");
}, "calculatePoint");
var xX = _((t15, e, r) => {
  ut.info(`our points ${JSON.stringify(e)}`), e[0] !== r && (e = e.reverse());
  const n = rg(e, 25), i = t15 ? 10 : 5, s = Math.atan2(e[0].y - n.y, e[0].x - n.x), a = { x: 0, y: 0 };
  return a.x = Math.sin(s) * i + (e[0].x + n.x) / 2, a.y = -Math.cos(s) * i + (e[0].y + n.y) / 2, a;
}, "calcCardinalityPosition");
function Wk(t15, e, r) {
  const n = structuredClone(r);
  ut.info("our points", n), e !== "start_left" && e !== "start_right" && n.reverse();
  const i = 25 + t15, s = rg(n, i), a = 10 + t15 * 0.5, o = Math.atan2(n[0].y - s.y, n[0].x - s.x), l = { x: 0, y: 0 };
  return e === "start_left" ? (l.x = Math.sin(o + Math.PI) * a + (n[0].x + s.x) / 2, l.y = -Math.cos(o + Math.PI) * a + (n[0].y + s.y) / 2) : e === "end_right" ? (l.x = Math.sin(o - Math.PI) * a + (n[0].x + s.x) / 2 - 5, l.y = -Math.cos(o - Math.PI) * a + (n[0].y + s.y) / 2 - 5) : e === "end_left" ? (l.x = Math.sin(o) * a + (n[0].x + s.x) / 2 - 5, l.y = -Math.cos(o) * a + (n[0].y + s.y) / 2 - 5) : (l.x = Math.sin(o) * a + (n[0].x + s.x) / 2, l.y = -Math.cos(o) * a + (n[0].y + s.y) / 2), l;
}
_(Wk, "calcTerminalLabelPosition");
function Hk(t15) {
  let e = "", r = "";
  for (const n of t15)
    n !== void 0 && (n.startsWith("color:") || n.startsWith("text-align:") ? r = r + n + ";" : e = e + n + ";");
  return { style: e, labelStyle: r };
}
_(Hk, "getStylesFromArray");
var A4 = 0;
var wX = _(() => (A4++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + A4), "generateId");
function Uk(t15) {
  let e = "";
  const r = "0123456789abcdef", n = r.length;
  for (let i = 0; i < t15; i++)
    e += r.charAt(Math.floor(Math.random() * n));
  return e;
}
_(Uk, "makeRandomHex");
var kX = _((t15) => Uk(t15.length), "random");
var vX = _(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0,
    text: ""
  };
}, "getTextObj");
var CX = _(function(t15, e) {
  const r = e.text.replace(fo.lineBreakRegex, " "), [, n] = Nu(e.fontSize), i = t15.append("text");
  i.attr("x", e.x), i.attr("y", e.y), i.style("text-anchor", e.anchor), i.style("font-family", e.fontFamily), i.style("font-size", n), i.style("font-weight", e.fontWeight), i.attr("fill", e.fill), e.class !== void 0 && i.attr("class", e.class);
  const s = i.append("tspan");
  return s.attr("x", e.x + e.textMargin * 2), s.attr("fill", e.fill), s.text(r), i;
}, "drawSimpleText");
var _X = pc(
  (t15, e, r) => {
    if (!t15 || (r = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      r
    ), fo.lineBreakRegex.test(t15)))
      return t15;
    const n = t15.split(" ").filter(Boolean), i = [];
    let s = "";
    return n.forEach((a, o) => {
      const l = Bi(`${a} `, r), c = Bi(s, r);
      if (l > e) {
        const { hyphenatedStrings: h, remainingWord: p } = SX(a, e, "-", r);
        i.push(s, ...h), s = p;
      } else c + l >= e ? (i.push(s), s = a) : s = [s, a].filter(Boolean).join(" ");
      o + 1 === n.length && i.push(s);
    }), i.filter((a) => a !== "").join(r.joinWith);
  },
  (t15, e, r) => `${t15}${e}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`
);
var SX = pc(
  (t15, e, r = "-", n) => {
    n = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      n
    );
    const i = [...t15], s = [];
    let a = "";
    return i.forEach((o, l) => {
      const c = `${a}${o}`;
      if (Bi(c, n) >= e) {
        const h = l + 1, p = i.length === h, m = `${c}${r}`;
        s.push(p ? c : m), a = "";
      } else
        a = c;
    }), { hyphenatedStrings: s, remainingWord: a };
  },
  (t15, e, r = "-", n) => `${t15}${e}${r}${n.fontSize}${n.fontWeight}${n.fontFamily}`
);
function Vk(t15, e) {
  return ng(t15, e).height;
}
_(Vk, "calculateTextHeight");
function Bi(t15, e) {
  return ng(t15, e).width;
}
_(Bi, "calculateTextWidth");
var ng = pc(
  (t15, e) => {
    const { fontSize: r = 12, fontFamily: n = "Arial", fontWeight: i = 400 } = e;
    if (!t15)
      return { width: 0, height: 0 };
    const [, s] = Nu(r), a = ["sans-serif", n], o = t15.split(fo.lineBreakRegex), l = [], c = ae("body");
    if (!c.remove)
      return { width: 0, height: 0, lineHeight: 0 };
    const h = c.append("svg");
    for (const m of a) {
      let g = 0;
      const y = { width: 0, height: 0, lineHeight: 0 };
      for (const x of o) {
        const k = vX();
        k.text = x || dX;
        const C = CX(h, k).style("font-size", s).style("font-weight", i).style("font-family", m), A = (C._groups || C)[0][0].getBBox();
        if (A.width === 0 && A.height === 0)
          throw new Error("svg element not in render tree");
        y.width = Math.round(Math.max(y.width, A.width)), g = Math.round(A.height), y.height += g, y.lineHeight = Math.round(Math.max(y.lineHeight, g));
      }
      l.push(y);
    }
    h.remove();
    const p = isNaN(l[1].height) || isNaN(l[1].width) || isNaN(l[1].lineHeight) || l[0].height > l[1].height && l[0].width > l[1].width && l[0].lineHeight > l[1].lineHeight ? 0 : 1;
    return l[p];
  },
  (t15, e) => `${t15}${e.fontSize}${e.fontWeight}${e.fontFamily}`
);
var Sp;
var AX = (Sp = class {
  constructor(t15 = false, e) {
    this.count = 0, this.count = e ? e.length : 0, this.next = t15 ? () => this.count++ : () => Date.now();
  }
}, _(Sp, "InitIDGenerator"), Sp);
var lh;
var TX = _(function(t15) {
  return lh = lh || document.createElement("div"), t15 = escape(t15).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), lh.innerHTML = t15, unescape(lh.textContent);
}, "entityDecode");
function ig(t15) {
  return "str" in t15;
}
_(ig, "isDetailedError");
var $X = _((t15, e, r, n) => {
  var _a3;
  if (!n)
    return;
  const i = (_a3 = t15.node()) == null ? void 0 : _a3.getBBox();
  i && t15.append("text").text(n).attr("text-anchor", "middle").attr("x", i.x + i.width / 2).attr("y", -r).attr("class", e);
}, "insertTitle");
var Nu = _((t15) => {
  if (typeof t15 == "number")
    return [t15, t15 + "px"];
  const e = parseInt(t15 ?? "", 10);
  return Number.isNaN(e) ? [void 0, void 0] : t15 === String(e) ? [e, t15 + "px"] : [e, t15];
}, "parseFontSize");
function sg(t15, e) {
  return uX({}, t15, e);
}
_(sg, "cleanAndMerge");
var Wn = {
  assignWithDepth: ur,
  wrapLabel: _X,
  calculateTextHeight: Vk,
  calculateTextWidth: Bi,
  calculateTextDimensions: ng,
  cleanAndMerge: sg,
  detectInit: mX,
  detectDirective: qk,
  isSubstringInArray: yX,
  interpolateToCurve: tg,
  calcLabelPosition: jk,
  calcCardinalityPosition: xX,
  calcTerminalLabelPosition: Wk,
  formatUrl: Rk,
  getStylesFromArray: Hk,
  generateId: wX,
  random: kX,
  runFunc: bX,
  entityDecode: TX,
  insertTitle: $X,
  parseFontSize: Nu,
  InitIDGenerator: AX
};
var EX = _(function(t15) {
  let e = t15;
  return e = e.replace(/style.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/classDef.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/#\w+;/g, function(r) {
    const n = r.substring(1, r.length - 1);
    return /^\+?\d+$/.test(n) ? "ﬂ°°" + n + "¶ß" : "ﬂ°" + n + "¶ß";
  }), e;
}, "encodeEntities");
var ca = _(function(t15) {
  return t15.replace(/ﬂ°°/g, "&#").replace(/ﬂ°/g, "&").replace(/¶ß/g, ";");
}, "decodeEntities");
var vrt = _((t15, e, {
  counter: r = 0,
  prefix: n,
  suffix: i
}, s) => s || `${n ? `${n}_` : ""}${t15}_${e}_${r}${i ? `_${i}` : ""}`, "getEdgeId");
function Tr(t15) {
  return t15 ?? null;
}
_(Tr, "handleUndefinedAttr");
var MX = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var O0 = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var Gk = Object.freeze({
  ...MX,
  ...O0
});
var BX = Object.freeze({
  ...Gk,
  body: "",
  hidden: false
});
var LX = Object.freeze({
  width: null,
  height: null
});
var DX = Object.freeze({
  // Dimensions
  ...LX,
  // Transformations
  ...O0
});
var FX = (t15, e, r, n = "") => {
  const i = t15.split(":");
  if (t15.slice(0, 1) === "@") {
    if (i.length < 2 || i.length > 3)
      return null;
    n = i.shift().slice(1);
  }
  if (i.length > 3 || !i.length)
    return null;
  if (i.length > 1) {
    const o = i.pop(), l = i.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: i.length > 0 ? i[0] : n,
      prefix: l,
      name: o
    };
    return Ap(c) ? c : null;
  }
  const s = i[0], a = s.split("-");
  if (a.length > 1) {
    const o = {
      provider: n,
      prefix: a.shift(),
      name: a.join("-")
    };
    return Ap(o) ? o : null;
  }
  if (r && n === "") {
    const o = {
      provider: n,
      prefix: "",
      name: s
    };
    return Ap(o, r) ? o : null;
  }
  return null;
};
var Ap = (t15, e) => t15 ? !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
// Check name: cannot be empty
((e && t15.prefix === "" || t15.prefix) && t15.name) : false;
function NX(t15, e) {
  const r = {};
  !t15.hFlip != !e.hFlip && (r.hFlip = true), !t15.vFlip != !e.vFlip && (r.vFlip = true);
  const n = ((t15.rotate || 0) + (e.rotate || 0)) % 4;
  return n && (r.rotate = n), r;
}
function T4(t15, e) {
  const r = NX(t15, e);
  for (const n in BX)
    n in O0 ? n in t15 && !(n in r) && (r[n] = O0[n]) : n in e ? r[n] = e[n] : n in t15 && (r[n] = t15[n]);
  return r;
}
function IX(t15, e) {
  const r = t15.icons, n = t15.aliases || /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function s(a) {
    if (r[a])
      return i[a] = [];
    if (!(a in i)) {
      i[a] = null;
      const o = n[a] && n[a].parent, l = o && s(o);
      l && (i[a] = [o].concat(l));
    }
    return i[a];
  }
  return (e || Object.keys(r).concat(Object.keys(n))).forEach(s), i;
}
function $4(t15, e, r) {
  const n = t15.icons, i = t15.aliases || /* @__PURE__ */ Object.create(null);
  let s = {};
  function a(o) {
    s = T4(
      n[o] || i[o],
      s
    );
  }
  return a(e), r.forEach(a), T4(t15, s);
}
function OX(t15, e) {
  if (t15.icons[e])
    return $4(t15, e, []);
  const r = IX(t15, [e])[e];
  return r ? $4(t15, e, r) : null;
}
var zX = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var qX = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function E4(t15, e, r) {
  if (e === 1)
    return t15;
  if (r = r || 100, typeof t15 == "number")
    return Math.ceil(t15 * e * r) / r;
  if (typeof t15 != "string")
    return t15;
  const n = t15.split(zX);
  if (n === null || !n.length)
    return t15;
  const i = [];
  let s = n.shift(), a = qX.test(s);
  for (; ; ) {
    if (a) {
      const o = parseFloat(s);
      isNaN(o) ? i.push(s) : i.push(Math.ceil(o * e * r) / r);
    } else
      i.push(s);
    if (s = n.shift(), s === void 0)
      return i.join("");
    a = !a;
  }
}
function RX(t15, e = "defs") {
  let r = "";
  const n = t15.indexOf("<" + e);
  for (; n >= 0; ) {
    const i = t15.indexOf(">", n), s = t15.indexOf("</" + e);
    if (i === -1 || s === -1)
      break;
    const a = t15.indexOf(">", s);
    if (a === -1)
      break;
    r += t15.slice(i + 1, s).trim(), t15 = t15.slice(0, n).trim() + t15.slice(a + 1);
  }
  return {
    defs: r,
    content: t15
  };
}
function PX(t15, e) {
  return t15 ? "<defs>" + t15 + "</defs>" + e : e;
}
function jX(t15, e, r) {
  const n = RX(t15);
  return PX(n.defs, e + n.content + r);
}
var WX = (t15) => t15 === "unset" || t15 === "undefined" || t15 === "none";
function HX(t15, e) {
  const r = {
    ...Gk,
    ...t15
  }, n = {
    ...DX,
    ...e
  }, i = {
    left: r.left,
    top: r.top,
    width: r.width,
    height: r.height
  };
  let s = r.body;
  [r, n].forEach((x) => {
    const k = [], C = x.hFlip, A = x.vFlip;
    let $ = x.rotate;
    C ? A ? $ += 2 : (k.push(
      "translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"
    ), k.push("scale(-1 1)"), i.top = i.left = 0) : A && (k.push(
      "translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"
    ), k.push("scale(1 -1)"), i.top = i.left = 0);
    let B;
    switch ($ < 0 && ($ -= Math.floor($ / 4) * 4), $ = $ % 4, $) {
      case 1:
        B = i.height / 2 + i.top, k.unshift(
          "rotate(90 " + B.toString() + " " + B.toString() + ")"
        );
        break;
      case 2:
        k.unshift(
          "rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")"
        );
        break;
      case 3:
        B = i.width / 2 + i.left, k.unshift(
          "rotate(-90 " + B.toString() + " " + B.toString() + ")"
        );
        break;
    }
    $ % 2 === 1 && (i.left !== i.top && (B = i.left, i.left = i.top, i.top = B), i.width !== i.height && (B = i.width, i.width = i.height, i.height = B)), k.length && (s = jX(
      s,
      '<g transform="' + k.join(" ") + '">',
      "</g>"
    ));
  });
  const a = n.width, o = n.height, l = i.width, c = i.height;
  let h, p;
  a === null ? (p = o === null ? "1em" : o === "auto" ? c : o, h = E4(p, l / c)) : (h = a === "auto" ? l : a, p = o === null ? E4(h, c / l) : o === "auto" ? c : o);
  const m = {}, g = (x, k) => {
    WX(k) || (m[x] = k.toString());
  };
  g("width", h), g("height", p);
  const y = [i.left, i.top, l, c];
  return m.viewBox = y.join(" "), {
    attributes: m,
    viewBox: y,
    body: s
  };
}
var UX = /\sid="(\S+)"/g;
var VX = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
var GX = 0;
function XX(t15, e = VX) {
  const r = [];
  let n;
  for (; n = UX.exec(t15); )
    r.push(n[1]);
  if (!r.length)
    return t15;
  const i = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return r.forEach((s) => {
    const a = typeof e == "function" ? e(s) : e + (GX++).toString(), o = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t15 = t15.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + o + ')([")]|\\.[a-z])', "g"),
      "$1" + a + i + "$3"
    );
  }), t15 = t15.replace(new RegExp(i, "g"), ""), t15;
}
function YX(t15, e) {
  let r = t15.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in e)
    r += " " + n + '="' + e[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + r + ">" + t15 + "</svg>";
}
function ag() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var ha = ag();
function Xk(t15) {
  ha = t15;
}
var kl = { exec: () => null };
function ye(t15, e = "") {
  let r = typeof t15 == "string" ? t15 : t15.source, n = { replace: (i, s) => {
    let a = typeof s == "string" ? s : s.source;
    return a = a.replace(Ar.caret, "$1"), r = r.replace(i, a), n;
  }, getRegex: () => new RegExp(r, e) };
  return n;
}
var Ar = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t15) => new RegExp(`^( {0,3}${t15})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}#`), htmlBeginRegex: (t15) => new RegExp(`^ {0,${Math.min(3, t15 - 1)}}<(?:[a-z].*>|!--)`, "i") };
var KX = /^(?:[ \t]*(?:\n|$))+/;
var ZX = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
var JX = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var mc = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var QX = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var og = /(?:[*+-]|\d{1,9}[.)])/;
var Yk = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
var Kk = ye(Yk).replace(/bull/g, og).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
var tY = ye(Yk).replace(/bull/g, og).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
var lg = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var eY = /^[^\n]+/;
var cg = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var rY = ye(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", cg).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var nY = ye(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, og).getRegex();
var Iu = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var hg = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var iY = ye("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", hg).replace("tag", Iu).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var Zk = ye(lg).replace("hr", mc).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Iu).getRegex();
var sY = ye(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", Zk).getRegex();
var ug = { blockquote: sY, code: ZX, def: rY, fences: JX, heading: QX, hr: mc, html: iY, lheading: Kk, list: nY, newline: KX, paragraph: Zk, table: kl, text: eY };
var M4 = ye("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", mc).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Iu).getRegex();
var aY = { ...ug, lheading: tY, table: M4, paragraph: ye(lg).replace("hr", mc).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", M4).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Iu).getRegex() };
var oY = { ...ug, html: ye(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", hg).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: kl, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: ye(lg).replace("hr", mc).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Kk).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() };
var lY = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var cY = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var Jk = /^( {2,}|\\)\n(?!\s*$)/;
var hY = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var Ou = /[\p{P}\p{S}]/u;
var dg = /[\s\p{P}\p{S}]/u;
var Qk = /[^\s\p{P}\p{S}]/u;
var uY = ye(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, dg).getRegex();
var tv = /(?!~)[\p{P}\p{S}]/u;
var dY = /(?!~)[\s\p{P}\p{S}]/u;
var pY = /(?:[^\s\p{P}\p{S}]|~)/u;
var fY = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g;
var ev = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
var mY = ye(ev, "u").replace(/punct/g, Ou).getRegex();
var gY = ye(ev, "u").replace(/punct/g, tv).getRegex();
var rv = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
var yY = ye(rv, "gu").replace(/notPunctSpace/g, Qk).replace(/punctSpace/g, dg).replace(/punct/g, Ou).getRegex();
var bY = ye(rv, "gu").replace(/notPunctSpace/g, pY).replace(/punctSpace/g, dY).replace(/punct/g, tv).getRegex();
var xY = ye("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, Qk).replace(/punctSpace/g, dg).replace(/punct/g, Ou).getRegex();
var wY = ye(/\\(punct)/, "gu").replace(/punct/g, Ou).getRegex();
var kY = ye(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var vY = ye(hg).replace("(?:-->|$)", "-->").getRegex();
var CY = ye("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", vY).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var z0 = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var _Y = ye(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", z0).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var nv = ye(/^!?\[(label)\]\[(ref)\]/).replace("label", z0).replace("ref", cg).getRegex();
var iv = ye(/^!?\[(ref)\](?:\[\])?/).replace("ref", cg).getRegex();
var SY = ye("reflink|nolink(?!\\()", "g").replace("reflink", nv).replace("nolink", iv).getRegex();
var pg = { _backpedal: kl, anyPunctuation: wY, autolink: kY, blockSkip: fY, br: Jk, code: cY, del: kl, emStrongLDelim: mY, emStrongRDelimAst: yY, emStrongRDelimUnd: xY, escape: lY, link: _Y, nolink: iv, punctuation: uY, reflink: nv, reflinkSearch: SY, tag: CY, text: hY, url: kl };
var AY = { ...pg, link: ye(/^!?\[(label)\]\((.*?)\)/).replace("label", z0).getRegex(), reflink: ye(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", z0).getRegex() };
var r1 = { ...pg, emStrongRDelimAst: bY, emStrongLDelim: gY, url: ye(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ };
var TY = { ...r1, br: ye(Jk).replace("{2,}", "*").getRegex(), text: ye(r1.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() };
var ch = { normal: ug, gfm: aY, pedantic: oY };
var Uo = { normal: pg, gfm: r1, breaks: TY, pedantic: AY };
var $Y = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
var B4 = (t15) => $Y[t15];
function In(t15, e) {
  if (e) {
    if (Ar.escapeTest.test(t15)) return t15.replace(Ar.escapeReplace, B4);
  } else if (Ar.escapeTestNoEncode.test(t15)) return t15.replace(Ar.escapeReplaceNoEncode, B4);
  return t15;
}
function L4(t15) {
  try {
    t15 = encodeURI(t15).replace(Ar.percentDecode, "%");
  } catch {
    return null;
  }
  return t15;
}
function D4(t15, e) {
  var _a3;
  let r = t15.replace(Ar.findPipe, (s, a, o) => {
    let l = false, c = a;
    for (; --c >= 0 && o[c] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), n = r.split(Ar.splitPipe), i = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !((_a3 = n.at(-1)) == null ? void 0 : _a3.trim()) && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; i < n.length; i++) n[i] = n[i].trim().replace(Ar.slashPipe, "|");
  return n;
}
function Vo(t15, e, r) {
  let n = t15.length;
  if (n === 0) return "";
  let i = 0;
  for (; i < n && t15.charAt(n - i - 1) === e; )
    i++;
  return t15.slice(0, n - i);
}
function EY(t15, e) {
  if (t15.indexOf(e[1]) === -1) return -1;
  let r = 0;
  for (let n = 0; n < t15.length; n++) if (t15[n] === "\\") n++;
  else if (t15[n] === e[0]) r++;
  else if (t15[n] === e[1] && (r--, r < 0)) return n;
  return r > 0 ? -2 : -1;
}
function F4(t15, e, r, n, i) {
  let s = e.href, a = e.title || null, o = t15[1].replace(i.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let l = { type: t15[0].charAt(0) === "!" ? "image" : "link", raw: r, href: s, title: a, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = false, l;
}
function MY(t15, e, r) {
  let n = t15.match(r.other.indentCodeCompensation);
  if (n === null) return e;
  let i = n[1];
  return e.split(`
`).map((s) => {
    let a = s.match(r.other.beginningSpace);
    if (a === null) return s;
    let [o] = a;
    return o.length >= i.length ? s.slice(i.length) : s;
  }).join(`
`);
}
var q0 = class {
  constructor(t15) {
    __publicField(this, "options");
    __publicField(this, "rules");
    __publicField(this, "lexer");
    this.options = t15 || ha;
  }
  space(t15) {
    let e = this.rules.block.newline.exec(t15);
    if (e && e[0].length > 0) return { type: "space", raw: e[0] };
  }
  code(t15) {
    let e = this.rules.block.code.exec(t15);
    if (e) {
      let r = e[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: e[0], codeBlockStyle: "indented", text: this.options.pedantic ? r : Vo(r, `
`) };
    }
  }
  fences(t15) {
    let e = this.rules.block.fences.exec(t15);
    if (e) {
      let r = e[0], n = MY(r, e[3] || "", this.rules);
      return { type: "code", raw: r, lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2], text: n };
    }
  }
  heading(t15) {
    let e = this.rules.block.heading.exec(t15);
    if (e) {
      let r = e[2].trim();
      if (this.rules.other.endingHash.test(r)) {
        let n = Vo(r, "#");
        (this.options.pedantic || !n || this.rules.other.endingSpaceChar.test(n)) && (r = n.trim());
      }
      return { type: "heading", raw: e[0], depth: e[1].length, text: r, tokens: this.lexer.inline(r) };
    }
  }
  hr(t15) {
    let e = this.rules.block.hr.exec(t15);
    if (e) return { type: "hr", raw: Vo(e[0], `
`) };
  }
  blockquote(t15) {
    let e = this.rules.block.blockquote.exec(t15);
    if (e) {
      let r = Vo(e[0], `
`).split(`
`), n = "", i = "", s = [];
      for (; r.length > 0; ) {
        let a = false, o = [], l;
        for (l = 0; l < r.length; l++) if (this.rules.other.blockquoteStart.test(r[l])) o.push(r[l]), a = true;
        else if (!a) o.push(r[l]);
        else break;
        r = r.slice(l);
        let c = o.join(`
`), h = c.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        n = n ? `${n}
${c}` : c, i = i ? `${i}
${h}` : h;
        let p = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(h, s, true), this.lexer.state.top = p, r.length === 0) break;
        let m = s.at(-1);
        if ((m == null ? void 0 : m.type) === "code") break;
        if ((m == null ? void 0 : m.type) === "blockquote") {
          let g = m, y = g.raw + `
` + r.join(`
`), x = this.blockquote(y);
          s[s.length - 1] = x, n = n.substring(0, n.length - g.raw.length) + x.raw, i = i.substring(0, i.length - g.text.length) + x.text;
          break;
        } else if ((m == null ? void 0 : m.type) === "list") {
          let g = m, y = g.raw + `
` + r.join(`
`), x = this.list(y);
          s[s.length - 1] = x, n = n.substring(0, n.length - m.raw.length) + x.raw, i = i.substring(0, i.length - g.raw.length) + x.raw, r = y.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: n, tokens: s, text: i };
    }
  }
  list(t15) {
    let e = this.rules.block.list.exec(t15);
    if (e) {
      let r = e[1].trim(), n = r.length > 1, i = { type: "list", raw: "", ordered: n, start: n ? +r.slice(0, -1) : "", loose: false, items: [] };
      r = n ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = n ? r : "[*+-]");
      let s = this.rules.other.listItemRegex(r), a = false;
      for (; t15; ) {
        let l = false, c = "", h = "";
        if (!(e = s.exec(t15)) || this.rules.block.hr.test(t15)) break;
        c = e[0], t15 = t15.substring(c.length);
        let p = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (C) => " ".repeat(3 * C.length)), m = t15.split(`
`, 1)[0], g = !p.trim(), y = 0;
        if (this.options.pedantic ? (y = 2, h = p.trimStart()) : g ? y = e[1].length + 1 : (y = e[2].search(this.rules.other.nonSpaceChar), y = y > 4 ? 1 : y, h = p.slice(y), y += e[1].length), g && this.rules.other.blankLine.test(m) && (c += m + `
`, t15 = t15.substring(m.length + 1), l = true), !l) {
          let C = this.rules.other.nextBulletRegex(y), A = this.rules.other.hrRegex(y), $ = this.rules.other.fencesBeginRegex(y), B = this.rules.other.headingBeginRegex(y), L = this.rules.other.htmlBeginRegex(y);
          for (; t15; ) {
            let q = t15.split(`
`, 1)[0], U;
            if (m = q, this.options.pedantic ? (m = m.replace(this.rules.other.listReplaceNesting, "  "), U = m) : U = m.replace(this.rules.other.tabCharGlobal, "    "), $.test(m) || B.test(m) || L.test(m) || C.test(m) || A.test(m)) break;
            if (U.search(this.rules.other.nonSpaceChar) >= y || !m.trim()) h += `
` + U.slice(y);
            else {
              if (g || p.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || $.test(p) || B.test(p) || A.test(p)) break;
              h += `
` + m;
            }
            !g && !m.trim() && (g = true), c += q + `
`, t15 = t15.substring(q.length + 1), p = U.slice(y);
          }
        }
        i.loose || (a ? i.loose = true : this.rules.other.doubleBlankLine.test(c) && (a = true));
        let x = null, k;
        this.options.gfm && (x = this.rules.other.listIsTask.exec(h), x && (k = x[0] !== "[ ] ", h = h.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: c, task: !!x, checked: k, loose: false, text: h, tokens: [] }), i.raw += c;
      }
      let o = i.items.at(-1);
      if (o) o.raw = o.raw.trimEnd(), o.text = o.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let l = 0; l < i.items.length; l++) if (this.lexer.state.top = false, i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, []), !i.loose) {
        let c = i.items[l].tokens.filter((p) => p.type === "space"), h = c.length > 0 && c.some((p) => this.rules.other.anyLine.test(p.raw));
        i.loose = h;
      }
      if (i.loose) for (let l = 0; l < i.items.length; l++) i.items[l].loose = true;
      return i;
    }
  }
  html(t15) {
    let e = this.rules.block.html.exec(t15);
    if (e) return { type: "html", block: true, raw: e[0], pre: e[1] === "pre" || e[1] === "script" || e[1] === "style", text: e[0] };
  }
  def(t15) {
    let e = this.rules.block.def.exec(t15);
    if (e) {
      let r = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), n = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
      return { type: "def", tag: r, raw: e[0], href: n, title: i };
    }
  }
  table(t15) {
    var _a3;
    let e = this.rules.block.table.exec(t15);
    if (!e || !this.rules.other.tableDelimiter.test(e[2])) return;
    let r = D4(e[1]), n = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = ((_a3 = e[3]) == null ? void 0 : _a3.trim()) ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: e[0], header: [], align: [], rows: [] };
    if (r.length === n.length) {
      for (let a of n) this.rules.other.tableAlignRight.test(a) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(a) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(a) ? s.align.push("left") : s.align.push(null);
      for (let a = 0; a < r.length; a++) s.header.push({ text: r[a], tokens: this.lexer.inline(r[a]), header: true, align: s.align[a] });
      for (let a of i) s.rows.push(D4(a, s.header.length).map((o, l) => ({ text: o, tokens: this.lexer.inline(o), header: false, align: s.align[l] })));
      return s;
    }
  }
  lheading(t15) {
    let e = this.rules.block.lheading.exec(t15);
    if (e) return { type: "heading", raw: e[0], depth: e[2].charAt(0) === "=" ? 1 : 2, text: e[1], tokens: this.lexer.inline(e[1]) };
  }
  paragraph(t15) {
    let e = this.rules.block.paragraph.exec(t15);
    if (e) {
      let r = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
      return { type: "paragraph", raw: e[0], text: r, tokens: this.lexer.inline(r) };
    }
  }
  text(t15) {
    let e = this.rules.block.text.exec(t15);
    if (e) return { type: "text", raw: e[0], text: e[0], tokens: this.lexer.inline(e[0]) };
  }
  escape(t15) {
    let e = this.rules.inline.escape.exec(t15);
    if (e) return { type: "escape", raw: e[0], text: e[1] };
  }
  tag(t15) {
    let e = this.rules.inline.tag.exec(t15);
    if (e) return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: e[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: e[0] };
  }
  link(t15) {
    let e = this.rules.inline.link.exec(t15);
    if (e) {
      let r = e[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) {
        if (!this.rules.other.endAngleBracket.test(r)) return;
        let s = Vo(r.slice(0, -1), "\\");
        if ((r.length - s.length) % 2 === 0) return;
      } else {
        let s = EY(e[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let a = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + s;
          e[2] = e[2].substring(0, s), e[0] = e[0].substring(0, a).trim(), e[3] = "";
        }
      }
      let n = e[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(n);
        s && (n = s[1], i = s[3]);
      } else i = e[3] ? e[3].slice(1, -1) : "";
      return n = n.trim(), this.rules.other.startAngleBracket.test(n) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(r) ? n = n.slice(1) : n = n.slice(1, -1)), F4(e, { href: n && n.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, e[0], this.lexer, this.rules);
    }
  }
  reflink(t15, e) {
    let r;
    if ((r = this.rules.inline.reflink.exec(t15)) || (r = this.rules.inline.nolink.exec(t15))) {
      let n = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = e[n.toLowerCase()];
      if (!i) {
        let s = r[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return F4(r, i, r[0], this.lexer, this.rules);
    }
  }
  emStrong(t15, e, r = "") {
    let n = this.rules.inline.emStrongLDelim.exec(t15);
    if (!(!n || n[3] && r.match(this.rules.other.unicodeAlphaNumeric)) && (!(n[1] || n[2]) || !r || this.rules.inline.punctuation.exec(r))) {
      let i = [...n[0]].length - 1, s, a, o = i, l = 0, c = n[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, e = e.slice(-1 * t15.length + i); (n = c.exec(e)) != null; ) {
        if (s = n[1] || n[2] || n[3] || n[4] || n[5] || n[6], !s) continue;
        if (a = [...s].length, n[3] || n[4]) {
          o += a;
          continue;
        } else if ((n[5] || n[6]) && i % 3 && !((i + a) % 3)) {
          l += a;
          continue;
        }
        if (o -= a, o > 0) continue;
        a = Math.min(a, a + o + l);
        let h = [...n[0]][0].length, p = t15.slice(0, i + n.index + h + a);
        if (Math.min(i, a) % 2) {
          let g = p.slice(1, -1);
          return { type: "em", raw: p, text: g, tokens: this.lexer.inlineTokens(g) };
        }
        let m = p.slice(2, -2);
        return { type: "strong", raw: p, text: m, tokens: this.lexer.inlineTokens(m) };
      }
    }
  }
  codespan(t15) {
    let e = this.rules.inline.code.exec(t15);
    if (e) {
      let r = e[2].replace(this.rules.other.newLineCharGlobal, " "), n = this.rules.other.nonSpaceChar.test(r), i = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r);
      return n && i && (r = r.substring(1, r.length - 1)), { type: "codespan", raw: e[0], text: r };
    }
  }
  br(t15) {
    let e = this.rules.inline.br.exec(t15);
    if (e) return { type: "br", raw: e[0] };
  }
  del(t15) {
    let e = this.rules.inline.del.exec(t15);
    if (e) return { type: "del", raw: e[0], text: e[2], tokens: this.lexer.inlineTokens(e[2]) };
  }
  autolink(t15) {
    let e = this.rules.inline.autolink.exec(t15);
    if (e) {
      let r, n;
      return e[2] === "@" ? (r = e[1], n = "mailto:" + r) : (r = e[1], n = r), { type: "link", raw: e[0], text: r, href: n, tokens: [{ type: "text", raw: r, text: r }] };
    }
  }
  url(t15) {
    var _a3;
    let e;
    if (e = this.rules.inline.url.exec(t15)) {
      let r, n;
      if (e[2] === "@") r = e[0], n = "mailto:" + r;
      else {
        let i;
        do
          i = e[0], e[0] = ((_a3 = this.rules.inline._backpedal.exec(e[0])) == null ? void 0 : _a3[0]) ?? "";
        while (i !== e[0]);
        r = e[0], e[1] === "www." ? n = "http://" + e[0] : n = e[0];
      }
      return { type: "link", raw: e[0], text: r, href: n, tokens: [{ type: "text", raw: r, text: r }] };
    }
  }
  inlineText(t15) {
    let e = this.rules.inline.text.exec(t15);
    if (e) {
      let r = this.lexer.state.inRawBlock;
      return { type: "text", raw: e[0], text: e[0], escaped: r };
    }
  }
};
var Ci = class n1 {
  constructor(e) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || ha, this.options.tokenizer = this.options.tokenizer || new q0(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let r = { other: Ar, block: ch.normal, inline: Uo.normal };
    this.options.pedantic ? (r.block = ch.pedantic, r.inline = Uo.pedantic) : this.options.gfm && (r.block = ch.gfm, this.options.breaks ? r.inline = Uo.breaks : r.inline = Uo.gfm), this.tokenizer.rules = r;
  }
  static get rules() {
    return { block: ch, inline: Uo };
  }
  static lex(e, r) {
    return new n1(r).lex(e);
  }
  static lexInline(e, r) {
    return new n1(r).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(Ar.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      let n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = [], n = false) {
    var _a3, _b2, _c;
    for (this.options.pedantic && (e = e.replace(Ar.tabCharGlobal, "    ").replace(Ar.spaceLine, "")); e; ) {
      let i;
      if ((_b2 = (_a3 = this.options.extensions) == null ? void 0 : _a3.block) == null ? void 0 : _b2.some((a) => (i = a.call({ lexer: this }, e, r)) ? (e = e.substring(i.raw.length), r.push(i), true) : false)) continue;
      if (i = this.tokenizer.space(e)) {
        e = e.substring(i.raw.length);
        let a = r.at(-1);
        i.raw.length === 1 && a !== void 0 ? a.raw += `
` : r.push(i);
        continue;
      }
      if (i = this.tokenizer.code(e)) {
        e = e.substring(i.raw.length);
        let a = r.at(-1);
        (a == null ? void 0 : a.type) === "paragraph" || (a == null ? void 0 : a.type) === "text" ? (a.raw += `
` + i.raw, a.text += `
` + i.text, this.inlineQueue.at(-1).src = a.text) : r.push(i);
        continue;
      }
      if (i = this.tokenizer.fences(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.heading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.hr(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.blockquote(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.list(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.html(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.def(e)) {
        e = e.substring(i.raw.length);
        let a = r.at(-1);
        (a == null ? void 0 : a.type) === "paragraph" || (a == null ? void 0 : a.type) === "text" ? (a.raw += `
` + i.raw, a.text += `
` + i.raw, this.inlineQueue.at(-1).src = a.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = { href: i.href, title: i.title });
        continue;
      }
      if (i = this.tokenizer.table(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.lheading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      let s = e;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
        let a = 1 / 0, o = e.slice(1), l;
        this.options.extensions.startBlock.forEach((c) => {
          l = c.call({ lexer: this }, o), typeof l == "number" && l >= 0 && (a = Math.min(a, l));
        }), a < 1 / 0 && a >= 0 && (s = e.substring(0, a + 1));
      }
      if (this.state.top && (i = this.tokenizer.paragraph(s))) {
        let a = r.at(-1);
        n && (a == null ? void 0 : a.type) === "paragraph" ? (a.raw += `
` + i.raw, a.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = a.text) : r.push(i), n = s.length !== e.length, e = e.substring(i.raw.length);
        continue;
      }
      if (i = this.tokenizer.text(e)) {
        e = e.substring(i.raw.length);
        let a = r.at(-1);
        (a == null ? void 0 : a.type) === "text" ? (a.raw += `
` + i.raw, a.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = a.text) : r.push(i);
        continue;
      }
      if (e) {
        let a = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(a);
          break;
        } else throw new Error(a);
      }
    }
    return this.state.top = true, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  inlineTokens(e, r = []) {
    var _a3, _b2, _c;
    let n = e, i = null;
    if (this.tokens.links) {
      let o = Object.keys(this.tokens.links);
      if (o.length > 0) for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, i.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (i = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) n = n.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let s = false, a = "";
    for (; e; ) {
      s || (a = ""), s = false;
      let o;
      if ((_b2 = (_a3 = this.options.extensions) == null ? void 0 : _a3.inline) == null ? void 0 : _b2.some((c) => (o = c.call({ lexer: this }, e, r)) ? (e = e.substring(o.raw.length), r.push(o), true) : false)) continue;
      if (o = this.tokenizer.escape(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.link(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(o.raw.length);
        let c = r.at(-1);
        o.type === "text" && (c == null ? void 0 : c.type) === "text" ? (c.raw += o.raw, c.text += o.text) : r.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(e, n, a)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.br(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.del(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(e))) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      let l = e;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startInline) {
        let c = 1 / 0, h = e.slice(1), p;
        this.options.extensions.startInline.forEach((m) => {
          p = m.call({ lexer: this }, h), typeof p == "number" && p >= 0 && (c = Math.min(c, p));
        }), c < 1 / 0 && c >= 0 && (l = e.substring(0, c + 1));
      }
      if (o = this.tokenizer.inlineText(l)) {
        e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (a = o.raw.slice(-1)), s = true;
        let c = r.at(-1);
        (c == null ? void 0 : c.type) === "text" ? (c.raw += o.raw, c.text += o.text) : r.push(o);
        continue;
      }
      if (e) {
        let c = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(c);
          break;
        } else throw new Error(c);
      }
    }
    return r;
  }
};
var R0 = class {
  constructor(t15) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = t15 || ha;
  }
  space(t15) {
    return "";
  }
  code({ text: t15, lang: e, escaped: r }) {
    var _a3;
    let n = (_a3 = (e || "").match(Ar.notSpaceStart)) == null ? void 0 : _a3[0], i = t15.replace(Ar.endingNewline, "") + `
`;
    return n ? '<pre><code class="language-' + In(n) + '">' + (r ? i : In(i, true)) + `</code></pre>
` : "<pre><code>" + (r ? i : In(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: t15 }) {
    return `<blockquote>
${this.parser.parse(t15)}</blockquote>
`;
  }
  html({ text: t15 }) {
    return t15;
  }
  heading({ tokens: t15, depth: e }) {
    return `<h${e}>${this.parser.parseInline(t15)}</h${e}>
`;
  }
  hr(t15) {
    return `<hr>
`;
  }
  list(t15) {
    let e = t15.ordered, r = t15.start, n = "";
    for (let a = 0; a < t15.items.length; a++) {
      let o = t15.items[a];
      n += this.listitem(o);
    }
    let i = e ? "ol" : "ul", s = e && r !== 1 ? ' start="' + r + '"' : "";
    return "<" + i + s + `>
` + n + "</" + i + `>
`;
  }
  listitem(t15) {
    var _a3;
    let e = "";
    if (t15.task) {
      let r = this.checkbox({ checked: !!t15.checked });
      t15.loose ? ((_a3 = t15.tokens[0]) == null ? void 0 : _a3.type) === "paragraph" ? (t15.tokens[0].text = r + " " + t15.tokens[0].text, t15.tokens[0].tokens && t15.tokens[0].tokens.length > 0 && t15.tokens[0].tokens[0].type === "text" && (t15.tokens[0].tokens[0].text = r + " " + In(t15.tokens[0].tokens[0].text), t15.tokens[0].tokens[0].escaped = true)) : t15.tokens.unshift({ type: "text", raw: r + " ", text: r + " ", escaped: true }) : e += r + " ";
    }
    return e += this.parser.parse(t15.tokens, !!t15.loose), `<li>${e}</li>
`;
  }
  checkbox({ checked: t15 }) {
    return "<input " + (t15 ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: t15 }) {
    return `<p>${this.parser.parseInline(t15)}</p>
`;
  }
  table(t15) {
    let e = "", r = "";
    for (let i = 0; i < t15.header.length; i++) r += this.tablecell(t15.header[i]);
    e += this.tablerow({ text: r });
    let n = "";
    for (let i = 0; i < t15.rows.length; i++) {
      let s = t15.rows[i];
      r = "";
      for (let a = 0; a < s.length; a++) r += this.tablecell(s[a]);
      n += this.tablerow({ text: r });
    }
    return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + n + `</table>
`;
  }
  tablerow({ text: t15 }) {
    return `<tr>
${t15}</tr>
`;
  }
  tablecell(t15) {
    let e = this.parser.parseInline(t15.tokens), r = t15.header ? "th" : "td";
    return (t15.align ? `<${r} align="${t15.align}">` : `<${r}>`) + e + `</${r}>
`;
  }
  strong({ tokens: t15 }) {
    return `<strong>${this.parser.parseInline(t15)}</strong>`;
  }
  em({ tokens: t15 }) {
    return `<em>${this.parser.parseInline(t15)}</em>`;
  }
  codespan({ text: t15 }) {
    return `<code>${In(t15, true)}</code>`;
  }
  br(t15) {
    return "<br>";
  }
  del({ tokens: t15 }) {
    return `<del>${this.parser.parseInline(t15)}</del>`;
  }
  link({ href: t15, title: e, tokens: r }) {
    let n = this.parser.parseInline(r), i = L4(t15);
    if (i === null) return n;
    t15 = i;
    let s = '<a href="' + t15 + '"';
    return e && (s += ' title="' + In(e) + '"'), s += ">" + n + "</a>", s;
  }
  image({ href: t15, title: e, text: r, tokens: n }) {
    n && (r = this.parser.parseInline(n, this.parser.textRenderer));
    let i = L4(t15);
    if (i === null) return In(r);
    t15 = i;
    let s = `<img src="${t15}" alt="${r}"`;
    return e && (s += ` title="${In(e)}"`), s += ">", s;
  }
  text(t15) {
    return "tokens" in t15 && t15.tokens ? this.parser.parseInline(t15.tokens) : "escaped" in t15 && t15.escaped ? t15.text : In(t15.text);
  }
};
var fg = class {
  strong({ text: t15 }) {
    return t15;
  }
  em({ text: t15 }) {
    return t15;
  }
  codespan({ text: t15 }) {
    return t15;
  }
  del({ text: t15 }) {
    return t15;
  }
  html({ text: t15 }) {
    return t15;
  }
  text({ text: t15 }) {
    return t15;
  }
  link({ text: t15 }) {
    return "" + t15;
  }
  image({ text: t15 }) {
    return "" + t15;
  }
  br() {
    return "";
  }
};
var _i = class i1 {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = e || ha, this.options.renderer = this.options.renderer || new R0(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new fg();
  }
  static parse(e, r) {
    return new i1(r).parse(e);
  }
  static parseInline(e, r) {
    return new i1(r).parseInline(e);
  }
  parse(e, r = true) {
    var _a3, _b2;
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if ((_b2 = (_a3 = this.options.extensions) == null ? void 0 : _a3.renderers) == null ? void 0 : _b2[s.type]) {
        let o = s, l = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (l !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(o.type)) {
          n += l || "";
          continue;
        }
      }
      let a = s;
      switch (a.type) {
        case "space": {
          n += this.renderer.space(a);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(a);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(a);
          continue;
        }
        case "code": {
          n += this.renderer.code(a);
          continue;
        }
        case "table": {
          n += this.renderer.table(a);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(a);
          continue;
        }
        case "list": {
          n += this.renderer.list(a);
          continue;
        }
        case "html": {
          n += this.renderer.html(a);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(a);
          continue;
        }
        case "text": {
          let o = a, l = this.renderer.text(o);
          for (; i + 1 < e.length && e[i + 1].type === "text"; ) o = e[++i], l += `
` + this.renderer.text(o);
          r ? n += this.renderer.paragraph({ type: "paragraph", raw: l, text: l, tokens: [{ type: "text", raw: l, text: l, escaped: true }] }) : n += l;
          continue;
        }
        default: {
          let o = 'Token with "' + a.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
  parseInline(e, r = this.renderer) {
    var _a3, _b2;
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if ((_b2 = (_a3 = this.options.extensions) == null ? void 0 : _a3.renderers) == null ? void 0 : _b2[s.type]) {
        let o = this.options.extensions.renderers[s.type].call({ parser: this }, s);
        if (o !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type)) {
          n += o || "";
          continue;
        }
      }
      let a = s;
      switch (a.type) {
        case "escape": {
          n += r.text(a);
          break;
        }
        case "html": {
          n += r.html(a);
          break;
        }
        case "link": {
          n += r.link(a);
          break;
        }
        case "image": {
          n += r.image(a);
          break;
        }
        case "strong": {
          n += r.strong(a);
          break;
        }
        case "em": {
          n += r.em(a);
          break;
        }
        case "codespan": {
          n += r.codespan(a);
          break;
        }
        case "br": {
          n += r.br(a);
          break;
        }
        case "del": {
          n += r.del(a);
          break;
        }
        case "text": {
          n += r.text(a);
          break;
        }
        default: {
          let o = 'Token with "' + a.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
};
var _a2;
var Ih = (_a2 = class {
  constructor(t15) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = t15 || ha;
  }
  preprocess(t15) {
    return t15;
  }
  postprocess(t15) {
    return t15;
  }
  processAllTokens(t15) {
    return t15;
  }
  provideLexer() {
    return this.block ? Ci.lex : Ci.lexInline;
  }
  provideParser() {
    return this.block ? _i.parse : _i.parseInline;
  }
}, __publicField(_a2, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"])), _a2);
var BY = class {
  constructor(...t15) {
    __publicField(this, "defaults", ag());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", _i);
    __publicField(this, "Renderer", R0);
    __publicField(this, "TextRenderer", fg);
    __publicField(this, "Lexer", Ci);
    __publicField(this, "Tokenizer", q0);
    __publicField(this, "Hooks", Ih);
    this.use(...t15);
  }
  walkTokens(t15, e) {
    var _a3, _b2;
    let r = [];
    for (let n of t15) switch (r = r.concat(e.call(this, n)), n.type) {
      case "table": {
        let i = n;
        for (let s of i.header) r = r.concat(this.walkTokens(s.tokens, e));
        for (let s of i.rows) for (let a of s) r = r.concat(this.walkTokens(a.tokens, e));
        break;
      }
      case "list": {
        let i = n;
        r = r.concat(this.walkTokens(i.items, e));
        break;
      }
      default: {
        let i = n;
        ((_b2 = (_a3 = this.defaults.extensions) == null ? void 0 : _a3.childTokens) == null ? void 0 : _b2[i.type]) ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let a = i[s].flat(1 / 0);
          r = r.concat(this.walkTokens(a, e));
        }) : i.tokens && (r = r.concat(this.walkTokens(i.tokens, e)));
      }
    }
    return r;
  }
  use(...t15) {
    let e = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return t15.forEach((r) => {
      let n = { ...r };
      if (n.async = this.defaults.async || n.async || false, r.extensions && (r.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = e.renderers[i.name];
          s ? e.renderers[i.name] = function(...a) {
            let o = i.renderer.apply(this, a);
            return o === false && (o = s.apply(this, a)), o;
          } : e.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = e[i.level];
          s ? s.unshift(i.tokenizer) : e[i.level] = [i.tokenizer], i.start && (i.level === "block" ? e.startBlock ? e.startBlock.push(i.start) : e.startBlock = [i.start] : i.level === "inline" && (e.startInline ? e.startInline.push(i.start) : e.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (e.childTokens[i.name] = i.childTokens);
      }), n.extensions = e), r.renderer) {
        let i = this.defaults.renderer || new R0(this.defaults);
        for (let s in r.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let a = s, o = r.renderer[a], l = i[a];
          i[a] = (...c) => {
            let h = o.apply(i, c);
            return h === false && (h = l.apply(i, c)), h || "";
          };
        }
        n.renderer = i;
      }
      if (r.tokenizer) {
        let i = this.defaults.tokenizer || new q0(this.defaults);
        for (let s in r.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let a = s, o = r.tokenizer[a], l = i[a];
          i[a] = (...c) => {
            let h = o.apply(i, c);
            return h === false && (h = l.apply(i, c)), h;
          };
        }
        n.tokenizer = i;
      }
      if (r.hooks) {
        let i = this.defaults.hooks || new Ih();
        for (let s in r.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let a = s, o = r.hooks[a], l = i[a];
          Ih.passThroughHooks.has(s) ? i[a] = (c) => {
            if (this.defaults.async) return Promise.resolve(o.call(i, c)).then((p) => l.call(i, p));
            let h = o.call(i, c);
            return l.call(i, h);
          } : i[a] = (...c) => {
            let h = o.apply(i, c);
            return h === false && (h = l.apply(i, c)), h;
          };
        }
        n.hooks = i;
      }
      if (r.walkTokens) {
        let i = this.defaults.walkTokens, s = r.walkTokens;
        n.walkTokens = function(a) {
          let o = [];
          return o.push(s.call(this, a)), i && (o = o.concat(i.call(this, a))), o;
        };
      }
      this.defaults = { ...this.defaults, ...n };
    }), this;
  }
  setOptions(t15) {
    return this.defaults = { ...this.defaults, ...t15 }, this;
  }
  lexer(t15, e) {
    return Ci.lex(t15, e ?? this.defaults);
  }
  parser(t15, e) {
    return _i.parse(t15, e ?? this.defaults);
  }
  parseMarkdown(t15) {
    return (e, r) => {
      let n = { ...r }, i = { ...this.defaults, ...n }, s = this.onError(!!i.silent, !!i.async);
      if (this.defaults.async === true && n.async === false) return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof e > "u" || e === null) return s(new Error("marked(): input parameter is undefined or null"));
      if (typeof e != "string") return s(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"));
      i.hooks && (i.hooks.options = i, i.hooks.block = t15);
      let a = i.hooks ? i.hooks.provideLexer() : t15 ? Ci.lex : Ci.lexInline, o = i.hooks ? i.hooks.provideParser() : t15 ? _i.parse : _i.parseInline;
      if (i.async) return Promise.resolve(i.hooks ? i.hooks.preprocess(e) : e).then((l) => a(l, i)).then((l) => i.hooks ? i.hooks.processAllTokens(l) : l).then((l) => i.walkTokens ? Promise.all(this.walkTokens(l, i.walkTokens)).then(() => l) : l).then((l) => o(l, i)).then((l) => i.hooks ? i.hooks.postprocess(l) : l).catch(s);
      try {
        i.hooks && (e = i.hooks.preprocess(e));
        let l = a(e, i);
        i.hooks && (l = i.hooks.processAllTokens(l)), i.walkTokens && this.walkTokens(l, i.walkTokens);
        let c = o(l, i);
        return i.hooks && (c = i.hooks.postprocess(c)), c;
      } catch (l) {
        return s(l);
      }
    };
  }
  onError(t15, e) {
    return (r) => {
      if (r.message += `
Please report this to https://github.com/markedjs/marked.`, t15) {
        let n = "<p>An error occurred:</p><pre>" + In(r.message + "", true) + "</pre>";
        return e ? Promise.resolve(n) : n;
      }
      if (e) return Promise.reject(r);
      throw r;
    };
  }
};
var ea = new BY();
function ge(t15, e) {
  return ea.parse(t15, e);
}
ge.options = ge.setOptions = function(t15) {
  return ea.setOptions(t15), ge.defaults = ea.defaults, Xk(ge.defaults), ge;
};
ge.getDefaults = ag;
ge.defaults = ha;
ge.use = function(...t15) {
  return ea.use(...t15), ge.defaults = ea.defaults, Xk(ge.defaults), ge;
};
ge.walkTokens = function(t15, e) {
  return ea.walkTokens(t15, e);
};
ge.parseInline = ea.parseInline;
ge.Parser = _i;
ge.parser = _i.parse;
ge.Renderer = R0;
ge.TextRenderer = fg;
ge.Lexer = Ci;
ge.lexer = Ci.lex;
ge.Tokenizer = q0;
ge.Hooks = Ih;
ge.parse = ge;
ge.options;
ge.setOptions;
ge.use;
ge.walkTokens;
ge.parseInline;
_i.parse;
Ci.lex;
function sv(t15) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var n = Array.from(typeof t15 == "string" ? [t15] : t15);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i = n.reduce(function(o, l) {
    var c = l.match(/\n([\t ]+|(?!\s).)/g);
    return c ? o.concat(c.map(function(h) {
      var p, m;
      return (m = (p = h.match(/[\t ]/g)) === null || p === void 0 ? void 0 : p.length) !== null && m !== void 0 ? m : 0;
    })) : o;
  }, []);
  if (i.length) {
    var s = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
    n = n.map(function(o) {
      return o.replace(s, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var a = n[0];
  return e.forEach(function(o, l) {
    var c = a.match(/(?:^|\n)( *)$/), h = c ? c[1] : "", p = o;
    typeof o == "string" && o.includes(`
`) && (p = String(o).split(`
`).map(function(m, g) {
      return g === 0 ? m : "" + h + m;
    }).join(`
`)), a += p + n[l + 1];
  }), a;
}
var LY = {
  body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
  height: 80,
  width: 80
};
var s1 = /* @__PURE__ */ new Map();
var av = /* @__PURE__ */ new Map();
var DY = _((t15) => {
  for (const e of t15) {
    if (!e.name)
      throw new Error(
        'Invalid icon loader. Must have a "name" property with non-empty string value.'
      );
    if (ut.debug("Registering icon pack:", e.name), "loader" in e)
      av.set(e.name, e.loader);
    else if ("icons" in e)
      s1.set(e.name, e.icons);
    else
      throw ut.error("Invalid icon loader:", e), new Error('Invalid icon loader. Must have either "icons" or "loader" property.');
  }
}, "registerIconPacks");
var ov = _(async (t15, e) => {
  const r = FX(t15, true, e !== void 0);
  if (!r)
    throw new Error(`Invalid icon name: ${t15}`);
  const n = r.prefix || e;
  if (!n)
    throw new Error(`Icon name must contain a prefix: ${t15}`);
  let i = s1.get(n);
  if (!i) {
    const a = av.get(n);
    if (!a)
      throw new Error(`Icon set not found: ${r.prefix}`);
    try {
      i = { ...await a(), prefix: n }, s1.set(n, i);
    } catch (o) {
      throw ut.error(o), new Error(`Failed to load icon set: ${r.prefix}`);
    }
  }
  const s = OX(i, r.name);
  if (!s)
    throw new Error(`Icon not found: ${t15}`);
  return s;
}, "getRegisteredIconData");
var FY = _(async (t15) => {
  try {
    return await ov(t15), true;
  } catch {
    return false;
  }
}, "isIconAvailable");
var gc = _(async (t15, e, r) => {
  let n;
  try {
    n = await ov(t15, e == null ? void 0 : e.fallbackPrefix);
  } catch (s) {
    ut.error(s), n = LY;
  }
  const i = HX(n, e);
  return YX(XX(i.body), {
    ...i.attributes,
    ...r
  });
}, "getIconSVG");
function lv(t15, { markdownAutoWrap: e }) {
  const r = t15.replace(/<br\/>/g, `
`).replace(/\n{2,}/g, `
`), n = sv(r);
  return e === false ? n.replace(/ /g, "&nbsp;") : n;
}
_(lv, "preprocessMarkdown");
function cv(t15, e = {}) {
  const r = lv(t15, e), n = ge.lexer(r), i = [[]];
  let s = 0;
  function a(o, l = "normal") {
    o.type === "text" ? o.text.split(`
`).forEach((c, h) => {
      h !== 0 && (s++, i.push([])), c.split(" ").forEach((p) => {
        p = p.replace(/&#39;/g, "'"), p && i[s].push({ content: p, type: l });
      });
    }) : o.type === "strong" || o.type === "em" ? o.tokens.forEach((c) => {
      a(c, o.type);
    }) : o.type === "html" && i[s].push({ content: o.text, type: "normal" });
  }
  return _(a, "processNode"), n.forEach((o) => {
    var _a3;
    o.type === "paragraph" ? (_a3 = o.tokens) == null ? void 0 : _a3.forEach((l) => {
      a(l);
    }) : o.type === "html" && i[s].push({ content: o.text, type: "normal" });
  }), i;
}
_(cv, "markdownToLines");
function hv(t15, { markdownAutoWrap: e } = {}) {
  const r = ge.lexer(t15);
  function n(i) {
    var _a3, _b2, _c;
    return i.type === "text" ? e === false ? i.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;") : i.text.replace(/\n */g, "<br/>") : i.type === "strong" ? `<strong>${(_a3 = i.tokens) == null ? void 0 : _a3.map(n).join("")}</strong>` : i.type === "em" ? `<em>${(_b2 = i.tokens) == null ? void 0 : _b2.map(n).join("")}</em>` : i.type === "paragraph" ? `<p>${(_c = i.tokens) == null ? void 0 : _c.map(n).join("")}</p>` : i.type === "space" ? "" : i.type === "html" ? `${i.text}` : i.type === "escape" ? i.text : `Unsupported markdown: ${i.type}`;
  }
  return _(n, "output"), r.map(n).join("");
}
_(hv, "markdownToHTML");
function uv(t15) {
  return Intl.Segmenter ? [...new Intl.Segmenter().segment(t15)].map((e) => e.segment) : [...t15];
}
_(uv, "splitTextToChars");
function dv(t15, e) {
  const r = uv(e.content);
  return mg(t15, [], r, e.type);
}
_(dv, "splitWordToFitWidth");
function mg(t15, e, r, n) {
  if (r.length === 0)
    return [
      { content: e.join(""), type: n },
      { content: "", type: n }
    ];
  const [i, ...s] = r, a = [...e, i];
  return t15([{ content: a.join(""), type: n }]) ? mg(t15, a, s, n) : (e.length === 0 && i && (e.push(i), r.shift()), [
    { content: e.join(""), type: n },
    { content: r.join(""), type: n }
  ]);
}
_(mg, "splitWordToFitWidthRecursion");
function pv(t15, e) {
  if (t15.some(({ content: r }) => r.includes(`
`)))
    throw new Error("splitLineToFitWidth does not support newlines in the line");
  return P0(t15, e);
}
_(pv, "splitLineToFitWidth");
function P0(t15, e, r = [], n = []) {
  if (t15.length === 0)
    return n.length > 0 && r.push(n), r.length > 0 ? r : [];
  let i = "";
  t15[0].content === " " && (i = " ", t15.shift());
  const s = t15.shift() ?? { content: " ", type: "normal" }, a = [...n];
  if (i !== "" && a.push({ content: i, type: "normal" }), a.push(s), e(a))
    return P0(t15, e, r, a);
  if (n.length > 0)
    r.push(n), t15.unshift(s);
  else if (s.content) {
    const [o, l] = dv(e, s);
    r.push([o]), l.content && t15.unshift(l);
  }
  return P0(t15, e, r);
}
_(P0, "splitLineToFitWidthRecursion");
function a1(t15, e) {
  e && t15.attr("style", e);
}
_(a1, "applyStyle");
async function fv(t15, e, r, n, i = false) {
  const s = t15.append("foreignObject");
  s.attr("width", `${10 * r}px`), s.attr("height", `${10 * r}px`);
  const a = s.append("xhtml:div");
  let o = e.label;
  e.label && Ja(e.label) && (o = await Sm(e.label.replace(fo.lineBreakRegex, `
`), fe()));
  const l = e.isNode ? "nodeLabel" : "edgeLabel", c = a.append("span");
  c.html(o), a1(c, e.labelStyle), c.attr("class", `${l} ${n}`), a1(a, e.labelStyle), a.style("display", "table-cell"), a.style("white-space", "nowrap"), a.style("line-height", "1.5"), a.style("max-width", r + "px"), a.style("text-align", "center"), a.attr("xmlns", "http://www.w3.org/1999/xhtml"), i && a.attr("class", "labelBkg");
  let h = a.node().getBoundingClientRect();
  return h.width === r && (a.style("display", "table"), a.style("white-space", "break-spaces"), a.style("width", r + "px"), h = a.node().getBoundingClientRect()), s.node();
}
_(fv, "addHtmlSpan");
function zu(t15, e, r) {
  return t15.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", e * r - 0.1 + "em").attr("dy", r + "em");
}
_(zu, "createTspan");
function mv(t15, e, r) {
  const n = t15.append("text"), i = zu(n, 1, e);
  qu(i, r);
  const s = i.node().getComputedTextLength();
  return n.remove(), s;
}
_(mv, "computeWidthOfText");
function NY(t15, e, r) {
  var _a3;
  const n = t15.append("text"), i = zu(n, 1, e);
  qu(i, [{ content: r, type: "normal" }]);
  const s = (_a3 = i.node()) == null ? void 0 : _a3.getBoundingClientRect();
  return s && n.remove(), s;
}
_(NY, "computeDimensionOfText");
function gv(t15, e, r, n = false) {
  const i = e.append("g"), s = i.insert("rect").attr("class", "background").attr("style", "stroke: none"), a = i.append("text").attr("y", "-10.1");
  let o = 0;
  for (const l of r) {
    const c = _((p) => mv(i, 1.1, p) <= t15, "checkWidth"), h = c(l) ? [l] : pv(l, c);
    for (const p of h) {
      const m = zu(a, o, 1.1);
      qu(m, p), o++;
    }
  }
  if (n) {
    const l = a.node().getBBox(), c = 2;
    return s.attr("x", l.x - c).attr("y", l.y - c).attr("width", l.width + 2 * c).attr("height", l.height + 2 * c), i.node();
  } else
    return a.node();
}
_(gv, "createFormattedText");
function qu(t15, e) {
  t15.text(""), e.forEach((r, n) => {
    const i = t15.append("tspan").attr("font-style", r.type === "em" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", r.type === "strong" ? "bold" : "normal");
    n === 0 ? i.text(r.content) : i.text(" " + r.content);
  });
}
_(qu, "updateTextContentAndStyles");
async function yv(t15) {
  const e = [];
  t15.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (n, i, s) => (e.push(
    (async () => {
      const a = `${i}:${s}`;
      return await FY(a) ? await gc(a, void 0, { class: "label-icon" }) : `<i class='${vu(n).replace(":", " ")}'></i>`;
    })()
  ), n));
  const r = await Promise.all(e);
  return t15.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => r.shift() ?? "");
}
_(yv, "replaceIconSubstring");
var fs = _(async (t15, e = "", {
  style: r = "",
  isTitle: n = false,
  classes: i = "",
  useHtmlLabels: s = true,
  isNode: a = true,
  width: o = 200,
  addSvgBackground: l = false
} = {}, c) => {
  if (ut.debug(
    "XYZ createText",
    e,
    r,
    n,
    i,
    s,
    a,
    "addSvgBackground: ",
    l
  ), s) {
    const h = hv(e, c), p = await yv(ca(h)), m = e.replace(/\\\\/g, "\\"), g = {
      isNode: a,
      label: Ja(e) ? m : p,
      labelStyle: r.replace("fill:", "color:")
    };
    return await fv(t15, g, o, i, l);
  } else {
    const h = e.replace(/<br\s*\/?>/g, "<br/>"), p = cv(h.replace("<br>", "<br/>"), c), m = gv(
      o,
      t15,
      p,
      e ? l : false
    );
    if (a) {
      /stroke:/.exec(r) && (r = r.replace("stroke:", "lineColor:"));
      const g = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      ae(m).attr("style", g);
    } else {
      const g = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
      ae(m).select("rect").attr("style", g.replace(/background:/g, "fill:"));
      const y = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      ae(m).select("text").attr("style", y);
    }
    return m;
  }
}, "createText");
function Tp(t15, e, r) {
  if (t15 && t15.length) {
    const [n, i] = e, s = Math.PI / 180 * r, a = Math.cos(s), o = Math.sin(s);
    for (const l of t15) {
      const [c, h] = l;
      l[0] = (c - n) * a - (h - i) * o + n, l[1] = (c - n) * o + (h - i) * a + i;
    }
  }
}
function IY(t15, e) {
  return t15[0] === e[0] && t15[1] === e[1];
}
function OY(t15, e, r, n = 1) {
  const i = r, s = Math.max(e, 0.1), a = t15[0] && t15[0][0] && typeof t15[0][0] == "number" ? [t15] : t15, o = [0, 0];
  if (i) for (const c of a) Tp(c, o, i);
  const l = function(c, h, p) {
    const m = [];
    for (const A of c) {
      const $ = [...A];
      IY($[0], $[$.length - 1]) || $.push([$[0][0], $[0][1]]), $.length > 2 && m.push($);
    }
    const g = [];
    h = Math.max(h, 0.1);
    const y = [];
    for (const A of m) for (let $ = 0; $ < A.length - 1; $++) {
      const B = A[$], L = A[$ + 1];
      if (B[1] !== L[1]) {
        const q = Math.min(B[1], L[1]);
        y.push({ ymin: q, ymax: Math.max(B[1], L[1]), x: q === B[1] ? B[0] : L[0], islope: (L[0] - B[0]) / (L[1] - B[1]) });
      }
    }
    if (y.sort((A, $) => A.ymin < $.ymin ? -1 : A.ymin > $.ymin ? 1 : A.x < $.x ? -1 : A.x > $.x ? 1 : A.ymax === $.ymax ? 0 : (A.ymax - $.ymax) / Math.abs(A.ymax - $.ymax)), !y.length) return g;
    let x = [], k = y[0].ymin, C = 0;
    for (; x.length || y.length; ) {
      if (y.length) {
        let A = -1;
        for (let $ = 0; $ < y.length && !(y[$].ymin > k); $++) A = $;
        y.splice(0, A + 1).forEach(($) => {
          x.push({ s: k, edge: $ });
        });
      }
      if (x = x.filter((A) => !(A.edge.ymax <= k)), x.sort((A, $) => A.edge.x === $.edge.x ? 0 : (A.edge.x - $.edge.x) / Math.abs(A.edge.x - $.edge.x)), (p !== 1 || C % h == 0) && x.length > 1) for (let A = 0; A < x.length; A += 2) {
        const $ = A + 1;
        if ($ >= x.length) break;
        const B = x[A].edge, L = x[$].edge;
        g.push([[Math.round(B.x), k], [Math.round(L.x), k]]);
      }
      k += p, x.forEach((A) => {
        A.edge.x = A.edge.x + p * A.edge.islope;
      }), C++;
    }
    return g;
  }(a, s, n);
  if (i) {
    for (const c of a) Tp(c, o, -i);
    (function(c, h, p) {
      const m = [];
      c.forEach((g) => m.push(...g)), Tp(m, h, p);
    })(l, o, -i);
  }
  return l;
}
function yc(t15, e) {
  var r;
  const n = e.hachureAngle + 90;
  let i = e.hachureGap;
  i < 0 && (i = 4 * e.strokeWidth), i = Math.round(Math.max(i, 0.1));
  let s = 1;
  return e.roughness >= 1 && (((r = e.randomizer) === null || r === void 0 ? void 0 : r.next()) || Math.random()) > 0.7 && (s = i), OY(t15, i, n, s || 1);
}
var gg = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    return this._fillPolygons(e, r);
  }
  _fillPolygons(e, r) {
    const n = yc(e, r);
    return { type: "fillSketch", ops: this.renderLines(n, r) };
  }
  renderLines(e, r) {
    const n = [];
    for (const i of e) n.push(...this.helper.doubleLineOps(i[0][0], i[0][1], i[1][0], i[1][1], r));
    return n;
  }
};
function Ru(t15) {
  const e = t15[0], r = t15[1];
  return Math.sqrt(Math.pow(e[0] - r[0], 2) + Math.pow(e[1] - r[1], 2));
}
var zY = class extends gg {
  fillPolygons(e, r) {
    let n = r.hachureGap;
    n < 0 && (n = 4 * r.strokeWidth), n = Math.max(n, 0.1);
    const i = yc(e, Object.assign({}, r, { hachureGap: n })), s = Math.PI / 180 * r.hachureAngle, a = [], o = 0.5 * n * Math.cos(s), l = 0.5 * n * Math.sin(s);
    for (const [c, h] of i) Ru([c, h]) && a.push([[c[0] - o, c[1] + l], [...h]], [[c[0] + o, c[1] - l], [...h]]);
    return { type: "fillSketch", ops: this.renderLines(a, r) };
  }
};
var qY = class extends gg {
  fillPolygons(e, r) {
    const n = this._fillPolygons(e, r), i = Object.assign({}, r, { hachureAngle: r.hachureAngle + 90 }), s = this._fillPolygons(e, i);
    return n.ops = n.ops.concat(s.ops), n;
  }
};
var RY = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = yc(e, r = Object.assign({}, r, { hachureAngle: 0 }));
    return this.dotsOnLines(n, r);
  }
  dotsOnLines(e, r) {
    const n = [];
    let i = r.hachureGap;
    i < 0 && (i = 4 * r.strokeWidth), i = Math.max(i, 0.1);
    let s = r.fillWeight;
    s < 0 && (s = r.strokeWidth / 2);
    const a = i / 4;
    for (const o of e) {
      const l = Ru(o), c = l / i, h = Math.ceil(c) - 1, p = l - h * i, m = (o[0][0] + o[1][0]) / 2 - i / 4, g = Math.min(o[0][1], o[1][1]);
      for (let y = 0; y < h; y++) {
        const x = g + p + y * i, k = m - a + 2 * Math.random() * a, C = x - a + 2 * Math.random() * a, A = this.helper.ellipse(k, C, s, s, r);
        n.push(...A.ops);
      }
    }
    return { type: "fillSketch", ops: n };
  }
};
var PY = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = yc(e, r);
    return { type: "fillSketch", ops: this.dashedLine(n, r) };
  }
  dashedLine(e, r) {
    const n = r.dashOffset < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashOffset, i = r.dashGap < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashGap, s = [];
    return e.forEach((a) => {
      const o = Ru(a), l = Math.floor(o / (n + i)), c = (o + i - l * (n + i)) / 2;
      let h = a[0], p = a[1];
      h[0] > p[0] && (h = a[1], p = a[0]);
      const m = Math.atan((p[1] - h[1]) / (p[0] - h[0]));
      for (let g = 0; g < l; g++) {
        const y = g * (n + i), x = y + n, k = [h[0] + y * Math.cos(m) + c * Math.cos(m), h[1] + y * Math.sin(m) + c * Math.sin(m)], C = [h[0] + x * Math.cos(m) + c * Math.cos(m), h[1] + x * Math.sin(m) + c * Math.sin(m)];
        s.push(...this.helper.doubleLineOps(k[0], k[1], C[0], C[1], r));
      }
    }), s;
  }
};
var jY = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap, i = r.zigzagOffset < 0 ? n : r.zigzagOffset, s = yc(e, r = Object.assign({}, r, { hachureGap: n + i }));
    return { type: "fillSketch", ops: this.zigzagLines(s, i, r) };
  }
  zigzagLines(e, r, n) {
    const i = [];
    return e.forEach((s) => {
      const a = Ru(s), o = Math.round(a / (2 * r));
      let l = s[0], c = s[1];
      l[0] > c[0] && (l = s[1], c = s[0]);
      const h = Math.atan((c[1] - l[1]) / (c[0] - l[0]));
      for (let p = 0; p < o; p++) {
        const m = 2 * p * r, g = 2 * (p + 1) * r, y = Math.sqrt(2 * Math.pow(r, 2)), x = [l[0] + m * Math.cos(h), l[1] + m * Math.sin(h)], k = [l[0] + g * Math.cos(h), l[1] + g * Math.sin(h)], C = [x[0] + y * Math.cos(h + Math.PI / 4), x[1] + y * Math.sin(h + Math.PI / 4)];
        i.push(...this.helper.doubleLineOps(x[0], x[1], C[0], C[1], n), ...this.helper.doubleLineOps(C[0], C[1], k[0], k[1], n));
      }
    }), i;
  }
};
var Fr = {};
var WY = class {
  constructor(e) {
    this.seed = e;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
};
var HY = 0;
var $p = 1;
var N4 = 2;
var hh = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function Ep(t15, e) {
  return t15.type === e;
}
function yg(t15) {
  const e = [], r = function(a) {
    const o = new Array();
    for (; a !== ""; ) if (a.match(/^([ \t\r\n,]+)/)) a = a.substr(RegExp.$1.length);
    else if (a.match(/^([aAcChHlLmMqQsStTvVzZ])/)) o[o.length] = { type: HY, text: RegExp.$1 }, a = a.substr(RegExp.$1.length);
    else {
      if (!a.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
      o[o.length] = { type: $p, text: `${parseFloat(RegExp.$1)}` }, a = a.substr(RegExp.$1.length);
    }
    return o[o.length] = { type: N4, text: "" }, o;
  }(t15);
  let n = "BOD", i = 0, s = r[i];
  for (; !Ep(s, N4); ) {
    let a = 0;
    const o = [];
    if (n === "BOD") {
      if (s.text !== "M" && s.text !== "m") return yg("M0,0" + t15);
      i++, a = hh[s.text], n = s.text;
    } else Ep(s, $p) ? a = hh[n] : (i++, a = hh[s.text], n = s.text);
    if (!(i + a < r.length)) throw new Error("Path data ended short");
    for (let l = i; l < i + a; l++) {
      const c = r[l];
      if (!Ep(c, $p)) throw new Error("Param not a number: " + n + "," + c.text);
      o[o.length] = +c.text;
    }
    if (typeof hh[n] != "number") throw new Error("Bad segment: " + n);
    {
      const l = { key: n, data: o };
      e.push(l), i += a, s = r[i], n === "M" && (n = "L"), n === "m" && (n = "l");
    }
  }
  return e;
}
function bv(t15) {
  let e = 0, r = 0, n = 0, i = 0;
  const s = [];
  for (const { key: a, data: o } of t15) switch (a) {
    case "M":
      s.push({ key: "M", data: [...o] }), [e, r] = o, [n, i] = o;
      break;
    case "m":
      e += o[0], r += o[1], s.push({ key: "M", data: [e, r] }), n = e, i = r;
      break;
    case "L":
      s.push({ key: "L", data: [...o] }), [e, r] = o;
      break;
    case "l":
      e += o[0], r += o[1], s.push({ key: "L", data: [e, r] });
      break;
    case "C":
      s.push({ key: "C", data: [...o] }), e = o[4], r = o[5];
      break;
    case "c": {
      const l = o.map((c, h) => h % 2 ? c + r : c + e);
      s.push({ key: "C", data: l }), e = l[4], r = l[5];
      break;
    }
    case "Q":
      s.push({ key: "Q", data: [...o] }), e = o[2], r = o[3];
      break;
    case "q": {
      const l = o.map((c, h) => h % 2 ? c + r : c + e);
      s.push({ key: "Q", data: l }), e = l[2], r = l[3];
      break;
    }
    case "A":
      s.push({ key: "A", data: [...o] }), e = o[5], r = o[6];
      break;
    case "a":
      e += o[5], r += o[6], s.push({ key: "A", data: [o[0], o[1], o[2], o[3], o[4], e, r] });
      break;
    case "H":
      s.push({ key: "H", data: [...o] }), e = o[0];
      break;
    case "h":
      e += o[0], s.push({ key: "H", data: [e] });
      break;
    case "V":
      s.push({ key: "V", data: [...o] }), r = o[0];
      break;
    case "v":
      r += o[0], s.push({ key: "V", data: [r] });
      break;
    case "S":
      s.push({ key: "S", data: [...o] }), e = o[2], r = o[3];
      break;
    case "s": {
      const l = o.map((c, h) => h % 2 ? c + r : c + e);
      s.push({ key: "S", data: l }), e = l[2], r = l[3];
      break;
    }
    case "T":
      s.push({ key: "T", data: [...o] }), e = o[0], r = o[1];
      break;
    case "t":
      e += o[0], r += o[1], s.push({ key: "T", data: [e, r] });
      break;
    case "Z":
    case "z":
      s.push({ key: "Z", data: [] }), e = n, r = i;
  }
  return s;
}
function xv(t15) {
  const e = [];
  let r = "", n = 0, i = 0, s = 0, a = 0, o = 0, l = 0;
  for (const { key: c, data: h } of t15) {
    switch (c) {
      case "M":
        e.push({ key: "M", data: [...h] }), [n, i] = h, [s, a] = h;
        break;
      case "C":
        e.push({ key: "C", data: [...h] }), n = h[4], i = h[5], o = h[2], l = h[3];
        break;
      case "L":
        e.push({ key: "L", data: [...h] }), [n, i] = h;
        break;
      case "H":
        n = h[0], e.push({ key: "L", data: [n, i] });
        break;
      case "V":
        i = h[0], e.push({ key: "L", data: [n, i] });
        break;
      case "S": {
        let p = 0, m = 0;
        r === "C" || r === "S" ? (p = n + (n - o), m = i + (i - l)) : (p = n, m = i), e.push({ key: "C", data: [p, m, ...h] }), o = h[0], l = h[1], n = h[2], i = h[3];
        break;
      }
      case "T": {
        const [p, m] = h;
        let g = 0, y = 0;
        r === "Q" || r === "T" ? (g = n + (n - o), y = i + (i - l)) : (g = n, y = i);
        const x = n + 2 * (g - n) / 3, k = i + 2 * (y - i) / 3, C = p + 2 * (g - p) / 3, A = m + 2 * (y - m) / 3;
        e.push({ key: "C", data: [x, k, C, A, p, m] }), o = g, l = y, n = p, i = m;
        break;
      }
      case "Q": {
        const [p, m, g, y] = h, x = n + 2 * (p - n) / 3, k = i + 2 * (m - i) / 3, C = g + 2 * (p - g) / 3, A = y + 2 * (m - y) / 3;
        e.push({ key: "C", data: [x, k, C, A, g, y] }), o = p, l = m, n = g, i = y;
        break;
      }
      case "A": {
        const p = Math.abs(h[0]), m = Math.abs(h[1]), g = h[2], y = h[3], x = h[4], k = h[5], C = h[6];
        p === 0 || m === 0 ? (e.push({ key: "C", data: [n, i, k, C, k, C] }), n = k, i = C) : (n !== k || i !== C) && (wv(n, i, k, C, p, m, g, y, x).forEach(function(A) {
          e.push({ key: "C", data: A });
        }), n = k, i = C);
        break;
      }
      case "Z":
        e.push({ key: "Z", data: [] }), n = s, i = a;
    }
    r = c;
  }
  return e;
}
function Go(t15, e, r) {
  return [t15 * Math.cos(r) - e * Math.sin(r), t15 * Math.sin(r) + e * Math.cos(r)];
}
function wv(t15, e, r, n, i, s, a, o, l, c) {
  const h = (p = a, Math.PI * p / 180);
  var p;
  let m = [], g = 0, y = 0, x = 0, k = 0;
  if (c) [g, y, x, k] = c;
  else {
    [t15, e] = Go(t15, e, -h), [r, n] = Go(r, n, -h);
    const rt = (t15 - r) / 2, I = (e - n) / 2;
    let j = rt * rt / (i * i) + I * I / (s * s);
    j > 1 && (j = Math.sqrt(j), i *= j, s *= j);
    const z = i * i, K = s * s, Y = z * K - z * I * I - K * rt * rt, ot = z * I * I + K * rt * rt, et = (o === l ? -1 : 1) * Math.sqrt(Math.abs(Y / ot));
    x = et * i * I / s + (t15 + r) / 2, k = et * -s * rt / i + (e + n) / 2, g = Math.asin(parseFloat(((e - k) / s).toFixed(9))), y = Math.asin(parseFloat(((n - k) / s).toFixed(9))), t15 < x && (g = Math.PI - g), r < x && (y = Math.PI - y), g < 0 && (g = 2 * Math.PI + g), y < 0 && (y = 2 * Math.PI + y), l && g > y && (g -= 2 * Math.PI), !l && y > g && (y -= 2 * Math.PI);
  }
  let C = y - g;
  if (Math.abs(C) > 120 * Math.PI / 180) {
    const rt = y, I = r, j = n;
    y = l && y > g ? g + 120 * Math.PI / 180 * 1 : g + 120 * Math.PI / 180 * -1, m = wv(r = x + i * Math.cos(y), n = k + s * Math.sin(y), I, j, i, s, a, 0, l, [y, rt, x, k]);
  }
  C = y - g;
  const A = Math.cos(g), $ = Math.sin(g), B = Math.cos(y), L = Math.sin(y), q = Math.tan(C / 4), U = 4 / 3 * i * q, G = 4 / 3 * s * q, F = [t15, e], W = [t15 + U * $, e - G * A], R = [r + U * L, n - G * B], Q = [r, n];
  if (W[0] = 2 * F[0] - W[0], W[1] = 2 * F[1] - W[1], c) return [W, R, Q].concat(m);
  {
    m = [W, R, Q].concat(m);
    const rt = [];
    for (let I = 0; I < m.length; I += 3) {
      const j = Go(m[I][0], m[I][1], h), z = Go(m[I + 1][0], m[I + 1][1], h), K = Go(m[I + 2][0], m[I + 2][1], h);
      rt.push([j[0], j[1], z[0], z[1], K[0], K[1]]);
    }
    return rt;
  }
}
var UY = { randOffset: function(t15, e) {
  return Pt(t15, e);
}, randOffsetWithRange: function(t15, e, r) {
  return j0(t15, e, r);
}, ellipse: function(t15, e, r, n, i) {
  const s = vv(r, n, i);
  return o1(t15, e, i, s).opset;
}, doubleLineOps: function(t15, e, r, n, i) {
  return hs(t15, e, r, n, i, true);
} };
function kv(t15, e, r, n, i) {
  return { type: "path", ops: hs(t15, e, r, n, i) };
}
function Oh(t15, e, r) {
  const n = (t15 || []).length;
  if (n > 2) {
    const i = [];
    for (let s = 0; s < n - 1; s++) i.push(...hs(t15[s][0], t15[s][1], t15[s + 1][0], t15[s + 1][1], r));
    return e && i.push(...hs(t15[n - 1][0], t15[n - 1][1], t15[0][0], t15[0][1], r)), { type: "path", ops: i };
  }
  return n === 2 ? kv(t15[0][0], t15[0][1], t15[1][0], t15[1][1], r) : { type: "path", ops: [] };
}
function VY(t15, e, r, n, i) {
  return function(s, a) {
    return Oh(s, true, a);
  }([[t15, e], [t15 + r, e], [t15 + r, e + n], [t15, e + n]], i);
}
function I4(t15, e) {
  if (t15.length) {
    const r = typeof t15[0][0] == "number" ? [t15] : t15, n = uh(r[0], 1 * (1 + 0.2 * e.roughness), e), i = e.disableMultiStroke ? [] : uh(r[0], 1.5 * (1 + 0.22 * e.roughness), q4(e));
    for (let s = 1; s < r.length; s++) {
      const a = r[s];
      if (a.length) {
        const o = uh(a, 1 * (1 + 0.2 * e.roughness), e), l = e.disableMultiStroke ? [] : uh(a, 1.5 * (1 + 0.22 * e.roughness), q4(e));
        for (const c of o) c.op !== "move" && n.push(c);
        for (const c of l) c.op !== "move" && i.push(c);
      }
    }
    return { type: "path", ops: n.concat(i) };
  }
  return { type: "path", ops: [] };
}
function vv(t15, e, r) {
  const n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t15 / 2, 2) + Math.pow(e / 2, 2)) / 2)), i = Math.ceil(Math.max(r.curveStepCount, r.curveStepCount / Math.sqrt(200) * n)), s = 2 * Math.PI / i;
  let a = Math.abs(t15 / 2), o = Math.abs(e / 2);
  const l = 1 - r.curveFitting;
  return a += Pt(a * l, r), o += Pt(o * l, r), { increment: s, rx: a, ry: o };
}
function o1(t15, e, r, n) {
  const [i, s] = R4(n.increment, t15, e, n.rx, n.ry, 1, n.increment * j0(0.1, j0(0.4, 1, r), r), r);
  let a = W0(i, null, r);
  if (!r.disableMultiStroke && r.roughness !== 0) {
    const [o] = R4(n.increment, t15, e, n.rx, n.ry, 1.5, 0, r), l = W0(o, null, r);
    a = a.concat(l);
  }
  return { estimatedPoints: s, opset: { type: "path", ops: a } };
}
function O4(t15, e, r, n, i, s, a, o, l) {
  const c = t15, h = e;
  let p = Math.abs(r / 2), m = Math.abs(n / 2);
  p += Pt(0.01 * p, l), m += Pt(0.01 * m, l);
  let g = i, y = s;
  for (; g < 0; ) g += 2 * Math.PI, y += 2 * Math.PI;
  y - g > 2 * Math.PI && (g = 0, y = 2 * Math.PI);
  const x = 2 * Math.PI / l.curveStepCount, k = Math.min(x / 2, (y - g) / 2), C = P4(k, c, h, p, m, g, y, 1, l);
  if (!l.disableMultiStroke) {
    const A = P4(k, c, h, p, m, g, y, 1.5, l);
    C.push(...A);
  }
  return a && (o ? C.push(...hs(c, h, c + p * Math.cos(g), h + m * Math.sin(g), l), ...hs(c, h, c + p * Math.cos(y), h + m * Math.sin(y), l)) : C.push({ op: "lineTo", data: [c, h] }, { op: "lineTo", data: [c + p * Math.cos(g), h + m * Math.sin(g)] })), { type: "path", ops: C };
}
function z4(t15, e) {
  const r = xv(bv(yg(t15))), n = [];
  let i = [0, 0], s = [0, 0];
  for (const { key: a, data: o } of r) switch (a) {
    case "M":
      s = [o[0], o[1]], i = [o[0], o[1]];
      break;
    case "L":
      n.push(...hs(s[0], s[1], o[0], o[1], e)), s = [o[0], o[1]];
      break;
    case "C": {
      const [l, c, h, p, m, g] = o;
      n.push(...GY(l, c, h, p, m, g, s, e)), s = [m, g];
      break;
    }
    case "Z":
      n.push(...hs(s[0], s[1], i[0], i[1], e)), s = [i[0], i[1]];
  }
  return { type: "path", ops: n };
}
function Mp(t15, e) {
  const r = [];
  for (const n of t15) if (n.length) {
    const i = e.maxRandomnessOffset || 0, s = n.length;
    if (s > 2) {
      r.push({ op: "move", data: [n[0][0] + Pt(i, e), n[0][1] + Pt(i, e)] });
      for (let a = 1; a < s; a++) r.push({ op: "lineTo", data: [n[a][0] + Pt(i, e), n[a][1] + Pt(i, e)] });
    }
  }
  return { type: "fillPath", ops: r };
}
function Ca(t15, e) {
  return function(r, n) {
    let i = r.fillStyle || "hachure";
    if (!Fr[i]) switch (i) {
      case "zigzag":
        Fr[i] || (Fr[i] = new zY(n));
        break;
      case "cross-hatch":
        Fr[i] || (Fr[i] = new qY(n));
        break;
      case "dots":
        Fr[i] || (Fr[i] = new RY(n));
        break;
      case "dashed":
        Fr[i] || (Fr[i] = new PY(n));
        break;
      case "zigzag-line":
        Fr[i] || (Fr[i] = new jY(n));
        break;
      default:
        i = "hachure", Fr[i] || (Fr[i] = new gg(n));
    }
    return Fr[i];
  }(e, UY).fillPolygons(t15, e);
}
function q4(t15) {
  const e = Object.assign({}, t15);
  return e.randomizer = void 0, t15.seed && (e.seed = t15.seed + 1), e;
}
function Cv(t15) {
  return t15.randomizer || (t15.randomizer = new WY(t15.seed || 0)), t15.randomizer.next();
}
function j0(t15, e, r, n = 1) {
  return r.roughness * n * (Cv(r) * (e - t15) + t15);
}
function Pt(t15, e, r = 1) {
  return j0(-t15, t15, e, r);
}
function hs(t15, e, r, n, i, s = false) {
  const a = s ? i.disableMultiStrokeFill : i.disableMultiStroke, o = l1(t15, e, r, n, i, true, false);
  if (a) return o;
  const l = l1(t15, e, r, n, i, true, true);
  return o.concat(l);
}
function l1(t15, e, r, n, i, s, a) {
  const o = Math.pow(t15 - r, 2) + Math.pow(e - n, 2), l = Math.sqrt(o);
  let c = 1;
  c = l < 200 ? 1 : l > 500 ? 0.4 : -16668e-7 * l + 1.233334;
  let h = i.maxRandomnessOffset || 0;
  h * h * 100 > o && (h = l / 10);
  const p = h / 2, m = 0.2 + 0.2 * Cv(i);
  let g = i.bowing * i.maxRandomnessOffset * (n - e) / 200, y = i.bowing * i.maxRandomnessOffset * (t15 - r) / 200;
  g = Pt(g, i, c), y = Pt(y, i, c);
  const x = [], k = () => Pt(p, i, c), C = () => Pt(h, i, c), A = i.preserveVertices;
  return a ? x.push({ op: "move", data: [t15 + (A ? 0 : k()), e + (A ? 0 : k())] }) : x.push({ op: "move", data: [t15 + (A ? 0 : Pt(h, i, c)), e + (A ? 0 : Pt(h, i, c))] }), a ? x.push({ op: "bcurveTo", data: [g + t15 + (r - t15) * m + k(), y + e + (n - e) * m + k(), g + t15 + 2 * (r - t15) * m + k(), y + e + 2 * (n - e) * m + k(), r + (A ? 0 : k()), n + (A ? 0 : k())] }) : x.push({ op: "bcurveTo", data: [g + t15 + (r - t15) * m + C(), y + e + (n - e) * m + C(), g + t15 + 2 * (r - t15) * m + C(), y + e + 2 * (n - e) * m + C(), r + (A ? 0 : C()), n + (A ? 0 : C())] }), x;
}
function uh(t15, e, r) {
  if (!t15.length) return [];
  const n = [];
  n.push([t15[0][0] + Pt(e, r), t15[0][1] + Pt(e, r)]), n.push([t15[0][0] + Pt(e, r), t15[0][1] + Pt(e, r)]);
  for (let i = 1; i < t15.length; i++) n.push([t15[i][0] + Pt(e, r), t15[i][1] + Pt(e, r)]), i === t15.length - 1 && n.push([t15[i][0] + Pt(e, r), t15[i][1] + Pt(e, r)]);
  return W0(n, null, r);
}
function W0(t15, e, r) {
  const n = t15.length, i = [];
  if (n > 3) {
    const s = [], a = 1 - r.curveTightness;
    i.push({ op: "move", data: [t15[1][0], t15[1][1]] });
    for (let o = 1; o + 2 < n; o++) {
      const l = t15[o];
      s[0] = [l[0], l[1]], s[1] = [l[0] + (a * t15[o + 1][0] - a * t15[o - 1][0]) / 6, l[1] + (a * t15[o + 1][1] - a * t15[o - 1][1]) / 6], s[2] = [t15[o + 1][0] + (a * t15[o][0] - a * t15[o + 2][0]) / 6, t15[o + 1][1] + (a * t15[o][1] - a * t15[o + 2][1]) / 6], s[3] = [t15[o + 1][0], t15[o + 1][1]], i.push({ op: "bcurveTo", data: [s[1][0], s[1][1], s[2][0], s[2][1], s[3][0], s[3][1]] });
    }
  } else n === 3 ? (i.push({ op: "move", data: [t15[1][0], t15[1][1]] }), i.push({ op: "bcurveTo", data: [t15[1][0], t15[1][1], t15[2][0], t15[2][1], t15[2][0], t15[2][1]] })) : n === 2 && i.push(...l1(t15[0][0], t15[0][1], t15[1][0], t15[1][1], r, true, true));
  return i;
}
function R4(t15, e, r, n, i, s, a, o) {
  const l = [], c = [];
  if (o.roughness === 0) {
    t15 /= 4, c.push([e + n * Math.cos(-t15), r + i * Math.sin(-t15)]);
    for (let h = 0; h <= 2 * Math.PI; h += t15) {
      const p = [e + n * Math.cos(h), r + i * Math.sin(h)];
      l.push(p), c.push(p);
    }
    c.push([e + n * Math.cos(0), r + i * Math.sin(0)]), c.push([e + n * Math.cos(t15), r + i * Math.sin(t15)]);
  } else {
    const h = Pt(0.5, o) - Math.PI / 2;
    c.push([Pt(s, o) + e + 0.9 * n * Math.cos(h - t15), Pt(s, o) + r + 0.9 * i * Math.sin(h - t15)]);
    const p = 2 * Math.PI + h - 0.01;
    for (let m = h; m < p; m += t15) {
      const g = [Pt(s, o) + e + n * Math.cos(m), Pt(s, o) + r + i * Math.sin(m)];
      l.push(g), c.push(g);
    }
    c.push([Pt(s, o) + e + n * Math.cos(h + 2 * Math.PI + 0.5 * a), Pt(s, o) + r + i * Math.sin(h + 2 * Math.PI + 0.5 * a)]), c.push([Pt(s, o) + e + 0.98 * n * Math.cos(h + a), Pt(s, o) + r + 0.98 * i * Math.sin(h + a)]), c.push([Pt(s, o) + e + 0.9 * n * Math.cos(h + 0.5 * a), Pt(s, o) + r + 0.9 * i * Math.sin(h + 0.5 * a)]);
  }
  return [c, l];
}
function P4(t15, e, r, n, i, s, a, o, l) {
  const c = s + Pt(0.1, l), h = [];
  h.push([Pt(o, l) + e + 0.9 * n * Math.cos(c - t15), Pt(o, l) + r + 0.9 * i * Math.sin(c - t15)]);
  for (let p = c; p <= a; p += t15) h.push([Pt(o, l) + e + n * Math.cos(p), Pt(o, l) + r + i * Math.sin(p)]);
  return h.push([e + n * Math.cos(a), r + i * Math.sin(a)]), h.push([e + n * Math.cos(a), r + i * Math.sin(a)]), W0(h, null, l);
}
function GY(t15, e, r, n, i, s, a, o) {
  const l = [], c = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];
  let h = [0, 0];
  const p = o.disableMultiStroke ? 1 : 2, m = o.preserveVertices;
  for (let g = 0; g < p; g++) g === 0 ? l.push({ op: "move", data: [a[0], a[1]] }) : l.push({ op: "move", data: [a[0] + (m ? 0 : Pt(c[0], o)), a[1] + (m ? 0 : Pt(c[0], o))] }), h = m ? [i, s] : [i + Pt(c[g], o), s + Pt(c[g], o)], l.push({ op: "bcurveTo", data: [t15 + Pt(c[g], o), e + Pt(c[g], o), r + Pt(c[g], o), n + Pt(c[g], o), h[0], h[1]] });
  return l;
}
function Xo(t15) {
  return [...t15];
}
function j4(t15, e = 0) {
  const r = t15.length;
  if (r < 3) throw new Error("A curve must have at least three points.");
  const n = [];
  if (r === 3) n.push(Xo(t15[0]), Xo(t15[1]), Xo(t15[2]), Xo(t15[2]));
  else {
    const i = [];
    i.push(t15[0], t15[0]);
    for (let o = 1; o < t15.length; o++) i.push(t15[o]), o === t15.length - 1 && i.push(t15[o]);
    const s = [], a = 1 - e;
    n.push(Xo(i[0]));
    for (let o = 1; o + 2 < i.length; o++) {
      const l = i[o];
      s[0] = [l[0], l[1]], s[1] = [l[0] + (a * i[o + 1][0] - a * i[o - 1][0]) / 6, l[1] + (a * i[o + 1][1] - a * i[o - 1][1]) / 6], s[2] = [i[o + 1][0] + (a * i[o][0] - a * i[o + 2][0]) / 6, i[o + 1][1] + (a * i[o][1] - a * i[o + 2][1]) / 6], s[3] = [i[o + 1][0], i[o + 1][1]], n.push(s[1], s[2], s[3]);
    }
  }
  return n;
}
function zh(t15, e) {
  return Math.pow(t15[0] - e[0], 2) + Math.pow(t15[1] - e[1], 2);
}
function XY(t15, e, r) {
  const n = zh(e, r);
  if (n === 0) return zh(t15, e);
  let i = ((t15[0] - e[0]) * (r[0] - e[0]) + (t15[1] - e[1]) * (r[1] - e[1])) / n;
  return i = Math.max(0, Math.min(1, i)), zh(t15, Ls(e, r, i));
}
function Ls(t15, e, r) {
  return [t15[0] + (e[0] - t15[0]) * r, t15[1] + (e[1] - t15[1]) * r];
}
function c1(t15, e, r, n) {
  const i = n || [];
  if (function(o, l) {
    const c = o[l + 0], h = o[l + 1], p = o[l + 2], m = o[l + 3];
    let g = 3 * h[0] - 2 * c[0] - m[0];
    g *= g;
    let y = 3 * h[1] - 2 * c[1] - m[1];
    y *= y;
    let x = 3 * p[0] - 2 * m[0] - c[0];
    x *= x;
    let k = 3 * p[1] - 2 * m[1] - c[1];
    return k *= k, g < x && (g = x), y < k && (y = k), g + y;
  }(t15, e) < r) {
    const o = t15[e + 0];
    i.length ? (s = i[i.length - 1], a = o, Math.sqrt(zh(s, a)) > 1 && i.push(o)) : i.push(o), i.push(t15[e + 3]);
  } else {
    const o = t15[e + 0], l = t15[e + 1], c = t15[e + 2], h = t15[e + 3], p = Ls(o, l, 0.5), m = Ls(l, c, 0.5), g = Ls(c, h, 0.5), y = Ls(p, m, 0.5), x = Ls(m, g, 0.5), k = Ls(y, x, 0.5);
    c1([o, p, y, k], 0, r, i), c1([k, x, g, h], 0, r, i);
  }
  var s, a;
  return i;
}
function YY(t15, e) {
  return H0(t15, 0, t15.length, e);
}
function H0(t15, e, r, n, i) {
  const s = i || [], a = t15[e], o = t15[r - 1];
  let l = 0, c = 1;
  for (let h = e + 1; h < r - 1; ++h) {
    const p = XY(t15[h], a, o);
    p > l && (l = p, c = h);
  }
  return Math.sqrt(l) > n ? (H0(t15, e, c + 1, n, s), H0(t15, c, r, n, s)) : (s.length || s.push(a), s.push(o)), s;
}
function Bp(t15, e = 0.15, r) {
  const n = [], i = (t15.length - 1) / 3;
  for (let s = 0; s < i; s++)
    c1(t15, 3 * s, e, n);
  return r && r > 0 ? H0(n, 0, n.length, r) : n;
}
var Kr = "none";
var U0 = class {
  constructor(e) {
    this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: 0.95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: false, disableMultiStrokeFill: false, preserveVertices: false, fillShapeRoughnessGain: 0.8 }, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(e) {
    return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
  }
  _d(e, r, n) {
    return { shape: e, sets: r || [], options: n || this.defaultOptions };
  }
  line(e, r, n, i, s) {
    const a = this._o(s);
    return this._d("line", [kv(e, r, n, i, a)], a);
  }
  rectangle(e, r, n, i, s) {
    const a = this._o(s), o = [], l = VY(e, r, n, i, a);
    if (a.fill) {
      const c = [[e, r], [e + n, r], [e + n, r + i], [e, r + i]];
      a.fillStyle === "solid" ? o.push(Mp([c], a)) : o.push(Ca([c], a));
    }
    return a.stroke !== Kr && o.push(l), this._d("rectangle", o, a);
  }
  ellipse(e, r, n, i, s) {
    const a = this._o(s), o = [], l = vv(n, i, a), c = o1(e, r, a, l);
    if (a.fill) if (a.fillStyle === "solid") {
      const h = o1(e, r, a, l).opset;
      h.type = "fillPath", o.push(h);
    } else o.push(Ca([c.estimatedPoints], a));
    return a.stroke !== Kr && o.push(c.opset), this._d("ellipse", o, a);
  }
  circle(e, r, n, i) {
    const s = this.ellipse(e, r, n, n, i);
    return s.shape = "circle", s;
  }
  linearPath(e, r) {
    const n = this._o(r);
    return this._d("linearPath", [Oh(e, false, n)], n);
  }
  arc(e, r, n, i, s, a, o = false, l) {
    const c = this._o(l), h = [], p = O4(e, r, n, i, s, a, o, true, c);
    if (o && c.fill) if (c.fillStyle === "solid") {
      const m = Object.assign({}, c);
      m.disableMultiStroke = true;
      const g = O4(e, r, n, i, s, a, true, false, m);
      g.type = "fillPath", h.push(g);
    } else h.push(function(m, g, y, x, k, C, A) {
      const $ = m, B = g;
      let L = Math.abs(y / 2), q = Math.abs(x / 2);
      L += Pt(0.01 * L, A), q += Pt(0.01 * q, A);
      let U = k, G = C;
      for (; U < 0; ) U += 2 * Math.PI, G += 2 * Math.PI;
      G - U > 2 * Math.PI && (U = 0, G = 2 * Math.PI);
      const F = (G - U) / A.curveStepCount, W = [];
      for (let R = U; R <= G; R += F) W.push([$ + L * Math.cos(R), B + q * Math.sin(R)]);
      return W.push([$ + L * Math.cos(G), B + q * Math.sin(G)]), W.push([$, B]), Ca([W], A);
    }(e, r, n, i, s, a, c));
    return c.stroke !== Kr && h.push(p), this._d("arc", h, c);
  }
  curve(e, r) {
    const n = this._o(r), i = [], s = I4(e, n);
    if (n.fill && n.fill !== Kr) if (n.fillStyle === "solid") {
      const a = I4(e, Object.assign(Object.assign({}, n), { disableMultiStroke: true, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      i.push({ type: "fillPath", ops: this._mergedShape(a.ops) });
    } else {
      const a = [], o = e;
      if (o.length) {
        const l = typeof o[0][0] == "number" ? [o] : o;
        for (const c of l) c.length < 3 ? a.push(...c) : c.length === 3 ? a.push(...Bp(j4([c[0], c[0], c[1], c[2]]), 10, (1 + n.roughness) / 2)) : a.push(...Bp(j4(c), 10, (1 + n.roughness) / 2));
      }
      a.length && i.push(Ca([a], n));
    }
    return n.stroke !== Kr && i.push(s), this._d("curve", i, n);
  }
  polygon(e, r) {
    const n = this._o(r), i = [], s = Oh(e, true, n);
    return n.fill && (n.fillStyle === "solid" ? i.push(Mp([e], n)) : i.push(Ca([e], n))), n.stroke !== Kr && i.push(s), this._d("polygon", i, n);
  }
  path(e, r) {
    const n = this._o(r), i = [];
    if (!e) return this._d("path", i, n);
    e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const s = n.fill && n.fill !== "transparent" && n.fill !== Kr, a = n.stroke !== Kr, o = !!(n.simplification && n.simplification < 1), l = function(h, p, m) {
      const g = xv(bv(yg(h))), y = [];
      let x = [], k = [0, 0], C = [];
      const A = () => {
        C.length >= 4 && x.push(...Bp(C, p)), C = [];
      }, $ = () => {
        A(), x.length && (y.push(x), x = []);
      };
      for (const { key: L, data: q } of g) switch (L) {
        case "M":
          $(), k = [q[0], q[1]], x.push(k);
          break;
        case "L":
          A(), x.push([q[0], q[1]]);
          break;
        case "C":
          if (!C.length) {
            const U = x.length ? x[x.length - 1] : k;
            C.push([U[0], U[1]]);
          }
          C.push([q[0], q[1]]), C.push([q[2], q[3]]), C.push([q[4], q[5]]);
          break;
        case "Z":
          A(), x.push([k[0], k[1]]);
      }
      if ($(), !m) return y;
      const B = [];
      for (const L of y) {
        const q = YY(L, m);
        q.length && B.push(q);
      }
      return B;
    }(e, 1, o ? 4 - 4 * (n.simplification || 1) : (1 + n.roughness) / 2), c = z4(e, n);
    if (s) if (n.fillStyle === "solid") if (l.length === 1) {
      const h = z4(e, Object.assign(Object.assign({}, n), { disableMultiStroke: true, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      i.push({ type: "fillPath", ops: this._mergedShape(h.ops) });
    } else i.push(Mp(l, n));
    else i.push(Ca(l, n));
    return a && (o ? l.forEach((h) => {
      i.push(Oh(h, false, n));
    }) : i.push(c)), this._d("path", i, n);
  }
  opsToPath(e, r) {
    let n = "";
    for (const i of e.ops) {
      const s = typeof r == "number" && r >= 0 ? i.data.map((a) => +a.toFixed(r)) : i.data;
      switch (i.op) {
        case "move":
          n += `M${s[0]} ${s[1]} `;
          break;
        case "bcurveTo":
          n += `C${s[0]} ${s[1]}, ${s[2]} ${s[3]}, ${s[4]} ${s[5]} `;
          break;
        case "lineTo":
          n += `L${s[0]} ${s[1]} `;
      }
    }
    return n.trim();
  }
  toPaths(e) {
    const r = e.sets || [], n = e.options || this.defaultOptions, i = [];
    for (const s of r) {
      let a = null;
      switch (s.type) {
        case "path":
          a = { d: this.opsToPath(s), stroke: n.stroke, strokeWidth: n.strokeWidth, fill: Kr };
          break;
        case "fillPath":
          a = { d: this.opsToPath(s), stroke: Kr, strokeWidth: 0, fill: n.fill || Kr };
          break;
        case "fillSketch":
          a = this.fillSketch(s, n);
      }
      a && i.push(a);
    }
    return i;
  }
  fillSketch(e, r) {
    let n = r.fillWeight;
    return n < 0 && (n = r.strokeWidth / 2), { d: this.opsToPath(e), stroke: r.fill || Kr, strokeWidth: n, fill: Kr };
  }
  _mergedShape(e) {
    return e.filter((r, n) => n === 0 || r.op !== "move");
  }
};
var KY = class {
  constructor(e, r) {
    this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new U0(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), i = this.ctx, s = e.options.fixedDecimalPlaceDigits;
    for (const a of r) switch (a.type) {
      case "path":
        i.save(), i.strokeStyle = n.stroke === "none" ? "transparent" : n.stroke, i.lineWidth = n.strokeWidth, n.strokeLineDash && i.setLineDash(n.strokeLineDash), n.strokeLineDashOffset && (i.lineDashOffset = n.strokeLineDashOffset), this._drawToContext(i, a, s), i.restore();
        break;
      case "fillPath": {
        i.save(), i.fillStyle = n.fill || "";
        const o = e.shape === "curve" || e.shape === "polygon" || e.shape === "path" ? "evenodd" : "nonzero";
        this._drawToContext(i, a, s, o), i.restore();
        break;
      }
      case "fillSketch":
        this.fillSketch(i, a, n);
    }
  }
  fillSketch(e, r, n) {
    let i = n.fillWeight;
    i < 0 && (i = n.strokeWidth / 2), e.save(), n.fillLineDash && e.setLineDash(n.fillLineDash), n.fillLineDashOffset && (e.lineDashOffset = n.fillLineDashOffset), e.strokeStyle = n.fill || "", e.lineWidth = i, this._drawToContext(e, r, n.fixedDecimalPlaceDigits), e.restore();
  }
  _drawToContext(e, r, n, i = "nonzero") {
    e.beginPath();
    for (const s of r.ops) {
      const a = typeof n == "number" && n >= 0 ? s.data.map((o) => +o.toFixed(n)) : s.data;
      switch (s.op) {
        case "move":
          e.moveTo(a[0], a[1]);
          break;
        case "bcurveTo":
          e.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
          break;
        case "lineTo":
          e.lineTo(a[0], a[1]);
      }
    }
    r.type === "fillPath" ? e.fill(i) : e.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(e, r, n, i, s) {
    const a = this.gen.line(e, r, n, i, s);
    return this.draw(a), a;
  }
  rectangle(e, r, n, i, s) {
    const a = this.gen.rectangle(e, r, n, i, s);
    return this.draw(a), a;
  }
  ellipse(e, r, n, i, s) {
    const a = this.gen.ellipse(e, r, n, i, s);
    return this.draw(a), a;
  }
  circle(e, r, n, i) {
    const s = this.gen.circle(e, r, n, i);
    return this.draw(s), s;
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n), n;
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n), n;
  }
  arc(e, r, n, i, s, a, o = false, l) {
    const c = this.gen.arc(e, r, n, i, s, a, o, l);
    return this.draw(c), c;
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n), n;
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n), n;
  }
};
var dh = "http://www.w3.org/2000/svg";
var ZY = class {
  constructor(e, r) {
    this.svg = e, this.gen = new U0(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), i = this.svg.ownerDocument || window.document, s = i.createElementNS(dh, "g"), a = e.options.fixedDecimalPlaceDigits;
    for (const o of r) {
      let l = null;
      switch (o.type) {
        case "path":
          l = i.createElementNS(dh, "path"), l.setAttribute("d", this.opsToPath(o, a)), l.setAttribute("stroke", n.stroke), l.setAttribute("stroke-width", n.strokeWidth + ""), l.setAttribute("fill", "none"), n.strokeLineDash && l.setAttribute("stroke-dasharray", n.strokeLineDash.join(" ").trim()), n.strokeLineDashOffset && l.setAttribute("stroke-dashoffset", `${n.strokeLineDashOffset}`);
          break;
        case "fillPath":
          l = i.createElementNS(dh, "path"), l.setAttribute("d", this.opsToPath(o, a)), l.setAttribute("stroke", "none"), l.setAttribute("stroke-width", "0"), l.setAttribute("fill", n.fill || ""), e.shape !== "curve" && e.shape !== "polygon" || l.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          l = this.fillSketch(i, o, n);
      }
      l && s.appendChild(l);
    }
    return s;
  }
  fillSketch(e, r, n) {
    let i = n.fillWeight;
    i < 0 && (i = n.strokeWidth / 2);
    const s = e.createElementNS(dh, "path");
    return s.setAttribute("d", this.opsToPath(r, n.fixedDecimalPlaceDigits)), s.setAttribute("stroke", n.fill || ""), s.setAttribute("stroke-width", i + ""), s.setAttribute("fill", "none"), n.fillLineDash && s.setAttribute("stroke-dasharray", n.fillLineDash.join(" ").trim()), n.fillLineDashOffset && s.setAttribute("stroke-dashoffset", `${n.fillLineDashOffset}`), s;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(e, r) {
    return this.gen.opsToPath(e, r);
  }
  line(e, r, n, i, s) {
    const a = this.gen.line(e, r, n, i, s);
    return this.draw(a);
  }
  rectangle(e, r, n, i, s) {
    const a = this.gen.rectangle(e, r, n, i, s);
    return this.draw(a);
  }
  ellipse(e, r, n, i, s) {
    const a = this.gen.ellipse(e, r, n, i, s);
    return this.draw(a);
  }
  circle(e, r, n, i) {
    const s = this.gen.circle(e, r, n, i);
    return this.draw(s);
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n);
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n);
  }
  arc(e, r, n, i, s, a, o = false, l) {
    const c = this.gen.arc(e, r, n, i, s, a, o, l);
    return this.draw(c);
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n);
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n);
  }
};
var Mt = { canvas: (t15, e) => new KY(t15, e), svg: (t15, e) => new ZY(t15, e), generator: (t15) => new U0(t15), newSeed: () => U0.newSeed() };
var Vt = _(async (t15, e, r) => {
  var _a3, _b2;
  let n;
  const i = e.useHtmlLabels || Ke((_a3 = fe()) == null ? void 0 : _a3.htmlLabels);
  r ? n = r : n = "node default";
  const s = t15.insert("g").attr("class", n).attr("id", e.domId || e.id), a = s.insert("g").attr("class", "label").attr("style", Tr(e.labelStyle));
  let o;
  e.label === void 0 ? o = "" : o = typeof e.label == "string" ? e.label : e.label[0];
  const l = await fs(a, Zs(ca(o), fe()), {
    useHtmlLabels: i,
    width: e.width || ((_b2 = fe().flowchart) == null ? void 0 : _b2.wrappingWidth),
    // @ts-expect-error -- This is currently not used. Should this be `classes` instead?
    cssClasses: "markdown-node-label",
    style: e.labelStyle,
    addSvgBackground: !!e.icon || !!e.img
  });
  let c = l.getBBox();
  const h = ((e == null ? void 0 : e.padding) ?? 0) / 2;
  if (i) {
    const p = l.children[0], m = ae(l), g = p.getElementsByTagName("img");
    if (g) {
      const y = o.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...g].map(
          (x) => new Promise((k) => {
            function C() {
              if (x.style.display = "flex", x.style.flexDirection = "column", y) {
                const A = fe().fontSize ? fe().fontSize : window.getComputedStyle(document.body).fontSize, $ = 5, [B = N6.fontSize] = Nu(A), L = B * $ + "px";
                x.style.minWidth = L, x.style.maxWidth = L;
              } else
                x.style.width = "100%";
              k(x);
            }
            _(C, "setupImage"), setTimeout(() => {
              x.complete && C();
            }), x.addEventListener("error", C), x.addEventListener("load", C);
          })
        )
      );
    }
    c = p.getBoundingClientRect(), m.attr("width", c.width), m.attr("height", c.height);
  }
  return i ? a.attr("transform", "translate(" + -c.width / 2 + ", " + -c.height / 2 + ")") : a.attr("transform", "translate(0, " + -c.height / 2 + ")"), e.centerLabel && a.attr("transform", "translate(" + -c.width / 2 + ", " + -c.height / 2 + ")"), a.insert("rect", ":first-child"), { shapeSvg: s, bbox: c, halfPadding: h, label: a };
}, "labelHelper");
var Lp = _(async (t15, e, r) => {
  var _a3, _b2, _c, _d, _e, _f2;
  const n = r.useHtmlLabels || Ke((_b2 = (_a3 = fe()) == null ? void 0 : _a3.flowchart) == null ? void 0 : _b2.htmlLabels), i = t15.insert("g").attr("class", "label").attr("style", r.labelStyle || ""), s = await fs(i, Zs(ca(e), fe()), {
    useHtmlLabels: n,
    width: r.width || ((_d = (_c = fe()) == null ? void 0 : _c.flowchart) == null ? void 0 : _d.wrappingWidth),
    style: r.labelStyle,
    addSvgBackground: !!r.icon || !!r.img
  });
  let a = s.getBBox();
  const o = r.padding / 2;
  if (Ke((_f2 = (_e = fe()) == null ? void 0 : _e.flowchart) == null ? void 0 : _f2.htmlLabels)) {
    const l = s.children[0], c = ae(s);
    a = l.getBoundingClientRect(), c.attr("width", a.width), c.attr("height", a.height);
  }
  return n ? i.attr("transform", "translate(" + -a.width / 2 + ", " + -a.height / 2 + ")") : i.attr("transform", "translate(0, " + -a.height / 2 + ")"), r.centerLabel && i.attr("transform", "translate(" + -a.width / 2 + ", " + -a.height / 2 + ")"), i.insert("rect", ":first-child"), { shapeSvg: t15, bbox: a, halfPadding: o, label: i };
}, "insertLabel");
var Dt = _((t15, e) => {
  const r = e.node().getBBox();
  t15.width = r.width, t15.height = r.height;
}, "updateNodeBounds");
var Wt = _((t15, e) => (t15.look === "handDrawn" ? "rough-node" : "node") + " " + t15.cssClasses + " " + (e || ""), "getNodeClasses");
function oe(t15) {
  const e = t15.map((r, n) => `${n === 0 ? "M" : "L"}${r.x},${r.y}`);
  return e.push("Z"), e.join(" ");
}
_(oe, "createPathFromPoints");
function us(t15, e, r, n, i, s) {
  const a = [], o = r - t15, l = n - e, c = o / s, h = 2 * Math.PI / c, p = e + l / 2;
  for (let m = 0; m <= 50; m++) {
    const g = m / 50, y = t15 + g * o, x = p + i * Math.sin(h * (y - t15));
    a.push({ x: y, y: x });
  }
  return a;
}
_(us, "generateFullSineWavePoints");
function bg(t15, e, r, n, i, s) {
  const a = [], o = i * Math.PI / 180, l = (s * Math.PI / 180 - o) / (n - 1);
  for (let c = 0; c < n; c++) {
    const h = o + c * l, p = t15 + r * Math.cos(h), m = e + r * Math.sin(h);
    a.push({ x: -p, y: -m });
  }
  return a;
}
_(bg, "generateCirclePoints");
var JY = _((t15, e) => {
  var r = t15.x, n = t15.y, i = e.x - r, s = e.y - n, a = t15.width / 2, o = t15.height / 2, l, c;
  return Math.abs(s) * a > Math.abs(i) * o ? (s < 0 && (o = -o), l = s === 0 ? 0 : o * i / s, c = o) : (i < 0 && (a = -a), l = a, c = i === 0 ? 0 : a * s / i), { x: r + l, y: n + c };
}, "intersectRect");
var bo = JY;
function _v(t15, e) {
  e && t15.attr("style", e);
}
_(_v, "applyStyle");
async function Sv(t15) {
  const e = ae(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), r = e.append("xhtml:div");
  let n = t15.label;
  t15.label && Ja(t15.label) && (n = await Sm(t15.label.replace(fo.lineBreakRegex, `
`), fe()));
  const i = t15.isNode ? "nodeLabel" : "edgeLabel";
  return r.html(
    '<span class="' + i + '" ' + (t15.labelStyle ? 'style="' + t15.labelStyle + '"' : "") + // codeql [js/html-constructed-from-input] : false positive
    ">" + n + "</span>"
  ), _v(r, t15.labelStyle), r.style("display", "inline-block"), r.style("padding-right", "1px"), r.style("white-space", "nowrap"), r.attr("xmlns", "http://www.w3.org/1999/xhtml"), e.node();
}
_(Sv, "addHtmlLabel");
var QY = _(async (t15, e, r, n) => {
  let i = t15 || "";
  if (typeof i == "object" && (i = i[0]), Ke(fe().flowchart.htmlLabels)) {
    i = i.replace(/\\n|\n/g, "<br />"), ut.info("vertexText" + i);
    const s = {
      isNode: n,
      label: ca(i).replace(
        /fa[blrs]?:fa-[\w-]+/g,
        (a) => `<i class='${a.replace(":", " ")}'></i>`
      ),
      labelStyle: e && e.replace("fill:", "color:")
    };
    return await Sv(s);
  } else {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "text");
    s.setAttribute("style", e.replace("color:", "fill:"));
    let a = [];
    typeof i == "string" ? a = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? a = i : a = [];
    for (const o of a) {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), l.setAttribute("dy", "1em"), l.setAttribute("x", "0"), r ? l.setAttribute("class", "title-row") : l.setAttribute("class", "row"), l.textContent = o.trim(), s.appendChild(l);
    }
    return s;
  }
}, "createLabel");
var js = QY;
var Fi = _((t15, e, r, n, i) => [
  "M",
  t15 + i,
  e,
  // Move to the first point
  "H",
  t15 + r - i,
  // Draw horizontal line to the beginning of the right corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t15 + r,
  e + i,
  // Draw arc to the right top corner
  "V",
  e + n - i,
  // Draw vertical line down to the beginning of the right bottom corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t15 + r - i,
  e + n,
  // Draw arc to the right bottom corner
  "H",
  t15 + i,
  // Draw horizontal line to the beginning of the left bottom corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t15,
  e + n - i,
  // Draw arc to the left bottom corner
  "V",
  e + i,
  // Draw vertical line up to the beginning of the left top corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t15 + i,
  e,
  // Draw arc to the left top corner
  "Z"
  // Close the path
].join(" "), "createRoundedRectPathD");
var Av = _(async (t15, e) => {
  ut.info("Creating subgraph rect for ", e.id, e);
  const r = fe(), { themeVariables: n, handDrawnSeed: i } = r, { clusterBkg: s, clusterBorder: a } = n, { labelStyles: o, nodeStyles: l, borderStyles: c, backgroundStyles: h } = Ft(e), p = t15.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), m = Ke(r.flowchart.htmlLabels), g = p.insert("g").attr("class", "cluster-label "), y = await fs(g, e.label, {
    style: e.labelStyle,
    useHtmlLabels: m,
    isNode: true
  });
  let x = y.getBBox();
  if (Ke(r.flowchart.htmlLabels)) {
    const U = y.children[0], G = ae(y);
    x = U.getBoundingClientRect(), G.attr("width", x.width), G.attr("height", x.height);
  }
  const k = e.width <= x.width + e.padding ? x.width + e.padding : e.width;
  e.width <= x.width + e.padding ? e.diff = (k - e.width) / 2 - e.padding : e.diff = -e.padding;
  const C = e.height, A = e.x - k / 2, $ = e.y - C / 2;
  ut.trace("Data ", e, JSON.stringify(e));
  let B;
  if (e.look === "handDrawn") {
    const U = Mt.svg(p), G = Lt(e, {
      roughness: 0.7,
      fill: s,
      // fill: 'red',
      stroke: a,
      fillWeight: 3,
      seed: i
    }), F = U.path(Fi(A, $, k, C, 0), G);
    B = p.insert(() => (ut.debug("Rough node insert CXC", F), F), ":first-child"), B.select("path:nth-child(2)").attr("style", c.join(";")), B.select("path").attr("style", h.join(";").replace("fill", "stroke"));
  } else
    B = p.insert("rect", ":first-child"), B.attr("style", l).attr("rx", e.rx).attr("ry", e.ry).attr("x", A).attr("y", $).attr("width", k).attr("height", C);
  const { subGraphTitleTopMargin: L } = Om(r);
  if (g.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${e.x - x.width / 2}, ${e.y - e.height / 2 + L})`
  ), o) {
    const U = g.select("span");
    U && U.attr("style", o);
  }
  const q = B.node().getBBox();
  return e.offsetX = 0, e.width = q.width, e.height = q.height, e.offsetY = x.height - e.padding / 2, e.intersect = function(U) {
    return bo(e, U);
  }, { cluster: p, labelBBox: x };
}, "rect");
var tK = _((t15, e) => {
  const r = t15.insert("g").attr("class", "note-cluster").attr("id", e.id), n = r.insert("rect", ":first-child"), i = 0 * e.padding, s = i / 2;
  n.attr("rx", e.rx).attr("ry", e.ry).attr("x", e.x - e.width / 2 - s).attr("y", e.y - e.height / 2 - s).attr("width", e.width + i).attr("height", e.height + i).attr("fill", "none");
  const a = n.node().getBBox();
  return e.width = a.width, e.height = a.height, e.intersect = function(o) {
    return bo(e, o);
  }, { cluster: r, labelBBox: { width: 0, height: 0 } };
}, "noteGroup");
var eK = _(async (t15, e) => {
  const r = fe(), { themeVariables: n, handDrawnSeed: i } = r, { altBackground: s, compositeBackground: a, compositeTitleBackground: o, nodeBorder: l } = n, c = t15.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-id", e.id).attr("data-look", e.look), h = c.insert("g", ":first-child"), p = c.insert("g").attr("class", "cluster-label");
  let m = c.append("rect");
  const g = p.node().appendChild(await js(e.label, e.labelStyle, void 0, true));
  let y = g.getBBox();
  if (Ke(r.flowchart.htmlLabels)) {
    const F = g.children[0], W = ae(g);
    y = F.getBoundingClientRect(), W.attr("width", y.width), W.attr("height", y.height);
  }
  const x = 0 * e.padding, k = x / 2, C = (e.width <= y.width + e.padding ? y.width + e.padding : e.width) + x;
  e.width <= y.width + e.padding ? e.diff = (C - e.width) / 2 - e.padding : e.diff = -e.padding;
  const A = e.height + x, $ = e.height + x - y.height - 6, B = e.x - C / 2, L = e.y - A / 2;
  e.width = C;
  const q = e.y - e.height / 2 - k + y.height + 2;
  let U;
  if (e.look === "handDrawn") {
    const F = e.cssClasses.includes("statediagram-cluster-alt"), W = Mt.svg(c), R = e.rx || e.ry ? W.path(Fi(B, L, C, A, 10), {
      roughness: 0.7,
      fill: o,
      fillStyle: "solid",
      stroke: l,
      seed: i
    }) : W.rectangle(B, L, C, A, { seed: i });
    U = c.insert(() => R, ":first-child");
    const Q = W.rectangle(B, q, C, $, {
      fill: F ? s : a,
      fillStyle: F ? "hachure" : "solid",
      stroke: l,
      seed: i
    });
    U = c.insert(() => R, ":first-child"), m = c.insert(() => Q);
  } else
    U = h.insert("rect", ":first-child"), U.attr("class", "outer").attr("x", B).attr("y", L).attr("width", C).attr("height", A).attr("data-look", e.look), m.attr("class", "inner").attr("x", B).attr("y", q).attr("width", C).attr("height", $);
  p.attr(
    "transform",
    `translate(${e.x - y.width / 2}, ${L + 1 - (Ke(r.flowchart.htmlLabels) ? 0 : 3)})`
  );
  const G = U.node().getBBox();
  return e.height = G.height, e.offsetX = 0, e.offsetY = y.height - e.padding / 2, e.labelBBox = y, e.intersect = function(F) {
    return bo(e, F);
  }, { cluster: c, labelBBox: y };
}, "roundedWithTitle");
var rK = _(async (t15, e) => {
  ut.info("Creating subgraph rect for ", e.id, e);
  const r = fe(), { themeVariables: n, handDrawnSeed: i } = r, { clusterBkg: s, clusterBorder: a } = n, { labelStyles: o, nodeStyles: l, borderStyles: c, backgroundStyles: h } = Ft(e), p = t15.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), m = Ke(r.flowchart.htmlLabels), g = p.insert("g").attr("class", "cluster-label "), y = await fs(g, e.label, {
    style: e.labelStyle,
    useHtmlLabels: m,
    isNode: true,
    width: e.width
  });
  let x = y.getBBox();
  if (Ke(r.flowchart.htmlLabels)) {
    const U = y.children[0], G = ae(y);
    x = U.getBoundingClientRect(), G.attr("width", x.width), G.attr("height", x.height);
  }
  const k = e.width <= x.width + e.padding ? x.width + e.padding : e.width;
  e.width <= x.width + e.padding ? e.diff = (k - e.width) / 2 - e.padding : e.diff = -e.padding;
  const C = e.height, A = e.x - k / 2, $ = e.y - C / 2;
  ut.trace("Data ", e, JSON.stringify(e));
  let B;
  if (e.look === "handDrawn") {
    const U = Mt.svg(p), G = Lt(e, {
      roughness: 0.7,
      fill: s,
      // fill: 'red',
      stroke: a,
      fillWeight: 4,
      seed: i
    }), F = U.path(Fi(A, $, k, C, e.rx), G);
    B = p.insert(() => (ut.debug("Rough node insert CXC", F), F), ":first-child"), B.select("path:nth-child(2)").attr("style", c.join(";")), B.select("path").attr("style", h.join(";").replace("fill", "stroke"));
  } else
    B = p.insert("rect", ":first-child"), B.attr("style", l).attr("rx", e.rx).attr("ry", e.ry).attr("x", A).attr("y", $).attr("width", k).attr("height", C);
  const { subGraphTitleTopMargin: L } = Om(r);
  if (g.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${e.x - x.width / 2}, ${e.y - e.height / 2 + L})`
  ), o) {
    const U = g.select("span");
    U && U.attr("style", o);
  }
  const q = B.node().getBBox();
  return e.offsetX = 0, e.width = q.width, e.height = q.height, e.offsetY = x.height - e.padding / 2, e.intersect = function(U) {
    return bo(e, U);
  }, { cluster: p, labelBBox: x };
}, "kanbanSection");
var nK = _((t15, e) => {
  const r = fe(), { themeVariables: n, handDrawnSeed: i } = r, { nodeBorder: s } = n, a = t15.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-look", e.look), o = a.insert("g", ":first-child"), l = 0 * e.padding, c = e.width + l;
  e.diff = -e.padding;
  const h = e.height + l, p = e.x - c / 2, m = e.y - h / 2;
  e.width = c;
  let g;
  if (e.look === "handDrawn") {
    const x = Mt.svg(a).rectangle(p, m, c, h, {
      fill: "lightgrey",
      roughness: 0.5,
      strokeLineDash: [5],
      stroke: s,
      seed: i
    });
    g = a.insert(() => x, ":first-child");
  } else
    g = o.insert("rect", ":first-child"), g.attr("class", "divider").attr("x", p).attr("y", m).attr("width", c).attr("height", h).attr("data-look", e.look);
  const y = g.node().getBBox();
  return e.height = y.height, e.offsetX = 0, e.offsetY = 0, e.intersect = function(x) {
    return bo(e, x);
  }, { cluster: a, labelBBox: {} };
}, "divider");
var iK = Av;
var sK = {
  rect: Av,
  squareRect: iK,
  roundedWithTitle: eK,
  noteGroup: tK,
  divider: nK,
  kanbanSection: rK
};
var Tv = /* @__PURE__ */ new Map();
var aK = _(async (t15, e) => {
  const r = e.shape || "rect", n = await sK[r](t15, e);
  return Tv.set(e.id, n), n;
}, "insertCluster");
var Crt = _(() => {
  Tv = /* @__PURE__ */ new Map();
}, "clear");
function $v(t15, e) {
  return t15.intersect(e);
}
_($v, "intersectNode");
var oK = $v;
function Ev(t15, e, r, n) {
  var i = t15.x, s = t15.y, a = i - n.x, o = s - n.y, l = Math.sqrt(e * e * o * o + r * r * a * a), c = Math.abs(e * r * a / l);
  n.x < i && (c = -c);
  var h = Math.abs(e * r * o / l);
  return n.y < s && (h = -h), { x: i + c, y: s + h };
}
_(Ev, "intersectEllipse");
var Mv = Ev;
function Bv(t15, e, r) {
  return Mv(t15, e, e, r);
}
_(Bv, "intersectCircle");
var lK = Bv;
function Lv(t15, e, r, n) {
  var i, s, a, o, l, c, h, p, m, g, y, x, k, C, A;
  if (i = e.y - t15.y, a = t15.x - e.x, l = e.x * t15.y - t15.x * e.y, m = i * r.x + a * r.y + l, g = i * n.x + a * n.y + l, !(m !== 0 && g !== 0 && h1(m, g)) && (s = n.y - r.y, o = r.x - n.x, c = n.x * r.y - r.x * n.y, h = s * t15.x + o * t15.y + c, p = s * e.x + o * e.y + c, !(h !== 0 && p !== 0 && h1(h, p)) && (y = i * o - s * a, y !== 0)))
    return x = Math.abs(y / 2), k = a * c - o * l, C = k < 0 ? (k - x) / y : (k + x) / y, k = s * l - i * c, A = k < 0 ? (k - x) / y : (k + x) / y, { x: C, y: A };
}
_(Lv, "intersectLine");
function h1(t15, e) {
  return t15 * e > 0;
}
_(h1, "sameSign");
var cK = Lv;
function Dv(t15, e, r) {
  let n = t15.x, i = t15.y, s = [], a = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  typeof e.forEach == "function" ? e.forEach(function(h) {
    a = Math.min(a, h.x), o = Math.min(o, h.y);
  }) : (a = Math.min(a, e.x), o = Math.min(o, e.y));
  let l = n - t15.width / 2 - a, c = i - t15.height / 2 - o;
  for (let h = 0; h < e.length; h++) {
    let p = e[h], m = e[h < e.length - 1 ? h + 1 : 0], g = cK(
      t15,
      r,
      { x: l + p.x, y: c + p.y },
      { x: l + m.x, y: c + m.y }
    );
    g && s.push(g);
  }
  return s.length ? (s.length > 1 && s.sort(function(h, p) {
    let m = h.x - r.x, g = h.y - r.y, y = Math.sqrt(m * m + g * g), x = p.x - r.x, k = p.y - r.y, C = Math.sqrt(x * x + k * k);
    return y < C ? -1 : y === C ? 0 : 1;
  }), s[0]) : t15;
}
_(Dv, "intersectPolygon");
var hK = Dv;
var Et = {
  node: oK,
  circle: lK,
  ellipse: Mv,
  polygon: hK,
  rect: bo
};
function Fv(t15, e) {
  const { labelStyles: r } = Ft(e);
  e.labelStyle = r;
  const n = Wt(e);
  let i = n;
  n || (i = "anchor");
  const s = t15.insert("g").attr("class", i).attr("id", e.domId || e.id), a = 1, { cssStyles: o } = e, l = Mt.svg(s), c = Lt(e, { fill: "black", stroke: "none", fillStyle: "solid" });
  e.look !== "handDrawn" && (c.roughness = 0);
  const h = l.circle(0, 0, a * 2, c), p = s.insert(() => h, ":first-child");
  return p.attr("class", "anchor").attr("style", Tr(o)), Dt(e, p), e.intersect = function(m) {
    return ut.info("Circle intersect", e, a, m), Et.circle(e, a, m);
  }, s;
}
_(Fv, "anchor");
function u1(t15, e, r, n, i, s, a) {
  const o = (t15 + r) / 2, l = (e + n) / 2, c = Math.atan2(n - e, r - t15), h = (r - t15) / 2, p = (n - e) / 2, m = h / i, g = p / s, y = Math.sqrt(m ** 2 + g ** 2);
  if (y > 1)
    throw new Error("The given radii are too small to create an arc between the points.");
  const x = Math.sqrt(1 - y ** 2), k = o + x * s * Math.sin(c) * (a ? -1 : 1), C = l - x * i * Math.cos(c) * (a ? -1 : 1), A = Math.atan2((e - C) / s, (t15 - k) / i);
  let $ = Math.atan2((n - C) / s, (r - k) / i) - A;
  a && $ < 0 && ($ += 2 * Math.PI), !a && $ > 0 && ($ -= 2 * Math.PI);
  const B = [];
  for (let L = 0; L < 20; L++) {
    const q = L / 19, U = A + q * $, G = k + i * Math.cos(U), F = C + s * Math.sin(U);
    B.push({ x: G, y: F });
  }
  return B;
}
_(u1, "generateArcPoints");
async function Nv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = s.width + e.padding + 20, o = s.height + e.padding, l = o / 2, c = l / (2.5 + o / 50), { cssStyles: h } = e, p = [
    { x: a / 2, y: -o / 2 },
    { x: -a / 2, y: -o / 2 },
    ...u1(-a / 2, -o / 2, -a / 2, o / 2, c, l, false),
    { x: a / 2, y: o / 2 },
    ...u1(a / 2, o / 2, a / 2, -o / 2, c, l, true)
  ], m = Mt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = oe(p), x = m.path(y, g), k = i.insert(() => x, ":first-child");
  return k.attr("class", "basic label-container"), h && e.look !== "handDrawn" && k.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), k.attr("transform", `translate(${c / 2}, 0)`), Dt(e, k), e.intersect = function(C) {
    return Et.polygon(e, p, C);
  }, i;
}
_(Nv, "bowTieRect");
function Ni(t15, e, r, n) {
  return t15.insert("polygon", ":first-child").attr(
    "points",
    n.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
}
_(Ni, "insertPolygonShape");
async function Iv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = s.height + e.padding, o = 12, l = s.width + e.padding + o, c = 0, h = l, p = -a, m = 0, g = [
    { x: c + o, y: p },
    { x: h, y: p },
    { x: h, y: m },
    { x: c, y: m },
    { x: c, y: p + o },
    { x: c + o, y: p }
  ];
  let y;
  const { cssStyles: x } = e;
  if (e.look === "handDrawn") {
    const k = Mt.svg(i), C = Lt(e, {}), A = oe(g), $ = k.path(A, C);
    y = i.insert(() => $, ":first-child").attr("transform", `translate(${-l / 2}, ${a / 2})`), x && y.attr("style", x);
  } else
    y = Ni(i, l, a, g);
  return n && y.attr("style", n), Dt(e, y), e.intersect = function(k) {
    return Et.polygon(e, g, k);
  }, i;
}
_(Iv, "card");
function Ov(t15, e) {
  const { nodeStyles: r } = Ft(e);
  e.label = "";
  const n = t15.insert("g").attr("class", Wt(e)).attr("id", e.domId ?? e.id), { cssStyles: i } = e, s = Math.max(28, e.width ?? 0), a = [
    { x: 0, y: s / 2 },
    { x: s / 2, y: 0 },
    { x: 0, y: -s / 2 },
    { x: -s / 2, y: 0 }
  ], o = Mt.svg(n), l = Lt(e, {});
  e.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const c = oe(a), h = o.path(c, l), p = n.insert(() => h, ":first-child");
  return i && e.look !== "handDrawn" && p.selectAll("path").attr("style", i), r && e.look !== "handDrawn" && p.selectAll("path").attr("style", r), e.width = 28, e.height = 28, e.intersect = function(m) {
    return Et.polygon(e, a, m);
  }, n;
}
_(Ov, "choice");
async function zv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, halfPadding: a } = await Vt(t15, e, Wt(e)), o = s.width / 2 + a;
  let l;
  const { cssStyles: c } = e;
  if (e.look === "handDrawn") {
    const h = Mt.svg(i), p = Lt(e, {}), m = h.circle(0, 0, o * 2, p);
    l = i.insert(() => m, ":first-child"), l.attr("class", "basic label-container").attr("style", Tr(c));
  } else
    l = i.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", n).attr("r", o).attr("cx", 0).attr("cy", 0);
  return Dt(e, l), e.intersect = function(h) {
    return ut.info("Circle intersect", e, o, h), Et.circle(e, o, h);
  }, i;
}
_(zv, "circle");
function qv(t15) {
  const e = Math.cos(Math.PI / 4), r = Math.sin(Math.PI / 4), n = t15 * 2, i = { x: n / 2 * e, y: n / 2 * r }, s = { x: -(n / 2) * e, y: n / 2 * r }, a = { x: -(n / 2) * e, y: -(n / 2) * r }, o = { x: n / 2 * e, y: -(n / 2) * r };
  return `M ${s.x},${s.y} L ${o.x},${o.y}
                   M ${i.x},${i.y} L ${a.x},${a.y}`;
}
_(qv, "createLine");
function Rv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r, e.label = "";
  const i = t15.insert("g").attr("class", Wt(e)).attr("id", e.domId ?? e.id), s = Math.max(30, (e == null ? void 0 : e.width) ?? 0), { cssStyles: a } = e, o = Mt.svg(i), l = Lt(e, {});
  e.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const c = o.circle(0, 0, s * 2, l), h = qv(s), p = o.path(h, l), m = i.insert(() => c, ":first-child");
  return m.insert(() => p), a && e.look !== "handDrawn" && m.selectAll("path").attr("style", a), n && e.look !== "handDrawn" && m.selectAll("path").attr("style", n), Dt(e, m), e.intersect = function(g) {
    return ut.info("crossedCircle intersect", e, { radius: s, point: g }), Et.circle(e, s, g);
  }, i;
}
_(Rv, "crossedCircle");
function xi(t15, e, r, n = 100, i = 0, s = 180) {
  const a = [], o = i * Math.PI / 180, l = (s * Math.PI / 180 - o) / (n - 1);
  for (let c = 0; c < n; c++) {
    const h = o + c * l, p = t15 + r * Math.cos(h), m = e + r * Math.sin(h);
    a.push({ x: -p, y: -m });
  }
  return a;
}
_(xi, "generateCirclePoints");
async function Pv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = s.width + (e.padding ?? 0), l = s.height + (e.padding ?? 0), c = Math.max(5, l * 0.1), { cssStyles: h } = e, p = [
    ...xi(o / 2, -l / 2, c, 30, -90, 0),
    { x: -o / 2 - c, y: c },
    ...xi(o / 2 + c * 2, -c, c, 20, -180, -270),
    ...xi(o / 2 + c * 2, c, c, 20, -90, -180),
    { x: -o / 2 - c, y: -l / 2 },
    ...xi(o / 2, l / 2, c, 20, 0, 90)
  ], m = [
    { x: o / 2, y: -l / 2 - c },
    { x: -o / 2, y: -l / 2 - c },
    ...xi(o / 2, -l / 2, c, 20, -90, 0),
    { x: -o / 2 - c, y: -c },
    ...xi(o / 2 + o * 0.1, -c, c, 20, -180, -270),
    ...xi(o / 2 + o * 0.1, c, c, 20, -90, -180),
    { x: -o / 2 - c, y: l / 2 },
    ...xi(o / 2, l / 2, c, 20, 0, 90),
    { x: -o / 2, y: l / 2 + c },
    { x: o / 2, y: l / 2 + c }
  ], g = Mt.svg(i), y = Lt(e, { fill: "none" });
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = oe(p).replace("Z", ""), k = g.path(x, y), C = oe(m), A = g.path(C, { ...y }), $ = i.insert("g", ":first-child");
  return $.insert(() => A, ":first-child").attr("stroke-opacity", 0), $.insert(() => k, ":first-child"), $.attr("class", "text"), h && e.look !== "handDrawn" && $.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(${c}, 0)`), a.attr(
    "transform",
    `translate(${-o / 2 + c - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`
  ), Dt(e, $), e.intersect = function(B) {
    return Et.polygon(e, m, B);
  }, i;
}
_(Pv, "curlyBraceLeft");
function wi(t15, e, r, n = 100, i = 0, s = 180) {
  const a = [], o = i * Math.PI / 180, l = (s * Math.PI / 180 - o) / (n - 1);
  for (let c = 0; c < n; c++) {
    const h = o + c * l, p = t15 + r * Math.cos(h), m = e + r * Math.sin(h);
    a.push({ x: p, y: m });
  }
  return a;
}
_(wi, "generateCirclePoints");
async function jv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = s.width + (e.padding ?? 0), l = s.height + (e.padding ?? 0), c = Math.max(5, l * 0.1), { cssStyles: h } = e, p = [
    ...wi(o / 2, -l / 2, c, 20, -90, 0),
    { x: o / 2 + c, y: -c },
    ...wi(o / 2 + c * 2, -c, c, 20, -180, -270),
    ...wi(o / 2 + c * 2, c, c, 20, -90, -180),
    { x: o / 2 + c, y: l / 2 },
    ...wi(o / 2, l / 2, c, 20, 0, 90)
  ], m = [
    { x: -o / 2, y: -l / 2 - c },
    { x: o / 2, y: -l / 2 - c },
    ...wi(o / 2, -l / 2, c, 20, -90, 0),
    { x: o / 2 + c, y: -c },
    ...wi(o / 2 + c * 2, -c, c, 20, -180, -270),
    ...wi(o / 2 + c * 2, c, c, 20, -90, -180),
    { x: o / 2 + c, y: l / 2 },
    ...wi(o / 2, l / 2, c, 20, 0, 90),
    { x: o / 2, y: l / 2 + c },
    { x: -o / 2, y: l / 2 + c }
  ], g = Mt.svg(i), y = Lt(e, { fill: "none" });
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = oe(p).replace("Z", ""), k = g.path(x, y), C = oe(m), A = g.path(C, { ...y }), $ = i.insert("g", ":first-child");
  return $.insert(() => A, ":first-child").attr("stroke-opacity", 0), $.insert(() => k, ":first-child"), $.attr("class", "text"), h && e.look !== "handDrawn" && $.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(${-c}, 0)`), a.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) / 2 - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`
  ), Dt(e, $), e.intersect = function(B) {
    return Et.polygon(e, m, B);
  }, i;
}
_(jv, "curlyBraceRight");
function cr(t15, e, r, n = 100, i = 0, s = 180) {
  const a = [], o = i * Math.PI / 180, l = (s * Math.PI / 180 - o) / (n - 1);
  for (let c = 0; c < n; c++) {
    const h = o + c * l, p = t15 + r * Math.cos(h), m = e + r * Math.sin(h);
    a.push({ x: -p, y: -m });
  }
  return a;
}
_(cr, "generateCirclePoints");
async function Wv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = s.width + (e.padding ?? 0), l = s.height + (e.padding ?? 0), c = Math.max(5, l * 0.1), { cssStyles: h } = e, p = [
    ...cr(o / 2, -l / 2, c, 30, -90, 0),
    { x: -o / 2 - c, y: c },
    ...cr(o / 2 + c * 2, -c, c, 20, -180, -270),
    ...cr(o / 2 + c * 2, c, c, 20, -90, -180),
    { x: -o / 2 - c, y: -l / 2 },
    ...cr(o / 2, l / 2, c, 20, 0, 90)
  ], m = [
    ...cr(-o / 2 + c + c / 2, -l / 2, c, 20, -90, -180),
    { x: o / 2 - c / 2, y: c },
    ...cr(-o / 2 - c / 2, -c, c, 20, 0, 90),
    ...cr(-o / 2 - c / 2, c, c, 20, -90, 0),
    { x: o / 2 - c / 2, y: -c },
    ...cr(-o / 2 + c + c / 2, l / 2, c, 30, -180, -270)
  ], g = [
    { x: o / 2, y: -l / 2 - c },
    { x: -o / 2, y: -l / 2 - c },
    ...cr(o / 2, -l / 2, c, 20, -90, 0),
    { x: -o / 2 - c, y: -c },
    ...cr(o / 2 + c * 2, -c, c, 20, -180, -270),
    ...cr(o / 2 + c * 2, c, c, 20, -90, -180),
    { x: -o / 2 - c, y: l / 2 },
    ...cr(o / 2, l / 2, c, 20, 0, 90),
    { x: -o / 2, y: l / 2 + c },
    { x: o / 2 - c - c / 2, y: l / 2 + c },
    ...cr(-o / 2 + c + c / 2, -l / 2, c, 20, -90, -180),
    { x: o / 2 - c / 2, y: c },
    ...cr(-o / 2 - c / 2, -c, c, 20, 0, 90),
    ...cr(-o / 2 - c / 2, c, c, 20, -90, 0),
    { x: o / 2 - c / 2, y: -c },
    ...cr(-o / 2 + c + c / 2, l / 2, c, 30, -180, -270)
  ], y = Mt.svg(i), x = Lt(e, { fill: "none" });
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const k = oe(p).replace("Z", ""), C = y.path(k, x), A = oe(m).replace("Z", ""), $ = y.path(A, x), B = oe(g), L = y.path(B, { ...x }), q = i.insert("g", ":first-child");
  return q.insert(() => L, ":first-child").attr("stroke-opacity", 0), q.insert(() => C, ":first-child"), q.insert(() => $, ":first-child"), q.attr("class", "text"), h && e.look !== "handDrawn" && q.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && q.selectAll("path").attr("style", n), q.attr("transform", `translate(${c - c / 4}, 0)`), a.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) / 2 - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`
  ), Dt(e, q), e.intersect = function(U) {
    return Et.polygon(e, g, U);
  }, i;
}
_(Wv, "curlyBraces");
async function Hv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = 80, o = 20, l = Math.max(a, (s.width + (e.padding ?? 0) * 2) * 1.25, (e == null ? void 0 : e.width) ?? 0), c = Math.max(o, s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h = c / 2, { cssStyles: p } = e, m = Mt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = l, x = c, k = y - h, C = x / 4, A = [
    { x: k, y: 0 },
    { x: C, y: 0 },
    { x: 0, y: x / 2 },
    { x: C, y: x },
    { x: k, y: x },
    ...bg(-k, -x / 2, h, 50, 270, 90)
  ], $ = oe(A), B = m.path($, g), L = i.insert(() => B, ":first-child");
  return L.attr("class", "basic label-container"), p && e.look !== "handDrawn" && L.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && L.selectChildren("path").attr("style", n), L.attr("transform", `translate(${-l / 2}, ${-c / 2})`), Dt(e, L), e.intersect = function(q) {
    return Et.polygon(e, A, q);
  }, i;
}
_(Hv, "curvedTrapezoid");
var uK = _((t15, e, r, n, i, s) => [
  `M${t15},${e + s}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `a${i},${s} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `l0,${-n}`
].join(" "), "createCylinderPathD");
var dK = _((t15, e, r, n, i, s) => [
  `M${t15},${e + s}`,
  `M${t15 + r},${e + s}`,
  `a${i},${s} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `l0,${-n}`
].join(" "), "createOuterCylinderPathD");
var pK = _((t15, e, r, n, i, s) => [`M${t15 - r / 2},${-n / 2}`, `a${i},${s} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function Uv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + e.padding, e.width ?? 0), l = o / 2, c = l / (2.5 + o / 50), h = Math.max(s.height + c + e.padding, e.height ?? 0);
  let p;
  const { cssStyles: m } = e;
  if (e.look === "handDrawn") {
    const g = Mt.svg(i), y = dK(0, 0, o, h, l, c), x = pK(0, c, o, h, l, c), k = g.path(y, Lt(e, {})), C = g.path(x, Lt(e, { fill: "none" }));
    p = i.insert(() => C, ":first-child"), p = i.insert(() => k, ":first-child"), p.attr("class", "basic label-container"), m && p.attr("style", m);
  } else {
    const g = uK(0, 0, o, h, l, c);
    p = i.insert("path", ":first-child").attr("d", g).attr("class", "basic label-container").attr("style", Tr(m)).attr("style", n);
  }
  return p.attr("label-offset-y", c), p.attr("transform", `translate(${-o / 2}, ${-(h / 2 + c)})`), Dt(e, p), a.attr(
    "transform",
    `translate(${-(s.width / 2) - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + (e.padding ?? 0) / 1.5 - (s.y - (s.top ?? 0))})`
  ), e.intersect = function(g) {
    const y = Et.rect(e, g), x = y.x - (e.x ?? 0);
    if (l != 0 && (Math.abs(x) < (e.width ?? 0) / 2 || Math.abs(x) == (e.width ?? 0) / 2 && Math.abs(y.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - c)) {
      let k = c * c * (1 - x * x / (l * l));
      k > 0 && (k = Math.sqrt(k)), k = c - k, g.y - (e.y ?? 0) > 0 && (k = -k), y.y += k;
    }
    return y;
  }, i;
}
_(Uv, "cylinder");
async function Vv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = s.width + e.padding, l = s.height + e.padding, c = l * 0.2, h = -o / 2, p = -l / 2 - c / 2, { cssStyles: m } = e, g = Mt.svg(i), y = Lt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = [
    { x: h, y: p + c },
    { x: -h, y: p + c },
    { x: -h, y: -p },
    { x: h, y: -p },
    { x: h, y: p },
    { x: -h, y: p },
    { x: -h, y: p + c }
  ], k = g.polygon(
    x.map((A) => [A.x, A.y]),
    y
  ), C = i.insert(() => k, ":first-child");
  return C.attr("class", "basic label-container"), m && e.look !== "handDrawn" && C.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && C.selectAll("path").attr("style", n), a.attr(
    "transform",
    `translate(${h + (e.padding ?? 0) / 2 - (s.x - (s.left ?? 0))}, ${p + c + (e.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`
  ), Dt(e, C), e.intersect = function(A) {
    return Et.rect(e, A);
  }, i;
}
_(Vv, "dividedRectangle");
async function Gv(t15, e) {
  var _a3, _b2;
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, halfPadding: a } = await Vt(t15, e, Wt(e)), o = s.width / 2 + a + 5, l = s.width / 2 + a;
  let c;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const p = Mt.svg(i), m = Lt(e, { roughness: 0.2, strokeWidth: 2.5 }), g = Lt(e, { roughness: 0.2, strokeWidth: 1.5 }), y = p.circle(0, 0, o * 2, m), x = p.circle(0, 0, l * 2, g);
    c = i.insert("g", ":first-child"), c.attr("class", Tr(e.cssClasses)).attr("style", Tr(h)), (_a3 = c.node()) == null ? void 0 : _a3.appendChild(y), (_b2 = c.node()) == null ? void 0 : _b2.appendChild(x);
  } else {
    c = i.insert("g", ":first-child");
    const p = c.insert("circle", ":first-child"), m = c.insert("circle");
    c.attr("class", "basic label-container").attr("style", n), p.attr("class", "outer-circle").attr("style", n).attr("r", o).attr("cx", 0).attr("cy", 0), m.attr("class", "inner-circle").attr("style", n).attr("r", l).attr("cx", 0).attr("cy", 0);
  }
  return Dt(e, c), e.intersect = function(p) {
    return ut.info("DoubleCircle intersect", e, o, p), Et.circle(e, o, p);
  }, i;
}
_(Gv, "doublecircle");
function Xv(t15, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = Ft(e);
  e.label = "", e.labelStyle = n;
  const s = t15.insert("g").attr("class", Wt(e)).attr("id", e.domId ?? e.id), a = 7, { cssStyles: o } = e, l = Mt.svg(s), { nodeBorder: c } = r, h = Lt(e, { fillStyle: "solid" });
  e.look !== "handDrawn" && (h.roughness = 0);
  const p = l.circle(0, 0, a * 2, h), m = s.insert(() => p, ":first-child");
  return m.selectAll("path").attr("style", `fill: ${c} !important;`), o && o.length > 0 && e.look !== "handDrawn" && m.selectAll("path").attr("style", o), i && e.look !== "handDrawn" && m.selectAll("path").attr("style", i), Dt(e, m), e.intersect = function(g) {
    return ut.info("filledCircle intersect", e, { radius: a, point: g }), Et.circle(e, a, g);
  }, s;
}
_(Xv, "filledCircle");
async function Yv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = s.width + (e.padding ?? 0), l = o + s.height, c = o + s.height, h = [
    { x: 0, y: -l },
    { x: c, y: -l },
    { x: c / 2, y: 0 }
  ], { cssStyles: p } = e, m = Mt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = oe(h), x = m.path(y, g), k = i.insert(() => x, ":first-child").attr("transform", `translate(${-l / 2}, ${l / 2})`);
  return p && e.look !== "handDrawn" && k.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && k.selectChildren("path").attr("style", n), e.width = o, e.height = l, Dt(e, k), a.attr(
    "transform",
    `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${-l / 2 + (e.padding ?? 0) / 2 + (s.y - (s.top ?? 0))})`
  ), e.intersect = function(C) {
    return ut.info("Triangle intersect", e, h, C), Et.polygon(e, h, C);
  }, i;
}
_(Yv, "flippedTriangle");
function Kv(t15, e, { dir: r, config: { state: n, themeVariables: i } }) {
  const { nodeStyles: s } = Ft(e);
  e.label = "";
  const a = t15.insert("g").attr("class", Wt(e)).attr("id", e.domId ?? e.id), { cssStyles: o } = e;
  let l = Math.max(70, (e == null ? void 0 : e.width) ?? 0), c = Math.max(10, (e == null ? void 0 : e.height) ?? 0);
  r === "LR" && (l = Math.max(10, (e == null ? void 0 : e.width) ?? 0), c = Math.max(70, (e == null ? void 0 : e.height) ?? 0));
  const h = -1 * l / 2, p = -1 * c / 2, m = Mt.svg(a), g = Lt(e, {
    stroke: i.lineColor,
    fill: i.lineColor
  });
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = m.rectangle(h, p, l, c, g), x = a.insert(() => y, ":first-child");
  o && e.look !== "handDrawn" && x.selectAll("path").attr("style", o), s && e.look !== "handDrawn" && x.selectAll("path").attr("style", s), Dt(e, x);
  const k = (n == null ? void 0 : n.padding) ?? 0;
  return e.width && e.height && (e.width += k / 2 || 0, e.height += k / 2 || 0), e.intersect = function(C) {
    return Et.rect(e, C);
  }, a;
}
_(Kv, "forkJoin");
async function Zv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const i = 80, s = 50, { shapeSvg: a, bbox: o } = await Vt(t15, e, Wt(e)), l = Math.max(i, o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(s, o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h = c / 2, { cssStyles: p } = e, m = Mt.svg(a), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = [
    { x: -l / 2, y: -c / 2 },
    { x: l / 2 - h, y: -c / 2 },
    ...bg(-l / 2 + h, 0, h, 50, 90, 270),
    { x: l / 2 - h, y: c / 2 },
    { x: -l / 2, y: c / 2 }
  ], x = oe(y), k = m.path(x, g), C = a.insert(() => k, ":first-child");
  return C.attr("class", "basic label-container"), p && e.look !== "handDrawn" && C.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && C.selectChildren("path").attr("style", n), Dt(e, C), e.intersect = function(A) {
    return ut.info("Pill intersect", e, { radius: h, point: A }), Et.polygon(e, y, A);
  }, a;
}
_(Zv, "halfRoundedRectangle");
var fK = _((t15, e, r, n, i) => [
  `M${t15 + i},${e}`,
  `L${t15 + r - i},${e}`,
  `L${t15 + r},${e - n / 2}`,
  `L${t15 + r - i},${e - n}`,
  `L${t15 + i},${e - n}`,
  `L${t15},${e - n / 2}`,
  "Z"
].join(" "), "createHexagonPathD");
async function Jv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = 4, o = s.height + e.padding, l = o / a, c = s.width + 2 * l + e.padding, h = [
    { x: l, y: 0 },
    { x: c - l, y: 0 },
    { x: c, y: -o / 2 },
    { x: c - l, y: -o },
    { x: l, y: -o },
    { x: 0, y: -o / 2 }
  ];
  let p;
  const { cssStyles: m } = e;
  if (e.look === "handDrawn") {
    const g = Mt.svg(i), y = Lt(e, {}), x = fK(0, 0, c, o, l), k = g.path(x, y);
    p = i.insert(() => k, ":first-child").attr("transform", `translate(${-c / 2}, ${o / 2})`), m && p.attr("style", m);
  } else
    p = Ni(i, c, o, h);
  return n && p.attr("style", n), e.width = c, e.height = o, Dt(e, p), e.intersect = function(g) {
    return Et.polygon(e, h, g);
  }, i;
}
_(Jv, "hexagon");
async function Qv(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.label = "", e.labelStyle = r;
  const { shapeSvg: i } = await Vt(t15, e, Wt(e)), s = Math.max(30, (e == null ? void 0 : e.width) ?? 0), a = Math.max(30, (e == null ? void 0 : e.height) ?? 0), { cssStyles: o } = e, l = Mt.svg(i), c = Lt(e, {});
  e.look !== "handDrawn" && (c.roughness = 0, c.fillStyle = "solid");
  const h = [
    { x: 0, y: 0 },
    { x: s, y: 0 },
    { x: 0, y: a },
    { x: s, y: a }
  ], p = oe(h), m = l.path(p, c), g = i.insert(() => m, ":first-child");
  return g.attr("class", "basic label-container"), o && e.look !== "handDrawn" && g.selectChildren("path").attr("style", o), n && e.look !== "handDrawn" && g.selectChildren("path").attr("style", n), g.attr("transform", `translate(${-s / 2}, ${-a / 2})`), Dt(e, g), e.intersect = function(y) {
    return ut.info("Pill intersect", e, { points: h }), Et.polygon(e, h, y);
  }, i;
}
_(Qv, "hourglass");
async function t82(t15, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Ft(e);
  e.labelStyle = i;
  const s = e.assetHeight ?? 48, a = e.assetWidth ?? 48, o = Math.max(s, a), l = n == null ? void 0 : n.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: c, bbox: h, label: p } = await Vt(t15, e, "icon-shape default"), m = e.pos === "t", g = o, y = o, { nodeBorder: x } = r, { stylesMap: k } = mo(e), C = -y / 2, A = -g / 2, $ = e.label ? 8 : 0, B = Mt.svg(c), L = Lt(e, { stroke: "none", fill: "none" });
  e.look !== "handDrawn" && (L.roughness = 0, L.fillStyle = "solid");
  const q = B.rectangle(C, A, y, g, L), U = Math.max(y, h.width), G = g + h.height + $, F = B.rectangle(-U / 2, -G / 2, U, G, {
    ...L,
    fill: "transparent",
    stroke: "none"
  }), W = c.insert(() => q, ":first-child"), R = c.insert(() => F);
  if (e.icon) {
    const Q = c.append("g");
    Q.html(
      `<g>${await gc(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const rt = Q.node().getBBox(), I = rt.width, j = rt.height, z = rt.x, K = rt.y;
    Q.attr(
      "transform",
      `translate(${-I / 2 - z},${m ? h.height / 2 + $ / 2 - j / 2 - K : -h.height / 2 - $ / 2 - j / 2 - K})`
    ), Q.attr("style", `color: ${k.get("stroke") ?? x};`);
  }
  return p.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${m ? -G / 2 : G / 2 - h.height})`
  ), W.attr(
    "transform",
    `translate(0,${m ? h.height / 2 + $ / 2 : -h.height / 2 - $ / 2})`
  ), Dt(e, R), e.intersect = function(Q) {
    if (ut.info("iconSquare intersect", e, Q), !e.label)
      return Et.rect(e, Q);
    const rt = e.x ?? 0, I = e.y ?? 0, j = e.height ?? 0;
    let z = [];
    return m ? z = [
      { x: rt - h.width / 2, y: I - j / 2 },
      { x: rt + h.width / 2, y: I - j / 2 },
      { x: rt + h.width / 2, y: I - j / 2 + h.height + $ },
      { x: rt + y / 2, y: I - j / 2 + h.height + $ },
      { x: rt + y / 2, y: I + j / 2 },
      { x: rt - y / 2, y: I + j / 2 },
      { x: rt - y / 2, y: I - j / 2 + h.height + $ },
      { x: rt - h.width / 2, y: I - j / 2 + h.height + $ }
    ] : z = [
      { x: rt - y / 2, y: I - j / 2 },
      { x: rt + y / 2, y: I - j / 2 },
      { x: rt + y / 2, y: I - j / 2 + g },
      { x: rt + h.width / 2, y: I - j / 2 + g },
      { x: rt + h.width / 2 / 2, y: I + j / 2 },
      { x: rt - h.width / 2, y: I + j / 2 },
      { x: rt - h.width / 2, y: I - j / 2 + g },
      { x: rt - y / 2, y: I - j / 2 + g }
    ], Et.polygon(e, z, Q);
  }, c;
}
_(t82, "icon");
async function e8(t15, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Ft(e);
  e.labelStyle = i;
  const s = e.assetHeight ?? 48, a = e.assetWidth ?? 48, o = Math.max(s, a), l = n == null ? void 0 : n.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: c, bbox: h, label: p } = await Vt(t15, e, "icon-shape default"), m = 20, g = e.label ? 8 : 0, y = e.pos === "t", { nodeBorder: x, mainBkg: k } = r, { stylesMap: C } = mo(e), A = Mt.svg(c), $ = Lt(e, {});
  e.look !== "handDrawn" && ($.roughness = 0, $.fillStyle = "solid");
  const B = C.get("fill");
  $.stroke = B ?? k;
  const L = c.append("g");
  e.icon && L.html(
    `<g>${await gc(e.icon, {
      height: o,
      width: o,
      fallbackPrefix: ""
    })}</g>`
  );
  const q = L.node().getBBox(), U = q.width, G = q.height, F = q.x, W = q.y, R = Math.max(U, G) * Math.SQRT2 + m * 2, Q = A.circle(0, 0, R, $), rt = Math.max(R, h.width), I = R + h.height + g, j = A.rectangle(-rt / 2, -I / 2, rt, I, {
    ...$,
    fill: "transparent",
    stroke: "none"
  }), z = c.insert(() => Q, ":first-child"), K = c.insert(() => j);
  return L.attr(
    "transform",
    `translate(${-U / 2 - F},${y ? h.height / 2 + g / 2 - G / 2 - W : -h.height / 2 - g / 2 - G / 2 - W})`
  ), L.attr("style", `color: ${C.get("stroke") ?? x};`), p.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${y ? -I / 2 : I / 2 - h.height})`
  ), z.attr(
    "transform",
    `translate(0,${y ? h.height / 2 + g / 2 : -h.height / 2 - g / 2})`
  ), Dt(e, K), e.intersect = function(Y) {
    return ut.info("iconSquare intersect", e, Y), Et.rect(e, Y);
  }, c;
}
_(e8, "iconCircle");
async function r8(t15, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Ft(e);
  e.labelStyle = i;
  const s = e.assetHeight ?? 48, a = e.assetWidth ?? 48, o = Math.max(s, a), l = n == null ? void 0 : n.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: c, bbox: h, halfPadding: p, label: m } = await Vt(
    t15,
    e,
    "icon-shape default"
  ), g = e.pos === "t", y = o + p * 2, x = o + p * 2, { nodeBorder: k, mainBkg: C } = r, { stylesMap: A } = mo(e), $ = -x / 2, B = -y / 2, L = e.label ? 8 : 0, q = Mt.svg(c), U = Lt(e, {});
  e.look !== "handDrawn" && (U.roughness = 0, U.fillStyle = "solid");
  const G = A.get("fill");
  U.stroke = G ?? C;
  const F = q.path(Fi($, B, x, y, 5), U), W = Math.max(x, h.width), R = y + h.height + L, Q = q.rectangle(-W / 2, -R / 2, W, R, {
    ...U,
    fill: "transparent",
    stroke: "none"
  }), rt = c.insert(() => F, ":first-child").attr("class", "icon-shape2"), I = c.insert(() => Q);
  if (e.icon) {
    const j = c.append("g");
    j.html(
      `<g>${await gc(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const z = j.node().getBBox(), K = z.width, Y = z.height, ot = z.x, et = z.y;
    j.attr(
      "transform",
      `translate(${-K / 2 - ot},${g ? h.height / 2 + L / 2 - Y / 2 - et : -h.height / 2 - L / 2 - Y / 2 - et})`
    ), j.attr("style", `color: ${A.get("stroke") ?? k};`);
  }
  return m.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${g ? -R / 2 : R / 2 - h.height})`
  ), rt.attr(
    "transform",
    `translate(0,${g ? h.height / 2 + L / 2 : -h.height / 2 - L / 2})`
  ), Dt(e, I), e.intersect = function(j) {
    if (ut.info("iconSquare intersect", e, j), !e.label)
      return Et.rect(e, j);
    const z = e.x ?? 0, K = e.y ?? 0, Y = e.height ?? 0;
    let ot = [];
    return g ? ot = [
      { x: z - h.width / 2, y: K - Y / 2 },
      { x: z + h.width / 2, y: K - Y / 2 },
      { x: z + h.width / 2, y: K - Y / 2 + h.height + L },
      { x: z + x / 2, y: K - Y / 2 + h.height + L },
      { x: z + x / 2, y: K + Y / 2 },
      { x: z - x / 2, y: K + Y / 2 },
      { x: z - x / 2, y: K - Y / 2 + h.height + L },
      { x: z - h.width / 2, y: K - Y / 2 + h.height + L }
    ] : ot = [
      { x: z - x / 2, y: K - Y / 2 },
      { x: z + x / 2, y: K - Y / 2 },
      { x: z + x / 2, y: K - Y / 2 + y },
      { x: z + h.width / 2, y: K - Y / 2 + y },
      { x: z + h.width / 2 / 2, y: K + Y / 2 },
      { x: z - h.width / 2, y: K + Y / 2 },
      { x: z - h.width / 2, y: K - Y / 2 + y },
      { x: z - x / 2, y: K - Y / 2 + y }
    ], Et.polygon(e, ot, j);
  }, c;
}
_(r8, "iconRounded");
async function n8(t15, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Ft(e);
  e.labelStyle = i;
  const s = e.assetHeight ?? 48, a = e.assetWidth ?? 48, o = Math.max(s, a), l = n == null ? void 0 : n.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: c, bbox: h, halfPadding: p, label: m } = await Vt(
    t15,
    e,
    "icon-shape default"
  ), g = e.pos === "t", y = o + p * 2, x = o + p * 2, { nodeBorder: k, mainBkg: C } = r, { stylesMap: A } = mo(e), $ = -x / 2, B = -y / 2, L = e.label ? 8 : 0, q = Mt.svg(c), U = Lt(e, {});
  e.look !== "handDrawn" && (U.roughness = 0, U.fillStyle = "solid");
  const G = A.get("fill");
  U.stroke = G ?? C;
  const F = q.path(Fi($, B, x, y, 0.1), U), W = Math.max(x, h.width), R = y + h.height + L, Q = q.rectangle(-W / 2, -R / 2, W, R, {
    ...U,
    fill: "transparent",
    stroke: "none"
  }), rt = c.insert(() => F, ":first-child"), I = c.insert(() => Q);
  if (e.icon) {
    const j = c.append("g");
    j.html(
      `<g>${await gc(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const z = j.node().getBBox(), K = z.width, Y = z.height, ot = z.x, et = z.y;
    j.attr(
      "transform",
      `translate(${-K / 2 - ot},${g ? h.height / 2 + L / 2 - Y / 2 - et : -h.height / 2 - L / 2 - Y / 2 - et})`
    ), j.attr("style", `color: ${A.get("stroke") ?? k};`);
  }
  return m.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${g ? -R / 2 : R / 2 - h.height})`
  ), rt.attr(
    "transform",
    `translate(0,${g ? h.height / 2 + L / 2 : -h.height / 2 - L / 2})`
  ), Dt(e, I), e.intersect = function(j) {
    if (ut.info("iconSquare intersect", e, j), !e.label)
      return Et.rect(e, j);
    const z = e.x ?? 0, K = e.y ?? 0, Y = e.height ?? 0;
    let ot = [];
    return g ? ot = [
      { x: z - h.width / 2, y: K - Y / 2 },
      { x: z + h.width / 2, y: K - Y / 2 },
      { x: z + h.width / 2, y: K - Y / 2 + h.height + L },
      { x: z + x / 2, y: K - Y / 2 + h.height + L },
      { x: z + x / 2, y: K + Y / 2 },
      { x: z - x / 2, y: K + Y / 2 },
      { x: z - x / 2, y: K - Y / 2 + h.height + L },
      { x: z - h.width / 2, y: K - Y / 2 + h.height + L }
    ] : ot = [
      { x: z - x / 2, y: K - Y / 2 },
      { x: z + x / 2, y: K - Y / 2 },
      { x: z + x / 2, y: K - Y / 2 + y },
      { x: z + h.width / 2, y: K - Y / 2 + y },
      { x: z + h.width / 2 / 2, y: K + Y / 2 },
      { x: z - h.width / 2, y: K + Y / 2 },
      { x: z - h.width / 2, y: K - Y / 2 + y },
      { x: z - x / 2, y: K - Y / 2 + y }
    ], Et.polygon(e, ot, j);
  }, c;
}
_(n8, "iconSquare");
async function i8(t15, e, { config: { flowchart: r } }) {
  const n = new Image();
  n.src = (e == null ? void 0 : e.img) ?? "", await n.decode();
  const i = Number(n.naturalWidth.toString().replace("px", "")), s = Number(n.naturalHeight.toString().replace("px", ""));
  e.imageAspectRatio = i / s;
  const { labelStyles: a } = Ft(e);
  e.labelStyle = a;
  const o = r == null ? void 0 : r.wrappingWidth;
  e.defaultWidth = r == null ? void 0 : r.wrappingWidth;
  const l = Math.max(
    e.label ? o ?? 0 : 0,
    (e == null ? void 0 : e.assetWidth) ?? i
  ), c = e.constraint === "on" && (e == null ? void 0 : e.assetHeight) ? e.assetHeight * e.imageAspectRatio : l, h = e.constraint === "on" ? c / e.imageAspectRatio : (e == null ? void 0 : e.assetHeight) ?? s;
  e.width = Math.max(c, o ?? 0);
  const { shapeSvg: p, bbox: m, label: g } = await Vt(t15, e, "image-shape default"), y = e.pos === "t", x = -c / 2, k = -h / 2, C = e.label ? 8 : 0, A = Mt.svg(p), $ = Lt(e, {});
  e.look !== "handDrawn" && ($.roughness = 0, $.fillStyle = "solid");
  const B = A.rectangle(x, k, c, h, $), L = Math.max(c, m.width), q = h + m.height + C, U = A.rectangle(-L / 2, -q / 2, L, q, {
    ...$,
    fill: "none",
    stroke: "none"
  }), G = p.insert(() => B, ":first-child"), F = p.insert(() => U);
  if (e.img) {
    const W = p.append("image");
    W.attr("href", e.img), W.attr("width", c), W.attr("height", h), W.attr("preserveAspectRatio", "none"), W.attr(
      "transform",
      `translate(${-c / 2},${y ? q / 2 - h : -q / 2})`
    );
  }
  return g.attr(
    "transform",
    `translate(${-m.width / 2 - (m.x - (m.left ?? 0))},${y ? -h / 2 - m.height / 2 - C / 2 : h / 2 - m.height / 2 + C / 2})`
  ), G.attr(
    "transform",
    `translate(0,${y ? m.height / 2 + C / 2 : -m.height / 2 - C / 2})`
  ), Dt(e, F), e.intersect = function(W) {
    if (ut.info("iconSquare intersect", e, W), !e.label)
      return Et.rect(e, W);
    const R = e.x ?? 0, Q = e.y ?? 0, rt = e.height ?? 0;
    let I = [];
    return y ? I = [
      { x: R - m.width / 2, y: Q - rt / 2 },
      { x: R + m.width / 2, y: Q - rt / 2 },
      { x: R + m.width / 2, y: Q - rt / 2 + m.height + C },
      { x: R + c / 2, y: Q - rt / 2 + m.height + C },
      { x: R + c / 2, y: Q + rt / 2 },
      { x: R - c / 2, y: Q + rt / 2 },
      { x: R - c / 2, y: Q - rt / 2 + m.height + C },
      { x: R - m.width / 2, y: Q - rt / 2 + m.height + C }
    ] : I = [
      { x: R - c / 2, y: Q - rt / 2 },
      { x: R + c / 2, y: Q - rt / 2 },
      { x: R + c / 2, y: Q - rt / 2 + h },
      { x: R + m.width / 2, y: Q - rt / 2 + h },
      { x: R + m.width / 2 / 2, y: Q + rt / 2 },
      { x: R - m.width / 2, y: Q + rt / 2 },
      { x: R - m.width / 2, y: Q - rt / 2 + h },
      { x: R - c / 2, y: Q - rt / 2 + h }
    ], Et.polygon(e, I, W);
  }, p;
}
_(i8, "imageSquare");
async function s8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), o = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), l = [
    { x: 0, y: 0 },
    { x: a, y: 0 },
    { x: a + 3 * o / 6, y: -o },
    { x: -3 * o / 6, y: -o }
  ];
  let c;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const p = Mt.svg(i), m = Lt(e, {}), g = oe(l), y = p.path(g, m);
    c = i.insert(() => y, ":first-child").attr("transform", `translate(${-a / 2}, ${o / 2})`), h && c.attr("style", h);
  } else
    c = Ni(i, a, o, l);
  return n && c.attr("style", n), e.width = a, e.height = o, Dt(e, c), e.intersect = function(p) {
    return Et.polygon(e, l, p);
  }, i;
}
_(s8, "inv_trapezoid");
async function bc(t15, e, r) {
  const { labelStyles: n, nodeStyles: i } = Ft(e);
  e.labelStyle = n;
  const { shapeSvg: s, bbox: a } = await Vt(t15, e, Wt(e)), o = Math.max(a.width + r.labelPaddingX * 2, (e == null ? void 0 : e.width) || 0), l = Math.max(a.height + r.labelPaddingY * 2, (e == null ? void 0 : e.height) || 0), c = -o / 2, h = -l / 2;
  let p, { rx: m, ry: g } = e;
  const { cssStyles: y } = e;
  if ((r == null ? void 0 : r.rx) && r.ry && (m = r.rx, g = r.ry), e.look === "handDrawn") {
    const x = Mt.svg(s), k = Lt(e, {}), C = m || g ? x.path(Fi(c, h, o, l, m || 0), k) : x.rectangle(c, h, o, l, k);
    p = s.insert(() => C, ":first-child"), p.attr("class", "basic label-container").attr("style", Tr(y));
  } else
    p = s.insert("rect", ":first-child"), p.attr("class", "basic label-container").attr("style", i).attr("rx", Tr(m)).attr("ry", Tr(g)).attr("x", c).attr("y", h).attr("width", o).attr("height", l);
  return Dt(e, p), e.intersect = function(x) {
    return Et.rect(e, x);
  }, s;
}
_(bc, "drawRect");
async function a8(t15, e) {
  const { shapeSvg: r, bbox: n, label: i } = await Vt(t15, e, "label"), s = r.insert("rect", ":first-child");
  return s.attr("width", 0.1).attr("height", 0.1), r.attr("class", "label edgeLabel"), i.attr(
    "transform",
    `translate(${-(n.width / 2) - (n.x - (n.left ?? 0))}, ${-(n.height / 2) - (n.y - (n.top ?? 0))})`
  ), Dt(e, s), e.intersect = function(a) {
    return Et.rect(e, a);
  }, r;
}
_(a8, "labelRect");
async function o8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = Math.max(s.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), o = Math.max(s.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), l = [
    { x: 0, y: 0 },
    { x: a + 3 * o / 6, y: 0 },
    { x: a, y: -o },
    { x: -(3 * o) / 6, y: -o }
  ];
  let c;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const p = Mt.svg(i), m = Lt(e, {}), g = oe(l), y = p.path(g, m);
    c = i.insert(() => y, ":first-child").attr("transform", `translate(${-a / 2}, ${o / 2})`), h && c.attr("style", h);
  } else
    c = Ni(i, a, o, l);
  return n && c.attr("style", n), e.width = a, e.height = o, Dt(e, c), e.intersect = function(p) {
    return Et.polygon(e, l, p);
  }, i;
}
_(o8, "lean_left");
async function l8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = Math.max(s.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), o = Math.max(s.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), l = [
    { x: -3 * o / 6, y: 0 },
    { x: a, y: 0 },
    { x: a + 3 * o / 6, y: -o },
    { x: 0, y: -o }
  ];
  let c;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const p = Mt.svg(i), m = Lt(e, {}), g = oe(l), y = p.path(g, m);
    c = i.insert(() => y, ":first-child").attr("transform", `translate(${-a / 2}, ${o / 2})`), h && c.attr("style", h);
  } else
    c = Ni(i, a, o, l);
  return n && c.attr("style", n), e.width = a, e.height = o, Dt(e, c), e.intersect = function(p) {
    return Et.polygon(e, l, p);
  }, i;
}
_(l8, "lean_right");
function c8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.label = "", e.labelStyle = r;
  const i = t15.insert("g").attr("class", Wt(e)).attr("id", e.domId ?? e.id), { cssStyles: s } = e, a = Math.max(35, (e == null ? void 0 : e.width) ?? 0), o = Math.max(35, (e == null ? void 0 : e.height) ?? 0), l = 7, c = [
    { x: a, y: 0 },
    { x: 0, y: o + l / 2 },
    { x: a - 2 * l, y: o + l / 2 },
    { x: 0, y: 2 * o },
    { x: a, y: o - l / 2 },
    { x: 2 * l, y: o - l / 2 }
  ], h = Mt.svg(i), p = Lt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const m = oe(c), g = h.path(m, p), y = i.insert(() => g, ":first-child");
  return s && e.look !== "handDrawn" && y.selectAll("path").attr("style", s), n && e.look !== "handDrawn" && y.selectAll("path").attr("style", n), y.attr("transform", `translate(-${a / 2},${-o})`), Dt(e, y), e.intersect = function(x) {
    return ut.info("lightningBolt intersect", e, x), Et.polygon(e, c, x);
  }, i;
}
_(c8, "lightningBolt");
var mK = _((t15, e, r, n, i, s, a) => [
  `M${t15},${e + s}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `a${i},${s} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `l0,${-n}`,
  `M${t15},${e + s + a}`,
  `a${i},${s} 0,0,0 ${r},0`
].join(" "), "createCylinderPathD");
var gK = _((t15, e, r, n, i, s, a) => [
  `M${t15},${e + s}`,
  `M${t15 + r},${e + s}`,
  `a${i},${s} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${s} 0,0,0 ${r},0`,
  `l0,${-n}`,
  `M${t15},${e + s + a}`,
  `a${i},${s} 0,0,0 ${r},0`
].join(" "), "createOuterCylinderPathD");
var yK = _((t15, e, r, n, i, s) => [`M${t15 - r / 2},${-n / 2}`, `a${i},${s} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function h8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0), e.width ?? 0), l = o / 2, c = l / (2.5 + o / 50), h = Math.max(s.height + c + (e.padding ?? 0), e.height ?? 0), p = h * 0.1;
  let m;
  const { cssStyles: g } = e;
  if (e.look === "handDrawn") {
    const y = Mt.svg(i), x = gK(0, 0, o, h, l, c, p), k = yK(0, c, o, h, l, c), C = Lt(e, {}), A = y.path(x, C), $ = y.path(k, C);
    i.insert(() => $, ":first-child").attr("class", "line"), m = i.insert(() => A, ":first-child"), m.attr("class", "basic label-container"), g && m.attr("style", g);
  } else {
    const y = mK(0, 0, o, h, l, c, p);
    m = i.insert("path", ":first-child").attr("d", y).attr("class", "basic label-container").attr("style", Tr(g)).attr("style", n);
  }
  return m.attr("label-offset-y", c), m.attr("transform", `translate(${-o / 2}, ${-(h / 2 + c)})`), Dt(e, m), a.attr(
    "transform",
    `translate(${-(s.width / 2) - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + c - (s.y - (s.top ?? 0))})`
  ), e.intersect = function(y) {
    const x = Et.rect(e, y), k = x.x - (e.x ?? 0);
    if (l != 0 && (Math.abs(k) < (e.width ?? 0) / 2 || Math.abs(k) == (e.width ?? 0) / 2 && Math.abs(x.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - c)) {
      let C = c * c * (1 - k * k / (l * l));
      C > 0 && (C = Math.sqrt(C)), C = c - C, y.y - (e.y ?? 0) > 0 && (C = -C), x.y += C;
    }
    return x;
  }, i;
}
_(h8, "linedCylinder");
async function u8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = l / 4, h = l + c, { cssStyles: p } = e, m = Mt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = [
    { x: -o / 2 - o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: h / 2 },
    ...us(
      -o / 2 - o / 2 * 0.1,
      h / 2,
      o / 2 + o / 2 * 0.1,
      h / 2,
      c,
      0.8
    ),
    { x: o / 2 + o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2, y: -h / 2 },
    { x: -o / 2, y: h / 2 * 1.1 },
    { x: -o / 2, y: -h / 2 }
  ], x = m.polygon(
    y.map((C) => [C.x, C.y]),
    g
  ), k = i.insert(() => x, ":first-child");
  return k.attr("class", "basic label-container"), p && e.look !== "handDrawn" && k.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), k.attr("transform", `translate(0,${-c / 2})`), a.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) + o / 2 * 0.1 / 2 - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) - c / 2 - (s.y - (s.top ?? 0))})`
  ), Dt(e, k), e.intersect = function(C) {
    return Et.polygon(e, y, C);
  }, i;
}
_(u8, "linedWaveEdgedRect");
async function d8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = 5, h = -o / 2, p = -l / 2, { cssStyles: m } = e, g = Mt.svg(i), y = Lt(e, {}), x = [
    { x: h - c, y: p + c },
    { x: h - c, y: p + l + c },
    { x: h + o - c, y: p + l + c },
    { x: h + o - c, y: p + l },
    { x: h + o, y: p + l },
    { x: h + o, y: p + l - c },
    { x: h + o + c, y: p + l - c },
    { x: h + o + c, y: p - c },
    { x: h + c, y: p - c },
    { x: h + c, y: p },
    { x: h, y: p },
    { x: h, y: p + c }
  ], k = [
    { x: h, y: p + c },
    { x: h + o - c, y: p + c },
    { x: h + o - c, y: p + l },
    { x: h + o, y: p + l },
    { x: h + o, y: p },
    { x: h, y: p }
  ];
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const C = oe(x), A = g.path(C, y), $ = oe(k), B = g.path($, { ...y, fill: "none" }), L = i.insert(() => B, ":first-child");
  return L.insert(() => A, ":first-child"), L.attr("class", "basic label-container"), m && e.look !== "handDrawn" && L.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && L.selectAll("path").attr("style", n), a.attr(
    "transform",
    `translate(${-(s.width / 2) - c - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + c - (s.y - (s.top ?? 0))})`
  ), Dt(e, L), e.intersect = function(q) {
    return Et.polygon(e, x, q);
  }, i;
}
_(d8, "multiRect");
async function p8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = l / 4, h = l + c, p = -o / 2, m = -h / 2, g = 5, { cssStyles: y } = e, x = us(
    p - g,
    m + h + g,
    p + o - g,
    m + h + g,
    c,
    0.8
  ), k = x == null ? void 0 : x[x.length - 1], C = [
    { x: p - g, y: m + g },
    { x: p - g, y: m + h + g },
    ...x,
    { x: p + o - g, y: k.y - g },
    { x: p + o, y: k.y - g },
    { x: p + o, y: k.y - 2 * g },
    { x: p + o + g, y: k.y - 2 * g },
    { x: p + o + g, y: m - g },
    { x: p + g, y: m - g },
    { x: p + g, y: m },
    { x: p, y: m },
    { x: p, y: m + g }
  ], A = [
    { x: p, y: m + g },
    { x: p + o - g, y: m + g },
    { x: p + o - g, y: k.y - g },
    { x: p + o, y: k.y - g },
    { x: p + o, y: m },
    { x: p, y: m }
  ], $ = Mt.svg(i), B = Lt(e, {});
  e.look !== "handDrawn" && (B.roughness = 0, B.fillStyle = "solid");
  const L = oe(C), q = $.path(L, B), U = oe(A), G = $.path(U, B), F = i.insert(() => q, ":first-child");
  return F.insert(() => G), F.attr("class", "basic label-container"), y && e.look !== "handDrawn" && F.selectAll("path").attr("style", y), n && e.look !== "handDrawn" && F.selectAll("path").attr("style", n), F.attr("transform", `translate(0,${-c / 2})`), a.attr(
    "transform",
    `translate(${-(s.width / 2) - g - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + g - c / 2 - (s.y - (s.top ?? 0))})`
  ), Dt(e, F), e.intersect = function(W) {
    return Et.polygon(e, C, W);
  }, i;
}
_(p8, "multiWaveEdgedRectangle");
async function f8(t15, e, { config: { themeVariables: r } }) {
  var _a3;
  const { labelStyles: n, nodeStyles: i } = Ft(e);
  e.labelStyle = n, e.useHtmlLabels || ((_a3 = Hr().flowchart) == null ? void 0 : _a3.htmlLabels) !== false || (e.centerLabel = true);
  const { shapeSvg: s, bbox: a, label: o } = await Vt(t15, e, Wt(e)), l = Math.max(a.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(a.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h = -l / 2, p = -c / 2, { cssStyles: m } = e, g = Mt.svg(s), y = Lt(e, {
    fill: r.noteBkgColor,
    stroke: r.noteBorderColor
  });
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = g.rectangle(h, p, l, c, y), k = s.insert(() => x, ":first-child");
  return k.attr("class", "basic label-container"), m && e.look !== "handDrawn" && k.selectAll("path").attr("style", m), i && e.look !== "handDrawn" && k.selectAll("path").attr("style", i), o.attr(
    "transform",
    `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`
  ), Dt(e, k), e.intersect = function(C) {
    return Et.rect(e, C);
  }, s;
}
_(f8, "note");
var bK = _((t15, e, r) => [
  `M${t15 + r / 2},${e}`,
  `L${t15 + r},${e - r / 2}`,
  `L${t15 + r / 2},${e - r}`,
  `L${t15},${e - r / 2}`,
  "Z"
].join(" "), "createDecisionBoxPathD");
async function m8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = s.width + e.padding, o = s.height + e.padding, l = a + o, c = [
    { x: l / 2, y: 0 },
    { x: l, y: -l / 2 },
    { x: l / 2, y: -l },
    { x: 0, y: -l / 2 }
  ];
  let h;
  const { cssStyles: p } = e;
  if (e.look === "handDrawn") {
    const m = Mt.svg(i), g = Lt(e, {}), y = bK(0, 0, l), x = m.path(y, g);
    h = i.insert(() => x, ":first-child").attr("transform", `translate(${-l / 2}, ${l / 2})`), p && h.attr("style", p);
  } else
    h = Ni(i, l, l, c);
  return n && h.attr("style", n), Dt(e, h), e.intersect = function(m) {
    return ut.debug(
      `APA12 Intersect called SPLIT
point:`,
      m,
      `
node:
`,
      e,
      `
res:`,
      Et.polygon(e, c, m)
    ), Et.polygon(e, c, m);
  }, i;
}
_(m8, "question");
async function g8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), c = -o / 2, h = -l / 2, p = h / 2, m = [
    { x: c + p, y: h },
    { x: c, y: 0 },
    { x: c + p, y: -h },
    { x: -c, y: -h },
    { x: -c, y: h }
  ], { cssStyles: g } = e, y = Mt.svg(i), x = Lt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const k = oe(m), C = y.path(k, x), A = i.insert(() => C, ":first-child");
  return A.attr("class", "basic label-container"), g && e.look !== "handDrawn" && A.selectAll("path").attr("style", g), n && e.look !== "handDrawn" && A.selectAll("path").attr("style", n), A.attr("transform", `translate(${-p / 2},0)`), a.attr(
    "transform",
    `translate(${-p / 2 - s.width / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`
  ), Dt(e, A), e.intersect = function($) {
    return Et.polygon(e, m, $);
  }, i;
}
_(g8, "rect_left_inv_arrow");
async function y8(t15, e) {
  var _a3, _b2;
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  let i;
  e.cssClasses ? i = "node " + e.cssClasses : i = "node default";
  const s = t15.insert("g").attr("class", i).attr("id", e.domId || e.id), a = s.insert("g"), o = s.insert("g").attr("class", "label").attr("style", n), l = e.description, c = e.label, h = o.node().appendChild(await js(c, e.labelStyle, true, true));
  let p = { width: 0, height: 0 };
  if (Ke((_b2 = (_a3 = fe()) == null ? void 0 : _a3.flowchart) == null ? void 0 : _b2.htmlLabels)) {
    const G = h.children[0], F = ae(h);
    p = G.getBoundingClientRect(), F.attr("width", p.width), F.attr("height", p.height);
  }
  ut.info("Text 2", l);
  const m = l || [], g = h.getBBox(), y = o.node().appendChild(
    await js(
      m.join ? m.join("<br/>") : m,
      e.labelStyle,
      true,
      true
    )
  ), x = y.children[0], k = ae(y);
  p = x.getBoundingClientRect(), k.attr("width", p.width), k.attr("height", p.height);
  const C = (e.padding || 0) / 2;
  ae(y).attr(
    "transform",
    "translate( " + (p.width > g.width ? 0 : (g.width - p.width) / 2) + ", " + (g.height + C + 5) + ")"
  ), ae(h).attr(
    "transform",
    "translate( " + (p.width < g.width ? 0 : -(g.width - p.width) / 2) + ", 0)"
  ), p = o.node().getBBox(), o.attr(
    "transform",
    "translate(" + -p.width / 2 + ", " + (-p.height / 2 - C + 3) + ")"
  );
  const A = p.width + (e.padding || 0), $ = p.height + (e.padding || 0), B = -p.width / 2 - C, L = -p.height / 2 - C;
  let q, U;
  if (e.look === "handDrawn") {
    const G = Mt.svg(s), F = Lt(e, {}), W = G.path(
      Fi(B, L, A, $, e.rx || 0),
      F
    ), R = G.line(
      -p.width / 2 - C,
      -p.height / 2 - C + g.height + C,
      p.width / 2 + C,
      -p.height / 2 - C + g.height + C,
      F
    );
    U = s.insert(() => (ut.debug("Rough node insert CXC", W), R), ":first-child"), q = s.insert(() => (ut.debug("Rough node insert CXC", W), W), ":first-child");
  } else
    q = a.insert("rect", ":first-child"), U = a.insert("line"), q.attr("class", "outer title-state").attr("style", n).attr("x", -p.width / 2 - C).attr("y", -p.height / 2 - C).attr("width", p.width + (e.padding || 0)).attr("height", p.height + (e.padding || 0)), U.attr("class", "divider").attr("x1", -p.width / 2 - C).attr("x2", p.width / 2 + C).attr("y1", -p.height / 2 - C + g.height + C).attr("y2", -p.height / 2 - C + g.height + C);
  return Dt(e, q), e.intersect = function(G) {
    return Et.rect(e, G);
  }, s;
}
_(y8, "rectWithTitle");
async function b8(t15, e) {
  const r = {
    rx: 5,
    ry: 5,
    labelPaddingX: ((e == null ? void 0 : e.padding) || 0) * 1,
    labelPaddingY: ((e == null ? void 0 : e.padding) || 0) * 1
  };
  return bc(t15, e, r);
}
_(b8, "roundedRect");
async function x8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = (e == null ? void 0 : e.padding) ?? 0, l = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h = -s.width / 2 - o, p = -s.height / 2 - o, { cssStyles: m } = e, g = Mt.svg(i), y = Lt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = [
    { x: h, y: p },
    { x: h + l + 8, y: p },
    { x: h + l + 8, y: p + c },
    { x: h - 8, y: p + c },
    { x: h - 8, y: p },
    { x: h, y: p },
    { x: h, y: p + c }
  ], k = g.polygon(
    x.map((A) => [A.x, A.y]),
    y
  ), C = i.insert(() => k, ":first-child");
  return C.attr("class", "basic label-container").attr("style", Tr(m)), n && e.look !== "handDrawn" && C.selectAll("path").attr("style", n), m && e.look !== "handDrawn" && C.selectAll("path").attr("style", n), a.attr(
    "transform",
    `translate(${-l / 2 + 4 + (e.padding ?? 0) - (s.x - (s.left ?? 0))},${-c / 2 + (e.padding ?? 0) - (s.y - (s.top ?? 0))})`
  ), Dt(e, C), e.intersect = function(A) {
    return Et.rect(e, A);
  }, i;
}
_(x8, "shadedProcess");
async function w8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = -o / 2, h = -l / 2, { cssStyles: p } = e, m = Mt.svg(i), g = Lt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = [
    { x: c, y: h },
    { x: c, y: h + l },
    { x: c + o, y: h + l },
    { x: c + o, y: h - l / 2 }
  ], x = oe(y), k = m.path(x, g), C = i.insert(() => k, ":first-child");
  return C.attr("class", "basic label-container"), p && e.look !== "handDrawn" && C.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && C.selectChildren("path").attr("style", n), C.attr("transform", `translate(0, ${l / 4})`), a.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (s.x - (s.left ?? 0))}, ${-l / 4 + (e.padding ?? 0) - (s.y - (s.top ?? 0))})`
  ), Dt(e, C), e.intersect = function(A) {
    return Et.polygon(e, y, A);
  }, i;
}
_(w8, "slopedRect");
async function k8(t15, e) {
  const r = {
    rx: 0,
    ry: 0,
    labelPaddingX: ((e == null ? void 0 : e.padding) || 0) * 2,
    labelPaddingY: ((e == null ? void 0 : e.padding) || 0) * 1
  };
  return bc(t15, e, r);
}
_(k8, "squareRect");
async function v8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = s.height + e.padding, o = s.width + a / 4 + e.padding;
  let l;
  const { cssStyles: c } = e;
  if (e.look === "handDrawn") {
    const h = Mt.svg(i), p = Lt(e, {}), m = Fi(-o / 2, -a / 2, o, a, a / 2), g = h.path(m, p);
    l = i.insert(() => g, ":first-child"), l.attr("class", "basic label-container").attr("style", Tr(c));
  } else
    l = i.insert("rect", ":first-child"), l.attr("class", "basic label-container").attr("style", n).attr("rx", a / 2).attr("ry", a / 2).attr("x", -o / 2).attr("y", -a / 2).attr("width", o).attr("height", a);
  return Dt(e, l), e.intersect = function(h) {
    return Et.rect(e, h);
  }, i;
}
_(v8, "stadium");
async function C8(t15, e) {
  return bc(t15, e, {
    rx: 5,
    ry: 5
  });
}
_(C8, "state");
function _8(t15, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = Ft(e);
  e.labelStyle = n;
  const { cssStyles: s } = e, { lineColor: a, stateBorder: o, nodeBorder: l } = r, c = t15.insert("g").attr("class", "node default").attr("id", e.domId || e.id), h = Mt.svg(c), p = Lt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const m = h.circle(0, 0, 14, {
    ...p,
    stroke: a,
    strokeWidth: 2
  }), g = o ?? l, y = h.circle(0, 0, 5, {
    ...p,
    fill: g,
    stroke: g,
    strokeWidth: 2,
    fillStyle: "solid"
  }), x = c.insert(() => m, ":first-child");
  return x.insert(() => y), s && x.selectAll("path").attr("style", s), i && x.selectAll("path").attr("style", i), Dt(e, x), e.intersect = function(k) {
    return Et.circle(e, 7, k);
  }, c;
}
_(_8, "stateEnd");
function S8(t15, e, { config: { themeVariables: r } }) {
  const { lineColor: n } = r, i = t15.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
  let s;
  if (e.look === "handDrawn") {
    const a = Mt.svg(i).circle(0, 0, 14, nj(n));
    s = i.insert(() => a), s.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  } else
    s = i.insert("circle", ":first-child"), s.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  return Dt(e, s), e.intersect = function(a) {
    return Et.circle(e, 7, a);
  }, i;
}
_(S8, "stateStart");
async function A8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = ((e == null ? void 0 : e.padding) || 0) / 2, o = s.width + e.padding, l = s.height + e.padding, c = -s.width / 2 - a, h = -s.height / 2 - a, p = [
    { x: 0, y: 0 },
    { x: o, y: 0 },
    { x: o, y: -l },
    { x: 0, y: -l },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: o + 8, y: 0 },
    { x: o + 8, y: -l },
    { x: -8, y: -l },
    { x: -8, y: 0 }
  ];
  if (e.look === "handDrawn") {
    const m = Mt.svg(i), g = Lt(e, {}), y = m.rectangle(c - 8, h, o + 16, l, g), x = m.line(c, h, c, h + l, g), k = m.line(c + o, h, c + o, h + l, g);
    i.insert(() => x, ":first-child"), i.insert(() => k, ":first-child");
    const C = i.insert(() => y, ":first-child"), { cssStyles: A } = e;
    C.attr("class", "basic label-container").attr("style", Tr(A)), Dt(e, C);
  } else {
    const m = Ni(i, o, l, p);
    n && m.attr("style", n), Dt(e, m);
  }
  return e.intersect = function(m) {
    return Et.polygon(e, p, m);
  }, i;
}
_(A8, "subroutine");
async function T8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), o = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), l = -a / 2, c = -o / 2, h = 0.2 * o, p = 0.2 * o, { cssStyles: m } = e, g = Mt.svg(i), y = Lt(e, {}), x = [
    { x: l - h / 2, y: c },
    { x: l + a + h / 2, y: c },
    { x: l + a + h / 2, y: c + o },
    { x: l - h / 2, y: c + o }
  ], k = [
    { x: l + a - h / 2, y: c + o },
    { x: l + a + h / 2, y: c + o },
    { x: l + a + h / 2, y: c + o - p }
  ];
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const C = oe(x), A = g.path(C, y), $ = oe(k), B = g.path($, { ...y, fillStyle: "solid" }), L = i.insert(() => B, ":first-child");
  return L.insert(() => A, ":first-child"), L.attr("class", "basic label-container"), m && e.look !== "handDrawn" && L.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && L.selectAll("path").attr("style", n), Dt(e, L), e.intersect = function(q) {
    return Et.polygon(e, x, q);
  }, i;
}
_(T8, "taggedRect");
async function $8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = l / 4, h = 0.2 * o, p = 0.2 * l, m = l + c, { cssStyles: g } = e, y = Mt.svg(i), x = Lt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const k = [
    { x: -o / 2 - o / 2 * 0.1, y: m / 2 },
    ...us(
      -o / 2 - o / 2 * 0.1,
      m / 2,
      o / 2 + o / 2 * 0.1,
      m / 2,
      c,
      0.8
    ),
    { x: o / 2 + o / 2 * 0.1, y: -m / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: -m / 2 }
  ], C = -o / 2 + o / 2 * 0.1, A = -m / 2 - p * 0.4, $ = [
    { x: C + o - h, y: (A + l) * 1.4 },
    { x: C + o, y: A + l - p },
    { x: C + o, y: (A + l) * 0.9 },
    ...us(
      C + o,
      (A + l) * 1.3,
      C + o - h,
      (A + l) * 1.5,
      -l * 0.03,
      0.5
    )
  ], B = oe(k), L = y.path(B, x), q = oe($), U = y.path(q, {
    ...x,
    fillStyle: "solid"
  }), G = i.insert(() => U, ":first-child");
  return G.insert(() => L, ":first-child"), G.attr("class", "basic label-container"), g && e.look !== "handDrawn" && G.selectAll("path").attr("style", g), n && e.look !== "handDrawn" && G.selectAll("path").attr("style", n), G.attr("transform", `translate(0,${-c / 2})`), a.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) - c / 2 - (s.y - (s.top ?? 0))})`
  ), Dt(e, G), e.intersect = function(F) {
    return Et.polygon(e, k, F);
  }, i;
}
_($8, "taggedWaveEdgedRectangle");
async function E8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = Math.max(s.width + e.padding, (e == null ? void 0 : e.width) || 0), o = Math.max(s.height + e.padding, (e == null ? void 0 : e.height) || 0), l = -a / 2, c = -o / 2, h = i.insert("rect", ":first-child");
  return h.attr("class", "text").attr("style", n).attr("rx", 0).attr("ry", 0).attr("x", l).attr("y", c).attr("width", a).attr("height", o), Dt(e, h), e.intersect = function(p) {
    return Et.rect(e, p);
  }, i;
}
_(E8, "text");
var xK = _((t15, e, r, n, i, s) => `M${t15},${e}
    a${i},${s} 0,0,1 0,${-n}
    l${r},0
    a${i},${s} 0,0,1 0,${n}
    M${r},${-n}
    a${i},${s} 0,0,0 0,${n}
    l${-r},0`, "createCylinderPathD");
var wK = _((t15, e, r, n, i, s) => [
  `M${t15},${e}`,
  `M${t15 + r},${e}`,
  `a${i},${s} 0,0,0 0,${-n}`,
  `l${-r},0`,
  `a${i},${s} 0,0,0 0,${n}`,
  `l${r},0`
].join(" "), "createOuterCylinderPathD");
var kK = _((t15, e, r, n, i, s) => [`M${t15 + r / 2},${-n / 2}`, `a${i},${s} 0,0,0 0,${n}`].join(" "), "createInnerCylinderPathD");
async function M8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a, halfPadding: o } = await Vt(
    t15,
    e,
    Wt(e)
  ), l = e.look === "neo" ? o * 2 : o, c = s.height + l, h = c / 2, p = h / (2.5 + c / 50), m = s.width + p + l, { cssStyles: g } = e;
  let y;
  if (e.look === "handDrawn") {
    const x = Mt.svg(i), k = wK(0, 0, m, c, p, h), C = kK(0, 0, m, c, p, h), A = x.path(k, Lt(e, {})), $ = x.path(C, Lt(e, { fill: "none" }));
    y = i.insert(() => $, ":first-child"), y = i.insert(() => A, ":first-child"), y.attr("class", "basic label-container"), g && y.attr("style", g);
  } else {
    const x = xK(0, 0, m, c, p, h);
    y = i.insert("path", ":first-child").attr("d", x).attr("class", "basic label-container").attr("style", Tr(g)).attr("style", n), y.attr("class", "basic label-container"), g && y.selectAll("path").attr("style", g), n && y.selectAll("path").attr("style", n);
  }
  return y.attr("label-offset-x", p), y.attr("transform", `translate(${-m / 2}, ${c / 2} )`), a.attr(
    "transform",
    `translate(${-(s.width / 2) - p - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`
  ), Dt(e, y), e.intersect = function(x) {
    const k = Et.rect(e, x), C = k.y - (e.y ?? 0);
    if (h != 0 && (Math.abs(C) < (e.height ?? 0) / 2 || Math.abs(C) == (e.height ?? 0) / 2 && Math.abs(k.x - (e.x ?? 0)) > (e.width ?? 0) / 2 - p)) {
      let A = p * p * (1 - C * C / (h * h));
      A != 0 && (A = Math.sqrt(Math.abs(A))), A = p - A, x.x - (e.x ?? 0) > 0 && (A = -A), k.x += A;
    }
    return k;
  }, i;
}
_(M8, "tiltedCylinder");
async function B8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = s.width + e.padding, o = s.height + e.padding, l = [
    { x: -3 * o / 6, y: 0 },
    { x: a + 3 * o / 6, y: 0 },
    { x: a, y: -o },
    { x: 0, y: -o }
  ];
  let c;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const p = Mt.svg(i), m = Lt(e, {}), g = oe(l), y = p.path(g, m);
    c = i.insert(() => y, ":first-child").attr("transform", `translate(${-a / 2}, ${o / 2})`), h && c.attr("style", h);
  } else
    c = Ni(i, a, o, l);
  return n && c.attr("style", n), e.width = a, e.height = o, Dt(e, c), e.intersect = function(p) {
    return Et.polygon(e, l, p);
  }, i;
}
_(B8, "trapezoid");
async function L8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = 60, o = 20, l = Math.max(a, s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(o, s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), { cssStyles: h } = e, p = Mt.svg(i), m = Lt(e, {});
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const g = [
    { x: -l / 2 * 0.8, y: -c / 2 },
    { x: l / 2 * 0.8, y: -c / 2 },
    { x: l / 2, y: -c / 2 * 0.6 },
    { x: l / 2, y: c / 2 },
    { x: -l / 2, y: c / 2 },
    { x: -l / 2, y: -c / 2 * 0.6 }
  ], y = oe(g), x = p.path(y, m), k = i.insert(() => x, ":first-child");
  return k.attr("class", "basic label-container"), h && e.look !== "handDrawn" && k.selectChildren("path").attr("style", h), n && e.look !== "handDrawn" && k.selectChildren("path").attr("style", n), Dt(e, k), e.intersect = function(C) {
    return Et.polygon(e, g, C);
  }, i;
}
_(L8, "trapezoidalPentagon");
async function D8(t15, e) {
  var _a3;
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Ke((_a3 = fe().flowchart) == null ? void 0 : _a3.htmlLabels), l = s.width + (e.padding ?? 0), c = l + s.height, h = l + s.height, p = [
    { x: 0, y: 0 },
    { x: h, y: 0 },
    { x: h / 2, y: -c }
  ], { cssStyles: m } = e, g = Mt.svg(i), y = Lt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = oe(p), k = g.path(x, y), C = i.insert(() => k, ":first-child").attr("transform", `translate(${-c / 2}, ${c / 2})`);
  return m && e.look !== "handDrawn" && C.selectChildren("path").attr("style", m), n && e.look !== "handDrawn" && C.selectChildren("path").attr("style", n), e.width = l, e.height = c, Dt(e, C), a.attr(
    "transform",
    `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${c / 2 - (s.height + (e.padding ?? 0) / (o ? 2 : 1) - (s.y - (s.top ?? 0)))})`
  ), e.intersect = function(A) {
    return ut.info("Triangle intersect", e, p, A), Et.polygon(e, p, A);
  }, i;
}
_(D8, "triangle");
async function F8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = l / 8, h = l + c, { cssStyles: p } = e, m = 70 - o, g = m > 0 ? m / 2 : 0, y = Mt.svg(i), x = Lt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const k = [
    { x: -o / 2 - g, y: h / 2 },
    ...us(
      -o / 2 - g,
      h / 2,
      o / 2 + g,
      h / 2,
      c,
      0.8
    ),
    { x: o / 2 + g, y: -h / 2 },
    { x: -o / 2 - g, y: -h / 2 }
  ], C = oe(k), A = y.path(C, x), $ = i.insert(() => A, ":first-child");
  return $.attr("class", "basic label-container"), p && e.look !== "handDrawn" && $.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(0,${-c / 2})`), a.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (s.x - (s.left ?? 0))},${-l / 2 + (e.padding ?? 0) - c - (s.y - (s.top ?? 0))})`
  ), Dt(e, $), e.intersect = function(B) {
    return Et.polygon(e, k, B);
  }, i;
}
_(F8, "waveEdgedRectangle");
async function N8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s } = await Vt(t15, e, Wt(e)), a = 100, o = 50, l = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), c = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), h = l / c;
  let p = l, m = c;
  p > m * h ? m = p / h : p = m * h, p = Math.max(p, a), m = Math.max(m, o);
  const g = Math.min(m * 0.2, m / 4), y = m + g * 2, { cssStyles: x } = e, k = Mt.svg(i), C = Lt(e, {});
  e.look !== "handDrawn" && (C.roughness = 0, C.fillStyle = "solid");
  const A = [
    { x: -p / 2, y: y / 2 },
    ...us(-p / 2, y / 2, p / 2, y / 2, g, 1),
    { x: p / 2, y: -y / 2 },
    ...us(p / 2, -y / 2, -p / 2, -y / 2, g, -1)
  ], $ = oe(A), B = k.path($, C), L = i.insert(() => B, ":first-child");
  return L.attr("class", "basic label-container"), x && e.look !== "handDrawn" && L.selectAll("path").attr("style", x), n && e.look !== "handDrawn" && L.selectAll("path").attr("style", n), Dt(e, L), e.intersect = function(q) {
    return Et.polygon(e, A, q);
  }, i;
}
_(N8, "waveRectangle");
async function I8(t15, e) {
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: s, label: a } = await Vt(t15, e, Wt(e)), o = Math.max(s.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), l = Math.max(s.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), c = 5, h = -o / 2, p = -l / 2, { cssStyles: m } = e, g = Mt.svg(i), y = Lt(e, {}), x = [
    { x: h - c, y: p - c },
    { x: h - c, y: p + l },
    { x: h + o, y: p + l },
    { x: h + o, y: p - c }
  ], k = `M${h - c},${p - c} L${h + o},${p - c} L${h + o},${p + l} L${h - c},${p + l} L${h - c},${p - c}
                M${h - c},${p} L${h + o},${p}
                M${h},${p - c} L${h},${p + l}`;
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const C = g.path(k, y), A = i.insert(() => C, ":first-child");
  return A.attr("transform", `translate(${c / 2}, ${c / 2})`), A.attr("class", "basic label-container"), m && e.look !== "handDrawn" && A.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && A.selectAll("path").attr("style", n), a.attr(
    "transform",
    `translate(${-(s.width / 2) + c / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + c / 2 - (s.y - (s.top ?? 0))})`
  ), Dt(e, A), e.intersect = function($) {
    return Et.polygon(e, x, $);
  }, i;
}
_(I8, "windowPane");
async function xg(t15, e) {
  var _a3, _b2, _c, _d, _e;
  const r = e;
  if (r.alias && (e.label = r.alias), e.look === "handDrawn") {
    const { themeVariables: X } = Hr(), { background: ct } = X, gt = {
      ...e,
      id: e.id + "-background",
      look: "default",
      cssStyles: ["stroke: none", `fill: ${ct}`]
    };
    await xg(t15, gt);
  }
  const n = Hr();
  e.useHtmlLabels = n.htmlLabels;
  let i = ((_a3 = n.er) == null ? void 0 : _a3.diagramPadding) ?? 10, s = ((_b2 = n.er) == null ? void 0 : _b2.entityPadding) ?? 6;
  const { cssStyles: a } = e, { labelStyles: o, nodeStyles: l } = Ft(e);
  if (r.attributes.length === 0 && e.label) {
    const X = {
      rx: 0,
      ry: 0,
      labelPaddingX: i,
      labelPaddingY: i * 1.5
    };
    Bi(e.label, n) + X.labelPaddingX * 2 < n.er.minEntityWidth && (e.width = n.er.minEntityWidth);
    const ct = await bc(t15, e, X);
    if (!Ke(n.htmlLabels)) {
      const gt = ct.select("text"), xt = (_c = gt.node()) == null ? void 0 : _c.getBBox();
      gt.attr("transform", `translate(${-xt.width / 2}, 0)`);
    }
    return ct;
  }
  n.htmlLabels || (i *= 1.25, s *= 1.25);
  let c = Wt(e);
  c || (c = "node default");
  const h = t15.insert("g").attr("class", c).attr("id", e.domId || e.id), p = await Aa(h, e.label ?? "", n, 0, 0, ["name"], o);
  p.height += s;
  let m = 0;
  const g = [], y = [];
  let x = 0, k = 0, C = 0, A = 0, $ = true, B = true;
  for (const X of r.attributes) {
    const ct = await Aa(
      h,
      X.type,
      n,
      0,
      m,
      ["attribute-type"],
      o
    );
    x = Math.max(x, ct.width + i);
    const gt = await Aa(
      h,
      X.name,
      n,
      0,
      m,
      ["attribute-name"],
      o
    );
    k = Math.max(k, gt.width + i);
    const xt = await Aa(
      h,
      X.keys.join(),
      n,
      0,
      m,
      ["attribute-keys"],
      o
    );
    C = Math.max(C, xt.width + i);
    const Xt = await Aa(
      h,
      X.comment,
      n,
      0,
      m,
      ["attribute-comment"],
      o
    );
    A = Math.max(A, Xt.width + i);
    const H = Math.max(ct.height, gt.height, xt.height, Xt.height) + s;
    y.push({ yOffset: m, rowHeight: H }), m += H;
  }
  let L = 4;
  C <= i && ($ = false, C = 0, L--), A <= i && (B = false, A = 0, L--);
  const q = h.node().getBBox();
  if (p.width + i * 2 - (x + k + C + A) > 0) {
    const X = p.width + i * 2 - (x + k + C + A);
    x += X / L, k += X / L, C > 0 && (C += X / L), A > 0 && (A += X / L);
  }
  const U = x + k + C + A, G = Mt.svg(h), F = Lt(e, {});
  e.look !== "handDrawn" && (F.roughness = 0, F.fillStyle = "solid");
  let W = 0;
  y.length > 0 && (W = y.reduce((X, ct) => X + ((ct == null ? void 0 : ct.rowHeight) ?? 0), 0));
  const R = Math.max(q.width + i * 2, (e == null ? void 0 : e.width) || 0, U), Q = Math.max((W ?? 0) + p.height, (e == null ? void 0 : e.height) || 0), rt = -R / 2, I = -Q / 2;
  h.selectAll("g:not(:first-child)").each((X, ct, gt) => {
    const xt = ae(gt[ct]), Xt = xt.attr("transform");
    let H = 0, mt = 0;
    if (Xt) {
      const wt = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(Xt);
      wt && (H = parseFloat(wt[1]), mt = parseFloat(wt[2]), xt.attr("class").includes("attribute-name") ? H += x : xt.attr("class").includes("attribute-keys") ? H += x + k : xt.attr("class").includes("attribute-comment") && (H += x + k + C));
    }
    xt.attr(
      "transform",
      `translate(${rt + i / 2 + H}, ${mt + I + p.height + s / 2})`
    );
  }), h.select(".name").attr("transform", "translate(" + -p.width / 2 + ", " + (I + s / 2) + ")");
  const j = G.rectangle(rt, I, R, Q, F), z = h.insert(() => j, ":first-child").attr("style", a.join("")), { themeVariables: K } = Hr(), { rowEven: Y, rowOdd: ot, nodeBorder: et } = K;
  g.push(0);
  for (const [X, ct] of y.entries()) {
    const gt = (X + 1) % 2 === 0 && ct.yOffset !== 0, xt = G.rectangle(rt, p.height + I + (ct == null ? void 0 : ct.yOffset), R, ct == null ? void 0 : ct.rowHeight, {
      ...F,
      fill: gt ? Y : ot,
      stroke: et
    });
    h.insert(() => xt, "g.label").attr("style", a.join("")).attr("class", `row-rect-${gt ? "even" : "odd"}`);
  }
  let ht = G.line(rt, p.height + I, R + rt, p.height + I, F);
  h.insert(() => ht).attr("class", "divider"), ht = G.line(x + rt, p.height + I, x + rt, Q + I, F), h.insert(() => ht).attr("class", "divider"), $ && (ht = G.line(
    x + k + rt,
    p.height + I,
    x + k + rt,
    Q + I,
    F
  ), h.insert(() => ht).attr("class", "divider")), B && (ht = G.line(
    x + k + C + rt,
    p.height + I,
    x + k + C + rt,
    Q + I,
    F
  ), h.insert(() => ht).attr("class", "divider"));
  for (const X of g)
    ht = G.line(
      rt,
      p.height + I + X,
      R + rt,
      p.height + I + X,
      F
    ), h.insert(() => ht).attr("class", "divider");
  if (Dt(e, z), l && e.look !== "handDrawn") {
    const X = (_e = (_d = l.split(";")) == null ? void 0 : _d.filter((ct) => ct.includes("stroke"))) == null ? void 0 : _e.map((ct) => `${ct}`).join("; ");
    h.selectAll("path").attr("style", X ?? ""), h.selectAll(".row-rect-even path").attr("style", l);
  }
  return e.intersect = function(X) {
    return Et.rect(e, X);
  }, h;
}
_(xg, "erBox");
async function Aa(t15, e, r, n = 0, i = 0, s = [], a = "") {
  const o = t15.insert("g").attr("class", `label ${s.join(" ")}`).attr("transform", `translate(${n}, ${i})`).attr("style", a);
  e !== Ob(e) && (e = Ob(e), e = e.replaceAll("<", "&lt;").replaceAll(">", "&gt;"));
  const l = o.node().appendChild(
    await fs(
      o,
      e,
      {
        width: Bi(e, r) + 100,
        style: a,
        useHtmlLabels: r.htmlLabels
      },
      r
    )
  );
  if (e.includes("&lt;") || e.includes("&gt;")) {
    let h = l.children[0];
    for (h.textContent = h.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">"); h.childNodes[0]; )
      h = h.childNodes[0], h.textContent = h.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
  }
  let c = l.getBBox();
  if (Ke(r.htmlLabels)) {
    const h = l.children[0];
    h.style.textAlign = "start";
    const p = ae(l);
    c = h.getBoundingClientRect(), p.attr("width", c.width), p.attr("height", c.height);
  }
  return c;
}
_(Aa, "addText");
async function O8(t15, e, r, n, i = r.class.padding ?? 12) {
  const s = n ? 0 : 3, a = t15.insert("g").attr("class", Wt(e)).attr("id", e.domId || e.id);
  let o = null, l = null, c = null, h = null, p = 0, m = 0, g = 0;
  if (o = a.insert("g").attr("class", "annotation-group text"), e.annotations.length > 0) {
    const A = e.annotations[0];
    await hl(o, { text: `«${A}»` }, 0), p = o.node().getBBox().height;
  }
  l = a.insert("g").attr("class", "label-group text"), await hl(l, e, 0, ["font-weight: bolder"]);
  const y = l.node().getBBox();
  m = y.height, c = a.insert("g").attr("class", "members-group text");
  let x = 0;
  for (const A of e.members) {
    const $ = await hl(c, A, x, [A.parseClassifier()]);
    x += $ + s;
  }
  g = c.node().getBBox().height, g <= 0 && (g = i / 2), h = a.insert("g").attr("class", "methods-group text");
  let k = 0;
  for (const A of e.methods) {
    const $ = await hl(h, A, k, [A.parseClassifier()]);
    k += $ + s;
  }
  let C = a.node().getBBox();
  if (o !== null) {
    const A = o.node().getBBox();
    o.attr("transform", `translate(${-A.width / 2})`);
  }
  return l.attr("transform", `translate(${-y.width / 2}, ${p})`), C = a.node().getBBox(), c.attr(
    "transform",
    `translate(0, ${p + m + i * 2})`
  ), C = a.node().getBBox(), h.attr(
    "transform",
    `translate(0, ${p + m + (g ? g + i * 4 : i * 2)})`
  ), C = a.node().getBBox(), { shapeSvg: a, bbox: C };
}
_(O8, "textHelper");
async function hl(t15, e, r, n = []) {
  const i = t15.insert("g").attr("class", "label").attr("style", n.join("; ")), s = Hr();
  let a = "useHtmlLabels" in e ? e.useHtmlLabels : Ke(s.htmlLabels) ?? true, o = "";
  "text" in e ? o = e.text : o = e.label, !a && o.startsWith("\\") && (o = o.substring(1)), Ja(o) && (a = true);
  const l = await fs(
    i,
    vu(ca(o)),
    {
      width: Bi(o, s) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: a
    },
    s
  );
  let c, h = 1;
  if (a) {
    const p = l.children[0], m = ae(l);
    h = p.innerHTML.split("<br>").length, p.innerHTML.includes("</math>") && (h += p.innerHTML.split("<mrow>").length - 1);
    const g = p.getElementsByTagName("img");
    if (g) {
      const y = o.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...g].map(
          (x) => new Promise((k) => {
            function C() {
              var _a3;
              if (x.style.display = "flex", x.style.flexDirection = "column", y) {
                const A = ((_a3 = s.fontSize) == null ? void 0 : _a3.toString()) ?? window.getComputedStyle(document.body).fontSize, $ = parseInt(A, 10) * 5 + "px";
                x.style.minWidth = $, x.style.maxWidth = $;
              } else
                x.style.width = "100%";
              k(x);
            }
            _(C, "setupImage"), setTimeout(() => {
              x.complete && C();
            }), x.addEventListener("error", C), x.addEventListener("load", C);
          })
        )
      );
    }
    c = p.getBoundingClientRect(), m.attr("width", c.width), m.attr("height", c.height);
  } else {
    n.includes("font-weight: bolder") && ae(l).selectAll("tspan").attr("font-weight", ""), h = l.children.length;
    const p = l.children[0];
    (l.textContent === "" || l.textContent.includes("&gt")) && (p.textContent = o[0] + o.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim(), o[1] === " " && (p.textContent = p.textContent[0] + " " + p.textContent.substring(1))), p.textContent === "undefined" && (p.textContent = ""), c = l.getBBox();
  }
  return i.attr("transform", "translate(0," + (-c.height / (2 * h) + r) + ")"), c.height;
}
_(hl, "addText");
async function z8(t15, e) {
  var _a3, _b2;
  const r = fe(), n = r.class.padding ?? 12, i = n, s = e.useHtmlLabels ?? Ke(r.htmlLabels) ?? true, a = e;
  a.annotations = a.annotations ?? [], a.members = a.members ?? [], a.methods = a.methods ?? [];
  const { shapeSvg: o, bbox: l } = await O8(t15, e, r, s, i), { labelStyles: c, nodeStyles: h } = Ft(e);
  e.labelStyle = c, e.cssStyles = a.styles || "";
  const p = ((_a3 = a.styles) == null ? void 0 : _a3.join(";")) || h || "";
  e.cssStyles || (e.cssStyles = p.replaceAll("!important", "").split(";"));
  const m = a.members.length === 0 && a.methods.length === 0 && !((_b2 = r.class) == null ? void 0 : _b2.hideEmptyMembersBox), g = Mt.svg(o), y = Lt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = l.width;
  let k = l.height;
  a.members.length === 0 && a.methods.length === 0 ? k += i : a.members.length > 0 && a.methods.length === 0 && (k += i * 2);
  const C = -x / 2, A = -k / 2, $ = g.rectangle(
    C - n,
    A - n - (m ? n : a.members.length === 0 && a.methods.length === 0 ? -n / 2 : 0),
    x + 2 * n,
    k + 2 * n + (m ? n * 2 : a.members.length === 0 && a.methods.length === 0 ? -n : 0),
    y
  ), B = o.insert(() => $, ":first-child");
  B.attr("class", "basic label-container");
  const L = B.node().getBBox();
  o.selectAll(".text").each((F, W, R) => {
    var _a4;
    const Q = ae(R[W]), rt = Q.attr("transform");
    let I = 0;
    if (rt) {
      const K = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(rt);
      K && (I = parseFloat(K[2]));
    }
    let j = I + A + n - (m ? n : a.members.length === 0 && a.methods.length === 0 ? -n / 2 : 0);
    s || (j -= 4);
    let z = C;
    (Q.attr("class").includes("label-group") || Q.attr("class").includes("annotation-group")) && (z = -((_a4 = Q.node()) == null ? void 0 : _a4.getBBox().width) / 2 || 0, o.selectAll("text").each(function(K, Y, ot) {
      window.getComputedStyle(ot[Y]).textAnchor === "middle" && (z = 0);
    })), Q.attr("transform", `translate(${z}, ${j})`);
  });
  const q = o.select(".annotation-group").node().getBBox().height - (m ? n / 2 : 0) || 0, U = o.select(".label-group").node().getBBox().height - (m ? n / 2 : 0) || 0, G = o.select(".members-group").node().getBBox().height - (m ? n / 2 : 0) || 0;
  if (a.members.length > 0 || a.methods.length > 0 || m) {
    const F = g.line(
      L.x,
      q + U + A + n,
      L.x + L.width,
      q + U + A + n,
      y
    );
    o.insert(() => F).attr("class", "divider").attr("style", p);
  }
  if (m || a.members.length > 0 || a.methods.length > 0) {
    const F = g.line(
      L.x,
      q + U + G + A + i * 2 + n,
      L.x + L.width,
      q + U + G + A + n + i * 2,
      y
    );
    o.insert(() => F).attr("class", "divider").attr("style", p);
  }
  if (a.look !== "handDrawn" && o.selectAll("path").attr("style", p), B.select(":nth-child(2)").attr("style", p), o.selectAll(".divider").select("path").attr("style", p), e.labelStyle ? o.selectAll("span").attr("style", e.labelStyle) : o.selectAll("span").attr("style", p), !s) {
    const F = RegExp(/color\s*:\s*([^;]*)/), W = F.exec(p);
    if (W) {
      const R = W[0].replace("color", "fill");
      o.selectAll("tspan").attr("style", R);
    } else if (c) {
      const R = F.exec(c);
      if (R) {
        const Q = R[0].replace("color", "fill");
        o.selectAll("tspan").attr("style", Q);
      }
    }
  }
  return Dt(e, B), e.intersect = function(F) {
    return Et.rect(e, F);
  }, o;
}
_(z8, "classBox");
async function q8(t15, e) {
  var _a3, _b2;
  const { labelStyles: r, nodeStyles: n } = Ft(e);
  e.labelStyle = r;
  const i = e, s = e, a = 20, o = 20, l = "verifyMethod" in e, c = Wt(e), h = t15.insert("g").attr("class", c).attr("id", e.domId ?? e.id);
  let p;
  l ? p = await On(
    h,
    `&lt;&lt;${i.type}&gt;&gt;`,
    0,
    e.labelStyle
  ) : p = await On(h, "&lt;&lt;Element&gt;&gt;", 0, e.labelStyle);
  let m = p;
  const g = await On(
    h,
    i.name,
    m,
    e.labelStyle + "; font-weight: bold;"
  );
  if (m += g + o, l) {
    const q = await On(
      h,
      `${i.requirementId ? `id: ${i.requirementId}` : ""}`,
      m,
      e.labelStyle
    );
    m += q;
    const U = await On(
      h,
      `${i.text ? `Text: ${i.text}` : ""}`,
      m,
      e.labelStyle
    );
    m += U;
    const G = await On(
      h,
      `${i.risk ? `Risk: ${i.risk}` : ""}`,
      m,
      e.labelStyle
    );
    m += G, await On(
      h,
      `${i.verifyMethod ? `Verification: ${i.verifyMethod}` : ""}`,
      m,
      e.labelStyle
    );
  } else {
    const q = await On(
      h,
      `${s.type ? `Type: ${s.type}` : ""}`,
      m,
      e.labelStyle
    );
    m += q, await On(
      h,
      `${s.docRef ? `Doc Ref: ${s.docRef}` : ""}`,
      m,
      e.labelStyle
    );
  }
  const y = (((_a3 = h.node()) == null ? void 0 : _a3.getBBox().width) ?? 200) + a, x = (((_b2 = h.node()) == null ? void 0 : _b2.getBBox().height) ?? 200) + a, k = -y / 2, C = -x / 2, A = Mt.svg(h), $ = Lt(e, {});
  e.look !== "handDrawn" && ($.roughness = 0, $.fillStyle = "solid");
  const B = A.rectangle(k, C, y, x, $), L = h.insert(() => B, ":first-child");
  if (L.attr("class", "basic label-container").attr("style", n), h.selectAll(".label").each((q, U, G) => {
    const F = ae(G[U]), W = F.attr("transform");
    let R = 0, Q = 0;
    if (W) {
      const j = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(W);
      j && (R = parseFloat(j[1]), Q = parseFloat(j[2]));
    }
    const rt = Q - x / 2;
    let I = k + a / 2;
    (U === 0 || U === 1) && (I = R), F.attr("transform", `translate(${I}, ${rt + a})`);
  }), m > p + g + o) {
    const q = A.line(
      k,
      C + p + g + o,
      k + y,
      C + p + g + o,
      $
    );
    h.insert(() => q).attr("style", n);
  }
  return Dt(e, L), e.intersect = function(q) {
    return Et.rect(e, q);
  }, h;
}
_(q8, "requirementBox");
async function On(t15, e, r, n = "") {
  if (e === "")
    return 0;
  const i = t15.insert("g").attr("class", "label").attr("style", n), s = fe(), a = s.htmlLabels ?? true, o = await fs(
    i,
    vu(ca(e)),
    {
      width: Bi(e, s) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: a,
      style: n
    },
    s
  );
  let l;
  if (a) {
    const c = o.children[0], h = ae(o);
    l = c.getBoundingClientRect(), h.attr("width", l.width), h.attr("height", l.height);
  } else {
    const c = o.children[0];
    for (const h of c.children)
      h.textContent = h.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<"), n && h.setAttribute("style", n);
    l = o.getBBox(), l.height += 6;
  }
  return i.attr("transform", `translate(${-l.width / 2},${-l.height / 2 + r})`), l.height;
}
_(On, "addText");
var vK = _((t15) => {
  switch (t15) {
    case "Very High":
      return "red";
    case "High":
      return "orange";
    case "Medium":
      return null;
    case "Low":
      return "blue";
    case "Very Low":
      return "lightblue";
  }
}, "colorFromPriority");
async function R8(t15, e, { config: r }) {
  var _a3, _b2;
  const { labelStyles: n, nodeStyles: i } = Ft(e);
  e.labelStyle = n || "";
  const s = 10, a = e.width;
  e.width = (e.width ?? 200) - 10;
  const {
    shapeSvg: o,
    bbox: l,
    label: c
  } = await Vt(t15, e, Wt(e)), h = e.padding || 10;
  let p = "", m;
  "ticket" in e && e.ticket && ((_a3 = r == null ? void 0 : r.kanban) == null ? void 0 : _a3.ticketBaseUrl) && (p = (_b2 = r == null ? void 0 : r.kanban) == null ? void 0 : _b2.ticketBaseUrl.replace("#TICKET#", e.ticket), m = o.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", p).attr("target", "_blank"));
  const g = {
    useHtmlLabels: e.useHtmlLabels,
    labelStyle: e.labelStyle || "",
    width: e.width,
    img: e.img,
    padding: e.padding || 8,
    centerLabel: false
  };
  let y, x;
  m ? { label: y, bbox: x } = await Lp(
    m,
    "ticket" in e && e.ticket || "",
    g
  ) : { label: y, bbox: x } = await Lp(
    o,
    "ticket" in e && e.ticket || "",
    g
  );
  const { label: k, bbox: C } = await Lp(
    o,
    "assigned" in e && e.assigned || "",
    g
  );
  e.width = a;
  const A = 10, $ = (e == null ? void 0 : e.width) || 0, B = Math.max(x.height, C.height) / 2, L = Math.max(l.height + A * 2, (e == null ? void 0 : e.height) || 0) + B, q = -$ / 2, U = -L / 2;
  c.attr(
    "transform",
    "translate(" + (h - $ / 2) + ", " + (-B - l.height / 2) + ")"
  ), y.attr(
    "transform",
    "translate(" + (h - $ / 2) + ", " + (-B + l.height / 2) + ")"
  ), k.attr(
    "transform",
    "translate(" + (h + $ / 2 - C.width - 2 * s) + ", " + (-B + l.height / 2) + ")"
  );
  let G;
  const { rx: F, ry: W } = e, { cssStyles: R } = e;
  if (e.look === "handDrawn") {
    const Q = Mt.svg(o), rt = Lt(e, {}), I = F || W ? Q.path(Fi(q, U, $, L, F || 0), rt) : Q.rectangle(q, U, $, L, rt);
    G = o.insert(() => I, ":first-child"), G.attr("class", "basic label-container").attr("style", R || null);
  } else {
    G = o.insert("rect", ":first-child"), G.attr("class", "basic label-container __APA__").attr("style", i).attr("rx", F ?? 5).attr("ry", W ?? 5).attr("x", q).attr("y", U).attr("width", $).attr("height", L);
    const Q = "priority" in e && e.priority;
    if (Q) {
      const rt = o.append("line"), I = q + 2, j = U + Math.floor((F ?? 0) / 2), z = U + L - Math.floor((F ?? 0) / 2);
      rt.attr("x1", I).attr("y1", j).attr("x2", I).attr("y2", z).attr("stroke-width", "4").attr("stroke", vK(Q));
    }
  }
  return Dt(e, G), e.height = L, e.intersect = function(Q) {
    return Et.rect(e, Q);
  }, o;
}
_(R8, "kanbanItem");
var CK = [
  {
    semanticName: "Process",
    name: "Rectangle",
    shortName: "rect",
    description: "Standard process shape",
    aliases: ["proc", "process", "rectangle"],
    internalAliases: ["squareRect"],
    handler: k8
  },
  {
    semanticName: "Event",
    name: "Rounded Rectangle",
    shortName: "rounded",
    description: "Represents an event",
    aliases: ["event"],
    internalAliases: ["roundedRect"],
    handler: b8
  },
  {
    semanticName: "Terminal Point",
    name: "Stadium",
    shortName: "stadium",
    description: "Terminal point",
    aliases: ["terminal", "pill"],
    handler: v8
  },
  {
    semanticName: "Subprocess",
    name: "Framed Rectangle",
    shortName: "fr-rect",
    description: "Subprocess",
    aliases: ["subprocess", "subproc", "framed-rectangle", "subroutine"],
    handler: A8
  },
  {
    semanticName: "Database",
    name: "Cylinder",
    shortName: "cyl",
    description: "Database storage",
    aliases: ["db", "database", "cylinder"],
    handler: Uv
  },
  {
    semanticName: "Start",
    name: "Circle",
    shortName: "circle",
    description: "Starting point",
    aliases: ["circ"],
    handler: zv
  },
  {
    semanticName: "Decision",
    name: "Diamond",
    shortName: "diam",
    description: "Decision-making step",
    aliases: ["decision", "diamond", "question"],
    handler: m8
  },
  {
    semanticName: "Prepare Conditional",
    name: "Hexagon",
    shortName: "hex",
    description: "Preparation or condition step",
    aliases: ["hexagon", "prepare"],
    handler: Jv
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Right",
    shortName: "lean-r",
    description: "Represents input or output",
    aliases: ["lean-right", "in-out"],
    internalAliases: ["lean_right"],
    handler: l8
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Left",
    shortName: "lean-l",
    description: "Represents output or input",
    aliases: ["lean-left", "out-in"],
    internalAliases: ["lean_left"],
    handler: o8
  },
  {
    semanticName: "Priority Action",
    name: "Trapezoid Base Bottom",
    shortName: "trap-b",
    description: "Priority action",
    aliases: ["priority", "trapezoid-bottom", "trapezoid"],
    handler: B8
  },
  {
    semanticName: "Manual Operation",
    name: "Trapezoid Base Top",
    shortName: "trap-t",
    description: "Represents a manual task",
    aliases: ["manual", "trapezoid-top", "inv-trapezoid"],
    internalAliases: ["inv_trapezoid"],
    handler: s8
  },
  {
    semanticName: "Stop",
    name: "Double Circle",
    shortName: "dbl-circ",
    description: "Represents a stop point",
    aliases: ["double-circle"],
    internalAliases: ["doublecircle"],
    handler: Gv
  },
  {
    semanticName: "Text Block",
    name: "Text Block",
    shortName: "text",
    description: "Text block",
    handler: E8
  },
  {
    semanticName: "Card",
    name: "Notched Rectangle",
    shortName: "notch-rect",
    description: "Represents a card",
    aliases: ["card", "notched-rectangle"],
    handler: Iv
  },
  {
    semanticName: "Lined/Shaded Process",
    name: "Lined Rectangle",
    shortName: "lin-rect",
    description: "Lined process shape",
    aliases: ["lined-rectangle", "lined-process", "lin-proc", "shaded-process"],
    handler: x8
  },
  {
    semanticName: "Start",
    name: "Small Circle",
    shortName: "sm-circ",
    description: "Small starting point",
    aliases: ["start", "small-circle"],
    internalAliases: ["stateStart"],
    handler: S8
  },
  {
    semanticName: "Stop",
    name: "Framed Circle",
    shortName: "fr-circ",
    description: "Stop point",
    aliases: ["stop", "framed-circle"],
    internalAliases: ["stateEnd"],
    handler: _8
  },
  {
    semanticName: "Fork/Join",
    name: "Filled Rectangle",
    shortName: "fork",
    description: "Fork or join in process flow",
    aliases: ["join"],
    internalAliases: ["forkJoin"],
    handler: Kv
  },
  {
    semanticName: "Collate",
    name: "Hourglass",
    shortName: "hourglass",
    description: "Represents a collate operation",
    aliases: ["hourglass", "collate"],
    handler: Qv
  },
  {
    semanticName: "Comment",
    name: "Curly Brace",
    shortName: "brace",
    description: "Adds a comment",
    aliases: ["comment", "brace-l"],
    handler: Pv
  },
  {
    semanticName: "Comment Right",
    name: "Curly Brace",
    shortName: "brace-r",
    description: "Adds a comment",
    handler: jv
  },
  {
    semanticName: "Comment with braces on both sides",
    name: "Curly Braces",
    shortName: "braces",
    description: "Adds a comment",
    handler: Wv
  },
  {
    semanticName: "Com Link",
    name: "Lightning Bolt",
    shortName: "bolt",
    description: "Communication link",
    aliases: ["com-link", "lightning-bolt"],
    handler: c8
  },
  {
    semanticName: "Document",
    name: "Document",
    shortName: "doc",
    description: "Represents a document",
    aliases: ["doc", "document"],
    handler: F8
  },
  {
    semanticName: "Delay",
    name: "Half-Rounded Rectangle",
    shortName: "delay",
    description: "Represents a delay",
    aliases: ["half-rounded-rectangle"],
    handler: Zv
  },
  {
    semanticName: "Direct Access Storage",
    name: "Horizontal Cylinder",
    shortName: "h-cyl",
    description: "Direct access storage",
    aliases: ["das", "horizontal-cylinder"],
    handler: M8
  },
  {
    semanticName: "Disk Storage",
    name: "Lined Cylinder",
    shortName: "lin-cyl",
    description: "Disk storage",
    aliases: ["disk", "lined-cylinder"],
    handler: h8
  },
  {
    semanticName: "Display",
    name: "Curved Trapezoid",
    shortName: "curv-trap",
    description: "Represents a display",
    aliases: ["curved-trapezoid", "display"],
    handler: Hv
  },
  {
    semanticName: "Divided Process",
    name: "Divided Rectangle",
    shortName: "div-rect",
    description: "Divided process shape",
    aliases: ["div-proc", "divided-rectangle", "divided-process"],
    handler: Vv
  },
  {
    semanticName: "Extract",
    name: "Triangle",
    shortName: "tri",
    description: "Extraction process",
    aliases: ["extract", "triangle"],
    handler: D8
  },
  {
    semanticName: "Internal Storage",
    name: "Window Pane",
    shortName: "win-pane",
    description: "Internal storage",
    aliases: ["internal-storage", "window-pane"],
    handler: I8
  },
  {
    semanticName: "Junction",
    name: "Filled Circle",
    shortName: "f-circ",
    description: "Junction point",
    aliases: ["junction", "filled-circle"],
    handler: Xv
  },
  {
    semanticName: "Loop Limit",
    name: "Trapezoidal Pentagon",
    shortName: "notch-pent",
    description: "Loop limit step",
    aliases: ["loop-limit", "notched-pentagon"],
    handler: L8
  },
  {
    semanticName: "Manual File",
    name: "Flipped Triangle",
    shortName: "flip-tri",
    description: "Manual file operation",
    aliases: ["manual-file", "flipped-triangle"],
    handler: Yv
  },
  {
    semanticName: "Manual Input",
    name: "Sloped Rectangle",
    shortName: "sl-rect",
    description: "Manual input step",
    aliases: ["manual-input", "sloped-rectangle"],
    handler: w8
  },
  {
    semanticName: "Multi-Document",
    name: "Stacked Document",
    shortName: "docs",
    description: "Multiple documents",
    aliases: ["documents", "st-doc", "stacked-document"],
    handler: p8
  },
  {
    semanticName: "Multi-Process",
    name: "Stacked Rectangle",
    shortName: "st-rect",
    description: "Multiple processes",
    aliases: ["procs", "processes", "stacked-rectangle"],
    handler: d8
  },
  {
    semanticName: "Stored Data",
    name: "Bow Tie Rectangle",
    shortName: "bow-rect",
    description: "Stored data",
    aliases: ["stored-data", "bow-tie-rectangle"],
    handler: Nv
  },
  {
    semanticName: "Summary",
    name: "Crossed Circle",
    shortName: "cross-circ",
    description: "Summary",
    aliases: ["summary", "crossed-circle"],
    handler: Rv
  },
  {
    semanticName: "Tagged Document",
    name: "Tagged Document",
    shortName: "tag-doc",
    description: "Tagged document",
    aliases: ["tag-doc", "tagged-document"],
    handler: $8
  },
  {
    semanticName: "Tagged Process",
    name: "Tagged Rectangle",
    shortName: "tag-rect",
    description: "Tagged process",
    aliases: ["tagged-rectangle", "tag-proc", "tagged-process"],
    handler: T8
  },
  {
    semanticName: "Paper Tape",
    name: "Flag",
    shortName: "flag",
    description: "Paper tape",
    aliases: ["paper-tape"],
    handler: N8
  },
  {
    semanticName: "Odd",
    name: "Odd",
    shortName: "odd",
    description: "Odd shape",
    internalAliases: ["rect_left_inv_arrow"],
    handler: g8
  },
  {
    semanticName: "Lined Document",
    name: "Lined Document",
    shortName: "lin-doc",
    description: "Lined document",
    aliases: ["lined-document"],
    handler: u8
  }
];
var _K = _(() => {
  const t15 = [
    ...Object.entries({
      // States
      state: C8,
      choice: Ov,
      note: f8,
      // Rectangles
      rectWithTitle: y8,
      labelRect: a8,
      // Icons
      iconSquare: n8,
      iconCircle: e8,
      icon: t82,
      iconRounded: r8,
      imageSquare: i8,
      anchor: Fv,
      // Kanban diagram
      kanbanItem: R8,
      // class diagram
      classBox: z8,
      // er diagram
      erBox: xg,
      // Requirement diagram
      requirementBox: q8
    }),
    ...CK.flatMap((e) => [
      e.shortName,
      ..."aliases" in e ? e.aliases : [],
      ..."internalAliases" in e ? e.internalAliases : []
    ].map((r) => [r, e.handler]))
  ];
  return Object.fromEntries(t15);
}, "generateShapeMap");
var P8 = _K();
function SK(t15) {
  return t15 in P8;
}
_(SK, "isValidShape");
var Pu = /* @__PURE__ */ new Map();
async function j8(t15, e, r) {
  let n, i;
  e.shape === "rect" && (e.rx && e.ry ? e.shape = "roundedRect" : e.shape = "squareRect");
  const s = e.shape ? P8[e.shape] : void 0;
  if (!s)
    throw new Error(`No such shape: ${e.shape}. Please check your syntax.`);
  if (e.link) {
    let a;
    r.config.securityLevel === "sandbox" ? a = "_top" : e.linkTarget && (a = e.linkTarget || "_blank"), n = t15.insert("svg:a").attr("xlink:href", e.link).attr("target", a ?? null), i = await s(n, e, r);
  } else
    i = await s(t15, e, r), n = i;
  return e.tooltip && i.attr("title", e.tooltip), Pu.set(e.id, n), e.haveCallback && n.attr("class", n.attr("class") + " clickable"), n;
}
_(j8, "insertNode");
var _rt = _((t15, e) => {
  Pu.set(e.id, t15);
}, "setNodeElem");
var Srt = _(() => {
  Pu.clear();
}, "clear");
var Art = _((t15) => {
  const e = Pu.get(t15.id);
  ut.trace(
    "Transforming node",
    t15.diff,
    t15,
    "translate(" + (t15.x - t15.width / 2 - 5) + ", " + t15.width / 2 + ")"
  );
  const r = 8, n = t15.diff || 0;
  return t15.clusterNode ? e.attr(
    "transform",
    "translate(" + (t15.x + n - t15.width / 2) + ", " + (t15.y - t15.height / 2 - r) + ")"
  ) : e.attr("transform", "translate(" + t15.x + ", " + t15.y + ")"), n;
}, "positionNode");
var AK = _((t15, e, r, n, i, s) => {
  e.arrowTypeStart && W4(t15, "start", e.arrowTypeStart, r, n, i, s), e.arrowTypeEnd && W4(t15, "end", e.arrowTypeEnd, r, n, i, s);
}, "addEdgeMarkers");
var TK = {
  arrow_cross: { type: "cross", fill: false },
  arrow_point: { type: "point", fill: true },
  arrow_barb: { type: "barb", fill: true },
  arrow_circle: { type: "circle", fill: false },
  aggregation: { type: "aggregation", fill: false },
  extension: { type: "extension", fill: false },
  composition: { type: "composition", fill: true },
  dependency: { type: "dependency", fill: true },
  lollipop: { type: "lollipop", fill: false },
  only_one: { type: "onlyOne", fill: false },
  zero_or_one: { type: "zeroOrOne", fill: false },
  one_or_more: { type: "oneOrMore", fill: false },
  zero_or_more: { type: "zeroOrMore", fill: false },
  requirement_arrow: { type: "requirement_arrow", fill: false },
  requirement_contains: { type: "requirement_contains", fill: false }
};
var W4 = _((t15, e, r, n, i, s, a) => {
  var _a3;
  const o = TK[r];
  if (!o) {
    ut.warn(`Unknown arrow type: ${r}`);
    return;
  }
  const l = o.type, c = `${i}_${s}-${l}${e === "start" ? "Start" : "End"}`;
  if (a && a.trim() !== "") {
    const h = a.replace(/[^\dA-Za-z]/g, "_"), p = `${c}_${h}`;
    if (!document.getElementById(p)) {
      const m = document.getElementById(c);
      if (m) {
        const g = m.cloneNode(true);
        g.id = p, g.querySelectorAll("path, circle, line").forEach((y) => {
          y.setAttribute("stroke", a), o.fill && y.setAttribute("fill", a);
        }), (_a3 = m.parentNode) == null ? void 0 : _a3.appendChild(g);
      }
    }
    t15.attr(`marker-${e}`, `url(${n}#${p})`);
  } else
    t15.attr(`marker-${e}`, `url(${n}#${c})`);
}, "addEdgeMarker");
var V0 = /* @__PURE__ */ new Map();
var hr = /* @__PURE__ */ new Map();
var Trt = _(() => {
  V0.clear(), hr.clear();
}, "clear");
var Yo = _((t15) => t15 ? t15.reduce((e, r) => e + ";" + r, "") : "", "getLabelStyles");
var $K = _(async (t15, e) => {
  let r = Ke(fe().flowchart.htmlLabels);
  const n = await fs(t15, e.label, {
    style: Yo(e.labelStyle),
    useHtmlLabels: r,
    addSvgBackground: true,
    isNode: false
  });
  ut.info("abc82", e, e.labelType);
  const i = t15.insert("g").attr("class", "edgeLabel"), s = i.insert("g").attr("class", "label");
  s.node().appendChild(n);
  let a = n.getBBox();
  if (r) {
    const l = n.children[0], c = ae(n);
    a = l.getBoundingClientRect(), c.attr("width", a.width), c.attr("height", a.height);
  }
  s.attr("transform", "translate(" + -a.width / 2 + ", " + -a.height / 2 + ")"), V0.set(e.id, i), e.width = a.width, e.height = a.height;
  let o;
  if (e.startLabelLeft) {
    const l = await js(
      e.startLabelLeft,
      Yo(e.labelStyle)
    ), c = t15.insert("g").attr("class", "edgeTerminals"), h = c.insert("g").attr("class", "inner");
    o = h.node().appendChild(l);
    const p = l.getBBox();
    h.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), hr.get(e.id) || hr.set(e.id, {}), hr.get(e.id).startLeft = c, ul(o, e.startLabelLeft);
  }
  if (e.startLabelRight) {
    const l = await js(
      e.startLabelRight,
      Yo(e.labelStyle)
    ), c = t15.insert("g").attr("class", "edgeTerminals"), h = c.insert("g").attr("class", "inner");
    o = c.node().appendChild(l), h.node().appendChild(l);
    const p = l.getBBox();
    h.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), hr.get(e.id) || hr.set(e.id, {}), hr.get(e.id).startRight = c, ul(o, e.startLabelRight);
  }
  if (e.endLabelLeft) {
    const l = await js(e.endLabelLeft, Yo(e.labelStyle)), c = t15.insert("g").attr("class", "edgeTerminals"), h = c.insert("g").attr("class", "inner");
    o = h.node().appendChild(l);
    const p = l.getBBox();
    h.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), c.node().appendChild(l), hr.get(e.id) || hr.set(e.id, {}), hr.get(e.id).endLeft = c, ul(o, e.endLabelLeft);
  }
  if (e.endLabelRight) {
    const l = await js(e.endLabelRight, Yo(e.labelStyle)), c = t15.insert("g").attr("class", "edgeTerminals"), h = c.insert("g").attr("class", "inner");
    o = h.node().appendChild(l);
    const p = l.getBBox();
    h.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), c.node().appendChild(l), hr.get(e.id) || hr.set(e.id, {}), hr.get(e.id).endRight = c, ul(o, e.endLabelRight);
  }
  return n;
}, "insertEdgeLabel");
function ul(t15, e) {
  fe().flowchart.htmlLabels && t15 && (t15.style.width = e.length * 9 + "px", t15.style.height = "12px");
}
_(ul, "setTerminalWidth");
var EK = _((t15, e) => {
  ut.debug("Moving label abc88 ", t15.id, t15.label, V0.get(t15.id), e);
  let r = e.updatedPath ? e.updatedPath : e.originalPath;
  const n = fe(), { subGraphTitleTotalMargin: i } = Om(n);
  if (t15.label) {
    const s = V0.get(t15.id);
    let a = t15.x, o = t15.y;
    if (r) {
      const l = Wn.calcLabelPosition(r);
      ut.debug(
        "Moving label " + t15.label + " from (",
        a,
        ",",
        o,
        ") to (",
        l.x,
        ",",
        l.y,
        ") abc88"
      ), e.updatedPath && (a = l.x, o = l.y);
    }
    s.attr("transform", `translate(${a}, ${o + i / 2})`);
  }
  if (t15.startLabelLeft) {
    const s = hr.get(t15.id).startLeft;
    let a = t15.x, o = t15.y;
    if (r) {
      const l = Wn.calcTerminalLabelPosition(t15.arrowTypeStart ? 10 : 0, "start_left", r);
      a = l.x, o = l.y;
    }
    s.attr("transform", `translate(${a}, ${o})`);
  }
  if (t15.startLabelRight) {
    const s = hr.get(t15.id).startRight;
    let a = t15.x, o = t15.y;
    if (r) {
      const l = Wn.calcTerminalLabelPosition(
        t15.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      a = l.x, o = l.y;
    }
    s.attr("transform", `translate(${a}, ${o})`);
  }
  if (t15.endLabelLeft) {
    const s = hr.get(t15.id).endLeft;
    let a = t15.x, o = t15.y;
    if (r) {
      const l = Wn.calcTerminalLabelPosition(t15.arrowTypeEnd ? 10 : 0, "end_left", r);
      a = l.x, o = l.y;
    }
    s.attr("transform", `translate(${a}, ${o})`);
  }
  if (t15.endLabelRight) {
    const s = hr.get(t15.id).endRight;
    let a = t15.x, o = t15.y;
    if (r) {
      const l = Wn.calcTerminalLabelPosition(t15.arrowTypeEnd ? 10 : 0, "end_right", r);
      a = l.x, o = l.y;
    }
    s.attr("transform", `translate(${a}, ${o})`);
  }
}, "positionEdgeLabel");
var MK = _((t15, e) => {
  const r = t15.x, n = t15.y, i = Math.abs(e.x - r), s = Math.abs(e.y - n), a = t15.width / 2, o = t15.height / 2;
  return i >= a || s >= o;
}, "outsideNode");
var BK = _((t15, e, r) => {
  ut.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(e)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${t15.x} y:${t15.y} w:${t15.width} h:${t15.height}`);
  const n = t15.x, i = t15.y, s = Math.abs(n - r.x), a = t15.width / 2;
  let o = r.x < e.x ? a - s : a + s;
  const l = t15.height / 2, c = Math.abs(e.y - r.y), h = Math.abs(e.x - r.x);
  if (Math.abs(i - e.y) * a > Math.abs(n - e.x) * l) {
    let p = r.y < e.y ? e.y - l - i : i - l - e.y;
    o = h * p / c;
    const m = {
      x: r.x < e.x ? r.x + o : r.x - h + o,
      y: r.y < e.y ? r.y + c - p : r.y - c + p
    };
    return o === 0 && (m.x = e.x, m.y = e.y), h === 0 && (m.x = e.x), c === 0 && (m.y = e.y), ut.debug(`abc89 top/bottom calc, Q ${c}, q ${p}, R ${h}, r ${o}`, m), m;
  } else {
    r.x < e.x ? o = e.x - a - n : o = n - a - e.x;
    let p = c * o / h, m = r.x < e.x ? r.x + h - o : r.x - h + o, g = r.y < e.y ? r.y + p : r.y - p;
    return ut.debug(`sides calc abc89, Q ${c}, q ${p}, R ${h}, r ${o}`, { _x: m, _y: g }), o === 0 && (m = e.x, g = e.y), h === 0 && (m = e.x), c === 0 && (g = e.y), { x: m, y: g };
  }
}, "intersection");
var H4 = _((t15, e) => {
  ut.warn("abc88 cutPathAtIntersect", t15, e);
  let r = [], n = t15[0], i = false;
  return t15.forEach((s) => {
    if (ut.info("abc88 checking point", s, e), !MK(e, s) && !i) {
      const a = BK(e, n, s);
      ut.debug("abc88 inside", s, n, a), ut.debug("abc88 intersection", a, e);
      let o = false;
      r.forEach((l) => {
        o = o || l.x === a.x && l.y === a.y;
      }), r.some((l) => l.x === a.x && l.y === a.y) ? ut.warn("abc88 no intersect", a, r) : r.push(a), i = true;
    } else
      ut.warn("abc88 outside", s, n), n = s, i || r.push(s);
  }), ut.debug("returning points", r), r;
}, "cutPathAtIntersect");
function W8(t15) {
  const e = [], r = [];
  for (let n = 1; n < t15.length - 1; n++) {
    const i = t15[n - 1], s = t15[n], a = t15[n + 1];
    (i.x === s.x && s.y === a.y && Math.abs(s.x - a.x) > 5 && Math.abs(s.y - i.y) > 5 || i.y === s.y && s.x === a.x && Math.abs(s.x - i.x) > 5 && Math.abs(s.y - a.y) > 5) && (e.push(s), r.push(n));
  }
  return { cornerPoints: e, cornerPointPositions: r };
}
_(W8, "extractCornerPoints");
var U4 = _(function(t15, e, r) {
  const n = e.x - t15.x, i = e.y - t15.y, s = Math.sqrt(n * n + i * i), a = r / s;
  return { x: e.x - a * n, y: e.y - a * i };
}, "findAdjacentPoint");
var LK = _(function(t15) {
  const { cornerPointPositions: e } = W8(t15), r = [];
  for (let n = 0; n < t15.length; n++)
    if (e.includes(n)) {
      const i = t15[n - 1], s = t15[n + 1], a = t15[n], o = U4(i, a, 5), l = U4(s, a, 5), c = l.x - o.x, h = l.y - o.y;
      r.push(o);
      const p = Math.sqrt(2) * 2;
      let m = { x: a.x, y: a.y };
      if (Math.abs(s.x - i.x) > 10 && Math.abs(s.y - i.y) >= 10) {
        ut.debug(
          "Corner point fixing",
          Math.abs(s.x - i.x),
          Math.abs(s.y - i.y)
        );
        const g = 5;
        a.x === o.x ? m = {
          x: c < 0 ? o.x - g + p : o.x + g - p,
          y: h < 0 ? o.y - p : o.y + p
        } : m = {
          x: c < 0 ? o.x - p : o.x + p,
          y: h < 0 ? o.y - g + p : o.y + g - p
        };
      } else
        ut.debug(
          "Corner point skipping fixing",
          Math.abs(s.x - i.x),
          Math.abs(s.y - i.y)
        );
      r.push(m, l);
    } else
      r.push(t15[n]);
  return r;
}, "fixCorners");
var DK = _(function(t15, e, r, n, i, s, a) {
  var _a3;
  const { handDrawnSeed: o } = fe();
  let l = e.points, c = false;
  const h = i;
  var p = s;
  const m = [];
  for (const F in e.cssCompiledStyles)
    $7(F) || m.push(e.cssCompiledStyles[F]);
  p.intersect && h.intersect && (l = l.slice(1, e.points.length - 1), l.unshift(h.intersect(l[0])), ut.debug(
    "Last point APA12",
    e.start,
    "-->",
    e.end,
    l[l.length - 1],
    p,
    p.intersect(l[l.length - 1])
  ), l.push(p.intersect(l[l.length - 1]))), e.toCluster && (ut.info("to cluster abc88", r.get(e.toCluster)), l = H4(e.points, r.get(e.toCluster).node), c = true), e.fromCluster && (ut.debug(
    "from cluster abc88",
    r.get(e.fromCluster),
    JSON.stringify(l, null, 2)
  ), l = H4(l.reverse(), r.get(e.fromCluster).node).reverse(), c = true);
  let g = l.filter((F) => !Number.isNaN(F.y));
  g = LK(g);
  let y = Nh;
  switch (y = E0, e.curve) {
    case "linear":
      y = E0;
      break;
    case "basis":
      y = Nh;
      break;
    case "cardinal":
      y = hk;
      break;
    case "bumpX":
      y = sk;
      break;
    case "bumpY":
      y = ak;
      break;
    case "catmullRom":
      y = dk;
      break;
    case "monotoneX":
      y = bk;
      break;
    case "monotoneY":
      y = xk;
      break;
    case "natural":
      y = kk;
      break;
    case "step":
      y = vk;
      break;
    case "stepAfter":
      y = _k;
      break;
    case "stepBefore":
      y = Ck;
      break;
    default:
      y = Nh;
  }
  const { x, y: k } = rj(e), C = EU().x(x).y(k).curve(y);
  let A;
  switch (e.thickness) {
    case "normal":
      A = "edge-thickness-normal";
      break;
    case "thick":
      A = "edge-thickness-thick";
      break;
    case "invisible":
      A = "edge-thickness-invisible";
      break;
    default:
      A = "edge-thickness-normal";
  }
  switch (e.pattern) {
    case "solid":
      A += " edge-pattern-solid";
      break;
    case "dotted":
      A += " edge-pattern-dotted";
      break;
    case "dashed":
      A += " edge-pattern-dashed";
      break;
    default:
      A += " edge-pattern-solid";
  }
  let $, B = C(g);
  const L = Array.isArray(e.style) ? e.style : e.style ? [e.style] : [];
  let q = L.find((F) => F == null ? void 0 : F.startsWith("stroke:"));
  if (e.look === "handDrawn") {
    const F = Mt.svg(t15);
    Object.assign([], g);
    const W = F.path(B, {
      roughness: 0.3,
      seed: o
    });
    A += " transition", $ = ae(W).select("path").attr("id", e.id).attr("class", " " + A + (e.classes ? " " + e.classes : "")).attr("style", L ? L.reduce((Q, rt) => Q + ";" + rt, "") : "");
    let R = $.attr("d");
    $.attr("d", R), t15.node().appendChild($.node());
  } else {
    const F = m.join(";"), W = L ? L.reduce((rt, I) => rt + I + ";", "") : "";
    let R = "";
    e.animate && (R = " edge-animation-fast"), e.animation && (R = " edge-animation-" + e.animation);
    const Q = F ? F + ";" + W + ";" : W;
    $ = t15.append("path").attr("d", B).attr("id", e.id).attr(
      "class",
      " " + A + (e.classes ? " " + e.classes : "") + (R ?? "")
    ).attr("style", Q), q = (_a3 = Q.match(/stroke:([^;]+)/)) == null ? void 0 : _a3[1];
  }
  let U = "";
  (fe().flowchart.arrowMarkerAbsolute || fe().state.arrowMarkerAbsolute) && (U = H6(true)), ut.info("arrowTypeStart", e.arrowTypeStart), ut.info("arrowTypeEnd", e.arrowTypeEnd), AK($, e, U, a, n, q);
  let G = {};
  return c && (G.updatedPath = l), G.originalPath = e.points, G;
}, "insertEdge");
var FK = _((t15, e, r, n) => {
  e.forEach((i) => {
    KK[i](t15, r, n);
  });
}, "insertMarkers");
var NK = _((t15, e, r) => {
  ut.trace("Making markers for ", r), t15.append("defs").append("marker").attr("id", r + "_" + e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension");
var IK = _((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition");
var OK = _((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation");
var zK = _((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency");
var qK = _((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), t15.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopEnd").attr("class", "marker lollipop " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop");
var RK = _((t15, e, r) => {
  t15.append("marker").attr("id", r + "_" + e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t15.append("marker").attr("id", r + "_" + e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point");
var PK = _((t15, e, r) => {
  t15.append("marker").attr("id", r + "_" + e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t15.append("marker").attr("id", r + "_" + e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle");
var jK = _((t15, e, r) => {
  t15.append("marker").attr("id", r + "_" + e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t15.append("marker").attr("id", r + "_" + e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross");
var WK = _((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb");
var HK = _((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-onlyOneStart").attr("class", "marker onlyOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-onlyOneEnd").attr("class", "marker onlyOne " + e).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18");
}, "only_one");
var UK = _((t15, e, r) => {
  const n = t15.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  n.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), n.append("path").attr("d", "M9,0 L9,18");
  const i = t15.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + e).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), i.append("path").attr("d", "M21,0 L21,18");
}, "zero_or_one");
var VK = _((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-oneOrMoreStart").attr("class", "marker oneOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), t15.append("defs").append("marker").attr("id", r + "_" + e + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + e).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
}, "one_or_more");
var GK = _((t15, e, r) => {
  const n = t15.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  n.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), n.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
  const i = t15.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + e).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), i.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
}, "zero_or_more");
var XK = _((t15, e, r) => {
  t15.append("defs").append("marker").attr("id", r + "_" + e + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L20,10
      M20,10
      L0,20`
  );
}, "requirement_arrow");
var YK = _((t15, e, r) => {
  const n = t15.append("defs").append("marker").attr("id", r + "_" + e + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
  n.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none"), n.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10), n.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10);
}, "requirement_contains");
var KK = {
  extension: NK,
  composition: IK,
  aggregation: OK,
  dependency: zK,
  lollipop: qK,
  point: RK,
  circle: PK,
  cross: jK,
  barb: WK,
  only_one: HK,
  zero_or_one: UK,
  one_or_more: VK,
  zero_or_more: GK,
  requirement_arrow: XK,
  requirement_contains: YK
};
var ZK = FK;
var JK = {
  common: fo,
  getConfig: Hr,
  insertCluster: aK,
  insertEdge: DK,
  insertEdgeLabel: $K,
  insertMarkers: ZK,
  insertNode: j8,
  interpolateToCurve: tg,
  labelHelper: Vt,
  log: ut,
  positionEdgeLabel: EK
};
var Gl = {};
var H8 = _((t15) => {
  for (const e of t15)
    Gl[e.name] = e;
}, "registerLayoutLoaders");
var QK = _(() => {
  H8([
    {
      name: "dagre",
      loader: _(async () => await import("./dagre-JOIXM2OF-BDcDNPqP-izlDELjO-6Z267MOI.js"), "loader")
    }
  ]);
}, "registerDefaultLayoutLoaders");
QK();
var $rt = _(async (t15, e) => {
  if (!(t15.layoutAlgorithm in Gl))
    throw new Error(`Unknown layout algorithm: ${t15.layoutAlgorithm}`);
  const r = Gl[t15.layoutAlgorithm];
  return (await r.loader()).render(t15, e, JK, {
    algorithm: r.algorithm
  });
}, "render");
var Ert = _((t15 = "", { fallback: e = "dagre" } = {}) => {
  if (t15 in Gl)
    return t15;
  if (e in Gl)
    return ut.warn(`Layout algorithm ${t15} is not registered. Using ${e} as fallback.`), e;
  throw new Error(`Both layout algorithms ${t15} and ${e} are not registered.`);
}, "getRegisteredLayoutAlgorithm");
var V4 = {
  name: "mermaid",
  version: "11.9.0",
  description: "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
  type: "module",
  module: "./dist/mermaid.core.mjs",
  types: "./dist/mermaid.d.ts",
  exports: {
    ".": {
      types: "./dist/mermaid.d.ts",
      import: "./dist/mermaid.core.mjs",
      default: "./dist/mermaid.core.mjs"
    },
    "./*": "./*"
  },
  keywords: [
    "diagram",
    "markdown",
    "flowchart",
    "sequence diagram",
    "gantt",
    "class diagram",
    "git graph",
    "mindmap",
    "packet diagram",
    "c4 diagram",
    "er diagram",
    "pie chart",
    "pie diagram",
    "quadrant chart",
    "requirement diagram",
    "graph"
  ],
  scripts: {
    clean: "rimraf dist",
    dev: "pnpm -w dev",
    "docs:code": "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
    "docs:build": "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
    "docs:verify": "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
    "docs:pre:vitepress": "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
    "docs:build:vitepress": "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
    "docs:dev": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:dev:docker": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:serve": "pnpm docs:build:vitepress && vitepress serve src/vitepress",
    "docs:spellcheck": 'cspell "src/docs/**/*.md"',
    "docs:release-version": "tsx scripts/update-release-version.mts",
    "docs:verify-version": "tsx scripts/update-release-version.mts --verify",
    "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
    "types:verify-config": "tsx scripts/create-types-from-json-schema.mts --verify",
    checkCircle: "npx madge --circular ./src",
    prepublishOnly: "pnpm docs:verify-version"
  },
  repository: {
    type: "git",
    url: "https://github.com/mermaid-js/mermaid"
  },
  author: "Knut Sveidqvist",
  license: "MIT",
  standard: {
    ignore: [
      "**/parser/*.js",
      "dist/**/*.js",
      "cypress/**/*.js"
    ],
    globals: [
      "page"
    ]
  },
  dependencies: {
    "@braintree/sanitize-url": "^7.0.4",
    "@iconify/utils": "^2.1.33",
    "@mermaid-js/parser": "workspace:^",
    "@types/d3": "^7.4.3",
    cytoscape: "^3.29.3",
    "cytoscape-cose-bilkent": "^4.1.0",
    "cytoscape-fcose": "^2.2.0",
    d3: "^7.9.0",
    "d3-sankey": "^0.12.3",
    "dagre-d3-es": "7.0.11",
    dayjs: "^1.11.13",
    dompurify: "^3.2.5",
    katex: "^0.16.22",
    khroma: "^2.1.0",
    "lodash-es": "^4.17.21",
    marked: "^16.0.0",
    roughjs: "^4.6.6",
    stylis: "^4.3.6",
    "ts-dedent": "^2.2.0",
    uuid: "^11.1.0"
  },
  devDependencies: {
    "@adobe/jsonschema2md": "^8.0.2",
    "@iconify/types": "^2.0.0",
    "@types/cytoscape": "^3.21.9",
    "@types/cytoscape-fcose": "^2.2.4",
    "@types/d3-sankey": "^0.12.4",
    "@types/d3-scale": "^4.0.9",
    "@types/d3-scale-chromatic": "^3.1.0",
    "@types/d3-selection": "^3.0.11",
    "@types/d3-shape": "^3.1.7",
    "@types/jsdom": "^21.1.7",
    "@types/katex": "^0.16.7",
    "@types/lodash-es": "^4.17.12",
    "@types/micromatch": "^4.0.9",
    "@types/stylis": "^4.2.7",
    "@types/uuid": "^10.0.0",
    ajv: "^8.17.1",
    canvas: "^3.1.0",
    chokidar: "3.6.0",
    concurrently: "^9.1.2",
    "csstree-validator": "^4.0.1",
    globby: "^14.0.2",
    jison: "^0.4.18",
    "js-base64": "^3.7.7",
    jsdom: "^26.1.0",
    "json-schema-to-typescript": "^15.0.4",
    micromatch: "^4.0.8",
    "path-browserify": "^1.0.1",
    prettier: "^3.5.2",
    remark: "^15.0.1",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    rimraf: "^6.0.1",
    "start-server-and-test": "^2.0.10",
    "type-fest": "^4.35.0",
    typedoc: "^0.27.8",
    "typedoc-plugin-markdown": "^4.4.2",
    typescript: "~5.7.3",
    "unist-util-flatmap": "^1.0.0",
    "unist-util-visit": "^5.0.0",
    vitepress: "^1.0.2",
    "vitepress-plugin-search": "1.0.4-alpha.22"
  },
  files: [
    "dist/",
    "README.md"
  ],
  publishConfig: {
    access: "public"
  }
};
var tZ = _((t15) => {
  var _a3;
  const { securityLevel: e } = fe();
  let r = ae("body");
  if (e === "sandbox") {
    const n = ((_a3 = ae(`#i${t15}`).node()) == null ? void 0 : _a3.contentDocument) ?? document;
    r = ae(n.body);
  }
  return r.select(`#${t15}`);
}, "selectSvgElement");
var U8 = "comm";
var V8 = "rule";
var G8 = "decl";
var eZ = "@import";
var rZ = "@namespace";
var nZ = "@keyframes";
var iZ = "@layer";
var X8 = Math.abs;
var wg = String.fromCharCode;
function Y8(t15) {
  return t15.trim();
}
function qh(t15, e, r) {
  return t15.replace(e, r);
}
function sZ(t15, e, r) {
  return t15.indexOf(e, r);
}
function qa(t15, e) {
  return t15.charCodeAt(e) | 0;
}
function no(t15, e, r) {
  return t15.slice(e, r);
}
function zn(t15) {
  return t15.length;
}
function aZ(t15) {
  return t15.length;
}
function ph(t15, e) {
  return e.push(t15), t15;
}
var ju = 1;
var io = 1;
var K8 = 0;
var bn = 0;
var Ue = 0;
var xo = "";
function kg(t15, e, r, n, i, s, a, o) {
  return { value: t15, root: e, parent: r, type: n, props: i, children: s, line: ju, column: io, length: a, return: "", siblings: o };
}
function oZ() {
  return Ue;
}
function lZ() {
  return Ue = bn > 0 ? qa(xo, --bn) : 0, io--, Ue === 10 && (io = 1, ju--), Ue;
}
function Sn() {
  return Ue = bn < K8 ? qa(xo, bn++) : 0, io++, Ue === 10 && (io = 1, ju++), Ue;
}
function rs() {
  return qa(xo, bn);
}
function Rh() {
  return bn;
}
function Wu(t15, e) {
  return no(xo, t15, e);
}
function Xl(t15) {
  switch (t15) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function cZ(t15) {
  return ju = io = 1, K8 = zn(xo = t15), bn = 0, [];
}
function hZ(t15) {
  return xo = "", t15;
}
function Dp(t15) {
  return Y8(Wu(bn - 1, d1(t15 === 91 ? t15 + 2 : t15 === 40 ? t15 + 1 : t15)));
}
function uZ(t15) {
  for (; (Ue = rs()) && Ue < 33; )
    Sn();
  return Xl(t15) > 2 || Xl(Ue) > 3 ? "" : " ";
}
function dZ(t15, e) {
  for (; --e && Sn() && !(Ue < 48 || Ue > 102 || Ue > 57 && Ue < 65 || Ue > 70 && Ue < 97); )
    ;
  return Wu(t15, Rh() + (e < 6 && rs() == 32 && Sn() == 32));
}
function d1(t15) {
  for (; Sn(); )
    switch (Ue) {
      case t15:
        return bn;
      case 34:
      case 39:
        t15 !== 34 && t15 !== 39 && d1(Ue);
        break;
      case 40:
        t15 === 41 && d1(t15);
        break;
      case 92:
        Sn();
        break;
    }
  return bn;
}
function pZ(t15, e) {
  for (; Sn() && t15 + Ue !== 57 && !(t15 + Ue === 84 && rs() === 47); )
    ;
  return "/*" + Wu(e, bn - 1) + "*" + wg(t15 === 47 ? t15 : Sn());
}
function fZ(t15) {
  for (; !Xl(rs()); )
    Sn();
  return Wu(t15, bn);
}
function mZ(t15) {
  return hZ(Ph("", null, null, null, [""], t15 = cZ(t15), 0, [0], t15));
}
function Ph(t15, e, r, n, i, s, a, o, l) {
  for (var c = 0, h = 0, p = a, m = 0, g = 0, y = 0, x = 1, k = 1, C = 1, A = 0, $ = "", B = i, L = s, q = n, U = $; k; )
    switch (y = A, A = Sn()) {
      case 40:
        if (y != 108 && qa(U, p - 1) == 58) {
          sZ(U += qh(Dp(A), "&", "&\f"), "&\f", X8(c ? o[c - 1] : 0)) != -1 && (C = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        U += Dp(A);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        U += uZ(y);
        break;
      case 92:
        U += dZ(Rh() - 1, 7);
        continue;
      case 47:
        switch (rs()) {
          case 42:
          case 47:
            ph(gZ(pZ(Sn(), Rh()), e, r, l), l), (Xl(y || 1) == 5 || Xl(rs() || 1) == 5) && zn(U) && no(U, -1, void 0) !== " " && (U += " ");
            break;
          default:
            U += "/";
        }
        break;
      case 123 * x:
        o[c++] = zn(U) * C;
      case 125 * x:
      case 59:
      case 0:
        switch (A) {
          case 0:
          case 125:
            k = 0;
          case 59 + h:
            C == -1 && (U = qh(U, /\f/g, "")), g > 0 && (zn(U) - p || x === 0 && y === 47) && ph(g > 32 ? X4(U + ";", n, r, p - 1, l) : X4(qh(U, " ", "") + ";", n, r, p - 2, l), l);
            break;
          case 59:
            U += ";";
          default:
            if (ph(q = G4(U, e, r, c, h, i, o, $, B = [], L = [], p, s), s), A === 123)
              if (h === 0)
                Ph(U, e, q, q, B, s, p, o, L);
              else {
                switch (m) {
                  case 99:
                    if (qa(U, 3) === 110) break;
                  case 108:
                    if (qa(U, 2) === 97) break;
                  default:
                    h = 0;
                  case 100:
                  case 109:
                  case 115:
                }
                h ? Ph(t15, q, q, n && ph(G4(t15, q, q, 0, 0, i, o, $, i, B = [], p, L), L), i, L, p, o, n ? B : L) : Ph(U, q, q, q, [""], L, 0, o, L);
              }
        }
        c = h = g = 0, x = C = 1, $ = U = "", p = a;
        break;
      case 58:
        p = 1 + zn(U), g = y;
      default:
        if (x < 1) {
          if (A == 123)
            --x;
          else if (A == 125 && x++ == 0 && lZ() == 125)
            continue;
        }
        switch (U += wg(A), A * x) {
          case 38:
            C = h > 0 ? 1 : (U += "\f", -1);
            break;
          case 44:
            o[c++] = (zn(U) - 1) * C, C = 1;
            break;
          case 64:
            rs() === 45 && (U += Dp(Sn())), m = rs(), h = p = zn($ = U += fZ(Rh())), A++;
            break;
          case 45:
            y === 45 && zn(U) == 2 && (x = 0);
        }
    }
  return s;
}
function G4(t15, e, r, n, i, s, a, o, l, c, h, p) {
  for (var m = i - 1, g = i === 0 ? s : [""], y = aZ(g), x = 0, k = 0, C = 0; x < n; ++x)
    for (var A = 0, $ = no(t15, m + 1, m = X8(k = a[x])), B = t15; A < y; ++A)
      (B = Y8(k > 0 ? g[A] + " " + $ : qh($, /&\f/g, g[A]))) && (l[C++] = B);
  return kg(t15, e, r, i === 0 ? V8 : o, l, c, h, p);
}
function gZ(t15, e, r, n) {
  return kg(t15, e, r, U8, wg(oZ()), no(t15, 2, -2), 0, n);
}
function X4(t15, e, r, n, i) {
  return kg(t15, e, r, G8, no(t15, 0, n), no(t15, n + 1, -1), n, i);
}
function p1(t15, e) {
  for (var r = "", n = 0; n < t15.length; n++)
    r += e(t15[n], n, t15, e) || "";
  return r;
}
function yZ(t15, e, r, n) {
  switch (t15.type) {
    case iZ:
      if (t15.children.length) break;
    case eZ:
    case rZ:
    case G8:
      return t15.return = t15.return || t15.value;
    case U8:
      return "";
    case nZ:
      return t15.return = t15.value + "{" + p1(t15.children, n) + "}";
    case V8:
      if (!zn(t15.value = t15.props.join(","))) return "";
  }
  return zn(r = p1(t15.children, n)) ? t15.return = t15.value + "{" + r + "}" : "";
}
var bZ = $k(Object.keys, Object);
var xZ = Object.prototype;
var wZ = xZ.hasOwnProperty;
function kZ(t15) {
  if (!Du(t15))
    return bZ(t15);
  var e = [];
  for (var r in Object(t15))
    wZ.call(t15, r) && r != "constructor" && e.push(r);
  return e;
}
var f1 = la(ri, "DataView");
var m1 = la(ri, "Promise");
var g1 = la(ri, "Set");
var y1 = la(ri, "WeakMap");
var Y4 = "[object Map]";
var vZ = "[object Object]";
var K4 = "[object Promise]";
var Z4 = "[object Set]";
var J4 = "[object WeakMap]";
var Q4 = "[object DataView]";
var CZ = oa(f1);
var _Z = oa(Vl);
var SZ = oa(m1);
var AZ = oa(g1);
var TZ = oa(y1);
var Ds = go;
(f1 && Ds(new f1(new ArrayBuffer(1))) != Q4 || Vl && Ds(new Vl()) != Y4 || m1 && Ds(m1.resolve()) != K4 || g1 && Ds(new g1()) != Z4 || y1 && Ds(new y1()) != J4) && (Ds = function(t15) {
  var e = go(t15), r = e == vZ ? t15.constructor : void 0, n = r ? oa(r) : "";
  if (n)
    switch (n) {
      case CZ:
        return Q4;
      case _Z:
        return Y4;
      case SZ:
        return K4;
      case AZ:
        return Z4;
      case TZ:
        return J4;
    }
  return e;
});
var $Z = "[object Map]";
var EZ = "[object Set]";
var MZ = Object.prototype;
var BZ = MZ.hasOwnProperty;
function t52(t15) {
  if (t15 == null)
    return true;
  if (Fu(t15) && (I0(t15) || typeof t15 == "string" || typeof t15.splice == "function" || Jm(t15) || Qm(t15) || N0(t15)))
    return !t15.length;
  var e = Ds(t15);
  if (e == $Z || e == EZ)
    return !t15.size;
  if (Du(t15))
    return !kZ(t15).length;
  for (var r in t15)
    if (BZ.call(t15, r))
      return false;
  return true;
}
var Z8 = "c4";
var LZ = _((t15) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(t15), "detector");
var DZ = _(async () => {
  const { diagram: t15 } = await import("./c4Diagram-6F6E4RAY-CA6nILOZ-3MiejLXJ-4NPUN46C.js");
  return { id: Z8, diagram: t15 };
}, "loader");
var FZ = {
  id: Z8,
  detector: LZ,
  loader: DZ
};
var NZ = FZ;
var J8 = "flowchart";
var IZ = _((t15, e) => {
  var _a3, _b2;
  return ((_a3 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a3.defaultRenderer) === "dagre-wrapper" || ((_b2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _b2.defaultRenderer) === "elk" ? false : /^\s*graph/.test(t15);
}, "detector");
var OZ = _(async () => {
  const { diagram: t15 } = await import("./flowDiagram-KYDEHFYC-DpS-glZz-DBnfZMyX-U2QAYT5R.js");
  return { id: J8, diagram: t15 };
}, "loader");
var zZ = {
  id: J8,
  detector: IZ,
  loader: OZ
};
var qZ = zZ;
var Q8 = "flowchart-v2";
var RZ = _((t15, e) => {
  var _a3, _b2, _c;
  return ((_a3 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a3.defaultRenderer) === "dagre-d3" ? false : (((_b2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _b2.defaultRenderer) === "elk" && (e.layout = "elk"), /^\s*graph/.test(t15) && ((_c = e == null ? void 0 : e.flowchart) == null ? void 0 : _c.defaultRenderer) === "dagre-wrapper" ? true : /^\s*flowchart/.test(t15));
}, "detector");
var PZ = _(async () => {
  const { diagram: t15 } = await import("./flowDiagram-KYDEHFYC-DpS-glZz-DBnfZMyX-U2QAYT5R.js");
  return { id: Q8, diagram: t15 };
}, "loader");
var jZ = {
  id: Q8,
  detector: RZ,
  loader: PZ
};
var WZ = jZ;
var t92 = "er";
var HZ = _((t15) => /^\s*erDiagram/.test(t15), "detector");
var UZ = _(async () => {
  const { diagram: t15 } = await import("./erDiagram-3M52JZNH-5IK6PHHM-DBx0ALIu-YMQWHLZH.js");
  return { id: t92, diagram: t15 };
}, "loader");
var VZ = {
  id: t92,
  detector: HZ,
  loader: UZ
};
var GZ = VZ;
var e9 = "gitGraph";
var XZ = _((t15) => /^\s*gitGraph/.test(t15), "detector");
var YZ = _(async () => {
  const { diagram: t15 } = await import("./gitGraphDiagram-GW3U2K7C-ajdBRxVY-Bll3hvRc-T3WGL5JZ.js");
  return { id: e9, diagram: t15 };
}, "loader");
var KZ = {
  id: e9,
  detector: XZ,
  loader: YZ
};
var ZZ = KZ;
var r9 = "gantt";
var JZ = _((t15) => /^\s*gantt/.test(t15), "detector");
var QZ = _(async () => {
  const { diagram: t15 } = await import("./ganttDiagram-EK5VF46D-CS0VRiw3-CDoTWFLZ-XWFEFSJV.js");
  return { id: r9, diagram: t15 };
}, "loader");
var tJ = {
  id: r9,
  detector: JZ,
  loader: QZ
};
var eJ = tJ;
var n9 = "info";
var rJ = _((t15) => /^\s*info/.test(t15), "detector");
var nJ = _(async () => {
  const { diagram: t15 } = await import("./infoDiagram-LHK5PUON-DOTUJ3NR-BKgVxJ4O-2LSHRAR7.js");
  return { id: n9, diagram: t15 };
}, "loader");
var iJ = {
  id: n9,
  detector: rJ,
  loader: nJ
};
var i9 = "pie";
var sJ = _((t15) => /^\s*pie/.test(t15), "detector");
var aJ = _(async () => {
  const { diagram: t15 } = await import("./pieDiagram-NIOCPIFQ-BXQPy3iQ-BjRivpuL-W2KPMLSG.js");
  return { id: i9, diagram: t15 };
}, "loader");
var oJ = {
  id: i9,
  detector: sJ,
  loader: aJ
};
var s9 = "quadrantChart";
var lJ = _((t15) => /^\s*quadrantChart/.test(t15), "detector");
var cJ = _(async () => {
  const { diagram: t15 } = await import("./quadrantDiagram-2OG54O6I-DOVf2JC2-B29GoNOT-IPA6KGBD.js");
  return { id: s9, diagram: t15 };
}, "loader");
var hJ = {
  id: s9,
  detector: lJ,
  loader: cJ
};
var uJ = hJ;
var a9 = "xychart";
var dJ = _((t15) => /^\s*xychart-beta/.test(t15), "detector");
var pJ = _(async () => {
  const { diagram: t15 } = await import("./xychartDiagram-H2YORKM3-Cw4T3dzy-ndkPiqGB-M63GDMAV.js");
  return { id: a9, diagram: t15 };
}, "loader");
var fJ = {
  id: a9,
  detector: dJ,
  loader: pJ
};
var mJ = fJ;
var o9 = "requirement";
var gJ = _((t15) => /^\s*requirement(Diagram)?/.test(t15), "detector");
var yJ = _(async () => {
  const { diagram: t15 } = await import("./requirementDiagram-QOLK2EJ7-KcolRPGR-Jgn6f_6f-O35NZBKH.js");
  return { id: o9, diagram: t15 };
}, "loader");
var bJ = {
  id: o9,
  detector: gJ,
  loader: yJ
};
var xJ = bJ;
var l9 = "sequence";
var wJ = _((t15) => /^\s*sequenceDiagram/.test(t15), "detector");
var kJ = _(async () => {
  const { diagram: t15 } = await import("./sequenceDiagram-SKLFT4DO-DrtFnZAE-CEA9RDjm-VDC4B6DV.js");
  return { id: l9, diagram: t15 };
}, "loader");
var vJ = {
  id: l9,
  detector: wJ,
  loader: kJ
};
var CJ = vJ;
var c9 = "class";
var _J = _((t15, e) => {
  var _a3;
  return ((_a3 = e == null ? void 0 : e.class) == null ? void 0 : _a3.defaultRenderer) === "dagre-wrapper" ? false : /^\s*classDiagram/.test(t15);
}, "detector");
var SJ = _(async () => {
  const { diagram: t15 } = await import("./classDiagram-M3E45YP4-wmmfWv7q-DlNs-aPJ-7X36HNKS.js");
  return { id: c9, diagram: t15 };
}, "loader");
var AJ = {
  id: c9,
  detector: _J,
  loader: SJ
};
var TJ = AJ;
var h9 = "classDiagram";
var $J = _((t15, e) => {
  var _a3;
  return /^\s*classDiagram/.test(t15) && ((_a3 = e == null ? void 0 : e.class) == null ? void 0 : _a3.defaultRenderer) === "dagre-wrapper" ? true : /^\s*classDiagram-v2/.test(t15);
}, "detector");
var EJ = _(async () => {
  const { diagram: t15 } = await import("./classDiagram-v2-YAWTLIQI-wmmfWv7q-DlNs-aPJ-T7TC3NYR.js");
  return { id: h9, diagram: t15 };
}, "loader");
var MJ = {
  id: h9,
  detector: $J,
  loader: EJ
};
var BJ = MJ;
var u9 = "state";
var LJ = _((t15, e) => {
  var _a3;
  return ((_a3 = e == null ? void 0 : e.state) == null ? void 0 : _a3.defaultRenderer) === "dagre-wrapper" ? false : /^\s*stateDiagram/.test(t15);
}, "detector");
var DJ = _(async () => {
  const { diagram: t15 } = await import("./stateDiagram-MI5ZYTHO-BmHy1ClI-BCeLQPJB-JQEFCL5D.js");
  return { id: u9, diagram: t15 };
}, "loader");
var FJ = {
  id: u9,
  detector: LJ,
  loader: DJ
};
var NJ = FJ;
var d9 = "stateDiagram";
var IJ = _((t15, e) => {
  var _a3;
  return !!(/^\s*stateDiagram-v2/.test(t15) || /^\s*stateDiagram/.test(t15) && ((_a3 = e == null ? void 0 : e.state) == null ? void 0 : _a3.defaultRenderer) === "dagre-wrapper");
}, "detector");
var OJ = _(async () => {
  const { diagram: t15 } = await import("./stateDiagram-v2-5AN5P6BG-CXkji7Qq-BGk8_8Pf-SCIZBFCG.js");
  return { id: d9, diagram: t15 };
}, "loader");
var zJ = {
  id: d9,
  detector: IJ,
  loader: OJ
};
var qJ = zJ;
var p9 = "journey";
var RJ = _((t15) => /^\s*journey/.test(t15), "detector");
var PJ = _(async () => {
  const { diagram: t15 } = await import("./journeyDiagram-EWQZEKCU-DeLud0ov-BwvsCH-6-EUO3RQKW.js");
  return { id: p9, diagram: t15 };
}, "loader");
var jJ = {
  id: p9,
  detector: RJ,
  loader: PJ
};
var WJ = jJ;
var HJ = _((t15, e, r) => {
  ut.debug(`rendering svg for syntax error
`);
  const n = tZ(e), i = n.append("g");
  n.attr("viewBox", "0 0 2412 512"), U6(n, 100, 512, true), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
  ), i.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text"), i.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${r}`);
}, "draw");
var f9 = { draw: HJ };
var UJ = f9;
var VJ = {
  db: {},
  renderer: f9,
  parser: {
    parse: _(() => {
    }, "parse")
  }
};
var GJ = VJ;
var m9 = "flowchart-elk";
var XJ = _((t15, e = {}) => {
  var _a3;
  return (
    // If diagram explicitly states flowchart-elk
    /^\s*flowchart-elk/.test(t15) || // If a flowchart/graph diagram has their default renderer set to elk
    /^\s*flowchart|graph/.test(t15) && ((_a3 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a3.defaultRenderer) === "elk" ? (e.layout = "elk", true) : false
  );
}, "detector");
var YJ = _(async () => {
  const { diagram: t15 } = await import("./flowDiagram-KYDEHFYC-DpS-glZz-DBnfZMyX-U2QAYT5R.js");
  return { id: m9, diagram: t15 };
}, "loader");
var KJ = {
  id: m9,
  detector: XJ,
  loader: YJ
};
var ZJ = KJ;
var g9 = "timeline";
var JJ = _((t15) => /^\s*timeline/.test(t15), "detector");
var QJ = _(async () => {
  const { diagram: t15 } = await import("./timeline-definition-MYPXXCX6-DT8Gva88-7JZvkkhh-VK4FJEYN.js");
  return { id: g9, diagram: t15 };
}, "loader");
var tQ = {
  id: g9,
  detector: JJ,
  loader: QJ
};
var eQ = tQ;
var y9 = "mindmap";
var rQ = _((t15) => /^\s*mindmap/.test(t15), "detector");
var nQ = _(async () => {
  const { diagram: t15 } = await import("./mindmap-definition-6CBA2TL7-B8qFDYAN-CBG1vRNQ-TGN5Z7UY.js");
  return { id: y9, diagram: t15 };
}, "loader");
var iQ = {
  id: y9,
  detector: rQ,
  loader: nQ
};
var sQ = iQ;
var b9 = "kanban";
var aQ = _((t15) => /^\s*kanban/.test(t15), "detector");
var oQ = _(async () => {
  const { diagram: t15 } = await import("./kanban-definition-ZSS6B67P-B4ltCpQu-N7RlWHCM-K7MZM3IG.js");
  return { id: b9, diagram: t15 };
}, "loader");
var lQ = {
  id: b9,
  detector: aQ,
  loader: oQ
};
var cQ = lQ;
var x9 = "sankey";
var hQ = _((t15) => /^\s*sankey-beta/.test(t15), "detector");
var uQ = _(async () => {
  const { diagram: t15 } = await import("./sankeyDiagram-4UZDY2LN-DM2nzfvj-qWvVsSjs-LQUPVTWI.js");
  return { id: x9, diagram: t15 };
}, "loader");
var dQ = {
  id: x9,
  detector: hQ,
  loader: uQ
};
var pQ = dQ;
var w9 = "packet";
var fQ = _((t15) => /^\s*packet(-beta)?/.test(t15), "detector");
var mQ = _(async () => {
  const { diagram: t15 } = await import("./diagram-5UYTHUR4-DvP-66K_-BFEncZsD-PV7EQYUP.js");
  return { id: w9, diagram: t15 };
}, "loader");
var gQ = {
  id: w9,
  detector: fQ,
  loader: mQ
};
var k9 = "radar";
var yQ = _((t15) => /^\s*radar-beta/.test(t15), "detector");
var bQ = _(async () => {
  const { diagram: t15 } = await import("./diagram-ZTM2IBQH-C65UJ2WF-B2dqmVfy-C7ZVUMYP.js");
  return { id: k9, diagram: t15 };
}, "loader");
var xQ = {
  id: k9,
  detector: yQ,
  loader: bQ
};
var v9 = "block";
var wQ = _((t15) => /^\s*block-beta/.test(t15), "detector");
var kQ = _(async () => {
  const { diagram: t15 } = await import("./blockDiagram-6J76NXCF-BJB2lu6M-BZBzvUHw-YRU55WAR.js");
  return { id: v9, diagram: t15 };
}, "loader");
var vQ = {
  id: v9,
  detector: wQ,
  loader: kQ
};
var CQ = vQ;
var C9 = "architecture";
var _Q = _((t15) => /^\s*architecture/.test(t15), "detector");
var SQ = _(async () => {
  const { diagram: t15 } = await import("./architectureDiagram-SUXI7LT5-B0Jea6mg-DXIqLVDk-ZUI3LSGB.js");
  return { id: C9, diagram: t15 };
}, "loader");
var AQ = {
  id: C9,
  detector: _Q,
  loader: SQ
};
var TQ = AQ;
var _9 = "treemap";
var $Q = _((t15) => /^\s*treemap/.test(t15), "detector");
var EQ = _(async () => {
  const { diagram: t15 } = await import("./diagram-VMROVX33-fUguy4jx-D_cWkY9d-VFGZ5QQS.js");
  return { id: _9, diagram: t15 };
}, "loader");
var MQ = {
  id: _9,
  detector: $Q,
  loader: EQ
};
var e5 = false;
var Hu = _(() => {
  e5 || (e5 = true, g0("error", GJ, (t15) => t15.toLowerCase().trim() === "error"), g0(
    "---",
    // --- diagram type may appear if YAML front-matter is not parsed correctly
    {
      db: {
        clear: _(() => {
        }, "clear")
      },
      styles: {},
      // should never be used
      renderer: {
        draw: _(() => {
        }, "draw")
      },
      parser: {
        parse: _(() => {
          throw new Error(
            "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks"
          );
        }, "parse")
      },
      init: _(() => null, "init")
      // no op
    },
    (t15) => t15.toLowerCase().trimStart().startsWith("---")
  ), Af(ZJ, sQ, TQ), Af(
    NZ,
    cQ,
    BJ,
    TJ,
    GZ,
    eJ,
    iJ,
    oJ,
    xJ,
    CJ,
    WZ,
    qZ,
    eQ,
    ZZ,
    qJ,
    NJ,
    WJ,
    uJ,
    pQ,
    gQ,
    mJ,
    CQ,
    xQ,
    MQ
  ));
}, "addDiagrams");
var BQ = _(async () => {
  ut.debug("Loading registered diagrams");
  const t15 = (await Promise.allSettled(
    Object.entries(Ks).map(async ([e, { detector: r, loader: n }]) => {
      if (n)
        try {
          Mf(e);
        } catch {
          try {
            const { diagram: i, id: s } = await n();
            g0(s, i, r);
          } catch (i) {
            throw ut.error(`Failed to load external diagram with key ${e}. Removing from detectors.`), delete Ks[e], i;
          }
        }
    })
  )).filter((e) => e.status === "rejected");
  if (t15.length > 0) {
    ut.error(`Failed to load ${t15.length} external diagrams`);
    for (const e of t15)
      ut.error(e);
    throw new Error(`Failed to load ${t15.length} external diagrams`);
  }
}, "loadRegisteredDiagrams");
var LQ = "graphics-document document";
function S9(t15, e) {
  t15.attr("role", LQ), e !== "" && t15.attr("aria-roledescription", e);
}
_(S9, "setA11yDiagramInfo");
function A9(t15, e, r, n) {
  if (t15.insert !== void 0) {
    if (r) {
      const i = `chart-desc-${n}`;
      t15.attr("aria-describedby", i), t15.insert("desc", ":first-child").attr("id", i).text(r);
    }
    if (e) {
      const i = `chart-title-${n}`;
      t15.attr("aria-labelledby", i), t15.insert("title", ":first-child").attr("id", i).text(e);
    }
  }
}
_(A9, "addSVGa11yTitleDescription");
var fh;
var b1 = (fh = class {
  constructor(t15, e, r, n, i) {
    this.type = t15, this.text = e, this.db = r, this.parser = n, this.renderer = i;
  }
  static async fromText(t15, e = {}) {
    var _a3, _b2;
    const r = Hr(), n = _m(t15, r);
    t15 = EX(t15) + `
`;
    try {
      Mf(n);
    } catch {
      const l = nR(n);
      if (!l)
        throw new B6(`Diagram ${n} not found.`);
      const { id: c, diagram: h } = await l();
      g0(c, h);
    }
    const { db: i, parser: s, renderer: a, init: o } = Mf(n);
    return s.parser && (s.parser.yy = i), (_a3 = i.clear) == null ? void 0 : _a3.call(i), o == null ? void 0 : o(r), e.title && ((_b2 = i.setDiagramTitle) == null ? void 0 : _b2.call(i, e.title)), await s.parse(t15), new fh(n, t15, i, s, a);
  }
  async render(t15, e) {
    await this.renderer.draw(this.text, t15, e, this);
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}, _(fh, "Diagram"), fh);
var r5 = [];
var DQ = _(() => {
  r5.forEach((t15) => {
    t15();
  }), r5 = [];
}, "attachFunctions");
var FQ = _((t15) => t15.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(), "cleanupComments");
function T9(t15) {
  const e = t15.match(M6);
  if (!e)
    return {
      text: t15,
      metadata: {}
    };
  let r = ej(e[1], {
    // To support config, we need JSON schema.
    // https://www.yaml.org/spec/1.2/spec.html#id2803231
    schema: tj
  }) ?? {};
  r = typeof r == "object" && !Array.isArray(r) ? r : {};
  const n = {};
  return r.displayMode && (n.displayMode = r.displayMode.toString()), r.title && (n.title = r.title.toString()), r.config && (n.config = r.config), {
    text: t15.slice(e[0].length),
    metadata: n
  };
}
_(T9, "extractFrontMatter");
var NQ = _((t15) => t15.replace(/\r\n?/g, `
`).replace(
  /<(\w+)([^>]*)>/g,
  (e, r, n) => "<" + r + n.replace(/="([^"]*)"/g, "='$1'") + ">"
), "cleanupText");
var IQ = _((t15) => {
  const { text: e, metadata: r } = T9(t15), { displayMode: n, title: i, config: s = {} } = r;
  return n && (s.gantt || (s.gantt = {}), s.gantt.displayMode = n), { title: i, config: s, text: e };
}, "processFrontmatter");
var OQ = _((t15) => {
  const e = Wn.detectInit(t15) ?? {}, r = Wn.detectDirective(t15, "wrap");
  return Array.isArray(r) ? e.wrap = r.some(({ type: n }) => n === "wrap") : (r == null ? void 0 : r.type) === "wrap" && (e.wrap = true), {
    text: gX(t15),
    directive: e
  };
}, "processDirectives");
function vg(t15) {
  const e = NQ(t15), r = IQ(e), n = OQ(r.text), i = sg(r.config, n.directive);
  return t15 = FQ(n.text), {
    code: t15,
    title: r.title,
    config: i
  };
}
_(vg, "preprocessDiagram");
function $9(t15) {
  const e = new TextEncoder().encode(t15), r = Array.from(e, (n) => String.fromCodePoint(n)).join("");
  return btoa(r);
}
_($9, "toBase64");
var zQ = 5e4;
var qQ = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
var RQ = "sandbox";
var PQ = "loose";
var jQ = "http://www.w3.org/2000/svg";
var WQ = "http://www.w3.org/1999/xlink";
var HQ = "http://www.w3.org/1999/xhtml";
var UQ = "100%";
var VQ = "100%";
var GQ = "border:0;margin:0;";
var XQ = "margin:0";
var YQ = "allow-top-navigation-by-user-activation allow-popups";
var KQ = 'The "iframe" tag is not supported by your browser.';
var ZQ = ["foreignobject"];
var JQ = ["dominant-baseline"];
function Cg(t15) {
  const e = vg(t15);
  return f0(), xR(e.config ?? {}), e;
}
_(Cg, "processAndSetConfigs");
async function E9(t15, e) {
  Hu();
  try {
    const { code: r, config: n } = Cg(t15);
    return { diagramType: (await B9(r)).type, config: n };
  } catch (r) {
    if (e == null ? void 0 : e.suppressErrors)
      return false;
    throw r;
  }
}
_(E9, "parse");
var n5 = _((t15, e, r = []) => `
.${t15} ${e} { ${r.join(" !important; ")} !important; }`, "cssImportantStyles");
var QQ = _((t15, e = /* @__PURE__ */ new Map()) => {
  var _a3;
  let r = "";
  if (t15.themeCSS !== void 0 && (r += `
${t15.themeCSS}`), t15.fontFamily !== void 0 && (r += `
:root { --mermaid-font-family: ${t15.fontFamily}}`), t15.altFontFamily !== void 0 && (r += `
:root { --mermaid-alt-font-family: ${t15.altFontFamily}}`), e instanceof Map) {
    const n = t15.htmlLabels ?? ((_a3 = t15.flowchart) == null ? void 0 : _a3.htmlLabels) ? ["> *", "span"] : ["rect", "polygon", "ellipse", "circle", "path"];
    e.forEach((i) => {
      t52(i.styles) || n.forEach((s) => {
        r += n5(i.id, s, i.styles);
      }), t52(i.textStyles) || (r += n5(
        i.id,
        "tspan",
        ((i == null ? void 0 : i.textStyles) || []).map((s) => s.replace("color", "fill"))
      ));
    });
  }
  return r;
}, "createCssStyles");
var ttt = _((t15, e, r, n) => {
  const i = QQ(t15, r), s = OR(e, i, t15.themeVariables);
  return p1(mZ(`${n}{${s}}`), yZ);
}, "createUserStyles");
var ett = _((t15 = "", e, r) => {
  let n = t15;
  return !r && !e && (n = n.replace(
    /marker-end="url\([\d+./:=?A-Za-z-]*?#/g,
    'marker-end="url(#'
  )), n = ca(n), n = n.replace(/<br>/g, "<br/>"), n;
}, "cleanUpSvgCode");
var rtt = _((t15 = "", e) => {
  var _a3, _b2;
  const r = ((_b2 = (_a3 = e == null ? void 0 : e.viewBox) == null ? void 0 : _a3.baseVal) == null ? void 0 : _b2.height) ? e.viewBox.baseVal.height + "px" : VQ, n = $9(`<body style="${XQ}">${t15}</body>`);
  return `<iframe style="width:${UQ};height:${r};${GQ}" src="data:text/html;charset=UTF-8;base64,${n}" sandbox="${YQ}">
  ${KQ}
</iframe>`;
}, "putIntoIFrame");
var i5 = _((t15, e, r, n, i) => {
  const s = t15.append("div");
  s.attr("id", r), n && s.attr("style", n);
  const a = s.append("svg").attr("id", e).attr("width", "100%").attr("xmlns", jQ);
  return i && a.attr("xmlns:xlink", i), a.append("g"), t15;
}, "appendDivSvgG");
function x1(t15, e) {
  return t15.append("iframe").attr("id", e).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
_(x1, "sandboxedIframe");
var ntt = _((t15, e, r, n) => {
  var _a3, _b2, _c;
  (_a3 = t15.getElementById(e)) == null ? void 0 : _a3.remove(), (_b2 = t15.getElementById(r)) == null ? void 0 : _b2.remove(), (_c = t15.getElementById(n)) == null ? void 0 : _c.remove();
}, "removeExistingElements");
var itt = _(async function(t15, e, r) {
  var _a3, _b2, _c, _d, _e, _f2;
  Hu();
  const n = Cg(e);
  e = n.code;
  const i = Hr();
  ut.debug(i), e.length > ((i == null ? void 0 : i.maxTextSize) ?? zQ) && (e = qQ);
  const s = "#" + t15, a = "i" + t15, o = "#" + a, l = "d" + t15, c = "#" + l, h = _(() => {
    const Q = ae(m ? o : c).node();
    Q && "remove" in Q && Q.remove();
  }, "removeTempElements");
  let p = ae("body");
  const m = i.securityLevel === RQ, g = i.securityLevel === PQ, y = i.fontFamily;
  if (r !== void 0) {
    if (r && (r.innerHTML = ""), m) {
      const Q = x1(ae(r), a);
      p = ae(Q.nodes()[0].contentDocument.body), p.node().style.margin = 0;
    } else
      p = ae(r);
    i5(p, t15, l, `font-family: ${y}`, WQ);
  } else {
    if (ntt(document, t15, l, a), m) {
      const Q = x1(ae("body"), a);
      p = ae(Q.nodes()[0].contentDocument.body), p.node().style.margin = 0;
    } else
      p = ae("body");
    i5(p, t15, l);
  }
  let x, k;
  try {
    x = await b1.fromText(e, { title: n.title });
  } catch (Q) {
    if (i.suppressErrorRendering)
      throw h(), Q;
    x = await b1.fromText("error"), k = Q;
  }
  const C = p.select(c).node(), A = x.type, $ = C.firstChild, B = $.firstChild, L = (_b2 = (_a3 = x.renderer).getClasses) == null ? void 0 : _b2.call(_a3, e, x), q = ttt(i, A, L, s), U = document.createElement("style");
  U.innerHTML = q, $.insertBefore(U, B);
  try {
    await x.renderer.draw(e, t15, V4.version, x);
  } catch (Q) {
    throw i.suppressErrorRendering ? h() : UJ.draw(e, t15, V4.version), Q;
  }
  const G = p.select(`${c} svg`), F = (_d = (_c = x.db).getAccTitle) == null ? void 0 : _d.call(_c), W = (_f2 = (_e = x.db).getAccDescription) == null ? void 0 : _f2.call(_e);
  L9(A, G, F, W), p.select(`[id="${t15}"]`).selectAll("foreignobject > *").attr("xmlns", HQ);
  let R = p.select(c).node().innerHTML;
  if (ut.debug("config.arrowMarkerAbsolute", i.arrowMarkerAbsolute), R = ett(R, m, Ke(i.arrowMarkerAbsolute)), m) {
    const Q = p.select(c + " svg").node();
    R = rtt(R, Q);
  } else g || (R = Ya.sanitize(R, {
    ADD_TAGS: ZQ,
    ADD_ATTR: JQ,
    HTML_INTEGRATION_POINTS: { foreignobject: true }
  }));
  if (DQ(), k)
    throw k;
  return h(), {
    diagramType: A,
    svg: R,
    bindFunctions: x.db.bindFunctions
  };
}, "render");
function M9(t15 = {}) {
  var _a3;
  const e = ur({}, t15);
  (e == null ? void 0 : e.fontFamily) && !((_a3 = e.themeVariables) == null ? void 0 : _a3.fontFamily) && (e.themeVariables || (e.themeVariables = {}), e.themeVariables.fontFamily = e.fontFamily), yR(e), (e == null ? void 0 : e.theme) && e.theme in Ti ? e.themeVariables = Ti[e.theme].getThemeVariables(
    e.themeVariables
  ) : e && (e.themeVariables = Ti.default.getThemeVariables(e.themeVariables));
  const r = typeof e == "object" ? gR(e) : O6();
  Cm(r.logLevel), Hu();
}
_(M9, "initialize");
var B9 = _((t15, e = {}) => {
  const { code: r } = vg(t15);
  return b1.fromText(r, e);
}, "getDiagramFromText");
function L9(t15, e, r, n) {
  S9(e, t15), A9(e, r, n, e.attr("id"));
}
_(L9, "addA11yInfo");
var ra = Object.freeze({
  render: itt,
  parse: E9,
  getDiagramFromText: B9,
  initialize: M9,
  getConfig: Hr,
  setConfig: z6,
  getSiteConfig: O6,
  updateSiteConfig: bR,
  reset: _(() => {
    f0();
  }, "reset"),
  globalReset: _(() => {
    f0(Ka);
  }, "globalReset"),
  defaultConfig: Ka
});
Cm(Hr().logLevel);
f0(Hr());
var stt = _((t15, e, r) => {
  ut.warn(t15), ig(t15) ? (r && r(t15.str, t15.hash), e.push({ ...t15, message: t15.str, error: t15 })) : (r && r(t15), t15 instanceof Error && e.push({
    str: t15.message,
    message: t15.message,
    hash: t15.name,
    error: t15
  }));
}, "handleError");
var D9 = _(async function(t15 = {
  querySelector: ".mermaid"
}) {
  try {
    await att(t15);
  } catch (e) {
    if (ig(e) && ut.error(e.str), Li.parseError && Li.parseError(e), !t15.suppressErrors)
      throw ut.error("Use the suppressErrors option to suppress these errors"), e;
  }
}, "run");
var att = _(async function({ postRenderCallback: t15, querySelector: e, nodes: r } = {
  querySelector: ".mermaid"
}) {
  const n = ra.getConfig();
  ut.debug(`${t15 ? "" : "No "}Callback function found`);
  let i;
  if (r)
    i = r;
  else if (e)
    i = document.querySelectorAll(e);
  else
    throw new Error("Nodes and querySelector are both undefined");
  ut.debug(`Found ${i.length} diagrams`), (n == null ? void 0 : n.startOnLoad) !== void 0 && (ut.debug("Start On Load: " + (n == null ? void 0 : n.startOnLoad)), ra.updateSiteConfig({ startOnLoad: n == null ? void 0 : n.startOnLoad }));
  const s = new Wn.InitIDGenerator(n.deterministicIds, n.deterministicIDSeed);
  let a;
  const o = [];
  for (const l of Array.from(i)) {
    if (ut.info("Rendering diagram: " + l.id), l.getAttribute("data-processed"))
      continue;
    l.setAttribute("data-processed", "true");
    const c = `mermaid-${s.next()}`;
    a = l.innerHTML, a = sv(Wn.entityDecode(a)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const h = Wn.detectInit(a);
    h && ut.debug("Detected early reinit: ", h);
    try {
      const { svg: p, bindFunctions: m } = await O9(c, a, l);
      l.innerHTML = p, t15 && await t15(c), m && m(l);
    } catch (p) {
      stt(p, o, Li.parseError);
    }
  }
  if (o.length > 0)
    throw o[0];
}, "runThrowsErrors");
var F9 = _(function(t15) {
  ra.initialize(t15);
}, "initialize");
var ott = _(async function(t15, e, r) {
  ut.warn("mermaid.init is deprecated. Please use run instead."), t15 && F9(t15);
  const n = { postRenderCallback: r, querySelector: ".mermaid" };
  typeof e == "string" ? n.querySelector = e : e && (e instanceof HTMLElement ? n.nodes = [e] : n.nodes = e), await D9(n);
}, "init");
var ltt = _(async (t15, {
  lazyLoad: e = true
} = {}) => {
  Hu(), Af(...t15), e === false && await BQ();
}, "registerExternalDiagrams");
var N9 = _(function() {
  if (Li.startOnLoad) {
    const { startOnLoad: t15 } = ra.getConfig();
    t15 && Li.run().catch((e) => ut.error("Mermaid failed to initialize", e));
  }
}, "contentLoaded");
typeof document < "u" && window.addEventListener("load", N9, false);
var ctt = _(function(t15) {
  Li.parseError = t15;
}, "setParseErrorHandler");
var G0 = [];
var Fp = false;
var I9 = _(async () => {
  if (!Fp) {
    for (Fp = true; G0.length > 0; ) {
      const t15 = G0.shift();
      if (t15)
        try {
          await t15();
        } catch (e) {
          ut.error("Error executing queue", e);
        }
    }
    Fp = false;
  }
}, "executeQueue");
var htt = _(async (t15, e) => new Promise((r, n) => {
  const i = _(() => new Promise((s, a) => {
    ra.parse(t15, e).then(
      (o) => {
        s(o), r(o);
      },
      (o) => {
        var _a3;
        ut.error("Error parsing", o), (_a3 = Li.parseError) == null ? void 0 : _a3.call(Li, o), a(o), n(o);
      }
    );
  }), "performCall");
  G0.push(i), I9().catch(n);
}), "parse");
var O9 = _((t15, e, r) => new Promise((n, i) => {
  const s = _(() => new Promise((a, o) => {
    ra.render(t15, e, r).then(
      (l) => {
        a(l), n(l);
      },
      (l) => {
        var _a3;
        ut.error("Error parsing", l), (_a3 = Li.parseError) == null ? void 0 : _a3.call(Li, l), o(l), i(l);
      }
    );
  }), "performCall");
  G0.push(s), I9().catch(i);
}), "render");
var utt = _(() => Object.keys(Ks).map((t15) => ({
  id: t15
})), "getRegisteredDiagramsMetadata");
var Li = {
  startOnLoad: true,
  mermaidAPI: ra,
  parse: htt,
  render: O9,
  init: ott,
  run: D9,
  registerExternalDiagrams: ltt,
  registerLayoutLoaders: H8,
  initialize: F9,
  parseError: void 0,
  contentLoaded: N9,
  setParseErrorHandler: ctt,
  detectType: _m,
  registerIconPacks: DY,
  getRegisteredDiagramsMetadata: utt
};
var s5 = Li;
var $s = /* @__PURE__ */ new Map();
var Np = /* @__PURE__ */ new Map();
var Zr = /* @__PURE__ */ new Map();
var dl = /* @__PURE__ */ new Map();
var Ip = /* @__PURE__ */ new Map();
var a5 = /* @__PURE__ */ new WeakMap();
var mi = /* @__PURE__ */ new Set();
function dtt(t15) {
  if (dl.has(t15))
    return dl.get(t15);
  if ((/* @__PURE__ */ new Set(["script", "style", "meta", "link", "noscript", "template"])).has(t15)) {
    const s = {};
    return dl.set(t15, s), s;
  }
  let e = document.getElementById("snapdom-sandbox");
  e || (e = document.createElement("div"), e.id = "snapdom-sandbox", e.style.position = "absolute", e.style.left = "-9999px", e.style.top = "-9999px", e.style.width = "0", e.style.height = "0", e.style.overflow = "hidden", document.body.appendChild(e));
  const r = document.createElement(t15);
  r.style.all = "initial", e.appendChild(r);
  const n = getComputedStyle(r), i = {};
  for (let s of n)
    i[s] = n.getPropertyValue(s);
  return e.removeChild(r), dl.set(t15, i), i;
}
function w1(t15, e, r = false) {
  const n = [], i = dtt(e);
  for (let [s, a] of Object.entries(t15))
    if (!r)
      a && n.push(`${s}:${a}`);
    else {
      const o = i[s];
      a && a !== o && n.push(`${s}:${a}`);
    }
  return n.sort().join(";");
}
function ptt(t15) {
  const e = /* @__PURE__ */ new Set();
  return t15.nodeType !== Node.ELEMENT_NODE && t15.nodeType !== Node.DOCUMENT_FRAGMENT_NODE ? [] : (t15.tagName && e.add(t15.tagName.toLowerCase()), typeof t15.querySelectorAll == "function" && t15.querySelectorAll("*").forEach((r) => e.add(r.tagName.toLowerCase())), Array.from(e));
}
function ftt(t15) {
  const e = /* @__PURE__ */ new Map();
  for (let n of t15) {
    const i = dl.get(n);
    if (!i) continue;
    const s = Object.entries(i).map(([a, o]) => `${a}:${o};`).sort().join("");
    e.has(s) || e.set(s, []), e.get(s).push(n);
  }
  let r = "";
  for (let [n, i] of e.entries())
    r += `${i.join(",")} { ${n} }
`;
  return r;
}
function mtt(t15) {
  const e = new Set(t15.values()), r = /* @__PURE__ */ new Map();
  let n = 1;
  for (const i of e)
    r.set(i, `c${n++}`);
  return r;
}
async function z9(t15, e = {}) {
  var _a3;
  const r = (_a3 = t15.match(/url\(["']?(.*?)["']?\)/)) == null ? void 0 : _a3[1];
  if (r) {
    const n = Ag(r);
    if (Np.has(n))
      return e.skipInline ? void 0 : `url(${Np.get(n)})`;
    {
      const i = await Sg(n, { useProxy: e.useProxy });
      return Np.set(n, i), e.skipInline ? void 0 : `url("${i}")`;
    }
  }
  return t15;
}
function Ko(t15, { fast: e = false } = {}) {
  if (e) return t15();
  "requestIdleCallback" in window ? requestIdleCallback(t15, { timeout: 50 }) : setTimeout(t15, 1);
}
function _g(t15, e = null) {
  if (!(t15 instanceof Element))
    return window.getComputedStyle(t15, e);
  let r = a5.get(t15);
  if (r || (r = /* @__PURE__ */ new Map(), a5.set(t15, r)), !r.has(e)) {
    const n = window.getComputedStyle(t15, e);
    r.set(e, n);
  }
  return r.get(e);
}
function gtt(t15) {
  let e = t15.replace(/^['"]|['"]$/g, "");
  if (e.startsWith("\\"))
    try {
      return String.fromCharCode(parseInt(e.replace("\\", ""), 16));
    } catch {
      return e;
    }
  return e;
}
function q9(t15) {
  const e = t15.indexOf("url(");
  if (e === -1) return null;
  let r = t15.slice(e + 4).trim();
  return r.endsWith(")") && (r = r.slice(0, -1).trim()), (r.startsWith('"') && r.endsWith('"') || r.startsWith("'") && r.endsWith("'")) && (r = r.slice(1, -1)), r;
}
function Sg(t15, { timeout: e = 3e3, useProxy: r = "" } = {}) {
  function n(a) {
    try {
      return new URL(a, window.location.href).origin === window.location.origin ? "use-credentials" : "anonymous";
    } catch {
      return "anonymous";
    }
  }
  async function i(a) {
    const o = (l) => fetch(l, {
      mode: "cors",
      credentials: n(l) === "use-credentials" ? "include" : "omit"
    }).then((c) => c.blob()).then((c) => new Promise((h, p) => {
      const m = new FileReader();
      m.onloadend = () => {
        const g = m.result;
        if (typeof g != "string" || !g.startsWith("data:image/")) {
          p(new Error("Invalid image data URL"));
          return;
        }
        h(g);
      }, m.onerror = () => p(new Error("FileReader error")), m.readAsDataURL(c);
    }));
    try {
      return await o(a);
    } catch {
      if (r && typeof r == "string") {
        const l = r.replace(/\/$/, "") + Ag(a);
        try {
          return await o(l);
        } catch {
          throw console.error(`[SnapDOM - fetchImage] Proxy fallback failed for: ${a}`), new Error("CORS restrictions prevented image capture (even via proxy)");
        }
      } else
        throw console.error(`[SnapDOM - fetchImage] No valid proxy URL provided for fallback: ${a}`), new Error("Fetch fallback failed and no proxy provided");
    }
  }
  const s = n(t15);
  return console.log(`[SnapDOM - fetchImage] Start loading image: ${t15} with crossOrigin=${s}`), $s.has(t15) ? (console.log(`[SnapDOM - fetchImage] Cache hit for: ${t15}`), Promise.resolve($s.get(t15))) : t15.startsWith("data:image/") ? ($s.set(t15, t15), Promise.resolve(t15)) : /\.svg(\?.*)?$/i.test(t15) ? (async () => {
    try {
      const a = await (await fetch(t15, {
        mode: "cors",
        credentials: s === "use-credentials" ? "include" : "omit"
      })).text(), o = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(a)}`;
      return $s.set(t15, o), o;
    } catch {
      return i(t15);
    }
  })() : new Promise((a, o) => {
    const l = setTimeout(() => {
      console.log(`[SnapDOM - fetchImage] Timeout after ${e}ms for image: ${t15}`), o(new Error("Image load timed out"));
    }, e), c = new Image();
    c.crossOrigin = s, c.onload = async () => {
      clearTimeout(l);
      try {
        await c.decode();
        const h = document.createElement("canvas");
        h.width = c.width, h.height = c.height, h.getContext("2d").drawImage(c, 0, 0, h.width, h.height);
        const p = h.toDataURL("image/png");
        $s.set(t15, p), a(p);
      } catch {
        try {
          const h = await i(t15);
          $s.set(t15, h), a(h);
        } catch (h) {
          o(h);
        }
      }
    }, c.onerror = async () => {
      clearTimeout(l), console.error(`[SnapDOM - fetchImage] Image failed to load: ${t15}`);
      try {
        const h = await i(t15);
        $s.set(t15, h), a(h);
      } catch (h) {
        o(h);
      }
    }, c.src = t15;
  });
}
function o5(t15) {
  const e = {};
  for (let r of t15)
    e[r] = t15.getPropertyValue(r);
  return e;
}
function R9() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function ytt(t15) {
  if (!t15 || t15 === "none") return "";
  let e = t15.replace(/translate[XY]?\([^)]*\)/g, "");
  return e = e.replace(/matrix\(([^)]+)\)/g, (r, n) => {
    const i = n.split(",").map((s) => s.trim());
    return i.length !== 6 ? `matrix(${n})` : (i[4] = "0", i[5] = "0", `matrix(${i.join(", ")})`);
  }), e = e.replace(/matrix3d\(([^)]+)\)/g, (r, n) => {
    const i = n.split(",").map((s) => s.trim());
    return i.length !== 16 ? `matrix3d(${n})` : (i[12] = "0", i[13] = "0", `matrix3d(${i.join(", ")})`);
  }), e.trim().replace(/\s{2,}/g, " ");
}
function Ag(t15) {
  if (/%[0-9A-Fa-f]{2}/.test(t15)) return t15;
  try {
    return encodeURI(t15);
  } catch {
    return t15;
  }
}
function P9(t15) {
  const e = [];
  let r = 0, n = 0;
  for (let i = 0; i < t15.length; i++) {
    const s = t15[i];
    s === "(" && r++, s === ")" && r--, s === "," && r === 0 && (e.push(t15.slice(n, i).trim()), n = i + 1);
  }
  return e.push(t15.slice(n).trim()), e;
}
var Op = /* @__PURE__ */ new WeakMap();
var zp = /* @__PURE__ */ new Map();
function btt(t15) {
  const e = {};
  for (let r = 0; r < t15.length; r++) {
    const n = t15[r];
    let i = t15.getPropertyValue(n);
    (n === "background-image" || n === "content") && i.includes("url(") && !i.includes("data:") && (i = "none"), e[n] = i;
  }
  return e;
}
function l5(t15, e, r, n, i) {
  var _a3;
  if (t15.tagName === "STYLE") return;
  n.has(t15) || n.set(t15, _g(t15));
  const s = n.get(t15);
  if (!Op.has(t15)) {
    const h = btt(s);
    Op.set(t15, h);
  }
  const a = Op.get(t15), o = Object.entries(a).sort(([h], [p]) => h.localeCompare(p)).map(([h, p]) => `${h}:${p}`).join(";");
  if (zp.has(o)) {
    r.set(e, zp.get(o));
    return;
  }
  const l = ((_a3 = t15.tagName) == null ? void 0 : _a3.toLowerCase()) || "div", c = w1(a, l, i);
  zp.set(o, c), r.set(e, c);
}
function xtt(t15) {
  return t15.nodeType === Node.ELEMENT_NODE && t15.tagName === "SLOT";
}
function jh(t15, e, r, n, i, s = {}, a) {
  var _a3, _b2;
  if (t15.nodeType === Node.TEXT_NODE || t15.nodeType !== Node.ELEMENT_NODE) return t15.cloneNode(true);
  if (t15.getAttribute("data-capture") === "exclude") {
    const l = document.createElement("div"), c = t15.getBoundingClientRect();
    return l.style.cssText = `display: inline-block; width: ${c.width}px; height: ${c.height}px; visibility: hidden;`, l;
  }
  if (s.exclude && Array.isArray(s.exclude))
    for (const l of s.exclude)
      try {
        if ((_a3 = t15.matches) == null ? void 0 : _a3.call(t15, l)) {
          const c = document.createElement("div"), h = t15.getBoundingClientRect();
          return c.style.cssText = `display: inline-block; width: ${h.width}px; height: ${h.height}px; visibility: hidden;`, c;
        }
      } catch (c) {
        console.warn(`Invalid selector in exclude option: ${l}`, c);
      }
  if (typeof s.filter == "function")
    try {
      if (!s.filter(t15, a || t15)) {
        const l = document.createElement("div"), c = t15.getBoundingClientRect();
        return l.style.cssText = `display: inline-block; width: ${c.width}px; height: ${c.height}px; visibility: hidden;`, l;
      }
    } catch (l) {
      console.warn("Error in filter function:", l);
    }
  if (t15.tagName === "IFRAME") {
    const l = document.createElement("div");
    return l.textContent = "", l.style.cssText = `width: ${t15.offsetWidth}px; height: ${t15.offsetHeight}px; background-image: repeating-linear-gradient(45deg, #ddd, #ddd 5px, #f9f9f9 5px, #f9f9f9 10px);display: flex;align-items: center;justify-content: center;font-size: 12px;color: #555; border: 1px solid #aaa;`, l;
  }
  if (t15.getAttribute("data-capture") === "placeholder") {
    const l = t15.cloneNode(false);
    n.set(l, t15), l5(t15, l, e, r, i);
    const c = document.createElement("div");
    return c.textContent = t15.getAttribute("data-placeholder-text") || "", c.style.cssText = "color: #666;font-size: 12px;text-align: center;line-height: 1.4;padding: 0.5em;box-sizing: border-box;", l.appendChild(c), l;
  }
  if (t15.tagName === "CANVAS") {
    const l = t15.toDataURL(), c = document.createElement("img");
    return c.src = l, c.width = t15.width, c.height = t15.height, c.style.display = "inline-block", c.style.width = t15.style.width || `${t15.width}px`, c.style.height = t15.style.height || `${t15.height}px`, c;
  }
  const o = t15.cloneNode(false);
  if (n.set(o, t15), t15 instanceof HTMLInputElement)
    o.value = t15.value, o.setAttribute("value", t15.value), t15.checked !== void 0 && (o.checked = t15.checked, t15.checked && o.setAttribute("checked", ""));
  else if (t15 instanceof HTMLTextAreaElement) {
    const l = t15.getBoundingClientRect();
    o.textContent = t15.value, o.style.width = `${l.width}px`, o.style.height = `${l.height}px`;
  } else t15 instanceof HTMLSelectElement && (o.value = t15.value, Array.from(o.options).forEach((l) => {
    l.value === t15.value ? l.setAttribute("selected", "") : l.removeAttribute("selected");
  }));
  if (l5(t15, o, e, r, i), xtt(t15)) {
    const l = ((_b2 = t15.assignedNodes) == null ? void 0 : _b2.call(t15, { flatten: true })) || [], c = l.length > 0 ? l : Array.from(t15.childNodes), h = document.createDocumentFragment();
    for (const p of c) {
      const m = jh(p, e, r, n, i, s, a || t15);
      m && h.appendChild(m);
    }
    return h;
  } else if (!(t15 instanceof HTMLTextAreaElement)) {
    const l = t15.shadowRoot ? t15.shadowRoot.childNodes : t15.childNodes;
    for (const c of l) {
      const h = jh(c, e, r, n, i, s, a || t15);
      h && o.appendChild(h);
    }
    if (t15.shadowRoot && t15.childNodes.length > 0 && !t15.shadowRoot.querySelector("slot")) {
      const c = document.createDocumentFragment();
      for (const h of t15.childNodes) {
        const p = jh(h, e, r, n, i, s, a || t15);
        p && c.appendChild(p);
      }
      o.appendChild(c);
    }
  }
  return o;
}
var wtt = [
  // /uicons/i,
  /font\s*awesome/i,
  /material\s*icons/i,
  /ionicons/i,
  /glyphicons/i,
  /feather/i,
  /bootstrap\s*icons/i,
  /remix\s*icons/i,
  /heroicons/i,
  /layui/i,
  /lucide/i
];
var k1 = [];
function ktt(t15) {
  const e = Array.isArray(t15) ? t15 : [t15];
  for (const r of e)
    r instanceof RegExp ? k1.push(r) : typeof r == "string" ? k1.push(new RegExp(r, "i")) : console.warn("[snapdom] Ignored invalid iconFont value:", r);
}
function Ui(t15) {
  const e = typeof t15 == "string" ? t15 : "", r = [...wtt, ...k1];
  for (const n of r)
    if (n instanceof RegExp && n.test(e)) return true;
  return !!(/icon/i.test(e) || /glyph/i.test(e) || /symbols/i.test(e) || /feather/i.test(e) || /fontawesome/i.test(e));
}
async function vtt(t15, e, r, n = 32, i = "#000") {
  e = e.replace(/^['"]+|['"]+$/g, "");
  const s = window.devicePixelRatio || 1, a = document.createElement("canvas").getContext("2d");
  a.font = r ? `${r} ${n}px "${e}"` : `${n}px "${e}"`;
  const o = a.measureText(t15), l = o.actualBoundingBoxAscent || n * 0.8, c = o.actualBoundingBoxDescent || n * 0.2, h = l + c, p = o.width, m = document.createElement("canvas");
  m.width = Math.ceil(p * s), m.height = Math.ceil(h * s);
  const g = m.getContext("2d");
  return g.scale(s, s), g.font = a.font, g.textAlign = "left", g.textBaseline = "alphabetic", g.fillStyle = i, g.fillText(t15, 0, l), m.toDataURL();
}
function j9(t15) {
  return Array.from(document.styleSheets).some((e) => e.href === t15);
}
function Ctt(t15) {
  return new Promise((e) => {
    if (j9(t15)) return e(null);
    const r = document.createElement("link");
    r.rel = "stylesheet", r.href = t15, r.setAttribute("data-snapdom", "injected-import"), r.onload = () => e(r), r.onerror = () => e(null), document.head.appendChild(r);
  });
}
async function _tt({ preCached: t15 = false } = {}) {
  if (Zr.has("fonts-embed-css")) {
    if (t15) {
      const s = document.createElement("style");
      s.setAttribute("data-snapdom", "embedFonts"), s.textContent = Zr.get("fonts-embed-css"), document.head.appendChild(s);
    }
    return Zr.get("fonts-embed-css");
  }
  const e = /@import\s+url\(["']?([^"')]+)["']?\)/g, r = [];
  for (const s of document.querySelectorAll("style")) {
    const a = s.textContent || "", o = Array.from(a.matchAll(e));
    for (const l of o) {
      const c = l[1];
      Ui(c) || j9(c) || r.push(c);
    }
  }
  await Promise.all(r.map(Ctt));
  const n = Array.from(document.querySelectorAll('link[rel="stylesheet"]')).filter((s) => s.href);
  let i = "";
  for (const s of n)
    try {
      const a = await (await fetch(s.href)).text();
      if (Ui(s.href) || Ui(a)) continue;
      const o = /url\((["']?)([^"')]+)\1\)/g, l = await Promise.all(
        Array.from(a.matchAll(o)).map(async (h) => {
          let p = q9(h[0]);
          if (!p) return null;
          let m = p;
          if (!m.startsWith("http") && !m.startsWith("data:") && (m = new URL(m, s.href).href), Ui(m)) return null;
          if (Zr.has(m))
            return mi.add(m), { original: h[0], inlined: `url(${Zr.get(m)})` };
          if (mi.has(m)) return null;
          try {
            const g = await (await fetch(m)).blob(), y = await new Promise((x) => {
              const k = new FileReader();
              k.onload = () => x(k.result), k.readAsDataURL(g);
            });
            return Zr.set(m, y), mi.add(m), { original: h[0], inlined: `url(${y})` };
          } catch {
            return console.warn("[snapdom] Failed to fetch font resource:", m), null;
          }
        })
      );
      let c = a;
      for (const h of l)
        h && (c = c.replace(h.original, h.inlined));
      i += c + `
`;
    } catch {
      console.warn("[snapdom] Failed to fetch CSS:", s.href);
    }
  for (const s of document.styleSheets)
    try {
      if (!s.href || n.every((a) => a.href !== s.href)) {
        for (const a of s.cssRules)
          if (a.type === CSSRule.FONT_FACE_RULE) {
            const o = a.style.getPropertyValue("src"), l = a.style.getPropertyValue("font-family");
            if (!o || Ui(l)) continue;
            const c = /url\((["']?)([^"')]+)\1\)/g;
            let h = o;
            const p = Array.from(o.matchAll(c));
            for (const m of p) {
              let g = m[2].trim();
              if (!g) continue;
              let y = g;
              if (!y.startsWith("http") && !y.startsWith("data:") && (y = new URL(y, s.href || location.href).href), !Ui(y)) {
                if (Zr.has(y)) {
                  mi.add(y), h = h.replace(m[0], `url(${Zr.get(y)})`);
                  continue;
                }
                if (!mi.has(y))
                  try {
                    const x = await (await fetch(y)).blob(), k = await new Promise((C) => {
                      const A = new FileReader();
                      A.onload = () => C(A.result), A.readAsDataURL(x);
                    });
                    Zr.set(y, k), mi.add(y), h = h.replace(m[0], `url(${k})`);
                  } catch {
                    console.warn("[snapdom] Failed to fetch font URL:", y);
                  }
              }
            }
            i += `@font-face {
  font-family: ${l};
  src: ${h};
  font-style: ${a.style.getPropertyValue("font-style") || "normal"};
  font-weight: ${a.style.getPropertyValue("font-weight") || "normal"};
}
`;
          }
      }
    } catch (a) {
      console.warn("[snapdom] Cannot access stylesheet", s.href, a);
    }
  for (const s of document.fonts)
    if (s.family && s.status === "loaded" && s._snapdomSrc) {
      if (Ui(s.family)) continue;
      let a = s._snapdomSrc;
      if (!a.startsWith("data:")) {
        if (Zr.has(s._snapdomSrc))
          a = Zr.get(s._snapdomSrc), mi.add(s._snapdomSrc);
        else if (!mi.has(s._snapdomSrc))
          try {
            const o = await (await fetch(s._snapdomSrc)).blob();
            a = await new Promise((l) => {
              const c = new FileReader();
              c.onload = () => l(c.result), c.readAsDataURL(o);
            }), Zr.set(s._snapdomSrc, a), mi.add(s._snapdomSrc);
          } catch {
            console.warn("[snapdom] Failed to fetch dynamic font src:", s._snapdomSrc);
            continue;
          }
      }
      i += `@font-face {
  font-family: '${s.family}';
  src: url(${a});
  font-style: ${s.style || "normal"};
  font-weight: ${s.weight || "normal"};
}
`;
    }
  if (i && (Zr.set("fonts-embed-css", i), t15)) {
    const s = document.createElement("style");
    s.setAttribute("data-snapdom", "embedFonts"), s.textContent = i, document.head.appendChild(s);
  }
  return i;
}
async function W9(t15, e, r, n, i, s = false, a) {
  var _a3;
  if (!(t15 instanceof Element) || !(e instanceof Element)) return;
  for (const c of ["::before", "::after", "::first-letter"])
    try {
      const h = _g(t15, c);
      if (!h || typeof h[Symbol.iterator] != "function") continue;
      if (c === "::first-letter") {
        const C = getComputedStyle(t15);
        if (!(h.color !== C.color || h.fontSize !== C.fontSize || h.fontWeight !== C.fontWeight)) continue;
        const A = Array.from(e.childNodes).find(
          (W) => W.nodeType === Node.TEXT_NODE && W.textContent && W.textContent.trim().length > 0
        );
        if (!A) continue;
        const $ = A.textContent, B = (_a3 = $.match(/^([^\p{L}\p{N}\s]*[\p{L}\p{N}](?:['’])?)/u)) == null ? void 0 : _a3[0], L = $.slice((B == null ? void 0 : B.length) || 0);
        if (!B || /[\uD800-\uDFFF]/.test(B)) continue;
        const q = document.createElement("span");
        q.textContent = B, q.dataset.snapdomPseudo = "::first-letter";
        const U = o5(h), G = w1(U, "span", i);
        r.set(q, G);
        const F = document.createTextNode(L);
        e.replaceChild(F, A), e.insertBefore(q, F);
        continue;
      }
      const p = h.getPropertyValue("content"), m = h.getPropertyValue("background-image"), g = h.getPropertyValue("background-color"), y = p !== "none", x = m && m !== "none", k = g && g !== "transparent" && g !== "rgba(0, 0, 0, 0)";
      if (y || x || k) {
        const C = h.getPropertyValue("font-family"), A = parseInt(h.getPropertyValue("font-size")) || 32, $ = parseInt(h.getPropertyValue("font-weight")) || false, B = h.getPropertyValue("color") || "#000", L = document.createElement("span");
        L.dataset.snapdomPseudo = c;
        const q = o5(h), U = w1(q, "span", i);
        r.set(L, U);
        const G = Ui(C), F = gtt(p);
        if (G && F.length === 1) {
          const W = document.createElement("img");
          W.src = await vtt(F, C, $, A, B), W.style = `width:${A}px;height:auto;object-fit:contain;`, L.appendChild(W);
        } else if (F.startsWith("url(")) {
          const W = q9(F);
          if (W && W.trim() !== "")
            try {
              const R = document.createElement("img"), Q = await Sg(Ag(W, { useProxy: a }));
              R.src = Q, R.style = `width:${A}px;height:auto;object-fit:contain;`, L.appendChild(R);
            } catch (R) {
              console.error(`[snapdom] Error in pseudo ${c} for`, t15, R);
            }
        } else !G && F && F !== "none" && (L.textContent = F);
        if (x)
          try {
            const W = P9(m), R = await Promise.all(
              W.map((Q) => z9(Q))
            );
            L.style.backgroundImage = R.join(", ");
          } catch (W) {
            console.warn(`[snapdom] Failed to inline background-image for ${c}`, W);
          }
        if (k && (L.style.backgroundColor = g), !(L.childNodes.length > 0 || L.textContent && L.textContent.trim() !== "" || x || k)) continue;
        c === "::before" ? e.insertBefore(L, e.firstChild) : e.appendChild(L);
      }
    } catch (h) {
      console.warn(`[snapdom] Failed to capture ${c} for`, t15, h);
    }
  const o = Array.from(t15.children), l = Array.from(e.children).filter((c) => !c.dataset.snapdomPseudo);
  for (let c = 0; c < Math.min(o.length, l.length); c++)
    await W9(
      o[c],
      l[c],
      r,
      n,
      i,
      s,
      a
    );
}
function Stt(t15) {
  if (!t15) return;
  const e = document.querySelectorAll("svg > defs");
  e.length && t15.querySelectorAll("svg").forEach((r) => {
    const n = r.querySelectorAll("use");
    if (!n.length) return;
    const i = /* @__PURE__ */ new Set();
    if (n.forEach((a) => {
      const o = a.getAttribute("xlink:href") || a.getAttribute("href");
      o && o.startsWith("#") && i.add(o.slice(1));
    }), !i.size) return;
    const s = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    for (const a of i)
      for (const o of e) {
        const l = o.querySelector(`#${CSS.escape(a)}`);
        if (l) {
          s.appendChild(l.cloneNode(true));
          break;
        }
      }
    s.childNodes.length && r.insertBefore(s, r.firstChild);
  });
}
async function Att(t15, e = false, r = false, n = {}) {
  var _a3;
  const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new Map();
  let o;
  try {
    o = jh(t15, i, s, a, e, n, t15);
  } catch (c) {
    throw console.warn("deepClone failed:", c), c;
  }
  try {
    await W9(t15, o, i, s, e, r, n.useProxy);
  } catch (c) {
    console.warn("inlinePseudoElements failed:", c);
  }
  try {
    Stt(o);
  } catch (c) {
    console.warn("inlineExternalDef failed:", c);
  }
  let l = "";
  if (e) {
    const c = mtt(i);
    l = Array.from(c.entries()).map(([h, p]) => `.${p}{${h}}`).join("");
    for (const [h, p] of i.entries()) {
      if (h.tagName === "STYLE") continue;
      const m = c.get(p);
      m && h.classList.add(m);
      const g = (_a3 = h.style) == null ? void 0 : _a3.backgroundImage;
      h.removeAttribute("style"), g && g !== "none" && (h.style.backgroundImage = g);
    }
  } else
    for (const [c, h] of i.entries())
      c.tagName !== "STYLE" && c.setAttribute("style", h.replace(/;/g, "; "));
  for (const [c, h] of a.entries()) {
    const p = h.scrollLeft, m = h.scrollTop;
    if ((p || m) && c instanceof HTMLElement) {
      c.style.overflow = "hidden", c.style.scrollbarWidth = "none", c.style.msOverflowStyle = "none";
      const g = document.createElement("div");
      for (g.style.transform = `translate(${-p}px, ${-m}px)`, g.style.willChange = "transform", g.style.display = "inline-block", g.style.width = "100%"; c.firstChild; )
        g.appendChild(c.firstChild);
      c.appendChild(g);
    }
  }
  if (t15 === a.get(o)) {
    const c = s.get(t15) || window.getComputedStyle(t15);
    s.set(t15, c);
    const h = ytt(c.transform);
    o.style.margin = "0", o.style.position = "static", o.style.top = "auto", o.style.left = "auto", o.style.right = "auto", o.style.bottom = "auto", o.style.zIndex = "auto", o.style.float = "none", o.style.clear = "none", o.style.transform = h || "";
  }
  for (const [c, h] of a.entries())
    h.tagName === "PRE" && (c.style.marginTop = "0", c.style.marginBlockStart = "0");
  return { clone: o, classCSS: l, styleCache: s };
}
async function Ttt(t15, e = {}) {
  const r = Array.from(t15.querySelectorAll("img")), n = async (i) => {
    const s = i.src;
    try {
      const a = await Sg(s, { useProxy: e.useProxy });
      i.src = a, i.width || (i.width = i.naturalWidth || 100), i.height || (i.height = i.naturalHeight || 100);
    } catch {
      const a = document.createElement("div");
      a.style = `width: ${i.width || 100}px; height: ${i.height || 100}px; background: #ccc; display: inline-block; text-align: center; line-height: ${i.height || 100}px; color: #666; font-size: 12px;`, a.innerText = "img", i.replaceWith(a);
    }
  };
  for (let i = 0; i < r.length; i += 4) {
    const s = r.slice(i, i + 4).map(n);
    await Promise.allSettled(s);
  }
}
async function $tt(t15, e, r, n = {}) {
  const i = [[t15, e]], s = [
    "background-image",
    "mask",
    "mask-image",
    "-webkit-mask-image",
    "mask-source",
    "mask-box-image-source",
    "mask-border-source",
    "-webkit-mask-box-image-source"
  ];
  for (; i.length; ) {
    const [a, o] = i.shift(), l = r.get(a) || _g(a);
    r.has(a) || r.set(a, l);
    for (const m of s) {
      const g = l.getPropertyValue(m);
      if (!g || g === "none") continue;
      const y = P9(g), x = await Promise.all(
        y.map((k) => z9(k, n))
      );
      x.some((k) => k && k !== "none" && !/^url\(undefined/.test(k)) && o.style.setProperty(m, x.join(", "));
    }
    const c = l.getPropertyValue("background-color");
    c && c !== "transparent" && c !== "rgba(0, 0, 0, 0)" && (o.style.backgroundColor = c);
    const h = Array.from(a.children), p = Array.from(o.children);
    for (let m = 0; m < Math.min(h.length, p.length); m++)
      i.push([h[m], p[m]]);
  }
}
async function Ett(t15, e = {}) {
  if (!t15) throw new Error("Element cannot be null or undefined");
  const { compress: r = true, embedFonts: n = false, fast: i = true, scale: s = 1, useProxy: a = "" } = e;
  let o, l, c, h = "", p = "", m, g;
  if ({ clone: o, classCSS: l, styleCache: c } = await Att(t15, r, n, e), await new Promise((x) => {
    Ko(async () => {
      await Ttt(o, e), x();
    }, { fast: i });
  }), await new Promise((x) => {
    Ko(async () => {
      await $tt(t15, o, c, e), x();
    }, { fast: i });
  }), n && await new Promise((x) => {
    Ko(async () => {
      h = await _tt(), x();
    }, { fast: i });
  }), r) {
    const x = ptt(o).sort(), k = x.join(",");
    Ip.has(k) ? p = Ip.get(k) : await new Promise((C) => {
      Ko(() => {
        p = ftt(x), Ip.set(k, p), C();
      }, { fast: i });
    });
  }
  await new Promise((x) => {
    Ko(() => {
      const k = t15.getBoundingClientRect();
      let C = k.width, A = k.height;
      const $ = Number.isFinite(e.width), B = Number.isFinite(e.height), L = typeof s == "number" && s !== 1;
      if (!L) {
        const W = k.width / k.height;
        $ && B ? (C = e.width, A = e.height) : $ ? (C = e.width, A = C / W) : B && (A = e.height, C = A * W);
      }
      if (C = Math.ceil(C), A = Math.ceil(A), o.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), o.style.transformOrigin = "top left", !L && ($ || B)) {
        const W = k.width, R = k.height, Q = C / W, rt = A / R, I = o.style.transform || "", j = `scale(${Q}, ${rt})`;
        o.style.transform = `${j} ${I}`.trim();
      } else L && R9() && (o.style.scale = `${s}`);
      const q = "http://www.w3.org/2000/svg", U = document.createElementNS(q, "foreignObject");
      U.setAttribute("width", "100%"), U.setAttribute("height", "100%");
      const G = document.createElement("style");
      G.textContent = p + h + "svg{overflow:visible;}" + l, U.appendChild(G), U.appendChild(o);
      const F = new XMLSerializer().serializeToString(U);
      g = `<svg xmlns="${q}" width="${C}" height="${A}" viewBox="0 0 ${C} ${A}">` + F + "</svg>", m = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(g)}`, x();
    }, { fast: i });
  });
  const y = document.getElementById("snapdom-sandbox");
  return y && y.style.position === "absolute" && y.remove(), m;
}
async function Mtt(t15, { dpr: e = 1, scale: r = 1 }) {
  const n = new Image();
  return n.src = t15, await n.decode(), R9 ? (n.width = n.width * r, n.height = n.height * r) : (n.width = n.width / r, n.height = n.height / r), n;
}
async function H9(t15, { dpr: e = 1, scale: r = 1 } = {}) {
  const n = new Image();
  n.src = t15, await n.decode();
  const i = document.createElement("canvas"), s = n.width * r, a = n.height * r;
  i.width = Math.ceil(s * e), i.height = Math.ceil(a * e);
  const o = i.getContext("2d");
  return o.scale(e, e), o.drawImage(n, 0, 0, s, a), i.style.width = `${s}px`, i.style.height = `${a}px`, i;
}
async function U9(t15, {
  type: e = "svg",
  scale: r = 1,
  backgroundColor: n = "#fff",
  quality: i
} = {}) {
  const s = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[e] || "image/png";
  if (e === "svg") {
    const o = decodeURIComponent(t15.split(",")[1]);
    return new Blob([o], { type: "image/svg+xml" });
  }
  const a = await Tg(t15, { dpr: 1, scale: r }, n);
  return new Promise((o) => {
    a.toBlob((l) => o(l), `${s}`, i);
  });
}
async function Tg(t15, { dpr: e = 1, scale: r = 1 }, n) {
  const i = await H9(t15, { dpr: e, scale: r });
  if (!n) return i;
  const s = document.createElement("canvas");
  s.width = i.width, s.height = i.height;
  const a = s.getContext("2d");
  return a.fillStyle = n, a.fillRect(0, 0, s.width, s.height), a.drawImage(i, 0, 0), s;
}
async function qp(t15, { dpr: e = 1, scale: r = 1, backgroundColor: n = "#fff", quality: i }, s = "png") {
  const a = await Tg(t15, { dpr: e, scale: r }, n), o = new Image();
  return o.src = a.toDataURL(`image/${s}`, i), await o.decode(), o.style.width = `${a.width / e}px`, o.style.height = `${a.height / e}px`, o;
}
async function Btt(t15, { dpr: e = 1, scale: r = 1, backgroundColor: n = "#fff", format: i = "png", filename: s = "capture" } = {}) {
  if (i === "svg") {
    const p = await U9(t15), m = URL.createObjectURL(p), g = document.createElement("a");
    g.href = m, g.download = `${s}.svg`, g.click(), URL.revokeObjectURL(m);
    return;
  }
  const a = ["jpg", "jpeg", "webp"].includes(i) ? "#fff" : void 0, o = await Tg(t15, { dpr: e, scale: r }, n ?? a), l = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[i] || "image/png", c = o.toDataURL(l), h = document.createElement("a");
  h.href = c, h.download = `${s}.${i}`, h.click();
}
async function Ze(t15, e = {}) {
  if (e = { scale: 1, ...e }, !t15) throw new Error("Element cannot be null or undefined");
  return e.iconFonts && ktt(e.iconFonts), await Ze.capture(t15, e);
}
Ze.capture = async (t15, e = {}) => {
  const r = await Ett(t15, e), n = window.devicePixelRatio || 1, i = e.scale || 1;
  return {
    url: r,
    options: e,
    toRaw: () => r,
    toImg: () => Mtt(r, { dpr: n, scale: i }),
    toCanvas: () => H9(r, { dpr: n, scale: i }),
    toBlob: (s) => U9(r, { scale: i, ...s }),
    toPng: (s) => qp(r, { dpr: n, scale: i, ...s }, "png"),
    toJpg: (s) => qp(r, { dpr: n, scale: i, ...s }, "jpeg"),
    toWebp: (s) => qp(r, { dpr: n, scale: i, ...s }, "webp"),
    download: ({ format: s = "png", filename: a = "capture", backgroundColor: o } = {}) => Btt(r, { dpr: n, scale: i, backgroundColor: o, format: s, filename: a })
  };
};
Ze.toRaw = async (t15, e) => (await Ze.capture(t15, e)).toRaw();
Ze.toImg = async (t15, e) => (await Ze.capture(t15, e)).toImg();
Ze.toCanvas = async (t15, e) => (await Ze.capture(t15, e)).toCanvas();
Ze.toBlob = async (t15, e) => (await Ze.capture(t15, e)).toBlob(e);
Ze.toPng = async (t15, e) => (await Ze.capture(t15, e)).toPng(e);
Ze.toJpg = async (t15, e) => (await Ze.capture(t15, e)).toJpg(e);
Ze.toWebp = async (t15, e) => (await Ze.capture(t15, e)).toWebp(e);
Ze.download = async (t15, e = {}) => {
  const {
    format: r = "png",
    filename: n = "capture",
    backgroundColor: i,
    ...s
  } = e;
  return await (await Ze.capture(t15, s)).download({ format: r, filename: n, backgroundColor: i });
};
function Ltt(t15) {
  navigator.clipboard.writeText(t15);
}
var v1 = 1;
var Dtt = class {
  constructor() {
    __publicField(this, "subscribers");
    __publicField(this, "toasts");
    __publicField(this, "dismissedToasts");
    __publicField(this, "subscribe", (t15) => (this.subscribers.push(t15), () => {
      const e = this.subscribers.indexOf(t15);
      this.subscribers.splice(e, 1);
    }));
    __publicField(this, "publish", (t15) => {
      this.subscribers.forEach((e) => e(t15));
    });
    __publicField(this, "addToast", (t15) => {
      this.publish(t15), this.toasts = [...this.toasts, t15];
    });
    __publicField(this, "create", (t15) => {
      var _a3;
      const { message: e, ...r } = t15, n = typeof t15.id == "number" || t15.id && ((_a3 = t15.id) == null ? void 0 : _a3.length) > 0 ? t15.id : v1++, i = this.toasts.find((a) => a.id === n), s = t15.dismissible === void 0 ? true : t15.dismissible;
      return this.dismissedToasts.has(n) && this.dismissedToasts.delete(n), i ? this.toasts = this.toasts.map((a) => a.id === n ? (this.publish({
        ...a,
        ...t15,
        id: n,
        title: e
      }), {
        ...a,
        ...t15,
        id: n,
        dismissible: s,
        title: e
      }) : a) : this.addToast({
        title: e,
        ...r,
        dismissible: s,
        id: n
      }), n;
    });
    __publicField(this, "dismiss", (t15) => (t15 ? (this.dismissedToasts.add(t15), requestAnimationFrame(() => this.subscribers.forEach((e) => e({
      id: t15,
      dismiss: true
    })))) : this.toasts.forEach((e) => {
      this.subscribers.forEach((r) => r({
        id: e.id,
        dismiss: true
      }));
    }), t15));
    __publicField(this, "message", (t15, e) => this.create({
      ...e,
      message: t15,
      type: "default"
    }));
    __publicField(this, "error", (t15, e) => this.create({
      ...e,
      type: "error",
      message: t15
    }));
    __publicField(this, "success", (t15, e) => this.create({
      ...e,
      type: "success",
      message: t15
    }));
    __publicField(this, "info", (t15, e) => this.create({
      ...e,
      type: "info",
      message: t15
    }));
    __publicField(this, "warning", (t15, e) => this.create({
      ...e,
      type: "warning",
      message: t15
    }));
    __publicField(this, "loading", (t15, e) => this.create({
      ...e,
      type: "loading",
      message: t15
    }));
    __publicField(this, "promise", (t15, e) => {
      if (!e) return;
      let r;
      e.loading !== void 0 && (r = this.create({
        ...e,
        promise: t15,
        type: "loading",
        message: e.loading,
        description: typeof e.description != "function" ? e.description : void 0
      }));
      const n = Promise.resolve(t15 instanceof Function ? t15() : t15);
      let i = r !== void 0, s;
      const a = n.then(async (l) => {
        if (s = ["resolve", l], isVNode(l))
          i = false, this.create({
            id: r,
            type: "default",
            message: l
          });
        else if (Ntt(l) && !l.ok) {
          i = false;
          const c = typeof e.error == "function" ? await e.error(`HTTP error! status: ${l.status}`) : e.error, h = typeof e.description == "function" ? await e.description(`HTTP error! status: ${l.status}`) : e.description, p = typeof c == "object" && !isVNode(c) ? c : {
            message: c || "",
            id: r || ""
          };
          this.create({
            id: r,
            type: "error",
            description: h,
            ...p
          });
        } else if (l instanceof Error) {
          i = false;
          const c = typeof e.error == "function" ? await e.error(l) : e.error, h = typeof e.description == "function" ? await e.description(l) : e.description, p = typeof c == "object" && !isVNode(c) ? c : {
            message: c || "",
            id: r || ""
          };
          this.create({
            id: r,
            type: "error",
            description: h,
            ...p
          });
        } else if (e.success !== void 0) {
          i = false;
          const c = typeof e.success == "function" ? await e.success(l) : e.success, h = typeof e.description == "function" ? await e.description(l) : e.description, p = typeof c == "object" && !isVNode(c) ? c : {
            message: c || "",
            id: r || ""
          };
          this.create({
            id: r,
            type: "success",
            description: h,
            ...p
          });
        }
      }).catch(async (l) => {
        if (s = ["reject", l], e.error !== void 0) {
          i = false;
          const c = typeof e.error == "function" ? await e.error(l) : e.error, h = typeof e.description == "function" ? await e.description(l) : e.description, p = typeof c == "object" && !isVNode(c) ? c : {
            message: c || "",
            id: r || ""
          };
          this.create({
            id: r,
            type: "error",
            description: h,
            ...p
          });
        }
      }).finally(() => {
        var _a3;
        i && (this.dismiss(r), r = void 0), (_a3 = e.finally) == null ? void 0 : _a3.call(e);
      }), o = () => new Promise((l, c) => a.then(() => s[0] === "reject" ? c(s[1]) : l(s[1])).catch(c));
      return typeof r != "string" && typeof r != "number" ? { unwrap: o } : Object.assign(r, { unwrap: o });
    });
    __publicField(this, "custom", (t15, e) => {
      const r = (e == null ? void 0 : e.id) || v1++;
      return this.publish({
        component: t15,
        id: r,
        ...e
      }), r;
    });
    __publicField(this, "getActiveToasts", () => this.toasts.filter((t15) => !this.dismissedToasts.has(t15.id)));
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
};
var Ir = new Dtt();
function Ftt(t15, e) {
  const r = (e == null ? void 0 : e.id) || v1++;
  return Ir.create({
    message: t15,
    id: r,
    type: "default",
    ...e
  }), r;
}
var Ntt = (t15) => t15 && typeof t15 == "object" && "ok" in t15 && typeof t15.ok == "boolean" && "status" in t15 && typeof t15.status == "number";
var Itt = Ftt;
var Ott = () => Ir.toasts;
var ztt = () => Ir.getActiveToasts();
var mh = Object.assign(Itt, {
  success: Ir.success,
  info: Ir.info,
  warning: Ir.warning,
  error: Ir.error,
  custom: Ir.custom,
  message: Ir.message,
  promise: Ir.promise,
  dismiss: Ir.dismiss,
  loading: Ir.loading
}, {
  getHistory: Ott,
  getToasts: ztt
});
function gh(t15) {
  return t15.label !== void 0;
}
var qtt = 3;
var V9 = "24px";
var G9 = "16px";
var c5 = 4e3;
var Rtt = 356;
var Ptt = 14;
var jtt = 45;
var X9 = 200;
function Wtt() {
  const t15 = ref(false);
  return watchEffect(() => {
    const e = () => {
      t15.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", e), () => window.removeEventListener("visibilitychange", e);
  }), { isDocumentHidden: t15 };
}
function Pi(...t15) {
  return t15.filter(Boolean).join(" ");
}
function Htt(t15) {
  const [e, r] = t15.split("-"), n = [];
  return e && n.push(e), r && n.push(r), n;
}
function Utt(t15, e) {
  const r = {};
  return [t15, e].forEach((n, i) => {
    const s = i === 1, a = s ? "--mobile-offset" : "--offset", o = s ? G9 : V9;
    function l(c) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((h) => {
        r[`${a}-${h}`] = typeof c == "number" ? `${c}px` : c;
      });
    }
    typeof n == "number" || typeof n == "string" ? l(n) : typeof n == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((c) => {
      n[c] === void 0 ? r[`${a}-${c}`] = o : r[`${a}-${c}`] = typeof n[c] == "number" ? `${n[c]}px` : n[c];
    }) : l(o);
  }), r;
}
var Vtt = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded"
];
var Gtt = ["aria-label", "data-disabled"];
var Xtt = defineComponent({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(t15, { emit: e }) {
    const r = t15, n = e, i = ref(null), s = ref(null), a = ref(false), o = ref(false), l = ref(false), c = ref(false), h = ref(false), p = ref(0), m = ref(0), g = ref(r.toast.duration || r.duration || c5), y = ref(null), x = ref(null), k = computed(() => r.index === 0), C = computed(() => r.index + 1 <= r.visibleToasts), A = computed(() => r.toast.type), $ = computed(() => r.toast.dismissible !== false), B = computed(() => r.toast.class || ""), L = computed(() => r.descriptionClass || ""), q = computed(() => {
      const H = r.toast.position || r.position, mt = r.heights.filter((wt) => wt.position === H).findIndex((wt) => wt.toastId === r.toast.id);
      return mt >= 0 ? mt : 0;
    }), U = computed(() => {
      const H = r.toast.position || r.position;
      return r.heights.filter((mt) => mt.position === H).reduce((mt, wt, At) => At >= q.value ? mt : mt + wt.height, 0);
    }), G = computed(() => q.value * r.gap + U.value || 0), F = computed(() => r.toast.closeButton ?? r.closeButton), W = computed(() => r.toast.duration || r.duration || c5), R = ref(0), Q = ref(0), rt = ref(null), I = computed(() => r.position.split("-")), j = computed(() => I.value[0]), z = computed(() => I.value[1]), K = computed(() => typeof r.toast.title != "string"), Y = computed(() => typeof r.toast.description != "string"), { isDocumentHidden: ot } = Wtt(), et = computed(() => A.value && A.value === "loading");
    onMounted(() => {
      a.value = true, g.value = W.value;
    }), watchEffect(async () => {
      if (!a.value || !x.value) return;
      await nextTick();
      const H = x.value, mt = H.style.height;
      H.style.height = "auto";
      const wt = H.getBoundingClientRect().height;
      H.style.height = mt, m.value = wt, n("update:height", {
        toastId: r.toast.id,
        height: wt,
        position: r.toast.position || r.position
      });
    });
    function ht() {
      o.value = true, p.value = G.value, setTimeout(() => {
        n("removeToast", r.toast);
      }, X9);
    }
    function X() {
      var _a3, _b2;
      if (et.value || !$.value) return {};
      ht(), (_b2 = (_a3 = r.toast).onDismiss) == null ? void 0 : _b2.call(_a3, r.toast);
    }
    function ct(H) {
      et.value || !$.value || (y.value = /* @__PURE__ */ new Date(), p.value = G.value, H.target.setPointerCapture(H.pointerId), H.target.tagName !== "BUTTON" && (l.value = true, rt.value = {
        x: H.clientX,
        y: H.clientY
      }));
    }
    function gt() {
      var _a3, _b2, _c, _d, _e, _f2, _g2;
      if (c.value || !$.value) return;
      rt.value = null;
      const H = Number(((_a3 = x.value) == null ? void 0 : _a3.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), mt = Number(((_b2 = x.value) == null ? void 0 : _b2.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), wt = (/* @__PURE__ */ new Date()).getTime() - (((_c = y.value) == null ? void 0 : _c.getTime()) || 0), At = i.value === "x" ? H : mt, Ht = Math.abs(At) / wt;
      if (Math.abs(At) >= jtt || Ht > 0.11) {
        p.value = G.value, (_e = (_d = r.toast).onDismiss) == null ? void 0 : _e.call(_d, r.toast), i.value === "x" ? s.value = H > 0 ? "right" : "left" : s.value = mt > 0 ? "down" : "up", ht(), c.value = true;
        return;
      } else
        (_f2 = x.value) == null ? void 0 : _f2.style.setProperty("--swipe-amount-x", "0px"), (_g2 = x.value) == null ? void 0 : _g2.style.setProperty("--swipe-amount-y", "0px");
      h.value = false, l.value = false, i.value = null;
    }
    function xt(H) {
      var _a3, _b2, _c, _d;
      if (!rt.value || !$.value || (((_b2 = (_a3 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a3.toString()) == null ? void 0 : _b2.length) ?? false)) return;
      const mt = H.clientY - rt.value.y, wt = H.clientX - rt.value.x, At = r.swipeDirections ?? Htt(r.position);
      !i.value && (Math.abs(wt) > 1 || Math.abs(mt) > 1) && (i.value = Math.abs(wt) > Math.abs(mt) ? "x" : "y");
      let Ht = {
        x: 0,
        y: 0
      };
      const Ce = (he) => 1 / (1.5 + Math.abs(he) / 20);
      if (i.value === "y") {
        if (At.includes("top") || At.includes("bottom")) if (At.includes("top") && mt < 0 || At.includes("bottom") && mt > 0) Ht.y = mt;
        else {
          const he = mt * Ce(mt);
          Ht.y = Math.abs(he) < Math.abs(mt) ? he : mt;
        }
      } else if (i.value === "x" && (At.includes("left") || At.includes("right")))
        if (At.includes("left") && wt < 0 || At.includes("right") && wt > 0) Ht.x = wt;
        else {
          const he = wt * Ce(wt);
          Ht.x = Math.abs(he) < Math.abs(wt) ? he : wt;
        }
      (Math.abs(Ht.x) > 0 || Math.abs(Ht.y) > 0) && (h.value = true), (_c = x.value) == null ? void 0 : _c.style.setProperty("--swipe-amount-x", `${Ht.x}px`), (_d = x.value) == null ? void 0 : _d.style.setProperty("--swipe-amount-y", `${Ht.y}px`);
    }
    onMounted(() => {
      if (a.value = true, !x.value) return;
      const H = x.value.getBoundingClientRect().height;
      m.value = H;
      const mt = [{
        toastId: r.toast.id,
        height: H,
        position: r.toast.position
      }, ...r.heights];
      n("update:heights", mt);
    }), onBeforeUnmount(() => {
      x.value && n("removeToast", r.toast);
    }), watchEffect((H) => {
      if (r.toast.promise && A.value === "loading" || r.toast.duration === 1 / 0 || r.toast.type === "loading") return;
      let mt;
      const wt = () => {
        if (Q.value < R.value) {
          const Ht = (/* @__PURE__ */ new Date()).getTime() - R.value;
          g.value = g.value - Ht;
        }
        Q.value = (/* @__PURE__ */ new Date()).getTime();
      }, At = () => {
        g.value !== 1 / 0 && (R.value = (/* @__PURE__ */ new Date()).getTime(), mt = setTimeout(() => {
          var _a3, _b2;
          (_b2 = (_a3 = r.toast).onAutoClose) == null ? void 0 : _b2.call(_a3, r.toast), ht();
        }, g.value));
      };
      r.expanded || r.interacting || ot.value ? wt() : At(), H(() => {
        clearTimeout(mt);
      });
    }), watch(() => r.toast.delete, (H) => {
      H !== void 0 && H && ht();
    }, { deep: true });
    function Xt() {
      l.value = false, i.value = null, rt.value = null;
    }
    return (H, mt) => {
      var _a3, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p2, _q2, _r2, _s2, _t, _u2, _v2, _w2, _x2, _y, _z2, _A2;
      return openBlock(), createElementBlock("li", {
        tabindex: "0",
        ref_key: "toastRef",
        ref: x,
        class: normalizeClass(unref(Pi)(r.class, B.value, (_a3 = H.classes) == null ? void 0 : _a3.toast, (_b2 = H.toast.classes) == null ? void 0 : _b2.toast, (_c = H.classes) == null ? void 0 : _c[A.value], (_e = (_d = H.toast) == null ? void 0 : _d.classes) == null ? void 0 : _e[A.value])),
        "data-sonner-toast": "",
        "data-rich-colors": H.toast.richColors ?? H.defaultRichColors,
        "data-styled": !(H.toast.component || ((_f2 = H.toast) == null ? void 0 : _f2.unstyled) || H.unstyled),
        "data-mounted": a.value,
        "data-promise": !!H.toast.promise,
        "data-swiped": h.value,
        "data-removed": o.value,
        "data-visible": C.value,
        "data-y-position": j.value,
        "data-x-position": z.value,
        "data-index": H.index,
        "data-front": k.value,
        "data-swiping": l.value,
        "data-dismissible": $.value,
        "data-type": A.value,
        "data-invert": H.toast.invert || H.invert,
        "data-swipe-out": c.value,
        "data-swipe-direction": s.value,
        "data-expanded": !!(H.expanded || H.expandByDefault && a.value),
        style: normalizeStyle({
          "--index": H.index,
          "--toasts-before": H.index,
          "--z-index": H.toasts.length - H.index,
          "--offset": `${o.value ? p.value : G.value}px`,
          "--initial-height": H.expandByDefault ? "auto" : `${m.value}px`,
          ...H.style,
          ...r.toast.style
        }),
        onDragend: Xt,
        onPointerdown: ct,
        onPointerup: gt,
        onPointermove: xt
      }, [F.value && !H.toast.component && A.value !== "loading" ? (openBlock(), createElementBlock("button", {
        key: 0,
        "aria-label": H.closeButtonAriaLabel || "Close toast",
        "data-disabled": et.value,
        "data-close-button": "true",
        class: normalizeClass(unref(Pi)((_g2 = H.classes) == null ? void 0 : _g2.closeButton, (_i2 = (_h2 = H.toast) == null ? void 0 : _h2.classes) == null ? void 0 : _i2.closeButton)),
        onClick: X
      }, [((_j2 = H.icons) == null ? void 0 : _j2.close) ? (openBlock(), createBlock(resolveDynamicComponent((_k2 = H.icons) == null ? void 0 : _k2.close), { key: 0 })) : renderSlot(H.$slots, "close-icon", { key: 1 })], 10, Gtt)) : createCommentVNode("v-if", true), H.toast.component ? (openBlock(), createBlock(resolveDynamicComponent(H.toast.component), mergeProps({ key: 1 }, H.toast.componentProps, { onCloseToast: X }), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        A.value !== "default" || H.toast.icon || H.toast.promise ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-icon": "",
          class: normalizeClass(unref(Pi)((_l2 = H.classes) == null ? void 0 : _l2.icon, (_n2 = (_m2 = H.toast) == null ? void 0 : _m2.classes) == null ? void 0 : _n2.icon))
        }, [H.toast.icon ? (openBlock(), createBlock(resolveDynamicComponent(H.toast.icon), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [A.value === "loading" ? renderSlot(H.$slots, "loading-icon", { key: 0 }) : A.value === "success" ? renderSlot(H.$slots, "success-icon", { key: 1 }) : A.value === "error" ? renderSlot(H.$slots, "error-icon", { key: 2 }) : A.value === "warning" ? renderSlot(H.$slots, "warning-icon", { key: 3 }) : A.value === "info" ? renderSlot(H.$slots, "info-icon", { key: 4 }) : createCommentVNode("v-if", true)], 64))], 2)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          "data-content": "",
          class: normalizeClass(unref(Pi)((_o = H.classes) == null ? void 0 : _o.content, (_q2 = (_p2 = H.toast) == null ? void 0 : _p2.classes) == null ? void 0 : _q2.content))
        }, [createBaseVNode("div", {
          "data-title": "",
          class: normalizeClass(unref(Pi)((_r2 = H.classes) == null ? void 0 : _r2.title, (_s2 = H.toast.classes) == null ? void 0 : _s2.title))
        }, [K.value ? (openBlock(), createBlock(resolveDynamicComponent(H.toast.title), normalizeProps(mergeProps({ key: 0 }, H.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(H.toast.title), 1)], 64))], 2), H.toast.description ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-description": "",
          class: normalizeClass(unref(Pi)(H.descriptionClass, L.value, (_t = H.classes) == null ? void 0 : _t.description, (_u2 = H.toast.classes) == null ? void 0 : _u2.description))
        }, [Y.value ? (openBlock(), createBlock(resolveDynamicComponent(H.toast.description), normalizeProps(mergeProps({ key: 0 }, H.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(H.toast.description), 1)], 64))], 2)) : createCommentVNode("v-if", true)], 2),
        H.toast.cancel ? (openBlock(), createElementBlock("button", {
          key: 1,
          style: normalizeStyle(H.toast.cancelButtonStyle || H.cancelButtonStyle),
          class: normalizeClass(unref(Pi)((_v2 = H.classes) == null ? void 0 : _v2.cancelButton, (_w2 = H.toast.classes) == null ? void 0 : _w2.cancelButton)),
          "data-button": "",
          "data-cancel": "",
          onClick: mt[0] || (mt[0] = (wt) => {
            var _a4, _b3;
            unref(gh)(H.toast.cancel) && $.value && ((_b3 = (_a4 = H.toast.cancel).onClick) == null ? void 0 : _b3.call(_a4, wt), ht());
          })
        }, toDisplayString(unref(gh)(H.toast.cancel) ? (_x2 = H.toast.cancel) == null ? void 0 : _x2.label : H.toast.cancel), 7)) : createCommentVNode("v-if", true),
        H.toast.action ? (openBlock(), createElementBlock("button", {
          key: 2,
          style: normalizeStyle(H.toast.actionButtonStyle || H.actionButtonStyle),
          class: normalizeClass(unref(Pi)((_y = H.classes) == null ? void 0 : _y.actionButton, (_z2 = H.toast.classes) == null ? void 0 : _z2.actionButton)),
          "data-button": "",
          "data-action": "",
          onClick: mt[1] || (mt[1] = (wt) => {
            var _a4, _b3;
            unref(gh)(H.toast.action) && ((_b3 = (_a4 = H.toast.action).onClick) == null ? void 0 : _b3.call(_a4, wt), !wt.defaultPrevented && ht());
          })
        }, toDisplayString(unref(gh)(H.toast.action) ? (_A2 = H.toast.action) == null ? void 0 : _A2.label : H.toast.action), 7)) : createCommentVNode("v-if", true)
      ], 64))], 46, Vtt);
    };
  }
});
var Ytt = Xtt;
var xc = (t15, e) => {
  const r = t15.__vccOpts || t15;
  for (const [n, i] of e) r[n] = i;
  return r;
};
var Ktt = {};
var Ztt = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Jtt(t15, e) {
  return openBlock(), createElementBlock("svg", Ztt, e[0] || (e[0] = [createBaseVNode("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), createBaseVNode("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var Qtt = xc(Ktt, [["render", Jtt]]);
var tet = ["data-visible"];
var eet = { class: "sonner-spinner" };
var ret = defineComponent({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(t15) {
    const e = Array(12).fill(0);
    return (r, n) => (openBlock(), createElementBlock("div", {
      class: "sonner-loading-wrapper",
      "data-visible": r.visible
    }, [createBaseVNode("div", eet, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(e), (i) => (openBlock(), createElementBlock("div", {
      key: `spinner-bar-${i}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, tet));
  }
});
var net = ret;
var iet = {};
var set = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function aet(t15, e) {
  return openBlock(), createElementBlock("svg", set, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var oet = xc(iet, [["render", aet]]);
var cet = {};
var het = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function uet(t15, e) {
  return openBlock(), createElementBlock("svg", het, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var det = xc(cet, [["render", uet]]);
var pet = {};
var fet = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function met(t15, e) {
  return openBlock(), createElementBlock("svg", fet, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var get = xc(pet, [["render", met]]);
var yet = {};
var bet = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function xet(t15, e) {
  return openBlock(), createElementBlock("svg", bet, e[0] || (e[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var wet = xc(yet, [["render", xet]]);
var ket = ["aria-label"];
var vet = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position",
  "data-lifted"
];
var Cet = typeof window < "u" && typeof document < "u";
function _et() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const t15 = document.documentElement.getAttribute("dir");
  return t15 === "auto" || !t15 ? window.getComputedStyle(document.documentElement).direction : t15;
}
var Aet = defineComponent({
  name: "Toaster",
  inheritAttrs: false,
  __name: "Toaster",
  props: {
    invert: {
      type: Boolean,
      default: false
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: false
    },
    expand: {
      type: Boolean,
      default: false
    },
    duration: {},
    gap: { default: Ptt },
    visibleToasts: { default: qtt },
    closeButton: {
      type: Boolean,
      default: false
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: V9 },
    mobileOffset: { default: G9 },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(t15) {
    const e = t15, r = useAttrs(), n = ref([]);
    function i(F, W) {
      return n.value.filter((R) => !R.position && W === 0 || R.position === F);
    }
    const s = computed(() => {
      const F = n.value.filter((W) => W.position).map((W) => W.position);
      return F.length > 0 ? Array.from(new Set([e.position].concat(F))) : [e.position];
    }), a = computed(() => {
      const F = {};
      return s.value.forEach((W) => {
        F[W] = n.value.filter((R) => R.position === W);
      }), F;
    }), o = ref([]), l = ref(false), c = ref(false), h = ref(e.theme !== "system" ? e.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = ref(null), m = ref(null), g = ref(false), y = e.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function x(F) {
      var _a3;
      ((_a3 = n.value.find((W) => W.id === F.id)) == null ? void 0 : _a3.delete) || Ir.dismiss(F.id), n.value = n.value.filter(({ id: W }) => W !== F.id), setTimeout(() => {
        n.value.find((W) => W.id === F.id) || (o.value = o.value.filter((W) => W.toastId !== F.id));
      }, X9 + 50);
    }
    function k(F) {
      var _a3, _b2;
      g.value && !((_b2 = (_a3 = F.currentTarget) == null ? void 0 : _a3.contains) == null ? void 0 : _b2.call(_a3, F.relatedTarget)) && (g.value = false, m.value && (m.value.focus({ preventScroll: true }), m.value = null));
    }
    function C(F) {
      F.target instanceof HTMLElement && F.target.dataset.dismissible === "false" || g.value || (g.value = true, m.value = F.relatedTarget);
    }
    function A(F) {
      F.target && F.target instanceof HTMLElement && F.target.dataset.dismissible === "false" || (c.value = true);
    }
    watchEffect((F) => {
      const W = Ir.subscribe((R) => {
        if (R.dismiss) {
          requestAnimationFrame(() => {
            n.value = n.value.map((Q) => Q.id === R.id ? {
              ...Q,
              delete: true
            } : Q);
          });
          return;
        }
        nextTick(() => {
          const Q = n.value.findIndex((rt) => rt.id === R.id);
          Q !== -1 ? n.value = [
            ...n.value.slice(0, Q),
            {
              ...n.value[Q],
              ...R
            },
            ...n.value.slice(Q + 1)
          ] : n.value = [R, ...n.value];
        });
      });
      F(W);
    }), watchEffect((F) => {
      if (typeof window > "u") return;
      if (e.theme !== "system") {
        h.value = e.theme;
        return;
      }
      const W = window.matchMedia("(prefers-color-scheme: dark)"), R = (rt) => {
        h.value = rt ? "dark" : "light";
      };
      R(W.matches);
      const Q = (rt) => {
        R(rt.matches);
      };
      try {
        W.addEventListener("change", Q);
      } catch {
        W.addListener(Q);
      }
      F(() => {
        try {
          W.removeEventListener("change", Q);
        } catch {
          W.removeListener(Q);
        }
      });
    }), watchEffect(() => {
      p.value && m.value && (m.value.focus({ preventScroll: true }), m.value = null, g.value = false);
    }), watchEffect(() => {
      n.value.length <= 1 && (l.value = false);
    }), watchEffect((F) => {
      function W(R) {
        const Q = e.hotkey.every((j) => R[j] || R.code === j), rt = Array.isArray(p.value) ? p.value[0] : p.value;
        Q && (l.value = true, rt == null ? void 0 : rt.focus());
        const I = document.activeElement === p.value || (rt == null ? void 0 : rt.contains(document.activeElement));
        R.code === "Escape" && I && (l.value = false);
      }
      Cet && (document.addEventListener("keydown", W), F(() => {
        document.removeEventListener("keydown", W);
      }));
    });
    function $() {
      l.value = true;
    }
    function B() {
      c.value || (l.value = false);
    }
    function L() {
      l.value = false;
    }
    function q() {
      c.value = false;
    }
    function U(F) {
      o.value = F;
    }
    function G(F) {
      const W = o.value.findIndex((R) => R.toastId === F.toastId);
      if (W !== -1) o.value[W] = F;
      else {
        const R = o.value.findIndex((Q) => Q.position === F.position);
        R !== -1 ? o.value.splice(R, 0, F) : o.value.unshift(F);
      }
    }
    return (F, W) => (openBlock(), createElementBlock(Fragment, null, [createCommentVNode(" Remove item from normal navigation flow, only available via hotkey "), createBaseVNode("section", {
      "aria-label": `${F.containerAriaLabel} ${unref(y)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (R, Q) => {
      var _a3;
      return openBlock(), createElementBlock("ol", mergeProps({
        key: R,
        ref_for: true,
        ref_key: "listRef",
        ref: p,
        "data-sonner-toaster": "",
        "data-sonner-theme": h.value,
        class: e.class,
        dir: F.dir === "auto" ? _et() : F.dir,
        tabIndex: -1,
        "data-theme": F.theme,
        "data-rich-colors": F.richColors,
        "data-y-position": R.split("-")[0],
        "data-x-position": R.split("-")[1],
        "data-lifted": l.value && n.value.length > 1 && !F.expand,
        style: {
          "--front-toast-height": `${((_a3 = o.value[0]) == null ? void 0 : _a3.height) || 0}px`,
          "--width": `${unref(Rtt)}px`,
          "--gap": `${F.gap}px`,
          ...F.style,
          ...unref(r).style,
          ...unref(Utt)(F.offset, F.mobileOffset)
        }
      }, F.$attrs, {
        onBlur: k,
        onFocus: C,
        onMouseenter: $,
        onMousemove: $,
        onMouseleave: B,
        onDragend: L,
        onPointerdown: A,
        onPointerup: q
      }), [(openBlock(true), createElementBlock(Fragment, null, renderList(i(R, Q), (rt, I) => {
        var _a4, _b2, _c, _d, _e, _f2, _g2, _h2, _i2, _j2;
        return openBlock(), createBlock(Ytt, {
          key: rt.id,
          heights: o.value,
          icons: F.icons,
          index: I,
          toast: rt,
          defaultRichColors: F.richColors,
          duration: ((_a4 = F.toastOptions) == null ? void 0 : _a4.duration) ?? F.duration,
          class: normalizeClass(((_b2 = F.toastOptions) == null ? void 0 : _b2.class) ?? ""),
          descriptionClass: (_c = F.toastOptions) == null ? void 0 : _c.descriptionClass,
          invert: F.invert,
          visibleToasts: F.visibleToasts,
          closeButton: ((_d = F.toastOptions) == null ? void 0 : _d.closeButton) ?? F.closeButton,
          interacting: c.value,
          position: R,
          style: normalizeStyle((_e = F.toastOptions) == null ? void 0 : _e.style),
          unstyled: (_f2 = F.toastOptions) == null ? void 0 : _f2.unstyled,
          classes: (_g2 = F.toastOptions) == null ? void 0 : _g2.classes,
          cancelButtonStyle: (_h2 = F.toastOptions) == null ? void 0 : _h2.cancelButtonStyle,
          actionButtonStyle: (_i2 = F.toastOptions) == null ? void 0 : _i2.actionButtonStyle,
          "close-button-aria-label": (_j2 = F.toastOptions) == null ? void 0 : _j2.closeButtonAriaLabel,
          toasts: a.value[R],
          expandByDefault: F.expand,
          gap: F.gap,
          expanded: l.value,
          swipeDirections: e.swipeDirections,
          "onUpdate:heights": U,
          "onUpdate:height": G,
          onRemoveToast: x
        }, {
          "close-icon": withCtx(() => [renderSlot(F.$slots, "close-icon", {}, () => [createVNode(Qtt)])]),
          "loading-icon": withCtx(() => [renderSlot(F.$slots, "loading-icon", {}, () => [createVNode(net, { visible: rt.type === "loading" }, null, 8, ["visible"])])]),
          "success-icon": withCtx(() => [renderSlot(F.$slots, "success-icon", {}, () => [createVNode(oet)])]),
          "error-icon": withCtx(() => [renderSlot(F.$slots, "error-icon", {}, () => [createVNode(wet)])]),
          "warning-icon": withCtx(() => [renderSlot(F.$slots, "warning-icon", {}, () => [createVNode(get)])]),
          "info-icon": withCtx(() => [renderSlot(F.$slots, "info-icon", {}, () => [createVNode(det)])]),
          _: 2
        }, 1032, [
          "heights",
          "icons",
          "index",
          "toast",
          "defaultRichColors",
          "duration",
          "class",
          "descriptionClass",
          "invert",
          "visibleToasts",
          "closeButton",
          "interacting",
          "position",
          "style",
          "unstyled",
          "classes",
          "cancelButtonStyle",
          "actionButtonStyle",
          "close-button-aria-label",
          "toasts",
          "expandByDefault",
          "gap",
          "expanded",
          "swipeDirections"
        ]);
      }), 128))], 16, vet);
    }), 128))], 8, ket)], 2112));
  }
});
var Tet = Aet;
var $et = ["innerHTML"];
var Eet = { class: "mermaid-toolbar" };
var Met = defineComponent({
  __name: "MermaidChart",
  props: {
    code: { default: "" },
    showToolbar: { type: Boolean, default: false }
  },
  setup(t15) {
    const e = t15, r = computed(() => decodeURIComponent(e.code)), n = ref(), i = ref(), s = ref(), a = ref(false);
    async function o() {
      if (!i.value) return;
      i.value.innerHTML = "", await s5.initialize({
        startOnLoad: false,
        theme: document.documentElement.classList.contains("dark") ? "dark" : "default",
        securityLevel: "loose"
        // 允许点击交互
      });
      const p = Math.random().toString(36).substring(2, 15), { svg: m } = await s5.render(
        `mermaid-${p}`,
        r.value,
        i.value
      );
      n.value = m;
    }
    async function l() {
      if (s.value) {
        a.value = false;
        try {
          await (await Ze(s.value, {
            scale: 2,
            quality: 1,
            backgroundColor: getComputedStyle(
              document.documentElement
            ).getPropertyValue("--vp-c-bg-soft")
          })).download({ format: "png", filename: "mermaid-chart" }), mh.success("图表下载成功！");
        } catch (p) {
          console.error("下载失败:", p), mh.error("下载失败，请重试");
        } finally {
          setTimeout(() => {
            a.value = true;
          }, 100);
        }
      }
    }
    async function c() {
      if (r.value)
        try {
          Ltt(r.value), mh.success("代码复制成功！");
        } catch (p) {
          console.error("复制失败:", p), mh.error("复制失败，请重试");
        }
    }
    const h = ref();
    return onMounted(() => {
      o(), typeof window < "u" && window.MutationObserver && (h.value = new MutationObserver((p) => {
        for (const m of p)
          if (m.attributeName === "class" && m.target === document.documentElement) {
            o();
            break;
          }
      }), h.value.observe(document.documentElement, {
        attributes: true
      })), typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
        o();
      });
    }), (p, m) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", {
        ref_key: "containerRef",
        ref: s,
        class: "mermaid-container",
        onMouseenter: m[0] || (m[0] = (g) => a.value = true),
        onMouseleave: m[1] || (m[1] = (g) => a.value = false)
      }, [
        createBaseVNode("div", {
          ref_key: "mermaidEl",
          ref: i,
          class: "mermaid",
          innerHTML: n.value
        }, null, 8, $et),
        withDirectives(createBaseVNode("div", Eet, [
          createBaseVNode("button", {
            class: "toolbar-btn",
            title: "复制代码",
            onClick: c
          }, "📋"),
          createBaseVNode("button", {
            class: "toolbar-btn",
            title: "下载图表",
            onClick: l
          }, " ⬇️ ")
        ], 512), [
          [vShow, e.showToolbar]
        ])
      ], 544),
      createVNode(unref(Tet), {
        position: "top-right",
        "rich-colors": ""
      })
    ], 64));
  }
});
var Y9 = (t15, e) => {
  const r = t15.__vccOpts || t15;
  for (const [n, i] of e)
    r[n] = i;
  return r;
};
var K9 = Y9(Met, [["__scopeId", "data-v-2e972355"]]);
var Bet = { class: "vitepress-mermaid-preview" };
var Let = defineComponent({
  __name: "PreviewMermaidPath",
  props: {
    path: {},
    showToolbar: { type: Boolean, default: false }
  },
  setup(t15) {
    const e = t15, r = ref("");
    return (n, i) => {
      const s = resolveComponent("ClientOnly");
      return openBlock(), createElementBlock("div", Bet, [
        createVNode(s, null, {
          default: withCtx(() => [
            r.value ? (openBlock(), createBlock(K9, {
              key: 0,
              code: r.value,
              "show-toolbar": e.showToolbar
            }, null, 8, ["code", "show-toolbar"])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});
var Det = Y9(Let, [["__scopeId", "data-v-2ea0c3b6"]]);
function Fet(t15) {
  t15.component("MermaidChart", K9), t15.component("PreviewMermaidPath", Det);
}
function Mrt(t15) {
  kq(t15), Fet(t15);
}

export {
  kq,
  vq,
  Aq,
  Ut,
  Yn,
  yl,
  lc,
  Tt,
  Ot,
  _,
  eR,
  ut,
  ur,
  cR,
  N6,
  Hr,
  cc,
  Zs,
  H6,
  Ke,
  Ob,
  Ja,
  lrt,
  Sm,
  fo,
  U6,
  FR,
  V6,
  zR,
  qR,
  RR,
  PR,
  jR,
  WR,
  HR,
  fe,
  crt,
  hrt,
  VR,
  tj,
  ej,
  rj,
  Om,
  $7,
  Ft,
  oj,
  ae,
  Rm,
  j7,
  dc,
  Wl,
  JW,
  Wr,
  Pm,
  urt,
  U7,
  t42 as t4,
  Yi,
  sH,
  va,
  drt,
  prt,
  frt,
  mrt,
  grt,
  yrt,
  brt,
  a4,
  Um,
  o4,
  xrt,
  wrt,
  krt,
  SU,
  AU,
  EU,
  Nh,
  D0,
  go,
  aa,
  Km,
  Mu,
  ps,
  pc,
  yo,
  Zm,
  PV,
  WV,
  y4,
  HV,
  UV,
  VV,
  Ek,
  Du,
  YV,
  fc,
  N0,
  I0,
  Bk,
  Fu,
  tG,
  Jm,
  NG,
  v4,
  Qm,
  qG,
  RG,
  Nk,
  VG,
  Ik,
  zk,
  tX,
  eX,
  oX,
  lX,
  cX,
  hX,
  uX,
  dX,
  Hk,
  wX,
  kX,
  _X,
  Vk,
  Bi,
  Nu,
  sg,
  Wn,
  ca,
  vrt,
  LY,
  DY,
  gc,
  NY,
  yv,
  fs,
  Dt,
  aK,
  Crt,
  SK,
  j8,
  _rt,
  Srt,
  Art,
  Trt,
  $K,
  EK,
  DK,
  ZK,
  $rt,
  Ert,
  V4,
  tZ,
  kZ,
  g1,
  Ds,
  t52 as t5,
  Fet,
  Mrt
};
/*! Bundled license information:

vitepress-plugin-legend/dist/component-Dd_YnWOH.js:
  (*! @gera2ld/jsx-dom v2.2.2 | ISC License *)
  (*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE *)
  (*! Bundled license information:
  
  js-yaml/dist/js-yaml.mjs:
    (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
  *)
  (*! Check if previously processed *)
  (*!
   * Wait for document loaded before starting the execution
   *)
*/
//# sourceMappingURL=chunk-XXGV6SHG.js.map
