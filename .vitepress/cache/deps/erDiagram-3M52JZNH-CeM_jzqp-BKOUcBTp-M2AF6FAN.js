import {
  e
} from "./chunk-OZX3KR4I.js";
import {
  a
} from "./chunk-GTR7KR4L.js";
import {
  $
} from "./chunk-DBLBAHG2.js";
import {
  AR,
  S,
  Xn,
  _nt,
  ae,
  dP,
  fP,
  gP,
  gnt,
  hP,
  mP,
  me,
  pP,
  uP,
  ut,
  vnt,
  xl
} from "./chunk-G6K7VW2X.js";
import "./chunk-ZNML7WN5.js";
import "./chunk-DC5AMYBS.js";

// node_modules/.pnpm/vitepress-plugin-legend@1.0.4_jiti@1.21.7_markmap-common@0.18.9_typescript@5.4.3_yaml@2.8.0/node_modules/vitepress-plugin-legend/dist/erDiagram-3M52JZNH-CeM_jzqp-BKOUcBTp.js
var ut2 = function() {
  var e2 = S(function(m, r, a2, n) {
    for (a2 = a2 || {}, n = m.length; n--; a2[m[n]] = r) ;
    return a2;
  }, "o"), i = [6, 8, 10, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50], u = [1, 10], c = [1, 11], l = [1, 12], y = [1, 13], A = [1, 20], b = [1, 21], E = [1, 22], v = [1, 23], H = [1, 24], O = [1, 19], G = [1, 25], w = [1, 26], R = [1, 18], J = [1, 33], tt = [1, 34], et = [1, 35], st = [1, 36], it = [1, 37], yt = [6, 8, 10, 13, 15, 17, 20, 21, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50, 63, 64, 65, 66, 67], S2 = [1, 42], T = [1, 43], L = [1, 52], M = [40, 50, 68, 69], F = [1, 63], B = [1, 61], N = [1, 58], Y = [1, 62], P = [1, 64], Z = [6, 8, 10, 13, 17, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 41, 42, 43, 44, 48, 49, 50, 63, 64, 65, 66, 67], dt = [63, 64, 65, 66, 67], pt = [1, 81], _t = [1, 80], ft = [1, 78], bt = [1, 79], gt = [6, 10, 42, 47], I = [6, 10, 13, 41, 42, 47, 48, 49], U = [1, 89], z = [1, 88], j = [1, 87], K = [19, 56], mt = [1, 98], Et = [1, 97], nt = [19, 56, 58, 60], rt = {
    trace: S(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, ER_DIAGRAM: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, entityName: 11, relSpec: 12, COLON: 13, role: 14, STYLE_SEPARATOR: 15, idList: 16, BLOCK_START: 17, attributes: 18, BLOCK_STOP: 19, SQS: 20, SQE: 21, title: 22, title_value: 23, acc_title: 24, acc_title_value: 25, acc_descr: 26, acc_descr_value: 27, acc_descr_multiline_value: 28, direction: 29, classDefStatement: 30, classStatement: 31, styleStatement: 32, direction_tb: 33, direction_bt: 34, direction_rl: 35, direction_lr: 36, CLASSDEF: 37, stylesOpt: 38, separator: 39, UNICODE_TEXT: 40, STYLE_TEXT: 41, COMMA: 42, CLASS: 43, STYLE: 44, style: 45, styleComponent: 46, SEMI: 47, NUM: 48, BRKT: 49, ENTITY_NAME: 50, attribute: 51, attributeType: 52, attributeName: 53, attributeKeyTypeList: 54, attributeComment: 55, ATTRIBUTE_WORD: 56, attributeKeyType: 57, ",": 58, ATTRIBUTE_KEY: 59, COMMENT: 60, cardinality: 61, relType: 62, ZERO_OR_ONE: 63, ZERO_OR_MORE: 64, ONE_OR_MORE: 65, ONLY_ONE: 66, MD_PARENT: 67, NON_IDENTIFYING: 68, IDENTIFYING: 69, WORD: 70, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 13: "COLON", 15: "STYLE_SEPARATOR", 17: "BLOCK_START", 19: "BLOCK_STOP", 20: "SQS", 21: "SQE", 22: "title", 23: "title_value", 24: "acc_title", 25: "acc_title_value", 26: "acc_descr", 27: "acc_descr_value", 28: "acc_descr_multiline_value", 33: "direction_tb", 34: "direction_bt", 35: "direction_rl", 36: "direction_lr", 37: "CLASSDEF", 40: "UNICODE_TEXT", 41: "STYLE_TEXT", 42: "COMMA", 43: "CLASS", 44: "STYLE", 47: "SEMI", 48: "NUM", 49: "BRKT", 50: "ENTITY_NAME", 56: "ATTRIBUTE_WORD", 58: ",", 59: "ATTRIBUTE_KEY", 60: "COMMENT", 63: "ZERO_OR_ONE", 64: "ZERO_OR_MORE", 65: "ONE_OR_MORE", 66: "ONLY_ONE", 67: "MD_PARENT", 68: "NON_IDENTIFYING", 69: "IDENTIFYING", 70: "WORD" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 5], [9, 9], [9, 7], [9, 7], [9, 4], [9, 6], [9, 3], [9, 5], [9, 1], [9, 3], [9, 7], [9, 9], [9, 6], [9, 8], [9, 4], [9, 6], [9, 2], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [29, 1], [29, 1], [29, 1], [29, 1], [30, 4], [16, 1], [16, 1], [16, 3], [16, 3], [31, 3], [32, 4], [38, 1], [38, 3], [45, 1], [45, 2], [39, 1], [39, 1], [39, 1], [46, 1], [46, 1], [46, 1], [46, 1], [11, 1], [11, 1], [18, 1], [18, 2], [51, 2], [51, 3], [51, 3], [51, 4], [52, 1], [53, 1], [54, 1], [54, 3], [57, 1], [55, 1], [12, 3], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [62, 1], [62, 1], [14, 1], [14, 1], [14, 1]],
    performAction: S(function(m, r, a2, n, h, t, p) {
      var s = t.length - 1;
      switch (h) {
        case 1:
          break;
        case 2:
          this.$ = [];
          break;
        case 3:
          t[s - 1].push(t[s]), this.$ = t[s - 1];
          break;
        case 4:
        case 5:
          this.$ = t[s];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          n.addEntity(t[s - 4]), n.addEntity(t[s - 2]), n.addRelationship(t[s - 4], t[s], t[s - 2], t[s - 3]);
          break;
        case 9:
          n.addEntity(t[s - 8]), n.addEntity(t[s - 4]), n.addRelationship(t[s - 8], t[s], t[s - 4], t[s - 5]), n.setClass([t[s - 8]], t[s - 6]), n.setClass([t[s - 4]], t[s - 2]);
          break;
        case 10:
          n.addEntity(t[s - 6]), n.addEntity(t[s - 2]), n.addRelationship(t[s - 6], t[s], t[s - 2], t[s - 3]), n.setClass([t[s - 6]], t[s - 4]);
          break;
        case 11:
          n.addEntity(t[s - 6]), n.addEntity(t[s - 4]), n.addRelationship(t[s - 6], t[s], t[s - 4], t[s - 5]), n.setClass([t[s - 4]], t[s - 2]);
          break;
        case 12:
          n.addEntity(t[s - 3]), n.addAttributes(t[s - 3], t[s - 1]);
          break;
        case 13:
          n.addEntity(t[s - 5]), n.addAttributes(t[s - 5], t[s - 1]), n.setClass([t[s - 5]], t[s - 3]);
          break;
        case 14:
          n.addEntity(t[s - 2]);
          break;
        case 15:
          n.addEntity(t[s - 4]), n.setClass([t[s - 4]], t[s - 2]);
          break;
        case 16:
          n.addEntity(t[s]);
          break;
        case 17:
          n.addEntity(t[s - 2]), n.setClass([t[s - 2]], t[s]);
          break;
        case 18:
          n.addEntity(t[s - 6], t[s - 4]), n.addAttributes(t[s - 6], t[s - 1]);
          break;
        case 19:
          n.addEntity(t[s - 8], t[s - 6]), n.addAttributes(t[s - 8], t[s - 1]), n.setClass([t[s - 8]], t[s - 3]);
          break;
        case 20:
          n.addEntity(t[s - 5], t[s - 3]);
          break;
        case 21:
          n.addEntity(t[s - 7], t[s - 5]), n.setClass([t[s - 7]], t[s - 2]);
          break;
        case 22:
          n.addEntity(t[s - 3], t[s - 1]);
          break;
        case 23:
          n.addEntity(t[s - 5], t[s - 3]), n.setClass([t[s - 5]], t[s]);
          break;
        case 24:
        case 25:
          this.$ = t[s].trim(), n.setAccTitle(this.$);
          break;
        case 26:
        case 27:
          this.$ = t[s].trim(), n.setAccDescription(this.$);
          break;
        case 32:
          n.setDirection("TB");
          break;
        case 33:
          n.setDirection("BT");
          break;
        case 34:
          n.setDirection("RL");
          break;
        case 35:
          n.setDirection("LR");
          break;
        case 36:
          this.$ = t[s - 3], n.addClass(t[s - 2], t[s - 1]);
          break;
        case 37:
        case 38:
        case 56:
        case 64:
          this.$ = [t[s]];
          break;
        case 39:
        case 40:
          this.$ = t[s - 2].concat([t[s]]);
          break;
        case 41:
          this.$ = t[s - 2], n.setClass(t[s - 1], t[s]);
          break;
        case 42:
          this.$ = t[s - 3], n.addCssStyles(t[s - 2], t[s - 1]);
          break;
        case 43:
          this.$ = [t[s]];
          break;
        case 44:
          t[s - 2].push(t[s]), this.$ = t[s - 2];
          break;
        case 46:
          this.$ = t[s - 1] + t[s];
          break;
        case 54:
        case 76:
        case 77:
          this.$ = t[s].replace(/"/g, "");
          break;
        case 55:
        case 78:
          this.$ = t[s];
          break;
        case 57:
          t[s].push(t[s - 1]), this.$ = t[s];
          break;
        case 58:
          this.$ = { type: t[s - 1], name: t[s] };
          break;
        case 59:
          this.$ = { type: t[s - 2], name: t[s - 1], keys: t[s] };
          break;
        case 60:
          this.$ = { type: t[s - 2], name: t[s - 1], comment: t[s] };
          break;
        case 61:
          this.$ = { type: t[s - 3], name: t[s - 2], keys: t[s - 1], comment: t[s] };
          break;
        case 62:
        case 63:
        case 66:
          this.$ = t[s];
          break;
        case 65:
          t[s - 2].push(t[s]), this.$ = t[s - 2];
          break;
        case 67:
          this.$ = t[s].replace(/"/g, "");
          break;
        case 68:
          this.$ = { cardA: t[s], relType: t[s - 1], cardB: t[s - 2] };
          break;
        case 69:
          this.$ = n.Cardinality.ZERO_OR_ONE;
          break;
        case 70:
          this.$ = n.Cardinality.ZERO_OR_MORE;
          break;
        case 71:
          this.$ = n.Cardinality.ONE_OR_MORE;
          break;
        case 72:
          this.$ = n.Cardinality.ONLY_ONE;
          break;
        case 73:
          this.$ = n.Cardinality.MD_PARENT;
          break;
        case 74:
          this.$ = n.Identification.NON_IDENTIFYING;
          break;
        case 75:
          this.$ = n.Identification.IDENTIFYING;
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, e2(i, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: 9, 22: u, 24: c, 26: l, 28: y, 29: 14, 30: 15, 31: 16, 32: 17, 33: A, 34: b, 35: E, 36: v, 37: H, 40: O, 43: G, 44: w, 50: R }, e2(i, [2, 7], { 1: [2, 1] }), e2(i, [2, 3]), { 9: 27, 11: 9, 22: u, 24: c, 26: l, 28: y, 29: 14, 30: 15, 31: 16, 32: 17, 33: A, 34: b, 35: E, 36: v, 37: H, 40: O, 43: G, 44: w, 50: R }, e2(i, [2, 5]), e2(i, [2, 6]), e2(i, [2, 16], { 12: 28, 61: 32, 15: [1, 29], 17: [1, 30], 20: [1, 31], 63: J, 64: tt, 65: et, 66: st, 67: it }), { 23: [1, 38] }, { 25: [1, 39] }, { 27: [1, 40] }, e2(i, [2, 27]), e2(i, [2, 28]), e2(i, [2, 29]), e2(i, [2, 30]), e2(i, [2, 31]), e2(yt, [2, 54]), e2(yt, [2, 55]), e2(i, [2, 32]), e2(i, [2, 33]), e2(i, [2, 34]), e2(i, [2, 35]), { 16: 41, 40: S2, 41: T }, { 16: 44, 40: S2, 41: T }, { 16: 45, 40: S2, 41: T }, e2(i, [2, 4]), { 11: 46, 40: O, 50: R }, { 16: 47, 40: S2, 41: T }, { 18: 48, 19: [1, 49], 51: 50, 52: 51, 56: L }, { 11: 53, 40: O, 50: R }, { 62: 54, 68: [1, 55], 69: [1, 56] }, e2(M, [2, 69]), e2(M, [2, 70]), e2(M, [2, 71]), e2(M, [2, 72]), e2(M, [2, 73]), e2(i, [2, 24]), e2(i, [2, 25]), e2(i, [2, 26]), { 13: F, 38: 57, 41: B, 42: N, 45: 59, 46: 60, 48: Y, 49: P }, e2(Z, [2, 37]), e2(Z, [2, 38]), { 16: 65, 40: S2, 41: T, 42: N }, { 13: F, 38: 66, 41: B, 42: N, 45: 59, 46: 60, 48: Y, 49: P }, { 13: [1, 67], 15: [1, 68] }, e2(i, [2, 17], { 61: 32, 12: 69, 17: [1, 70], 42: N, 63: J, 64: tt, 65: et, 66: st, 67: it }), { 19: [1, 71] }, e2(i, [2, 14]), { 18: 72, 19: [2, 56], 51: 50, 52: 51, 56: L }, { 53: 73, 56: [1, 74] }, { 56: [2, 62] }, { 21: [1, 75] }, { 61: 76, 63: J, 64: tt, 65: et, 66: st, 67: it }, e2(dt, [2, 74]), e2(dt, [2, 75]), { 6: pt, 10: _t, 39: 77, 42: ft, 47: bt }, { 40: [1, 82], 41: [1, 83] }, e2(gt, [2, 43], { 46: 84, 13: F, 41: B, 48: Y, 49: P }), e2(I, [2, 45]), e2(I, [2, 50]), e2(I, [2, 51]), e2(I, [2, 52]), e2(I, [2, 53]), e2(i, [2, 41], { 42: N }), { 6: pt, 10: _t, 39: 85, 42: ft, 47: bt }, { 14: 86, 40: U, 50: z, 70: j }, { 16: 90, 40: S2, 41: T }, { 11: 91, 40: O, 50: R }, { 18: 92, 19: [1, 93], 51: 50, 52: 51, 56: L }, e2(i, [2, 12]), { 19: [2, 57] }, e2(K, [2, 58], { 54: 94, 55: 95, 57: 96, 59: mt, 60: Et }), e2([19, 56, 59, 60], [2, 63]), e2(i, [2, 22], { 15: [1, 100], 17: [1, 99] }), e2([40, 50], [2, 68]), e2(i, [2, 36]), { 13: F, 41: B, 45: 101, 46: 60, 48: Y, 49: P }, e2(i, [2, 47]), e2(i, [2, 48]), e2(i, [2, 49]), e2(Z, [2, 39]), e2(Z, [2, 40]), e2(I, [2, 46]), e2(i, [2, 42]), e2(i, [2, 8]), e2(i, [2, 76]), e2(i, [2, 77]), e2(i, [2, 78]), { 13: [1, 102], 42: N }, { 13: [1, 104], 15: [1, 103] }, { 19: [1, 105] }, e2(i, [2, 15]), e2(K, [2, 59], { 55: 106, 58: [1, 107], 60: Et }), e2(K, [2, 60]), e2(nt, [2, 64]), e2(K, [2, 67]), e2(nt, [2, 66]), { 18: 108, 19: [1, 109], 51: 50, 52: 51, 56: L }, { 16: 110, 40: S2, 41: T }, e2(gt, [2, 44], { 46: 84, 13: F, 41: B, 48: Y, 49: P }), { 14: 111, 40: U, 50: z, 70: j }, { 16: 112, 40: S2, 41: T }, { 14: 113, 40: U, 50: z, 70: j }, e2(i, [2, 13]), e2(K, [2, 61]), { 57: 114, 59: mt }, { 19: [1, 115] }, e2(i, [2, 20]), e2(i, [2, 23], { 17: [1, 116], 42: N }), e2(i, [2, 11]), { 13: [1, 117], 42: N }, e2(i, [2, 10]), e2(nt, [2, 65]), e2(i, [2, 18]), { 18: 118, 19: [1, 119], 51: 50, 52: 51, 56: L }, { 14: 120, 40: U, 50: z, 70: j }, { 19: [1, 121] }, e2(i, [2, 21]), e2(i, [2, 9]), e2(i, [2, 19])],
    defaultActions: { 52: [2, 62], 72: [2, 57] },
    parseError: S(function(m, r) {
      if (r.recoverable)
        this.trace(m);
      else {
        var a2 = new Error(m);
        throw a2.hash = r, a2;
      }
    }, "parseError"),
    parse: S(function(m) {
      var r = this, a2 = [0], n = [], h = [null], t = [], p = this.table, s = "", X = 0, kt = 0, Rt = 2, Ot = 1, xt = t.slice.call(arguments, 1), d = Object.create(this.lexer), x = { yy: {} };
      for (var at in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, at) && (x.yy[at] = this.yy[at]);
      d.setInput(m, x.yy), x.yy.lexer = d, x.yy.parser = this, typeof d.yylloc > "u" && (d.yylloc = {});
      var ct = d.yylloc;
      t.push(ct);
      var Ct = d.options && d.options.ranges;
      typeof x.yy.parseError == "function" ? this.parseError = x.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function It(f) {
        a2.length = a2.length - 2 * f, h.length = h.length - f, t.length = t.length - f;
      }
      S(It, "popStack");
      function St() {
        var f;
        return f = n.pop() || d.lex() || Ot, typeof f != "number" && (f instanceof Array && (n = f, f = n.pop()), f = r.symbols_[f] || f), f;
      }
      S(St, "lex");
      for (var _, C, g, ot, $2 = {}, Q, k, Tt, V; ; ) {
        if (C = a2[a2.length - 1], this.defaultActions[C] ? g = this.defaultActions[C] : ((_ === null || typeof _ > "u") && (_ = St()), g = p[C] && p[C][_]), typeof g > "u" || !g.length || !g[0]) {
          var lt = "";
          V = [];
          for (Q in p[C])
            this.terminals_[Q] && Q > Rt && V.push("'" + this.terminals_[Q] + "'");
          d.showPosition ? lt = "Parse error on line " + (X + 1) + `:
` + d.showPosition() + `
Expecting ` + V.join(", ") + ", got '" + (this.terminals_[_] || _) + "'" : lt = "Parse error on line " + (X + 1) + ": Unexpected " + (_ == Ot ? "end of input" : "'" + (this.terminals_[_] || _) + "'"), this.parseError(lt, {
            text: d.match,
            token: this.terminals_[_] || _,
            line: d.yylineno,
            loc: ct,
            expected: V
          });
        }
        if (g[0] instanceof Array && g.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + C + ", token: " + _);
        switch (g[0]) {
          case 1:
            a2.push(_), h.push(d.yytext), t.push(d.yylloc), a2.push(g[1]), _ = null, kt = d.yyleng, s = d.yytext, X = d.yylineno, ct = d.yylloc;
            break;
          case 2:
            if (k = this.productions_[g[1]][1], $2.$ = h[h.length - k], $2._$ = {
              first_line: t[t.length - (k || 1)].first_line,
              last_line: t[t.length - 1].last_line,
              first_column: t[t.length - (k || 1)].first_column,
              last_column: t[t.length - 1].last_column
            }, Ct && ($2._$.range = [
              t[t.length - (k || 1)].range[0],
              t[t.length - 1].range[1]
            ]), ot = this.performAction.apply($2, [
              s,
              kt,
              X,
              x.yy,
              g[1],
              h,
              t
            ].concat(xt)), typeof ot < "u")
              return ot;
            k && (a2 = a2.slice(0, -1 * k * 2), h = h.slice(0, -1 * k), t = t.slice(0, -1 * k)), a2.push(this.productions_[g[1]][0]), h.push($2.$), t.push($2._$), Tt = p[a2[a2.length - 2]][a2[a2.length - 1]], a2.push(Tt);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }, "parse")
  }, At = function() {
    var m = {
      EOF: 1,
      parseError: S(function(r, a2) {
        if (this.yy.parser)
          this.yy.parser.parseError(r, a2);
        else
          throw new Error(r);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: S(function(r, a2) {
        return this.yy = a2 || this.yy || {}, this._input = r, this._more = this._backtrack = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: S(function() {
        var r = this._input[0];
        this.yytext += r, this.yyleng++, this.offset++, this.match += r, this.matched += r;
        var a2 = r.match(/(?:\r\n?|\n).*/g);
        return a2 ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), r;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: S(function(r) {
        var a2 = r.length, n = r.split(/(?:\r\n?|\n)/g);
        this._input = r + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - a2), this.offset -= a2;
        var h = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), n.length - 1 && (this.yylineno -= n.length - 1);
        var t = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: n ? (n.length === h.length ? this.yylloc.first_column : 0) + h[h.length - n.length].length - n[0].length : this.yylloc.first_column - a2
        }, this.options.ranges && (this.yylloc.range = [t[0], t[0] + this.yyleng - a2]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: S(function() {
        return this._more = true, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: S(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = true;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: S(function(r) {
        this.unput(this.match.slice(r));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: S(function() {
        var r = this.matched.substr(0, this.matched.length - this.match.length);
        return (r.length > 20 ? "..." : "") + r.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: S(function() {
        var r = this.match;
        return r.length < 20 && (r += this._input.substr(0, 20 - r.length)), (r.substr(0, 20) + (r.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: S(function() {
        var r = this.pastInput(), a2 = new Array(r.length + 1).join("-");
        return r + this.upcomingInput() + `
` + a2 + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: S(function(r, a2) {
        var n, h, t;
        if (this.options.backtrack_lexer && (t = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (t.yylloc.range = this.yylloc.range.slice(0))), h = r[0].match(/(?:\r\n?|\n).*/g), h && (this.yylineno += h.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: h ? h[h.length - 1].length - h[h.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + r[0].length
        }, this.yytext += r[0], this.match += r[0], this.matches = r, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = false, this._backtrack = false, this._input = this._input.slice(r[0].length), this.matched += r[0], n = this.performAction.call(this, this.yy, this, a2, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = false), n)
          return n;
        if (this._backtrack) {
          for (var p in t)
            this[p] = t[p];
          return false;
        }
        return false;
      }, "test_match"),
      // return next match in input
      next: S(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = true);
        var r, a2, n, h;
        this._more || (this.yytext = "", this.match = "");
        for (var t = this._currentRules(), p = 0; p < t.length; p++)
          if (n = this._input.match(this.rules[t[p]]), n && (!a2 || n[0].length > a2[0].length)) {
            if (a2 = n, h = p, this.options.backtrack_lexer) {
              if (r = this.test_match(n, t[p]), r !== false)
                return r;
              if (this._backtrack) {
                a2 = false;
                continue;
              } else
                return false;
            } else if (!this.options.flex)
              break;
          }
        return a2 ? (r = this.test_match(a2, t[h]), r !== false ? r : false) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: S(function() {
        var r = this.next();
        return r || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: S(function(r) {
        this.conditionStack.push(r);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: S(function() {
        var r = this.conditionStack.length - 1;
        return r > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: S(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: S(function(r) {
        return r = this.conditionStack.length - 1 - Math.abs(r || 0), r >= 0 ? this.conditionStack[r] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: S(function(r) {
        this.begin(r);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: S(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": true },
      performAction: S(function(r, a2, n, h) {
        switch (n) {
          case 0:
            return this.begin("acc_title"), 24;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 26;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return 33;
          case 8:
            return 34;
          case 9:
            return 35;
          case 10:
            return 36;
          case 11:
            return 10;
          case 12:
            break;
          case 13:
            return 8;
          case 14:
            return 50;
          case 15:
            return 70;
          case 16:
            return 4;
          case 17:
            return this.begin("block"), 17;
          case 18:
            return 49;
          case 19:
            return 49;
          case 20:
            return 42;
          case 21:
            return 15;
          case 22:
            return 13;
          case 23:
            break;
          case 24:
            return 59;
          case 25:
            return 56;
          case 26:
            return 56;
          case 27:
            return 60;
          case 28:
            break;
          case 29:
            return this.popState(), 19;
          case 30:
            return a2.yytext[0];
          case 31:
            return 20;
          case 32:
            return 21;
          case 33:
            return this.begin("style"), 44;
          case 34:
            return this.popState(), 10;
          case 35:
            break;
          case 36:
            return 13;
          case 37:
            return 42;
          case 38:
            return 49;
          case 39:
            return this.begin("style"), 37;
          case 40:
            return 43;
          case 41:
            return 63;
          case 42:
            return 65;
          case 43:
            return 65;
          case 44:
            return 65;
          case 45:
            return 63;
          case 46:
            return 63;
          case 47:
            return 64;
          case 48:
            return 64;
          case 49:
            return 64;
          case 50:
            return 64;
          case 51:
            return 64;
          case 52:
            return 65;
          case 53:
            return 64;
          case 54:
            return 65;
          case 55:
            return 66;
          case 56:
            return 66;
          case 57:
            return 66;
          case 58:
            return 66;
          case 59:
            return 63;
          case 60:
            return 64;
          case 61:
            return 65;
          case 62:
            return 67;
          case 63:
            return 68;
          case 64:
            return 69;
          case 65:
            return 69;
          case 66:
            return 68;
          case 67:
            return 68;
          case 68:
            return 68;
          case 69:
            return 41;
          case 70:
            return 47;
          case 71:
            return 40;
          case 72:
            return 48;
          case 73:
            return a2.yytext[0];
          case 74:
            return 6;
        }
      }, "anonymous"),
      rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:#)/i, /^(?:#)/i, /^(?:,)/i, /^(?::::)/i, /^(?::)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i, /^(?:([^\s]*)[~].*[~]([^\s]*))/i, /^(?:([\*A-Za-z_\u00C0-\uFFFF][A-Za-z0-9\-\_\[\]\(\)\u00C0-\uFFFF\*]*))/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:style\b)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?::)/i, /^(?:,)/i, /^(?:#)/i, /^(?:classDef\b)/i, /^(?:class\b)/i, /^(?:one or zero\b)/i, /^(?:one or more\b)/i, /^(?:one or many\b)/i, /^(?:1\+)/i, /^(?:\|o\b)/i, /^(?:zero or one\b)/i, /^(?:zero or more\b)/i, /^(?:zero or many\b)/i, /^(?:0\+)/i, /^(?:\}o\b)/i, /^(?:many\(0\))/i, /^(?:many\(1\))/i, /^(?:many\b)/i, /^(?:\}\|)/i, /^(?:one\b)/i, /^(?:only one\b)/i, /^(?:1\b)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\s*u\b)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:to\b)/i, /^(?:optionally to\b)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:([^\x00-\x7F]|\w|-|\*)+)/i, /^(?:;)/i, /^(?:([^\x00-\x7F]|\w|-|\*)+)/i, /^(?:[0-9])/i, /^(?:.)/i, /^(?:$)/i],
      conditions: { style: { rules: [34, 35, 36, 37, 38, 69, 70], inclusive: false }, acc_descr_multiline: { rules: [5, 6], inclusive: false }, acc_descr: { rules: [3], inclusive: false }, acc_title: { rules: [1], inclusive: false }, block: { rules: [23, 24, 25, 26, 27, 28, 29, 30], inclusive: false }, INITIAL: { rules: [0, 2, 4, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 31, 32, 33, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 71, 72, 73, 74], inclusive: true } }
    };
    return m;
  }();
  rt.lexer = At;
  function W() {
    this.yy = {};
  }
  return S(W, "Parser"), W.prototype = rt, rt.Parser = W, new W();
}();
ut2.parser = ut2;
var Xt = ut2;
var ht;
var Qt = (ht = class {
  constructor() {
    this.entities = /* @__PURE__ */ new Map(), this.relationships = [], this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.Cardinality = {
      ZERO_OR_ONE: "ZERO_OR_ONE",
      ZERO_OR_MORE: "ZERO_OR_MORE",
      ONE_OR_MORE: "ONE_OR_MORE",
      ONLY_ONE: "ONLY_ONE",
      MD_PARENT: "MD_PARENT"
    }, this.Identification = {
      NON_IDENTIFYING: "NON_IDENTIFYING",
      IDENTIFYING: "IDENTIFYING"
    }, this.setAccTitle = uP, this.getAccTitle = dP, this.setAccDescription = pP, this.getAccDescription = fP, this.setDiagramTitle = mP, this.getDiagramTitle = gP, this.getConfig = S(() => me().er, "getConfig"), this.clear(), this.addEntity = this.addEntity.bind(this), this.addAttributes = this.addAttributes.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setDirection = this.setDirection.bind(this), this.addCssStyles = this.addCssStyles.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
  }
  /**
   * Add entity
   * @param name - The name of the entity
   * @param alias - The alias of the entity
   */
  addEntity(e2, i = "") {
    var _a;
    return this.entities.has(e2) ? !((_a = this.entities.get(e2)) == null ? void 0 : _a.alias) && i && (this.entities.get(e2).alias = i, ut.info(`Add alias '${i}' to entity '${e2}'`)) : (this.entities.set(e2, {
      id: `entity-${e2}-${this.entities.size}`,
      label: e2,
      attributes: [],
      alias: i,
      shape: "erBox",
      look: me().look ?? "default",
      cssClasses: "default",
      cssStyles: []
    }), ut.info("Added new entity :", e2)), this.entities.get(e2);
  }
  getEntity(e2) {
    return this.entities.get(e2);
  }
  getEntities() {
    return this.entities;
  }
  getClasses() {
    return this.classes;
  }
  addAttributes(e2, i) {
    const u = this.addEntity(e2);
    let c;
    for (c = i.length - 1; c >= 0; c--)
      i[c].keys || (i[c].keys = []), i[c].comment || (i[c].comment = ""), u.attributes.push(i[c]), ut.debug("Added attribute ", i[c].name);
  }
  /**
   * Add a relationship
   *
   * @param entA - The first entity in the relationship
   * @param rolA - The role played by the first entity in relation to the second
   * @param entB - The second entity in the relationship
   * @param rSpec - The details of the relationship between the two entities
   */
  addRelationship(e2, i, u, c) {
    const l = this.entities.get(e2), y = this.entities.get(u);
    if (!l || !y)
      return;
    const A = {
      entityA: l.id,
      roleA: i,
      entityB: y.id,
      relSpec: c
    };
    this.relationships.push(A), ut.debug("Added new relationship :", A);
  }
  getRelationships() {
    return this.relationships;
  }
  getDirection() {
    return this.direction;
  }
  setDirection(e2) {
    this.direction = e2;
  }
  getCompiledStyles(e2) {
    let i = [];
    for (const u of e2) {
      const c = this.classes.get(u);
      (c == null ? void 0 : c.styles) && (i = [...i, ...c.styles ?? []].map((l) => l.trim())), (c == null ? void 0 : c.textStyles) && (i = [...i, ...c.textStyles ?? []].map((l) => l.trim()));
    }
    return i;
  }
  addCssStyles(e2, i) {
    for (const u of e2) {
      const c = this.entities.get(u);
      if (!i || !c)
        return;
      for (const l of i)
        c.cssStyles.push(l);
    }
  }
  addClass(e2, i) {
    e2.forEach((u) => {
      let c = this.classes.get(u);
      c === void 0 && (c = { id: u, styles: [], textStyles: [] }, this.classes.set(u, c)), i && i.forEach(function(l) {
        if (/color/.exec(l)) {
          const y = l.replace("fill", "bgFill");
          c.textStyles.push(y);
        }
        c.styles.push(l);
      });
    });
  }
  setClass(e2, i) {
    for (const u of e2) {
      const c = this.entities.get(u);
      if (c)
        for (const l of i)
          c.cssClasses += " " + l;
    }
  }
  clear() {
    this.entities = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.relationships = [], hP();
  }
  getData() {
    const e2 = [], i = [], u = me();
    for (const l of this.entities.keys()) {
      const y = this.entities.get(l);
      y && (y.cssCompiledStyles = this.getCompiledStyles(y.cssClasses.split(" ")), e2.push(y));
    }
    let c = 0;
    for (const l of this.relationships) {
      const y = {
        id: gnt(l.entityA, l.entityB, {
          prefix: "id",
          counter: c++
        }),
        type: "normal",
        curve: "basis",
        start: l.entityA,
        end: l.entityB,
        label: l.roleA,
        labelpos: "c",
        thickness: "normal",
        classes: "relationshipLine",
        arrowTypeStart: l.relSpec.cardB.toLowerCase(),
        arrowTypeEnd: l.relSpec.cardA.toLowerCase(),
        pattern: l.relSpec.relType == "IDENTIFYING" ? "solid" : "dashed",
        look: u.look
      };
      i.push(y);
    }
    return { nodes: e2, edges: i, other: {}, config: u, direction: "TB" };
  }
}, S(ht, "ErDB"), ht);
var Nt = {};
AR(Nt, {
  draw: () => Vt
});
var Vt = S(async function(e2, i, u, c) {
  ut.info("REF0:"), ut.info("Drawing er diagram (unified)", i);
  const { securityLevel: l, er: y, layout: A } = me(), b = c.db.getData(), E = a(i, l);
  b.type = c.type, b.layoutAlgorithm = _nt(A), b.config.flowchart.nodeSpacing = (y == null ? void 0 : y.nodeSpacing) || 140, b.config.flowchart.rankSpacing = (y == null ? void 0 : y.rankSpacing) || 80, b.direction = c.db.getDirection(), b.markers = ["only_one", "zero_or_one", "one_or_more", "zero_or_more"], b.diagramId = i, await vnt(b, E), b.layoutAlgorithm === "elk" && E.select(".edges").lower();
  const v = E.selectAll('[id*="-background"]');
  Array.from(v).length > 0 && v.each(function() {
    const O = ae(this), G = O.attr("id").replace("-background", ""), w = E.select(`#${CSS.escape(G)}`);
    if (!w.empty()) {
      const R = w.attr("transform");
      O.attr("transform", R);
    }
  }), Xn.insertTitle(
    E,
    "erDiagramTitleText",
    (y == null ? void 0 : y.titleTopMargin) ?? 25,
    c.db.getDiagramTitle()
  ), $(E, 8, "erDiagram", (y == null ? void 0 : y.useMaxWidth) ?? true);
}, "draw");
var qt = S((e2, i) => {
  const u = e, c = u(e2, "r"), l = u(e2, "g"), y = u(e2, "b");
  return xl(c, l, y, i);
}, "fade");
var Ht = S((e2) => `
  .entityBox {
    fill: ${e2.mainBkg};
    stroke: ${e2.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${e2.tertiaryColor};
    opacity: 0.7;
    background-color: ${e2.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

  .labelBkg {
    background-color: ${qt(e2.tertiaryColor, 0.5)};
  }

  .edgeLabel .label {
    fill: ${e2.nodeBorder};
    font-size: 14px;
  }

  .label {
    font-family: ${e2.fontFamily};
    color: ${e2.nodeTextColor || e2.textColor};
  }

  .edge-pattern-dashed {
    stroke-dasharray: 8,8;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon
  {
    fill: ${e2.mainBkg};
    stroke: ${e2.nodeBorder};
    stroke-width: 1px;
  }

  .relationshipLine {
    stroke: ${e2.lineColor};
    stroke-width: 1;
    fill: none;
  }

  .marker {
    fill: none !important;
    stroke: ${e2.lineColor} !important;
    stroke-width: 1;
  }
`, "getStyles");
var Jt = Ht;
var ne = {
  parser: Xt,
  get db() {
    return new Qt();
  },
  renderer: Nt,
  styles: Jt
};
export {
  ne as diagram
};
//# sourceMappingURL=erDiagram-3M52JZNH-CeM_jzqp-BKOUcBTp-M2AF6FAN.js.map
