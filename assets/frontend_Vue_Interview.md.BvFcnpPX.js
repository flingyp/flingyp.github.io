import{_ as i,c as a,a3 as e,o as n}from"./chunks/framework.H5EfqC1G.js";const r=JSON.parse('{"title":"Vue 杂记","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/Vue/Interview.md","filePath":"frontend/Vue/Interview.md","lastUpdated":1733626394000}'),l={name:"frontend/Vue/Interview.md"};function t(h,s,p,k,d,E){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="vue-杂记" tabindex="-1">Vue 杂记 <a class="header-anchor" href="#vue-杂记" aria-label="Permalink to &quot;Vue 杂记&quot;">​</a></h1><h2 id="对-mvvm-的理解" tabindex="-1">对 MVVM 的理解 <a class="header-anchor" href="#对-mvvm-的理解" aria-label="Permalink to &quot;对 MVVM 的理解&quot;">​</a></h2><p>MVVM 是 <strong>Model-View-ViewModel</strong> 的缩写，是一种设计思想</p><ul><li>Model 层代表数据层，可以理解为SFC文件中的 <code>script</code> 部分</li><li>View 层代表视图层，可以理解为SFC文件中的 <code>template</code> 部分</li></ul><p>View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，并且之间的交互是双向的。对 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来。</p><p>而 ViewModel 这个中间层就是Vue需要做的事情：将 View 和 Model 双向建立连接</p><h2 id="vue2-和-vue3-的区别" tabindex="-1">Vue2 和 Vue3 的区别 <a class="header-anchor" href="#vue2-和-vue3-的区别" aria-label="Permalink to &quot;Vue2 和 Vue3 的区别&quot;">​</a></h2><ol><li>响应式系统的实现方式不同</li><li>Vue2 是选项式 API，Vue3 是组合式 API。在写法上思想上都有很大的变化</li><li>Vue3 中的 Composition API 使得代码更加的简洁，更加的易读</li><li>Diff 算法的优化</li></ol><blockquote><div class="tip custom-block"><p class="custom-block-title">Vue2</p><p>Vue2 Diff 算法就是进行虚拟节点对比，并返回一个 patch 对象，用来存储两个节点不同的地方，最后用 patch 记录的消息去局部更新 Dom。</p><p>Diff 算法会比较每一个 vnode，而对于一些不参更新的元素，进行比较是有点消耗性能的。</p></div></blockquote><blockquote><div class="tip custom-block"><p class="custom-block-title">Vue3</p><p>快速的 Patch 算法：Diff 算法在初始化的时候会给每个虚拟节点添加一个 patchFlags，patchFlags 就是优化的标识。只会比较 patchFlags 发生变化的 vnode,进行更新视图，对于没有变化的元素做静态标记，在渲染的时候直接复用。</p><p>静态提升：Vue3 在编译阶段通过静态提升来优化虚拟 DOM，将静态节点转化为常量，可以避免在每次渲染时重新创建和比较节点，从而提高渲染性能。</p><p>更快的 Diff 算法：Vue3 对 Diff 算法进行了优化，采用了双端指针的方式来进行比较，从而减少了比较的次数，并且将比较结果缓存到了一个位图数组中，以便下次比较时能够快速地获取之前的比较结果。</p></div></blockquote><ol start="5"><li>Vue3 支持 Tree-Shaking 可以优化打包后的文件体积，并且有了更好的 TS 类型推导</li></ol><h2 id="spa-的理解-有什么优缺点" tabindex="-1">SPA 的理解，有什么优缺点 <a class="header-anchor" href="#spa-的理解-有什么优缺点" aria-label="Permalink to &quot;SPA 的理解，有什么优缺点&quot;">​</a></h2><p>单页面引用（Single Page Application）是一种前端应用程序的架构模式。它只需要加载一个HTML页面，并且通过使用 JavaScript 动态的更新页面的内容，从而实现动态无刷新页面的用户体验</p><p>SPA 的优点：</p><ul><li>用户体验。无感刷新，较流畅</li></ul><p>SPA 的缺点：</p><ul><li>首次加载白屏问题</li><li>不利于SEO</li></ul><h2 id="vue3-组件之间的通信方式有哪些" tabindex="-1">Vue3 组件之间的通信方式有哪些 <a class="header-anchor" href="#vue3-组件之间的通信方式有哪些" aria-label="Permalink to &quot;Vue3 组件之间的通信方式有哪些&quot;">​</a></h2><ol><li><code>Props、Emits</code>：用于父子组件之间数据的传递</li><li><code>expose、ref</code>：在 Vue3 中我们可以通过 <code>ref</code> 去获取组件实例。但默认在 Vue3 中并不会将组件实例的相关属性和方法暴露出来。我们需要通过 <code>defineExpose</code> 将组件实例的属性和方法暴露出来</li><li><code>透传 Attributes</code>：指的是在子组件中，没使用 <code>prop</code> 或 <code>emits</code> 定义的 attribute，可以通过 <code>$attrs</code> 来访问。<a href="https://cn.vuejs.org/guide/components/attrs.html" target="_blank" rel="noreferrer">文档介绍</a></li><li><code>v-model</code> 语法糖</li><li><code>Slots</code> 插槽</li><li><code>Provide/Inject</code>：适合跨组件传递</li><li>跨组件通信工具：Pinia、Vuex</li><li>EventBus 事件总线：Vue3 推荐使用的一个发布订阅库 <code>Mitt</code></li></ol><h2 id="v-if-和-v-for-哪个优先级更高" tabindex="-1"><code>v-if</code> 和 <code>v-for</code> 哪个优先级更高 <a class="header-anchor" href="#v-if-和-v-for-哪个优先级更高" aria-label="Permalink to &quot;\`v-if\` 和 \`v-for\` 哪个优先级更高&quot;">​</a></h2><ul><li>在 Vue2 中 <code>v-for</code> 会比 <code>v-if</code> 的优先级高</li><li>在 Vue3 中 <code>v-if</code> 会比 <code>v-for</code> 的优先级高（这样是为了减少循环判断，提高框架性能）</li></ul><p><strong>总结</strong>：</p><ol><li>在使用 <code>v-if</code> 和 <code>v-for</code> 时，应该在外部包裹一层 <code>&lt;template v-for/v-if&gt;&lt;/template&gt;</code>，然后根据实际情况来判断是哪个API在外层，哪个API在里层</li><li>多用Computed，在面对要循环根据 <code>v-if</code> 所过滤后的数据列表，可以定义一个使用 <code>computed</code> 来进行过滤后渲染</li></ol><ul><li><a href="https://cn.vuejs.org/style-guide/rules-essential.html#avoid-v-if-with-v-for" target="_blank" rel="noreferrer">avoid-v-if-with-v-for</a></li></ul><h2 id="v-show-和-v-if-的区别" tabindex="-1"><code>v-show</code> 和 <code>v-if</code> 的区别 <a class="header-anchor" href="#v-show-和-v-if-的区别" aria-label="Permalink to &quot;\`v-show\` 和 \`v-if\` 的区别&quot;">​</a></h2><p>控制手段：<code>v-show</code> 是通过给元素设置 CSS <code>display: none</code> 来控制元素的显示与否 而<code>v-if</code> 是通过一定的 JS 手段将整个 DOM 节点进行添加或删除</p><p>编译过程：<code>v-if</code> 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件。<code>v-show</code> 只是简单一个基于 CSS 切换</p><p>编译条件：<code>v-if</code> 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和挂载。只有渲染条件为假时，并不做操作，直到为真才渲染</p><p><strong>总结</strong>：通过 <code>v-if</code> 来控制元素或子组件的显示和隐藏，组件会经历实例的创建、挂载和销毁等阶段。相对来说性能消耗较大，所以如果有频繁的控制元素的显示隐藏的需要，应当首选 <code>v-show</code></p><p>所以在 <code>v-show</code> 的切换时，是不会触发内部子组件的生命周期。而在 <code>v-if</code> 的切换时，是会触发组件的相关的生命周期函数的</p><h2 id="watch-和-computed-的区别" tabindex="-1"><code>watch</code> 和 <code>computed</code> 的区别 <a class="header-anchor" href="#watch-和-computed-的区别" aria-label="Permalink to &quot;\`watch\` 和 \`computed\` 的区别&quot;">​</a></h2><ul><li>Computed：会返回一个只读的响应式数据</li><li>Watch：检测响应式数据的变化后执行相关回调函数</li></ul><p>区别：两个使用场景不同</p><ol><li>计算属性会依据所依赖的响应式数据衍生出自己需要的响应式数据，所以计算属性不适合做异步操作或DOM操作</li><li>监听器是监测某个响应式数据的变化并且执行对应的副作用函数，可以执行一些异步操作等复杂逻辑</li></ol><p>Computed 的特点：</p><ol><li><strong>依赖追踪</strong>。Computed 会收集所依赖的响应式数据，只有当响应式数据发生改变时才会执行</li><li><strong>缓存</strong>。只有当其依赖的东西发生变化了才需要重新计算，否则就返回上一次执行的结果</li><li><strong>懒计算</strong>。声明了一个计算属性后并不是立即执行的，而是在访问 <code>.value</code> 后才去执行对应函数</li></ol><h2 id="谈一谈-vue3-中如何扩展组件" tabindex="-1">谈一谈 Vue3 中如何扩展组件 <a class="header-anchor" href="#谈一谈-vue3-中如何扩展组件" aria-label="Permalink to &quot;谈一谈 Vue3 中如何扩展组件&quot;">​</a></h2><p>Vue3 模式下最好的方式是通过 Composition API 来进行组件的扩展</p><p>通过使用Vue的响应式模块配合有独立作用域的函数，可以编写特定的业务功能模块和公共功能模块等。以达到更好的抽离代码优化组件结构以实现更好的搭配</p><p>当我们需要新增组件功能时，只需要在当前的组件基础上新增对应的钩子来完成功能的开发</p><ul><li><a href="https://staging-cn.vuejs.org/guide/reusability/composables.html" target="_blank" rel="noreferrer">官方关于组合式函数（composables 或 hooks）的介绍和用法</a></li></ul><h2 id="v-model-双向绑定使用" tabindex="-1"><code>v-model</code> 双向绑定使用 <a class="header-anchor" href="#v-model-双向绑定使用" aria-label="Permalink to &quot;\`v-model\` 双向绑定使用&quot;">​</a></h2><p><code>v-model</code> 是一个语法糖。默认情况下相当于 <code>v-bind:value</code> 和 <code>@update:value</code>，使用双向绑定可以减少繁琐事件，提高开发体验。</p><p>Vue3 甚至可以使用参数形式来绑定多个响应式数据。例如： <code>v-model:content</code>、<code>v-model:header</code></p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;modelValue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;content&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;header&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineEmits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;update:modelValue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;update:content&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;update:header&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">modelValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;update:modelValue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, $event.target.value)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;update:content&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, $event.target.value)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;update:header&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, $event.target.value)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">MyInput</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">MyInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">MyInput</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">content</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">MyInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">MyInput</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">header</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">MyInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="谈谈对-vue-数据响应式理解" tabindex="-1">谈谈对 Vue 数据响应式理解 <a class="header-anchor" href="#谈谈对-vue-数据响应式理解" aria-label="Permalink to &quot;谈谈对 Vue 数据响应式理解&quot;">​</a></h2><p>数据响应式：数据驱动视图的思想，<strong>能够使数据变化可以被检测并且做出相应的响应机制</strong></p><p>MVVM 分为三部分：视图层、数据层和视图逻辑层</p><p>而视图逻辑层就是要解决一个核心的问题是<strong>如何连接数据层和视图层</strong>。通过<strong>数据驱动视图，视图改变数据</strong>，要做到这点的就需要做到数据响应式处理</p><p>在 Vue2 中，采用的是 <code>Object.defineProperty()</code> 的方式对响应式数据进行拦截</p><p>但是使用此 API 有一些缺点：</p><ol><li>新增或删除属性的不会被依赖收集也就不会有响应式的特性，需要使用 <code>Vue.set/delete</code> 等 API 才能生效</li><li>对应 ES6 中的 Map、Set 这些数据结构不支持</li></ol><p>在 Vue3 中 采用的是 ES6 的 <code>Proxy</code> 代理实现响应式数据</p><h2 id="object-defineproperty-和-proxy有什么区别" tabindex="-1"><code>Object.defineProperty</code> 和 <code>Proxy</code>有什么区别 <a class="header-anchor" href="#object-defineproperty-和-proxy有什么区别" aria-label="Permalink to &quot;\`Object.defineProperty\` 和 \`Proxy\`有什么区别&quot;">​</a></h2><ul><li><code>defineProperty</code> 是 ES5 新增的方法，会直接在一个对象上定义一个新属性，或修改其现有属性，并返回此对象</li><li><code>Proxy</code> 是 E56 新增的，是针对一个对象的代理，而不是针对对象当中的某个属性的代理</li></ul><p><strong>区别</strong>：</p><ol><li><code>defineProperty</code> 只代理对象上的某个属性, 通过 Getter 和 Setter 方法来劫持属性的读取和写入操作。只能对定义好的属性进行数据监听，而新增属性或删除数据是不会被监听的，也就会失去响应式的特性</li><li>而 Proxy 是代理整个对象，可以完全解决 <code>defineProperty</code> 所带来的弊端</li><li>Proxy 在调用时递归，<code>Object.defineProperty</code> 在一开始就全部递归，Proxy 性能优于 <code>Object.defineProperty</code></li></ol><h2 id="虚拟-dom-的理解" tabindex="-1">虚拟 DOM 的理解 <a class="header-anchor" href="#虚拟-dom-的理解" aria-label="Permalink to &quot;虚拟 DOM 的理解&quot;">​</a></h2><p>虚拟DOM：是用来描述真实DOM的 JavaScript 对象</p><p>虚拟 DOM 如何生成？</p><p>在 Vue 中我们会为组件编写模板 template，这个模板会被编译器 compiler 编译为渲染函数，在接下来的挂载时刻 mount 过程中会调用 render 渲染函数来返回 虚拟 DOM，在后续的 patch 过程中会进一步转换为真实 DOM</p><p>挂载过程结束后，Vue 会进入更新流程，如果发现有响应式数据发生变化，就会引起组件重新渲染，此时就会产生新的虚拟 DOM，和上一次的渲染结构 Diff 就可以得到变化的地方，从而转换为最小量的 DOM 操作，高效更新视图</p><h2 id="对-diff-算法的理解" tabindex="-1">对 Diff 算法的理解 <a class="header-anchor" href="#对-diff-算法的理解" aria-label="Permalink to &quot;对 Diff 算法的理解&quot;">​</a></h2><p>Vue 中的 <code>diff</code> 算法又称为 <code>patching</code> 算法。虚拟 DOM 想要转换为真实 DOM 就需要通过此方法进行转换</p><p>当组件内响应式数据发生变化时，会触发实例执行其更新函数来获得最新的虚拟DOM。然后会执行 <code>patch</code> 函数，传入新旧虚拟DOM，通过Diff算法来找到两个虚拟DOM存在差异的地方，然后就可以最小化的更新视图</p><p>Patch 的过程是一个递归过程，遵循一个<strong>同层比较，深度优先策略</strong></p><ul><li>首先判断两个节点是否为相同同类节点，不同则删除重新创建</li><li>如果双方都是文本则更新文本内容</li><li>如果双方都是元素节点则递归更新子元素，同时更新元素属性</li><li>更新子节点又分为几种情况： <ul><li>新的子节点是文本，老的子节点是数组则清空，并设置文本</li><li>新的子节点是文本，老的字节点是文本则直接更新文本</li><li>新的子节点是数组，老的子节点是文本则清空文本，并创建子节点数组中的子元素</li><li>新的节点是数组，老的子节点也是数组，那么比较两组子节点，更新细节</li></ul></li></ul><p>Vue3 在 diff 算法中相比增加了 更新类型标记 来优化算法。作用就是为了在发送变化的地方添加一个 <code>flag</code> 标记，下次发送变化的时候直接找该地方进行比较。</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 对于单个有动态绑定的元素来说，我们可以在编译时推断出大量信息 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  &lt;!-- 仅含 class 绑定 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ active }</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  &lt;!-- 仅含 id 和 value 绑定 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  &lt;!-- 仅含文本子节点 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ dynamic }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>就是在编译阶段，会为模板生成渲染函数时，会判断每个元素所需要的更新类型，并且打上标记。在更新阶段进行 Diff 的时候就会根据这些类型标记去做对应的更新，极大的优化递归的过程</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElementVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    class: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_normalizeClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ active: _ctx.active }),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* CLASS */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 最后这个参数 2 就是一个更新类型标记 (patchFlag)</span></span></code></pre></div><details class="details custom-block"><summary>Vue2 和 Vue3 的 Diff算法区别</summary><p>Vue2</p><p>会对虚拟Dom进行全量的对比，在运行时会对所有节点生成一个虚拟节点树，当页面数据发生变化时，会遍历判断虚拟Dom所有节点（包括一些不会变化的节点）有没有发生变化</p><p>Vue3</p><p>静态标记：在模版编译时编译器会在动态标签末尾加上 /_ Text_/ PatchFlag。也就是在生成VNode的时候，同时打上标记，patch 过程中就会判断这个标记来 Diff 优化流程，跳过一些静态节点对比</p><p>静态提升：Vue3 在编译阶段通过静态提升来优化虚拟 DOM，将静态节点转化为常量，可以避免在每次渲染时重新创建和比较节点，从而提高渲染性能。</p><p>更快的 Diff 算法：Vue3 对 Diff 算法进行了优化，采用了双端指针的方式来进行比较，从而减少了比较的次数，并且将比较结果缓存到了一个位图数组中，以便下次比较时能够快速地获取之前的比较结果。</p></details><h2 id="响应式数据发生改变之后-vue-做了什么事情" tabindex="-1">响应式数据发生改变之后 Vue 做了什么事情 <a class="header-anchor" href="#响应式数据发生改变之后-vue-做了什么事情" aria-label="Permalink to &quot;响应式数据发生改变之后 Vue 做了什么事情&quot;">​</a></h2><p>当响应式数据发送变化后，会触发到响应式数据对应的 Set 方法，而在Set函数中会去执行trigger函数（派发更新），之后会自动触发重新渲染视图的操作</p><p>渲染前会调用 <code>beforeUpdate</code> 钩子函数，在渲染的过程中会 <code>patch</code> 重新比对新旧虚拟DOM，然后更新渲染到页面上，渲染后在去调用 <code>onUpdated</code> 钩子函数</p><h2 id="谈谈-vue-的生命周期吧" tabindex="-1">谈谈 Vue 的生命周期吧 <a class="header-anchor" href="#谈谈-vue-的生命周期吧" aria-label="Permalink to &quot;谈谈 Vue 的生命周期吧&quot;">​</a></h2><p>Vue 实例有一个完整的生命周期。从实例创建、初始化数据、模板编译、挂载 DOM、渲染、更新渲染、卸载等一系列过程，就是 Vue 的生命周期</p><ul><li><code>beforeCreate</code>：组件实例创建前。此时还无法访问到相关方法和数据</li><li><code>created</code>：实例创建后。组件响应式数据、事件等被初始化</li><li><code>beforeMount</code>：实例挂载前。渲染函数首次被调用</li><li><code>mounted</code>：实例挂载后。 组件实例被挂载到 DOM 上之后调用</li><li><code>beforeUpdate</code>：响应式数据被更新前。发生在虚拟 DOM 重新渲染和打补丁</li><li><code>updated</code>：响应式数据被更新后。由于数据更新导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</li><li><code>beforeUnmount</code>：实例卸载前</li><li><code>unmounted</code>：实例卸载后</li></ul><h2 id="说说-nexttick-的使用" tabindex="-1">说说 <code>nextTick</code> 的使用 <a class="header-anchor" href="#说说-nexttick-的使用" aria-label="Permalink to &quot;说说 \`nextTick\` 的使用&quot;">​</a></h2><p><code>nextTick()</code> 是等待下一次 DOM 更新刷新的工具方法</p><p>Vue 有一个异步更新策略，意思就是如果数据变化，Vue 不会立即更新 DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更后会异步的批量更新</p><p>这一策略会导致我们对数据的修改不会及时的体现在 DOM 上，此时如果想要获取更新后的 DOM 状态，就需要使用 <code>nextTick</code></p><h2 id="vue-router-中-hash-模式和-history-模式的区别" tabindex="-1">Vue Router 中 hash 模式和 history 模式的区别 <a class="header-anchor" href="#vue-router-中-hash-模式和-history-模式的区别" aria-label="Permalink to &quot;Vue Router 中 hash 模式和 history 模式的区别&quot;">​</a></h2><p>SPA 即<strong>单页面应用程序</strong>。只有一个 HTML 文件并且在<strong>用户与应用程序进行交互时</strong>动态的更新此页面的 Web 应用程序。浏览器一开始会加载必需的 HTML 、 CSS 和 JavaScript ，而所有的页面更新操作<strong>都由 JavaScript 来控制</strong>。</p><ul><li>SPA 的优点：用户体验好、页面内容的改变不需要我们去重新加载新的页面</li><li>SPA 的缺点：不利于搜索引擎的抓取，首页加载时间会过长、页面渲染的速度会相对较慢</li></ul><p>单页面应用程序时就提供了 Hash 和 History 两种模式</p><h3 id="hash-模式" tabindex="-1">Hash 模式 <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;Hash 模式&quot;">​</a></h3><p>Hash 模式的前端路由的路径是用井号 # 拼接在真实 URL 后面的。当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 <code>onhashchange</code> 事件。</p><p>例如：<a href="https://vadmire.top/#/login" target="_blank" rel="noreferrer">https://vadmire.top/#/login</a></p><p>特点：</p><ul><li><ol><li>Hash 变化会出现页面跳转即浏览器的前进和后退。</li></ol></li><li><ol start="2"><li>Hash 改变的是 # 后面的路由不会刷新页面，所有的更新操作是由 JavaScript 来实现的，并不会向服务器发送 HTTP 请求去获取对应路径页面。</li></ol></li><li><ol start="3"><li>Hash 通过 <code>window.onhashchange</code> 的方式，来监听 Hash 的改变，借此实现无刷新跳转的功能</li></ol></li></ul><h3 id="history-模式" tabindex="-1">History 模式 <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;History 模式&quot;">​</a></h3><p><code>History API</code> 是 HTML5 提供的新特性，允许开发者<strong>直接更改前端路由</strong>，即更新浏览器 URL 地址而不会<strong>重新发起请求</strong>。总结一句话：页面内容没变，地址栏的地址改变了</p><p>当我们使用 <code>History</code> 模式将前端项目部署上线后，在我们通过 <code>index.html</code> 去访问单页面应用某个路径下的内容，正常的路由跳转是没有问题的。<strong>但是我们重新刷新页面的时候就会出现 404 的情况</strong></p><p>原因在于：重新刷新页面后浏览器会重新发送一次 HTTP 请求，去请求对应路径下的页面。但是服务器其实是没有这个页面的所以会报 404 的情况。这个时候我们就需要 <strong>通过服务端来允许访问如何路径下的页面重定向到</strong> <code>index.html</code> 上</p><p>这里有一个小细节，如果出现真的 404 页面了呢？</p><p>因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [{ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: NotFoundComponent }],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>针对不同的应用场景我们可以选择不同模式</p><ul><li>如果是 <code>B端</code> 系统更加推荐 Hash 模式，相对简单容易</li><li>如果是 <code>C端</code> 系统对外观有一定要求就可以考虑选择 <code>History</code> 模式但是需要 <strong>服务端支持</strong></li></ul><h2 id="vue-项目部署到服务器后刷新出现-404-的问题" tabindex="-1">Vue 项目部署到服务器后刷新出现 404 的问题 <a class="header-anchor" href="#vue-项目部署到服务器后刷新出现-404-的问题" aria-label="Permalink to &quot;Vue 项目部署到服务器后刷新出现 404 的问题&quot;">​</a></h2><p>前后端分离开发模式下，前端只需要将项目打包，将打包文件扔到目标服务器即可。Vue 是单页面应用，无论有多少页面构建物都只会产出一个 <code>index.html</code> 文件</p><h3 id="如果路由是-history-模式" tabindex="-1">如果路由是 <code>History</code> 模式 <a class="header-anchor" href="#如果路由是-history-模式" aria-label="Permalink to &quot;如果路由是 \`History\` 模式&quot;">​</a></h3><p><code>History</code> 模式下就会出现页面刷新出现 404 问题</p><p><strong>原因</strong>：在于当我们在地址栏输入 <code>www.xxx.com</code> 地址时，首先一定会访问到服务器的目标文件的 <code>index.html</code> 这时候是不会有 404 的问题。但是如果我们在访问或者重定向到 <code>www.xxx.com/xx</code> 页面时其实就会向服务器发送一个 HTTP 请求，去请求 <code>/xx</code> 页面的文件内容，这个时候自然服务器是没有这个路径的文件资源的。所以就会报 404 问题</p><h3 id="如果路由是-hash-模式" tabindex="-1">如果路由是 <code>Hash</code> 模式 <a class="header-anchor" href="#如果路由是-hash-模式" aria-label="Permalink to &quot;如果路由是 \`Hash\` 模式&quot;">​</a></h3><p><code>Hash</code> 模块是用符号 # 表示的。 如 <code>www.xxx.com/#/xx</code></p><p>它的特点在于 <code>Hash</code> 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 <code>Hash</code> 不会重新加载页面。该模式下仅 <code>Hash</code> 符号之前的内容会被包含在请求中，如 <code>www.xxx.com/#/xx</code> 只有 <code>www.xxx.com</code> 会被包含在请求中</p><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><p>本质单页面应用就只有一个页面，路由则是通过 JS 来执行视图切换的，<code>History</code> 模式下去请求其他不存在的页面自然会报 404 问题。</p><p>所以如果你的项目配置的是 <code>History</code> 模式下，所以进行以下的配置</p><p>解决方案：就是在服务器进行配置，将任意页面都重定向到 <code>index.html</code> 文件，把路由交给前端处理</p><p>以 Nginx 为例子，只需要修改它的配置文件。添加：<code>try_files $uri $uri/ /index.html;</code> 这么一条配置即可</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  listen  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  server_name  www.xxx.com;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    index  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dist</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index.html;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    try_files $uri $uri</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index.html;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>配置完毕后，重启 Nginx： <code>nginx -s reload</code></p><p>为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: NotFoundComponent }, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加一条匹配404页面的路由</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="key-的作用" tabindex="-1">Key 的作用 <a class="header-anchor" href="#key-的作用" aria-label="Permalink to &quot;Key 的作用&quot;">​</a></h2><p>Key 属性的是为每个循环项分配一个唯一标识符，优化 <code>patch</code> 的过程</p><p>Key 属性帮助Vue更高效地更新DOM。当数据发生变化时，Vue会通过比较新旧虚拟DOM树来确定如何更新实际DOM。Key 可以帮助Vue识别哪些元素是已存在的、哪些是新增的、哪些是移除的，从而减少不必要的DOM操作。没有 Key 时，Vue只会简单地按照顺序更新元素，这样会导致一些无需的DOM操作导致性能下降</p><ul><li>如果发现新旧节点的 Key 值相同，那么就认为是相同的节点，不会再去重新渲染，而是复用之前的 DOM 节点</li><li>如果发现新旧节点的 Key 值不同，那么就认为是不同的节点，会重新渲染</li></ul><p>作用：</p><ol><li>减少不必要的节点重渲染，提高渲染效率</li><li>为了更好的复用之前的 DOM 节点，提升性能</li></ol><h2 id="vue-首次实例创建和挂载发生了什么" tabindex="-1">Vue 首次实例创建和挂载发生了什么 <a class="header-anchor" href="#vue-首次实例创建和挂载发生了什么" aria-label="Permalink to &quot;Vue 首次实例创建和挂载发生了什么&quot;">​</a></h2><p><code>createApp()</code> 会创建一个 App 实例，内部通过 <code>const app = ensureRenderer().createApp(...args)</code> 来进行实例的创建。内部最终是执行了一个函数 <code>createAppApi()</code> 来创建实例的。 方法会返回一个函数就叫做 <code>createApp</code>。内部会创建一个对象，最终返回这个对象，而这个对象就是 App 实例。</p><p>整个 App 实例呢配置了很多平时开发常用的 API，例如：<code>app.use()</code>、<code>app.mixin()</code>、<code>app.component()</code>、<code>app.directive()</code>、<code>app.mount()</code>、<code>app.provide()</code></p><p>创建完实例是，会提取内部写的 <code>mount</code> 方法，并且重写 <code>app.mount</code> 方法</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重写这块的方法主要是进行的是实例挂载前的清理工作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">containerOrSelector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ShadowRoot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取#app DOM Element</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> normalizeContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(containerOrSelector);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果没有就不会挂载 直接 return</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">container) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在挂载之前清理掉 DOM根节点里面的内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  container.innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里执行的是 App实例原有的mount方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(container, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, container </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SVGElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (container </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;v-cloak&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data-v-app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proxy;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>最后执行挂载方法，主要做了两件事。1. 通过 <code>createVNode()</code> 来创建虚拟 DOM 2. 调用 <code>render()</code> 渲染方法来渲染生成的虚拟 DOM 挂载到跟页面上</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  rootContainer: HostElement,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  isHydrate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> boolean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  isSVG</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> boolean</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): any {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isMounted) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 创建虚拟DOM</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vnode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      rootComponent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      rootProps</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isHydrate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hydrate) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      hydrate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, rootContainer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 调用渲染函数 runtime-core/src/renderer.ts 1227行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode, rootContainer, isSVG)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行完 render后表示挂载完成 修改 isMounted</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    isMounted </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getExposeProxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode.component</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.component</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.proxy</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre></div><p>总结：在实例创建阶段，Vue 会将一些全局 API 定义，在实例挂载阶段创建虚拟 DOM 最后调用渲染函数将虚拟 DOM 进行渲染</p><ol><li>创建 Vue 实例对象</li><li>配置实例属性和方法</li><li>执行 <code>mount</code> 方法</li><li>创建虚拟DOM（createVNode）</li><li>渲染挂载虚拟DOM（render）</li></ol><h2 id="vue-项目是如何解决跨域的呢" tabindex="-1">Vue 项目是如何解决跨域的呢 <a class="header-anchor" href="#vue-项目是如何解决跨域的呢" aria-label="Permalink to &quot;Vue 项目是如何解决跨域的呢&quot;">​</a></h2><p>同源策略是Web浏览器强制执行的安全机制，限制Web页面向其他源发出请求</p><p>同源条件：就是指在同一个域下（协议相同、主机相同、端口相同）的情况下</p><p>非同源：则上面条件有一个不同的都属于非同源，这个时候就会产生跨域问题</p><p>如何解决跨域有很多：<code>JSONP</code>、<code>CORS</code>、<code>Proxy</code>。实际开发中主要会采用 <code>CORS</code>、<code>Proxy</code> 这两种</p><h3 id="cors" tabindex="-1">CORS <a class="header-anchor" href="#cors" aria-label="Permalink to &quot;CORS&quot;">​</a></h3><p>CORS 跨域资源共享（Cross-Origin Resource Sharing）它是由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p><p>CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。一般都是后端配置 CORS，就可以实现跨域资源共享</p><p><code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code> 和 <code>Access-Control-Allow-Headers</code></p><p><code>Koa</code> 服务框架为例：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Origin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;Access-Control-Allow-Headers&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Methods&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;PUT, POST, GET, DELETE, OPTIONS&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ctx.method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;OPTIONS&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ctx.body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;Proxy&quot;">​</a></h3><p>代理服务器充当客户端和目标服务器之间的中介。客户端将请求发送到代理服务器，代理服务器将请求转发到目标服务器。然后将响应传递回客户端。这样，客户端代码不知道请求的跨域性质。</p><p><strong>方案一</strong>：平时开发中如果后台没有配置去 CORS，一般会通过脚手架来配置本地代理服务器，通过该服务器转发请求到后台服务，得到结果返回给前端。但是本地代理只是在开发中有效果，最终发布上线时如果 Web 应用和接口服务器不在一起仍会跨域</p><p>以 <code>vue-cli</code> 脚手架为例</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  devServer: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    host: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;127.0.0.1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    port: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8084</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    open: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vue项目启动时自动打开浏览器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    proxy: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;/api&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // &#39;/api&#39;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://xxx.xxx.xx.xx:8080&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//目标地址，一般是指后台服务器地址</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        changeOrigin: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//是否跨域</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pathRewrite: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // pathRewrite 的作用是把实际Request Url中的&#39;/api&#39;用&quot;&quot;代替</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &#39;^/api&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>通过 axios 发送请求中，配置请求的根路径：<code>axios.defaults.baseURL = &#39;/api&#39;</code></p><p><strong>方案二</strong>：通过配置 <code>Nginx</code> 实现反向代理</p><h2 id="自定义指令是什么-应用场景有哪些" tabindex="-1">自定义指令是什么？应用场景有哪些？ <a class="header-anchor" href="#自定义指令是什么-应用场景有哪些" aria-label="Permalink to &quot;自定义指令是什么？应用场景有哪些？&quot;">​</a></h2><p>在 <code>Vue</code> 中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统</p><p>不同的指令可以完成或实现不同的功能，除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令</p><h3 id="如何实现自定义指令" tabindex="-1">如何实现自定义指令 <a class="header-anchor" href="#如何实现自定义指令" aria-label="Permalink to &quot;如何实现自定义指令&quot;">​</a></h3><p>全局注册主要是通过 <code>Vue.directive</code> 方法进行注册。第一个参数是指令名称，第二个参数可以是对象，也可以是一个指令函数</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注册一个全局自定义指令 \`v-focus\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;focus&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 当被绑定的元素插入到 DOM 中时……</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  inserted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 聚焦元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>存在如下钩子函数：</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</li><li><code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</li><li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用</li></ul><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><ul><li>一键 Copy 功能</li><li>权限按钮</li><li>防止表单重复提交</li></ul><h2 id="keepalive-缓存组件" tabindex="-1">KeepAlive 缓存组件 <a class="header-anchor" href="#keepalive-缓存组件" aria-label="Permalink to &quot;KeepAlive 缓存组件&quot;">​</a></h2><p>KeepAlive 组件用于缓存、保持组件状态。会将不活动的组件实例缓存起来，不会去销毁它们，可以保证组件的活性。</p><p>结合 <code>include</code> 和 <code>exclude</code> 可以明确指定缓存哪些组件或排除缓存指定组件</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">view</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 结合 VueRouter --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ Component }</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Component</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>KeepAlive 组件的过程如下：</p><ol><li>当第一次渲染 KeepAlive 包裹的组件时，组件的 <code>activated</code> 生命周期钩子被调用。此时，组件被创建并添加到缓存中</li><li>如果组件被导航离开或隐藏， <code>deactivated</code> 生命周期钩子被调用。组件不会被销毁，而是保留在缓存中并保持其状态</li><li>当组件再次被导航到或重新激活时，activated 钩子被再次调用，并且组件从缓存中取出，状态得以恢复</li></ol><p>作用：KeepAlive 组件可以提高组件的渲染性能，避免重复创建和销毁组件，同时保留组件的状态，提供更流畅的用户体验</p><h2 id="关于首屏加载优化处理" tabindex="-1">关于首屏加载优化处理 <a class="header-anchor" href="#关于首屏加载优化处理" aria-label="Permalink to &quot;关于首屏加载优化处理&quot;">​</a></h2><ol><li>减小打包后入口文件的体积 <ul><li>针对代码规范封装、抽离合理，代码压缩</li><li>静态资源文件无损压缩</li><li>常用的NPM包或者库，打包配置CDN链接</li><li>尽量使用支持TreeShaking的包和库</li><li>配置打包，抽离公共模块的代码Chunks</li><li>开启GZIP压缩（需要服务端支持）</li></ul></li><li>使用路由懒加载、异步组件和动态组件（减少首次加载时，加载一些无关的组件文件）</li><li>利用浏览器缓存策略</li><li>利用 Async 延迟加载属性，等待页面 HTML+CSS 被渲染出来了在执行脚本文件</li><li>设置首屏加载Loading动画效果（优化用户体验）</li><li>骨架屏（优化用户体验）</li></ol><h2 id="常见修饰符" tabindex="-1">常见修饰符 <a class="header-anchor" href="#常见修饰符" aria-label="Permalink to &quot;常见修饰符&quot;">​</a></h2><h3 id="事件修饰符" tabindex="-1">事件修饰符 <a class="header-anchor" href="#事件修饰符" aria-label="Permalink to &quot;事件修饰符&quot;">​</a></h3><ul><li><code>.stop</code> 阻止事件冒泡</li><li><code>.capture</code> 事件捕获</li><li><code>.prevent</code> 阻止默认事件</li><li><code>.self</code> 只有当事件是从侦听器绑定的元素本身触发时才触发回调</li><li><code>.once</code> 只触发一次事件</li><li><code>.passive</code> 用于提升性能，告诉浏览器你不需要阻止事件的默认行为</li></ul><h3 id="按键修饰符" tabindex="-1">按键修饰符 <a class="header-anchor" href="#按键修饰符" aria-label="Permalink to &quot;按键修饰符&quot;">​</a></h3><ul><li><code>.enter</code> 回车键</li><li><code>.tab</code> 制表键</li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code> ESC 键</li><li><code>.space</code> 空格键</li><li><code>.up</code> 向上箭头键</li><li><code>.down</code> 向下箭头键</li><li><code>.left</code> 向左箭头键</li><li><code>.right</code> 向右箭头键</li></ul><h3 id="表单修饰符" tabindex="-1">表单修饰符 <a class="header-anchor" href="#表单修饰符" aria-label="Permalink to &quot;表单修饰符&quot;">​</a></h3><ul><li><code>.lazy</code> 在 <code>change</code> 事件中同步输入框的值</li><li><code>.number</code> 自动将用户的输入值转为 Number 类型</li><li><code>.trim</code> 自动过滤用户输入的首尾空格</li></ul><h2 id="composition-api-相对于-options-api-的优势" tabindex="-1">Composition API 相对于 Options API 的优势 <a class="header-anchor" href="#composition-api-相对于-options-api-的优势" aria-label="Permalink to &quot;Composition API 相对于 Options API 的优势&quot;">​</a></h2><ol><li>更灵活的逻辑组织。使代码更具有可读性和可维护性</li><li>更好的代码重用。可以将逻辑封装成为可复用的函数</li><li>更好的类型推导和代码提升。提供了更好的代码提示和类型安全性，减少了运行时错误</li><li>更好的逻辑复用和组合。将逻辑与视图层抽离分开，更加灵活</li><li>更小的生产包体积。支持TreeShaking功能，没有使用到的组合式API不会被打包其中</li></ol><h2 id="ref-和-reactive-的区别" tabindex="-1">Ref 和 Reactive 的区别 <a class="header-anchor" href="#ref-和-reactive-的区别" aria-label="Permalink to &quot;Ref 和 Reactive 的区别&quot;">​</a></h2><ol><li>Reactive 接受的是引用数据类型，是对一整个对象的代理。Ref 可以接受基础数据类型也可接受引用数据类型</li><li>Reactive 的缺陷是当将响应式对象进行解构那么解构出来的变量就失去了响应式，必须将其包装为 Ref 或 Computed 来其能被Vue追踪</li><li>Ref 内部使用的是 <code>RefImpl</code> 实现类来完成响应式数据的监听和更新</li><li>Ref 是通过 <code>RefImpl</code> 实现类 <code>get value()</code> 和 <code>set value()</code> 来实现依赖收集和派发更新。之后 <code>set value()</code> 会去比对和原始值的变化，如果有变化就会派发更新执行相关副作用函数</li><li>Ref 如果传递的是一个引用数据类型，会先将引用数据类型转换成代理对象 <code>toReactive(value)</code>。那么访问 <code>.value</code> 时访问的是代理对象而不是原始对象</li></ol><h2 id="异步组件和动态组件" tabindex="-1">异步组件和动态组件 <a class="header-anchor" href="#异步组件和动态组件" aria-label="Permalink to &quot;异步组件和动态组件&quot;">​</a></h2><p>异步组件：需要异步加载某个组件，一般用于性能优化的时候，可以使用异步组件来实现按需加载。</p><p>动态组件：是 Vue 中一个特殊的 Html 元素：<code>&lt;component&gt;</code>，它拥有一个特殊的 is 属性，属性值可以是 已注册组件的名称 或 一个组件的选项对象，它是用于不同组件之间进行动态切换的。</p><h2 id="vuex-和-pinia-有什么区别" tabindex="-1">Vuex 和 Pinia 有什么区别 <a class="header-anchor" href="#vuex-和-pinia-有什么区别" aria-label="Permalink to &quot;Vuex 和 Pinia 有什么区别&quot;">​</a></h2><ol><li>Pinia 没有<code>Mutations</code>的概念，只有<code>states</code>，<code>getters</code>，<code>actions</code>使用它来修改数据</li><li>Pinia 有 TypeScript 的支持，利于开发</li><li>Pinia 也没有<code>Modules</code>的概念，而是映射出为<code>Store</code>概念，每一个 Store 都是通过<code>defineStore</code>生成出来的。</li><li>Pinia 更加轻量级、体积较小</li></ol>`,188)]))}const c=i(l,[["render",t]]);export{r as __pageData,c as default};
