import{_ as s,c as a,o as n,X as o}from"./chunks/framework.6e839c56.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/Vue/RandomRecord.md","filePath":"frontend/Vue/RandomRecord.md"}'),l={name:"frontend/Vue/RandomRecord.md"},p=o(`<h2 id="_1-vue3-组件之间的通信方式有哪些" tabindex="-1">1. Vue3 组件之间的通信方式有哪些 <a class="header-anchor" href="#_1-vue3-组件之间的通信方式有哪些" aria-label="Permalink to &quot;1. Vue3 组件之间的通信方式有哪些&quot;">​</a></h2><ul><li><code>Props、Emits</code>：用于父子组件之间数据的传递</li><li><code>expose、ref</code>：在 Vue3 中我们需要通过 <code>ref</code> 去获取组件的实例，并且 Vue 并不会将所有组件实例属性和方法暴露出来。我们需要通过 <code>defineExpose</code> 将实例的属性和方法暴露出来。在父组件我们可以通过获取组件实例来向子组件传递数据。</li><li><code>透传 Attributes</code>：指的是在子组件中，没使用 prop 或 emits 定义的 attribute，可以通过 <code>$attrs</code> 来访问。<a href="https://cn.vuejs.org/guide/components/attrs.html" target="_blank" rel="noreferrer">文档介绍</a></li><li><code>v-model</code> 语法糖</li><li><code>Slots</code> 插槽</li><li><code>Provide/Inject</code>：适合跨组件传递</li><li>跨组件通信工具</li><li>EventBus 事件总线</li></ul><h2 id="_2-v-if-和-v-for-哪个优先级更高" tabindex="-1">2. <code>v-if</code> 和 <code>v-for</code> 哪个优先级更高 <a class="header-anchor" href="#_2-v-if-和-v-for-哪个优先级更高" aria-label="Permalink to &quot;2. \`v-if\` 和 \`v-for\` 哪个优先级更高&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">优先级比较</p><p>在 Vue2 中 <code>v-for</code> 会比 <code>v-if</code> 的优先级高</p><p>在 Vue3 中 <code>v-if</code> 会比 <code>v-for</code> 的优先级高</p><p>建议：在平时开发中永远不要将两个 API 放在同一个元素上。可以根据需求在外部包裹一层 <code>&lt;template v-for/v-if&gt;&lt;/template&gt;</code></p></div><h2 id="_3-v-model-双向绑定使用" tabindex="-1">3. <code>v-model</code> 双向绑定使用 <a class="header-anchor" href="#_3-v-model-双向绑定使用" aria-label="Permalink to &quot;3. \`v-model\` 双向绑定使用&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title"><code>v-model</code></p><p><code>v-model</code> 是一个语法糖。默认情况下相当于 <code>:value</code> 和 <code>@update:value</code>，使用双向绑定可以减少繁琐事件，提高开发体验。</p><p>Vue3 甚至可以使用参数形式来绑定多个响应式数据。例如： <code>v-model:content</code>、<code>v-model:header</code></p></div><h2 id="_4-vue3-中如何扩展一个组件" tabindex="-1">4. Vue3 中如何扩展一个组件 <a class="header-anchor" href="#_4-vue3-中如何扩展一个组件" aria-label="Permalink to &quot;4. Vue3 中如何扩展一个组件&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">扩展组件</p><p>Vue3 模式下最好通过 Composition API 来进行组件的扩展。首先开发者通过 <code>Props</code> 和 <code>Emits</code> 来与子组件进行通信，之后配合响应式模块可以很方便得多编写独立功能的钩子来提供响应式的数据。</p><p>当我们需要新增组件功能时，只需要在当前的组件基础上新增对应的钩子来完成功能的开发。</p><p><a href="https://staging-cn.vuejs.org/guide/reusability/composables.html" target="_blank" rel="noreferrer">官方关于组合式函数（composables 或 hooks）的介绍和用法</a></p></div><h2 id="_5-v-show-和-v-if-的区别" tabindex="-1">5. <code>v-show</code> 和 <code>v-if</code> 的区别 <a class="header-anchor" href="#_5-v-show-和-v-if-的区别" aria-label="Permalink to &quot;5. \`v-show\` 和 \`v-if\` 的区别&quot;">​</a></h2><p>控制手段：<code>v-show</code> 是通过给元素设置 CSS <code>display: none</code> 来控制元素的显示与否 而<code>v-if</code> 是通过一定的 JS 手段将整个 DOM 节点进行添加或删除</p><p>编译过程：<code>v-if</code> 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件。<code>v-show</code> 只是简单一个基于 CSS 切换</p><p>编译条件：<code>v-if</code> 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和挂载。只有渲染条件为假时，并不做操作，直到为真才渲染</p><p>总结：</p><ol><li><p>通过 <code>v-if</code> 来控制元素或子组件的显示和隐藏会经历实例创建、挂载和销毁等阶段。相对来说性能消耗较大，所以如果有频繁的控制元素的显示隐藏的需要，应当首选 <code>v-show</code></p></li><li><p><code>v-show</code> 由 false 变为 true 的时候不会触发组件的生命周期。<code>v-if</code> 由 false 变为 true 的时候，触发组件的 <code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code> 钩子，由 true 变为 false 的时候触发组件的 <code>beforeDestory</code>、<code>destoryed</code> 方法</p></li></ol><h2 id="_6-谈谈对-vue-数据响应式理解" tabindex="-1">6. 谈谈对 Vue 数据响应式理解 <a class="header-anchor" href="#_6-谈谈对-vue-数据响应式理解" aria-label="Permalink to &quot;6. 谈谈对 Vue 数据响应式理解&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>数据响应式：数据驱动视图的思想,<strong>能够使数据变化可以被检测并且做出相应的响应机制</strong></p><p>MVVM 框架中都要解决一个核心的问题是<strong>如何连接数据层和视图层</strong>。通过<strong>数据驱动视图</strong>，数据变化，视图更新，要做到这点的就需要做到数据响应式处理</p><p>在 Vue2 中，采用的是 <code>Object.defineProperty()</code> 的方式对响应式数据进行拦截。但是使用此 API 有一些缺点：1. 新增或删除属性的不会被依赖收集也就不会有响应式的特性，需要使用 <code>Vue.set/delete</code> 等 API 才能生效。2. 对应 ES6 中的 Map、Set 这些数据结构不支持。</p><p>在 Vue3 中 采用的是 ES6 的 <code>Proxy</code>代理实现数据的响应式</p></div><h2 id="_7-虚拟-dom-的理解" tabindex="-1">7. 虚拟 DOM 的理解 <a class="header-anchor" href="#_7-虚拟-dom-的理解" aria-label="Permalink to &quot;7. 虚拟 DOM 的理解&quot;">​</a></h2><p>虚拟 DOM：就是 JavaScript 对象，它通过不同的属性去描述一个 DOM 节点的视图结构</p><p>虚拟 DOM 如何生成？</p><p>在 Vue 中我们会为组件编写模板 template，这个模板会被编译器 compiler 编译为渲染函数，在接下来的挂载时刻 mount 过程中会调用 render 渲染函数来返回 虚拟 DOM，在后续的 patch 过程中会进一步转换为真实 DOM</p><p>挂载过程结束后，Vue 会进入更新流程，如果发现有响应式数据发生变化，就会引起组件重新渲染，此时就会产生新的虚拟 DOM，和上一次的渲染结构 Diff 就可以得到变化的地方，从而转换为最小量的 DOM 操作，高效更新视图</p><h2 id="_8-对-diff-算法的理解" tabindex="-1">8. 对 Diff 算法的理解 <a class="header-anchor" href="#_8-对-diff-算法的理解" aria-label="Permalink to &quot;8. 对 Diff 算法的理解&quot;">​</a></h2><p>Vue 中的 <code>diff</code> 算法又称为 <code>patching</code> 算法。虚拟 DOM 想要转换为真实 DOM 就需要通过此方法进行转换</p><p>Vue 中 <code>diff</code> 执行的时刻是组件内响应式数据变更触发实例执行其更新函数时，更新函数会再次执行渲染函数获得最新虚拟 DOM，然后执行 <code>patch</code> 函数，并传入新旧两次虚拟 DOM，通过对比两者找到变化的地方，最后将其转换为真实的 DOM</p><p>Patch 过程是一个递归过程，遵循一个<strong>同层比较，深度优先</strong>策略</p><ul><li>首先判断两个节点是否为相同同类节点，不同则删除重新创建</li><li>如果双方都是文本则更新文本内容</li><li>如果双方都是元素节点则递归更新子元素，同时更新元素属性</li><li>更新子节点又分为几种情况： <ul><li>新的子节点是文本，老的子节点是数组则清空，并设置文本</li><li>新的子节点是文本，老的字节点是文本则直接更新文本</li><li>新的子节点是数组，老的子节点是文本则清空文本，并创建子节点数组中的子元素</li><li>新的节点是数组，老的子节点也是数组，那么比较两组子节点，更新细节</li></ul></li></ul><p>Vue3 在 diff 算法中相比增加了 更新类型标记 来优化算法。作用就是为了在发送变化的地方添加一个 <code>flag</code> 标记，下次发送变化的时候直接找该地方进行比较。</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#758575DD;">&lt;!-- 对于单个有动态绑定的元素来说，我们可以在编译时推断出大量信息 --&gt;</span></span>
<span class="line"><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">template</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#758575DD;">&lt;!-- 仅含 class 绑定 --&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">div</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">:class</span><span style="color:#666666;">=</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">{ active }</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">&gt;&lt;/</span><span style="color:#4D9375;">div</span><span style="color:#666666;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#758575DD;">&lt;!-- 仅含 id 和 value 绑定 --&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">input</span><span style="color:#666666;"> </span><span style="color:#BD976A;">:id</span><span style="color:#666666;">=</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">id</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;"> </span><span style="color:#BD976A;">:value</span><span style="color:#666666;">=</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">value</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#758575DD;">&lt;!-- 仅含文本子节点 --&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">div</span><span style="color:#666666;">&gt;</span><span style="color:#DBD7CAEE;">{{ dynamic }}</span><span style="color:#666666;">&lt;/</span><span style="color:#4D9375;">div</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#666666;">&lt;/</span><span style="color:#4D9375;">template</span><span style="color:#666666;">&gt;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#A0ADA0;">&lt;!-- 对于单个有动态绑定的元素来说，我们可以在编译时推断出大量信息 --&gt;</span></span>
<span class="line"><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">template</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#A0ADA0;">&lt;!-- 仅含 class 绑定 --&gt;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">div</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">:class</span><span style="color:#999999;">=</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">{ active }</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">&gt;&lt;/</span><span style="color:#1E754F;">div</span><span style="color:#999999;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#A0ADA0;">&lt;!-- 仅含 id 和 value 绑定 --&gt;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">input</span><span style="color:#999999;"> </span><span style="color:#B07D48;">:id</span><span style="color:#999999;">=</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">id</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;"> </span><span style="color:#B07D48;">:value</span><span style="color:#999999;">=</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">value</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#A0ADA0;">&lt;!-- 仅含文本子节点 --&gt;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">div</span><span style="color:#999999;">&gt;</span><span style="color:#393A34;">{{ dynamic }}</span><span style="color:#999999;">&lt;/</span><span style="color:#1E754F;">div</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#999999;">&lt;/</span><span style="color:#1E754F;">template</span><span style="color:#999999;">&gt;</span></span></code></pre></div><p>就是在编译阶段，会为模板生成渲染函数时，会判断每个元素所需要的更新类型，并且打上标记。在更新阶段进行 Diff 的时候就会根据这些类型标记去做对应的更新，极大的优化递归的过程</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#80A665;">createElementVNode</span><span style="color:#666666;">(</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">div</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#666666;">    </span><span style="color:#B8A965;">class</span><span style="color:#666666;">: </span><span style="color:#80A665;">_normalizeClass</span><span style="color:#666666;">({ </span><span style="color:#B8A965;">active</span><span style="color:#666666;">: </span><span style="color:#BD976A;">_ctx</span><span style="color:#666666;">.</span><span style="color:#BD976A;">active</span><span style="color:#666666;"> }),</span></span>
<span class="line"><span style="color:#666666;">  },</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#CB7676;">null</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#4C9A91;">2</span><span style="color:#DBD7CAEE;"> </span><span style="color:#758575DD;">/* CLASS */</span></span>
<span class="line"><span style="color:#666666;">);</span></span>
<span class="line"><span style="color:#758575DD;">// 最后这个参数 2 就是一个更新类型标记 (patchFlag)</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#59873A;">createElementVNode</span><span style="color:#999999;">(</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">div</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">    </span><span style="color:#998418;">class</span><span style="color:#999999;">: </span><span style="color:#59873A;">_normalizeClass</span><span style="color:#999999;">({ </span><span style="color:#998418;">active</span><span style="color:#999999;">: </span><span style="color:#B07D48;">_ctx</span><span style="color:#999999;">.</span><span style="color:#B07D48;">active</span><span style="color:#999999;"> }),</span></span>
<span class="line"><span style="color:#999999;">  },</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">null</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#2F798A;">2</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">/* CLASS */</span></span>
<span class="line"><span style="color:#999999;">);</span></span>
<span class="line"><span style="color:#A0ADA0;">// 最后这个参数 2 就是一个更新类型标记 (patchFlag)</span></span></code></pre></div><h2 id="_9-vue2-object-defineproperty-和-vue3-proxy有什么区别" tabindex="-1">9. Vue2 <code>Object.defineProperty</code> 和 Vue3 <code>Proxy</code>有什么区别 <a class="header-anchor" href="#_9-vue2-object-defineproperty-和-vue3-proxy有什么区别" aria-label="Permalink to &quot;9. Vue2 \`Object.defineProperty\` 和 Vue3 \`Proxy\`有什么区别&quot;">​</a></h2><p><code>defineProperty</code> 是 ES5 新增的方法，是对一个对象新增或修改某个属性，然后返回该对象</p><p><code>Proxy</code> 是 E56 新增的，是对对象的代理，并不是直接的去修改对象</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>区别：在 Vue2 中 <code>defineProperty</code> 只能对定义好的数据进行数据监听，而新增属性或删除数据是不会被监听的，也就会失去响应式的特性。而 <code>Proxy</code> 是对整个对象的代理监听。</p></div><h2 id="_10-响应式数据发生改变之后-vue-做了什么事情" tabindex="-1">10. 响应式数据发生改变之后 Vue 做了什么事情 <a class="header-anchor" href="#_10-响应式数据发生改变之后-vue-做了什么事情" aria-label="Permalink to &quot;10. 响应式数据发生改变之后 Vue 做了什么事情&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当响应式数据监听到数据的变化后，会触发对应组件的渲染方法，渲染前会调用 <code>beforeUpdate</code> 钩子函数，在渲染的过程中会 <code>patch</code> 重新获取变化后的虚拟 DOM 然后渲染到页面上，渲染后在去调用 <code>updated</code> 钩子函数。</p></div><h2 id="_11-谈谈-vue-的生命周期吧" tabindex="-1">11. 谈谈 Vue 的生命周期吧 <a class="header-anchor" href="#_11-谈谈-vue-的生命周期吧" aria-label="Permalink to &quot;11. 谈谈 Vue 的生命周期吧&quot;">​</a></h2><p>Vue 实例有一个完整的生命周期。从实例创建、初始化数据、编译模板、挂载 DOM、渲染、更新、又渲染、卸载等一系列过程，就是 Vue 的声明周期</p><ul><li><code>beforeCreate</code>：组件实例创建之前调用，此时还无法访问到相关方法和数据</li><li><code>created</code>：组件实例创建之后调用。实例完成：数据观测、属性和方法的运算、 watch/event 事件回调。但是 DOM 还未挂载</li><li><code>beforeMount</code>：挂载之前调用，相关 render 函数首次被调用</li><li><code>mounted</code>：组件实例被挂载到 DOM 上之后调用</li><li><code>beforeUpdate</code>：响应式数据被更新前调用，发生在虚拟 DOM 重新渲染和打补丁</li><li><code>updated</code>：由于数据更新导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</li><li><code>beforeDestroy</code>：组件实例销毁前调用</li><li><code>destroyed</code>：组件实例销毁之后调用</li></ul><h2 id="_12-说说-nexttick-的使用" tabindex="-1">12. 说说 <code>nextTick</code> 的使用 <a class="header-anchor" href="#_12-说说-nexttick-的使用" aria-label="Permalink to &quot;12. 说说 \`nextTick\` 的使用&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>nextTick()</code> 是等待下一次 DOM 更新刷新的工具方法</p><p>Vue 有一个异步更新策略，意思就是如果数据变化，Vue 不会立即更新 DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更后会异步的批量更新。这一策略会导致我们对数据的修改不会及时的体现在 DOM 上，此时如果想要获取更新后的 DOM 状态，就需要使用 <code>nextTick</code></p></div><h2 id="_13-watch-和-computed-的区别" tabindex="-1">13. <code>watch</code> 和 <code>computed</code> 的区别 <a class="header-anchor" href="#_13-watch-和-computed-的区别" aria-label="Permalink to &quot;13. \`watch\` 和 \`computed\` 的区别&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>computed：会返回一个只读的响应式的数据</p><p>watch：检测响应式数据的变化，执行回调</p><p>区别：</p><ol><li><p>计算属性可以从响应式数据派生出自己需要的响应式属性。监听器可以监测某个响应式数据的变化并且执行对应的副作用，可以执行一些异步操作等复杂逻辑</p></li><li><p>两个的使用场景不同。计算属性一般用于对响应式数据进行加工处理得到的全新的响应式数据。监听器则是在数据发送变化后需要执行的操作</p></li></ol></div><h2 id="_14-vue-router-中-hash-模式和-history-模式的区别" tabindex="-1">14. Vue Router 中 hash 模式和 history 模式的区别 <a class="header-anchor" href="#_14-vue-router-中-hash-模式和-history-模式的区别" aria-label="Permalink to &quot;14. Vue Router 中 hash 模式和 history 模式的区别&quot;">​</a></h2><p>SPA 即<strong>单页面应用程序</strong>。只有一个 HTML 文件并且在<strong>用户与应用程序进行交互时</strong>动态的更新此页面的 Web 应用程序。浏览器一开始会加载必需的 HTML 、 CSS 和 JavaScript ，而所有的页面更新操作<strong>都由 JavaScript 来控制</strong>。</p><ul><li>SPA 的优点：用户体验好、页面内容的改变不需要我们去重新加载新的页面</li><li>SPA 的缺点：不利于搜索引擎的抓取，首页加载时间会过长、页面渲染的速度会相对较慢</li></ul><p>单页面应用程序时就提供了 Hash 和 History 两种模式</p><h3 id="hash-模式" tabindex="-1">Hash 模式 <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;Hash 模式&quot;">​</a></h3><p>Hash 模式的前端路由的路径是用井号 # 拼接在真实 URL 后面的。当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 <code>onhashchange</code> 事件。</p><p>例如：<a href="https://vadmire.top/#/login" target="_blank" rel="noreferrer">https://vadmire.top/#/login</a></p><p>特点：</p><ul><li><ol><li>Hash 变化会出现页面跳转即浏览器的前进和后退。</li></ol></li><li><ol start="2"><li>Hash 改变的是 # 后面的路由不会刷新页面，所有的更新操作是由 JavaScript 来实现的，并不会向服务器发送 HTTP 请求去获取对应路径页面。</li></ol></li><li><ol start="3"><li>Hash 通过 <code>window.onhashchange</code> 的方式，来监听 Hash 的改变，借此实现无刷新跳转的功能</li></ol></li></ul><h3 id="history-模式" tabindex="-1">History 模式 <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;History 模式&quot;">​</a></h3><p><code>History API</code> 是 HTML5 提供的新特性，允许开发者<strong>直接更改前端路由</strong>，即更新浏览器 URL 地址而不会<strong>重新发起请求</strong>。总结一句话：页面内容没变，地址栏的地址改变了</p><p>当我们使用 <code>History</code> 模式将前端项目部署上线后，在我们通过 <code>index.html</code> 去访问单页面应用某个路径下的内容，正常的路由跳转是没有问题的。<strong>但是我们重新刷新页面的时候就会出现 404 的情况</strong></p><p>原因在于：重新刷新页面后浏览器会重新发送一次 HTTP 请求，去请求对应路径下的页面。但是服务器其实是没有这个页面的所以会报 404 的情况。这个时候我们就需要 <strong>通过服务端来允许访问如何路径下的页面重定向到</strong> <code>index.html</code> 上</p><p>这里有一个小细节，如果出现真的 404 页面了呢？</p><p>因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#CB7676;">const </span><span style="color:#BD976A;">router</span><span style="color:#CB7676;"> </span><span style="color:#666666;">=</span><span style="color:#CB7676;"> new </span><span style="color:#80A665;">VueRouter</span><span style="color:#666666;">({</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#B8A965;">mode</span><span style="color:#666666;">: </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">history</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#B8A965;">routes</span><span style="color:#666666;">: [{ </span><span style="color:#B8A965;">path</span><span style="color:#666666;">: </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">*</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">, </span><span style="color:#B8A965;">component</span><span style="color:#666666;">: </span><span style="color:#BD976A;">NotFoundComponent</span><span style="color:#666666;"> }],</span></span>
<span class="line"><span style="color:#666666;">});</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#AB5959;">const </span><span style="color:#B07D48;">router</span><span style="color:#AB5959;"> </span><span style="color:#999999;">=</span><span style="color:#AB5959;"> new </span><span style="color:#59873A;">VueRouter</span><span style="color:#999999;">({</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#998418;">mode</span><span style="color:#999999;">: </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">history</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#998418;">routes</span><span style="color:#999999;">: [{ </span><span style="color:#998418;">path</span><span style="color:#999999;">: </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">*</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">, </span><span style="color:#998418;">component</span><span style="color:#999999;">: </span><span style="color:#B07D48;">NotFoundComponent</span><span style="color:#999999;"> }],</span></span>
<span class="line"><span style="color:#999999;">});</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>针对不同的应用场景我们可以选择不同模式</p><ul><li>如果是 <code>B端</code> 系统更加推荐 Hash 模式，相对简单容易</li><li>如果是 <code>C端</code> 系统对外观有一定要求就可以考虑选择 <code>History</code> 模式但是需要 <strong>服务端支持</strong></li></ul><h2 id="_15-key-的作用" tabindex="-1">15. Key 的作用 <a class="header-anchor" href="#_15-key-的作用" aria-label="Permalink to &quot;15. Key 的作用&quot;">​</a></h2><p>Key 的作用是用于优化的 <code>patch</code> 性能的，更高效的更新虚拟 DOM</p><p>实际开发使用中在渲染一组列表是 key 是必须设置的，而且必须是唯一标识，应该避免使用数组索引作为 Key，这可能导致一些隐藏的 Bug</p><p>Vue 在使用相同标签元素过渡切换时，也会使用 Key 属性，其目的是为了让 Vue 可以区分它们，否则 Vue 只会替换其内部属性而不会触发过渡效果</p><h2 id="_16-vue-首次实例创建和挂载发生了什么" tabindex="-1">16. Vue 首次实例创建和挂载发生了什么 <a class="header-anchor" href="#_16-vue-首次实例创建和挂载发生了什么" aria-label="Permalink to &quot;16. Vue 首次实例创建和挂载发生了什么&quot;">​</a></h2><p><code>createApp()</code> 会创建一个 App 实例，内部通过 <code>const app = ensureRenderer().createApp(...args)</code> 来进行实例的创建。内部最终是执行了一个函数 <code>createAppApi()</code> 来创建实例的。 方法会返回一个函数就叫做 <code>createApp</code>。内部会创建一个对象，最终返回这个对象，而这个对象就是 App 实例。</p><p>整个 App 实例呢配置了很多平时开发常用的 API，例如：<code>app.use()</code>、<code>app.mixin()</code>、<code>app.component()</code>、<code>app.directive()</code>、<code>app.mount()</code>、<code>app.provide()</code></p><p>创建完实例是，会提取内部写的 <code>mount</code> 方法，并且重写 <code>app.mount</code> 方法</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#758575DD;">// 重写这块的方法主要是进行的是实例挂载前的清理工作</span></span>
<span class="line"><span style="color:#BD976A;">app</span><span style="color:#666666;">.</span><span style="color:#80A665;">mount</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">(</span><span style="color:#BD976A;">containerOrSelector</span><span style="color:#666666;">: </span><span style="color:#5DA994;">Element</span><span style="color:#666666;"> | </span><span style="color:#5DA994;">ShadowRoot</span><span style="color:#666666;"> | </span><span style="color:#5DA994;">string</span><span style="color:#666666;">):</span><span style="color:#DBD7CAEE;"> </span><span style="color:#5DA994;">any</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">=&gt;</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#758575DD;">// 获取#app DOM Element</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#CB7676;">const </span><span style="color:#BD976A;">container</span><span style="color:#CB7676;"> </span><span style="color:#666666;">=</span><span style="color:#CB7676;"> </span><span style="color:#80A665;">normalizeContainer</span><span style="color:#666666;">(</span><span style="color:#BD976A;">containerOrSelector</span><span style="color:#666666;">);</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#758575DD;">// 如果没有就不会挂载 直接 return</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#4D9375;">if</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">(</span><span style="color:#CB7676;">!</span><span style="color:#BD976A;">container</span><span style="color:#666666;">)</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">return</span><span style="color:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#758575DD;">// 在挂载之前清理掉 DOM根节点里面的内容</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">container</span><span style="color:#666666;">.</span><span style="color:#BD976A;">innerHTML</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#C98A7D99;">&quot;&quot;</span><span style="color:#666666;">;</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#758575DD;">// 这里执行的是 App实例原有的mount方法</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#CB7676;">const </span><span style="color:#BD976A;">proxy</span><span style="color:#CB7676;"> </span><span style="color:#666666;">=</span><span style="color:#CB7676;"> </span><span style="color:#80A665;">mount</span><span style="color:#666666;">(</span><span style="color:#BD976A;">container</span><span style="color:#666666;">,</span><span style="color:#CB7676;"> </span><span style="color:#4D9375;">false</span><span style="color:#666666;">,</span><span style="color:#CB7676;"> </span><span style="color:#BD976A;">container</span><span style="color:#CB7676;"> instanceof </span><span style="color:#5DA994;">SVGElement</span><span style="color:#666666;">);</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#4D9375;">if</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">(</span><span style="color:#BD976A;">container</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">instanceof</span><span style="color:#DBD7CAEE;"> </span><span style="color:#5DA994;">Element</span><span style="color:#666666;">)</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#BD976A;">container</span><span style="color:#666666;">.</span><span style="color:#80A665;">removeAttribute</span><span style="color:#666666;">(</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">v-cloak</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">);</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#BD976A;">container</span><span style="color:#666666;">.</span><span style="color:#80A665;">setAttribute</span><span style="color:#666666;">(</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">data-v-app</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#C98A7D99;">&quot;&quot;</span><span style="color:#666666;">);</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">}</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#4D9375;">return</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">proxy</span><span style="color:#666666;">;</span></span>
<span class="line"><span style="color:#666666;">};</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#A0ADA0;">// 重写这块的方法主要是进行的是实例挂载前的清理工作</span></span>
<span class="line"><span style="color:#B07D48;">app</span><span style="color:#999999;">.</span><span style="color:#59873A;">mount</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#999999;">(</span><span style="color:#B07D48;">containerOrSelector</span><span style="color:#999999;">: </span><span style="color:#2E8F82;">Element</span><span style="color:#999999;"> | </span><span style="color:#2E8F82;">ShadowRoot</span><span style="color:#999999;"> | </span><span style="color:#2E8F82;">string</span><span style="color:#999999;">):</span><span style="color:#393A34;"> </span><span style="color:#2E8F82;">any</span><span style="color:#393A34;"> </span><span style="color:#999999;">=&gt;</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#A0ADA0;">// 获取#app DOM Element</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">const </span><span style="color:#B07D48;">container</span><span style="color:#AB5959;"> </span><span style="color:#999999;">=</span><span style="color:#AB5959;"> </span><span style="color:#59873A;">normalizeContainer</span><span style="color:#999999;">(</span><span style="color:#B07D48;">containerOrSelector</span><span style="color:#999999;">);</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#A0ADA0;">// 如果没有就不会挂载 直接 return</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#1E754F;">if</span><span style="color:#393A34;"> </span><span style="color:#999999;">(</span><span style="color:#AB5959;">!</span><span style="color:#B07D48;">container</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">return</span><span style="color:#999999;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#A0ADA0;">// 在挂载之前清理掉 DOM根节点里面的内容</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">container</span><span style="color:#999999;">.</span><span style="color:#B07D48;">innerHTML</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;&quot;</span><span style="color:#999999;">;</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#A0ADA0;">// 这里执行的是 App实例原有的mount方法</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">const </span><span style="color:#B07D48;">proxy</span><span style="color:#AB5959;"> </span><span style="color:#999999;">=</span><span style="color:#AB5959;"> </span><span style="color:#59873A;">mount</span><span style="color:#999999;">(</span><span style="color:#B07D48;">container</span><span style="color:#999999;">,</span><span style="color:#AB5959;"> </span><span style="color:#1E754F;">false</span><span style="color:#999999;">,</span><span style="color:#AB5959;"> </span><span style="color:#B07D48;">container</span><span style="color:#AB5959;"> instanceof </span><span style="color:#2E8F82;">SVGElement</span><span style="color:#999999;">);</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#1E754F;">if</span><span style="color:#393A34;"> </span><span style="color:#999999;">(</span><span style="color:#B07D48;">container</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">instanceof</span><span style="color:#393A34;"> </span><span style="color:#2E8F82;">Element</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#B07D48;">container</span><span style="color:#999999;">.</span><span style="color:#59873A;">removeAttribute</span><span style="color:#999999;">(</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">v-cloak</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">);</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#B07D48;">container</span><span style="color:#999999;">.</span><span style="color:#59873A;">setAttribute</span><span style="color:#999999;">(</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">data-v-app</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;&quot;</span><span style="color:#999999;">);</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#1E754F;">return</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">proxy</span><span style="color:#999999;">;</span></span>
<span class="line"><span style="color:#999999;">};</span></span></code></pre></div><p>最后执行挂载方法，主要做了两件事。1. 通过 <code>createVNode()</code> 来创建虚拟 DOM 2. 调用 <code>render()</code> 渲染方法来渲染生成的虚拟 DOM 挂载到跟页面上</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#80A665;">mount</span><span style="color:#666666;">(</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">rootContainer</span><span style="color:#DBD7CAEE;">: </span><span style="color:#BD976A;">HostElement</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">isHydrate</span><span style="color:#CB7676;">?:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">boolean</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">isSVG</span><span style="color:#CB7676;">?:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">boolean</span></span>
<span class="line"><span style="color:#666666;">)</span><span style="color:#DBD7CAEE;">: </span><span style="color:#BD976A;">any</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#4D9375;">if</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">(</span><span style="color:#CB7676;">!</span><span style="color:#BD976A;">isMounted</span><span style="color:#666666;">)</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#666666;">    </span><span style="color:#758575DD;">// 创建虚拟DOM</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#CB7676;">const </span><span style="color:#BD976A;">vnode</span><span style="color:#CB7676;"> </span><span style="color:#666666;">=</span><span style="color:#CB7676;"> </span><span style="color:#80A665;">createVNode</span><span style="color:#666666;">(</span></span>
<span class="line"><span style="color:#CB7676;">      </span><span style="color:#BD976A;">rootComponent</span><span style="color:#CB7676;"> </span><span style="color:#4D9375;">as</span><span style="color:#CB7676;"> </span><span style="color:#5DA994;">ConcreteComponent</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#CB7676;">      </span><span style="color:#BD976A;">rootProps</span></span>
<span class="line"><span style="color:#CB7676;">    </span><span style="color:#666666;">)</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#4D9375;">if</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">(</span><span style="color:#BD976A;">isHydrate</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">&amp;&amp;</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">hydrate</span><span style="color:#666666;">)</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">      </span><span style="color:#80A665;">hydrate</span><span style="color:#666666;">(</span><span style="color:#BD976A;">vnode</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">as</span><span style="color:#DBD7CAEE;"> </span><span style="color:#5DA994;">VNode</span><span style="color:#666666;">&lt;</span><span style="color:#5DA994;">Node</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#5DA994;">Element</span><span style="color:#666666;">&gt;,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">rootContainer</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">as</span><span style="color:#DBD7CAEE;"> </span><span style="color:#5DA994;">any</span><span style="color:#666666;">)</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#666666;">}</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">else</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#666666;">      </span><span style="color:#758575DD;">// 调用渲染函数 runtime-core/src/renderer.ts 1227行</span></span>
<span class="line"><span style="color:#DBD7CAEE;">      </span><span style="color:#80A665;">render</span><span style="color:#666666;">(</span><span style="color:#BD976A;">vnode</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">rootContainer</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">isSVG</span><span style="color:#666666;">)</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#666666;">}</span></span>
<span class="line"><span style="color:#666666;">    </span><span style="color:#758575DD;">// 执行完 render后表示挂载完成 修改 isMounted</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#BD976A;">isMounted</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">true</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#4D9375;">return</span><span style="color:#DBD7CAEE;"> </span><span style="color:#80A665;">getExposeProxy</span><span style="color:#666666;">(</span><span style="color:#BD976A;">vnode</span><span style="color:#666666;">.</span><span style="color:#BD976A;">component</span><span style="color:#CB7676;">!</span><span style="color:#666666;">)</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">||</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">vnode</span><span style="color:#666666;">.</span><span style="color:#BD976A;">component</span><span style="color:#CB7676;">!</span><span style="color:#666666;">.</span><span style="color:#BD976A;">proxy</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">}</span></span>
<span class="line"><span style="color:#666666;">},</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#59873A;">mount</span><span style="color:#999999;">(</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">rootContainer</span><span style="color:#393A34;">: </span><span style="color:#B07D48;">HostElement</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">isHydrate</span><span style="color:#AB5959;">?:</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">boolean</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">isSVG</span><span style="color:#AB5959;">?:</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">boolean</span></span>
<span class="line"><span style="color:#999999;">)</span><span style="color:#393A34;">: </span><span style="color:#B07D48;">any</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#1E754F;">if</span><span style="color:#393A34;"> </span><span style="color:#999999;">(</span><span style="color:#AB5959;">!</span><span style="color:#B07D48;">isMounted</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">    </span><span style="color:#A0ADA0;">// 创建虚拟DOM</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#AB5959;">const </span><span style="color:#B07D48;">vnode</span><span style="color:#AB5959;"> </span><span style="color:#999999;">=</span><span style="color:#AB5959;"> </span><span style="color:#59873A;">createVNode</span><span style="color:#999999;">(</span></span>
<span class="line"><span style="color:#AB5959;">      </span><span style="color:#B07D48;">rootComponent</span><span style="color:#AB5959;"> </span><span style="color:#1E754F;">as</span><span style="color:#AB5959;"> </span><span style="color:#2E8F82;">ConcreteComponent</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#AB5959;">      </span><span style="color:#B07D48;">rootProps</span></span>
<span class="line"><span style="color:#AB5959;">    </span><span style="color:#999999;">)</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#1E754F;">if</span><span style="color:#393A34;"> </span><span style="color:#999999;">(</span><span style="color:#B07D48;">isHydrate</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">&amp;&amp;</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">hydrate</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">      </span><span style="color:#59873A;">hydrate</span><span style="color:#999999;">(</span><span style="color:#B07D48;">vnode</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">as</span><span style="color:#393A34;"> </span><span style="color:#2E8F82;">VNode</span><span style="color:#999999;">&lt;</span><span style="color:#2E8F82;">Node</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#2E8F82;">Element</span><span style="color:#999999;">&gt;,</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">rootContainer</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">as</span><span style="color:#393A34;"> </span><span style="color:#2E8F82;">any</span><span style="color:#999999;">)</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#999999;">}</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">else</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">      </span><span style="color:#A0ADA0;">// 调用渲染函数 runtime-core/src/renderer.ts 1227行</span></span>
<span class="line"><span style="color:#393A34;">      </span><span style="color:#59873A;">render</span><span style="color:#999999;">(</span><span style="color:#B07D48;">vnode</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">rootContainer</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">isSVG</span><span style="color:#999999;">)</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#999999;">    </span><span style="color:#A0ADA0;">// 执行完 render后表示挂载完成 修改 isMounted</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#B07D48;">isMounted</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">true</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#1E754F;">return</span><span style="color:#393A34;"> </span><span style="color:#59873A;">getExposeProxy</span><span style="color:#999999;">(</span><span style="color:#B07D48;">vnode</span><span style="color:#999999;">.</span><span style="color:#B07D48;">component</span><span style="color:#AB5959;">!</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">||</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">vnode</span><span style="color:#999999;">.</span><span style="color:#B07D48;">component</span><span style="color:#AB5959;">!</span><span style="color:#999999;">.</span><span style="color:#B07D48;">proxy</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#999999;">},</span></span></code></pre></div><p>总结：在实例创建阶段，Vue 会将一些全局 API 定义，在实例挂载阶段创建虚拟 DOM 最后调用渲染函数将虚拟 DOM 进行渲染</p><h2 id="_17-vue-项目部署到服务器后刷新出现-404-的问题" tabindex="-1">17. Vue 项目部署到服务器后刷新出现 404 的问题 <a class="header-anchor" href="#_17-vue-项目部署到服务器后刷新出现-404-的问题" aria-label="Permalink to &quot;17. Vue 项目部署到服务器后刷新出现 404 的问题&quot;">​</a></h2><p>前后端分离开发模式下，前端只需要将项目打包，将打包文件扔到目标服务器即可。Vue 是单页面应用，无论有多少页面构建物都只会产出一个 <code>index.html</code> 文件</p><h3 id="如果路由是-history-模式" tabindex="-1">如果路由是 <code>History</code> 模式 <a class="header-anchor" href="#如果路由是-history-模式" aria-label="Permalink to &quot;如果路由是 \`History\` 模式&quot;">​</a></h3><p><code>History</code> 模式下就会出现页面刷新出现 404 问题</p><p><strong>原因</strong>：在于当我们在地址栏输入 <code>www.xxx.com</code> 地址时，首先一定会访问到服务器的目标文件的 <code>index.html</code> 这时候是不会有 404 的问题。但是如果我们在访问或者重定向到 <code>www.xxx.com/xx</code> 页面时其实就会向服务器发送一个 HTTP 请求，去请求 <code>/xx</code> 页面的文件内容，这个时候自然服务器是没有这个路径的文件资源的。所以就会报 404 问题</p><h3 id="如果路由是-hash-模式" tabindex="-1">如果路由是 <code>Hash</code> 模式 <a class="header-anchor" href="#如果路由是-hash-模式" aria-label="Permalink to &quot;如果路由是 \`Hash\` 模式&quot;">​</a></h3><p><code>Hash</code> 模块是用符号 # 表示的。 如 <code>www.xxx.com/#/xx</code></p><p>它的特点在于 <code>Hash</code> 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 <code>Hash</code> 不会重新加载页面。该模式下仅 <code>Hash</code> 符号之前的内容会被包含在请求中，如 <code>www.xxx.com/#/xx</code> 只有 <code>www.xxx.com</code> 会被包含在请求中</p><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><p>本质单页面应用就只有一个页面，路由则是通过 JS 来执行视图切换的，<code>History</code> 模式下去请求其他不存在的页面自然会报 404 问题。</p><p>所以如果你的项目配置的是 <code>History</code> 模式下，所以进行以下的配置</p><p>解决方案：就是在服务器进行配置，将任意页面都重定向到 <code>index.html</code> 文件，把路由交给前端处理</p><p>以 Nginx 为例子，只需要修改它的配置文件。添加：<code>try_files $uri $uri/ /index.html;</code> 这么一条配置即可</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#BD976A;">server</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">listen</span><span style="color:#DBD7CAEE;">  </span><span style="color:#4C9A91;">80</span><span style="color:#666666;">;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">server_name</span><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">www</span><span style="color:#666666;">.</span><span style="color:#BD976A;">xxx</span><span style="color:#666666;">.</span><span style="color:#BD976A;">com</span><span style="color:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">location</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">/</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#BD976A;">index</span><span style="color:#DBD7CAEE;">  </span><span style="color:#CB7676;">/</span><span style="color:#BD976A;">data</span><span style="color:#CB7676;">/</span><span style="color:#BD976A;">dist</span><span style="color:#CB7676;">/</span><span style="color:#BD976A;">index</span><span style="color:#666666;">.</span><span style="color:#BD976A;">html</span><span style="color:#666666;">;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#BD976A;">try_files</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">$uri</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">$uri</span><span style="color:#CB7676;">/</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">/</span><span style="color:#BD976A;">index</span><span style="color:#666666;">.</span><span style="color:#BD976A;">html</span><span style="color:#666666;">;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">}</span></span>
<span class="line"><span style="color:#666666;">}</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#B07D48;">server</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">listen</span><span style="color:#393A34;">  </span><span style="color:#2F798A;">80</span><span style="color:#999999;">;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">server_name</span><span style="color:#393A34;">  </span><span style="color:#B07D48;">www</span><span style="color:#999999;">.</span><span style="color:#B07D48;">xxx</span><span style="color:#999999;">.</span><span style="color:#B07D48;">com</span><span style="color:#999999;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">location</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">/</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#B07D48;">index</span><span style="color:#393A34;">  </span><span style="color:#AB5959;">/</span><span style="color:#B07D48;">data</span><span style="color:#AB5959;">/</span><span style="color:#B07D48;">dist</span><span style="color:#AB5959;">/</span><span style="color:#B07D48;">index</span><span style="color:#999999;">.</span><span style="color:#B07D48;">html</span><span style="color:#999999;">;</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#B07D48;">try_files</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">$uri</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">$uri</span><span style="color:#AB5959;">/</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">/</span><span style="color:#B07D48;">index</span><span style="color:#999999;">.</span><span style="color:#B07D48;">html</span><span style="color:#999999;">;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#999999;">}</span></span></code></pre></div><p>配置完毕后，重启 Nginx： <code>nginx -s reload</code></p><p>为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#CB7676;">const </span><span style="color:#BD976A;">router</span><span style="color:#CB7676;"> </span><span style="color:#666666;">=</span><span style="color:#CB7676;"> new </span><span style="color:#80A665;">VueRouter</span><span style="color:#666666;">({</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#B8A965;">mode</span><span style="color:#666666;">: </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">history</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#B8A965;">routes</span><span style="color:#666666;">: [</span></span>
<span class="line"><span style="color:#666666;">    { </span><span style="color:#B8A965;">path</span><span style="color:#666666;">: </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">*</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">, </span><span style="color:#B8A965;">component</span><span style="color:#666666;">: </span><span style="color:#BD976A;">NotFoundComponent</span><span style="color:#666666;"> }, </span><span style="color:#758575DD;">// 添加一条匹配404页面的路由</span></span>
<span class="line"><span style="color:#666666;">  ],</span></span>
<span class="line"><span style="color:#666666;">});</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#AB5959;">const </span><span style="color:#B07D48;">router</span><span style="color:#AB5959;"> </span><span style="color:#999999;">=</span><span style="color:#AB5959;"> new </span><span style="color:#59873A;">VueRouter</span><span style="color:#999999;">({</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#998418;">mode</span><span style="color:#999999;">: </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">history</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#998418;">routes</span><span style="color:#999999;">: [</span></span>
<span class="line"><span style="color:#999999;">    { </span><span style="color:#998418;">path</span><span style="color:#999999;">: </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">*</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">, </span><span style="color:#998418;">component</span><span style="color:#999999;">: </span><span style="color:#B07D48;">NotFoundComponent</span><span style="color:#999999;"> }, </span><span style="color:#A0ADA0;">// 添加一条匹配404页面的路由</span></span>
<span class="line"><span style="color:#999999;">  ],</span></span>
<span class="line"><span style="color:#999999;">});</span></span></code></pre></div><h2 id="_18-vue-项目是如何解决跨域的呢" tabindex="-1">18. Vue 项目是如何解决跨域的呢 <a class="header-anchor" href="#_18-vue-项目是如何解决跨域的呢" aria-label="Permalink to &quot;18. Vue 项目是如何解决跨域的呢&quot;">​</a></h2><p>跨域的本质是<strong>浏览器的同源策略</strong>的一种安全手段，它是浏览器最核心也是最基本的安全功能</p><p>同源：就是指在同一个域下（协议相同、主机相同、端口相同）的情况下。非同源：则上面有一个不同都属于非同源，这个时候就会产生跨域</p><p>如何解决跨域有很多：<code>JSONP</code>、<code>CORS</code>、<code>Proxy</code>。实际开发中主要会采用 <code>CORS</code>、<code>Proxy</code> 这两种</p><h3 id="cors" tabindex="-1">CORS <a class="header-anchor" href="#cors" aria-label="Permalink to &quot;CORS&quot;">​</a></h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p><p>CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。一般都是后端配置 CORS，就可以实现跨域资源共享</p><p><code>Koa</code> 服务框架为例：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#BD976A;">app</span><span style="color:#666666;">.</span><span style="color:#80A665;">use</span><span style="color:#666666;">(</span><span style="color:#CB7676;">async</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">(</span><span style="color:#BD976A;">ctx</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">next</span><span style="color:#666666;">)</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">=&gt;</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">ctx</span><span style="color:#666666;">.</span><span style="color:#80A665;">set</span><span style="color:#666666;">(</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">Access-Control-Allow-Origin</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">*</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">);</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">ctx</span><span style="color:#666666;">.</span><span style="color:#80A665;">set</span><span style="color:#666666;">(</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">Access-Control-Allow-Headers</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild</span><span style="color:#C98A7D99;">&quot;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">);</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">ctx</span><span style="color:#666666;">.</span><span style="color:#80A665;">set</span><span style="color:#666666;">(</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">Access-Control-Allow-Methods</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">PUT, POST, GET, DELETE, OPTIONS</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">);</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#4D9375;">if</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">(</span><span style="color:#BD976A;">ctx</span><span style="color:#666666;">.</span><span style="color:#BD976A;">method</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">==</span><span style="color:#DBD7CAEE;"> </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">OPTIONS</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">)</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#BD976A;">ctx</span><span style="color:#666666;">.</span><span style="color:#BD976A;">body</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4C9A91;">200</span><span style="color:#666666;">;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">}</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">else</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#4D9375;">await</span><span style="color:#DBD7CAEE;"> </span><span style="color:#80A665;">next</span><span style="color:#666666;">();</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">}</span></span>
<span class="line"><span style="color:#666666;">});</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#B07D48;">app</span><span style="color:#999999;">.</span><span style="color:#59873A;">use</span><span style="color:#999999;">(</span><span style="color:#AB5959;">async</span><span style="color:#393A34;"> </span><span style="color:#999999;">(</span><span style="color:#B07D48;">ctx</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">next</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#999999;">=&gt;</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">ctx</span><span style="color:#999999;">.</span><span style="color:#59873A;">set</span><span style="color:#999999;">(</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">Access-Control-Allow-Origin</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">*</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">);</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">ctx</span><span style="color:#999999;">.</span><span style="color:#59873A;">set</span><span style="color:#999999;">(</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">Access-Control-Allow-Headers</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild</span><span style="color:#B5695999;">&quot;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">);</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">ctx</span><span style="color:#999999;">.</span><span style="color:#59873A;">set</span><span style="color:#999999;">(</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">Access-Control-Allow-Methods</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">PUT, POST, GET, DELETE, OPTIONS</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">);</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#1E754F;">if</span><span style="color:#393A34;"> </span><span style="color:#999999;">(</span><span style="color:#B07D48;">ctx</span><span style="color:#999999;">.</span><span style="color:#B07D48;">method</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">==</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">OPTIONS</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#B07D48;">ctx</span><span style="color:#999999;">.</span><span style="color:#B07D48;">body</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">200</span><span style="color:#999999;">;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">}</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">else</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#1E754F;">await</span><span style="color:#393A34;"> </span><span style="color:#59873A;">next</span><span style="color:#999999;">();</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#999999;">});</span></span></code></pre></div><h3 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;Proxy&quot;">​</a></h3><p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保 障网络终端的隐私或安全，防止攻击</p><p><strong>方案一</strong>：平时开发中如果后台没有配置去 CORS，一般会通过脚手架来配置本地代理服务器，通过该服务器转发请求到后台服务，得到结果返回给前端。但是本地代理只是在开发中有效果，最终发布上线时如果 Web 应用和接口服务器不在一起仍会跨域</p><p>以 <code>vue-cli</code> 脚手架为例</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#B8A965;">module</span><span style="color:#666666;">.</span><span style="color:#B8A965;">exports</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#B8A965;">devServer</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#B8A965;">host</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">127.0.0.1</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#B8A965;">port</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4C9A91;">8084</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#B8A965;">open</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">true</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#758575DD;">// vue项目启动时自动打开浏览器</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#B8A965;">proxy</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#DBD7CAEE;">      </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">/api</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#666666;">        </span><span style="color:#758575DD;">// &#39;/api&#39;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span>
<span class="line"><span style="color:#DBD7CAEE;">        </span><span style="color:#B8A965;">target</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">http://xxx.xxx.xx.xx:8080</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#758575DD;">//目标地址，一般是指后台服务器地址</span></span>
<span class="line"><span style="color:#DBD7CAEE;">        </span><span style="color:#B8A965;">changeOrigin</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">true</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#758575DD;">//是否跨域</span></span>
<span class="line"><span style="color:#DBD7CAEE;">        </span><span style="color:#B8A965;">pathRewrite</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#666666;">          </span><span style="color:#758575DD;">// pathRewrite 的作用是把实际Request Url中的&#39;/api&#39;用&quot;&quot;代替</span></span>
<span class="line"><span style="color:#DBD7CAEE;">          </span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">^/api</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">:</span><span style="color:#DBD7CAEE;"> </span><span style="color:#C98A7D99;">&quot;&quot;</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#DBD7CAEE;">        </span><span style="color:#666666;">},</span></span>
<span class="line"><span style="color:#DBD7CAEE;">      </span><span style="color:#666666;">},</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#666666;">},</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">},</span></span>
<span class="line"><span style="color:#666666;">};</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#998418;">module</span><span style="color:#999999;">.</span><span style="color:#998418;">exports</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#998418;">devServer</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#998418;">host</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">127.0.0.1</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#998418;">port</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">8084</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#998418;">open</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">true</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">// vue项目启动时自动打开浏览器</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#998418;">proxy</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">      </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">/api</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">        </span><span style="color:#A0ADA0;">// &#39;/api&#39;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span>
<span class="line"><span style="color:#393A34;">        </span><span style="color:#998418;">target</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">http://xxx.xxx.xx.xx:8080</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">//目标地址，一般是指后台服务器地址</span></span>
<span class="line"><span style="color:#393A34;">        </span><span style="color:#998418;">changeOrigin</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">true</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">//是否跨域</span></span>
<span class="line"><span style="color:#393A34;">        </span><span style="color:#998418;">pathRewrite</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">          </span><span style="color:#A0ADA0;">// pathRewrite 的作用是把实际Request Url中的&#39;/api&#39;用&quot;&quot;代替</span></span>
<span class="line"><span style="color:#393A34;">          </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">^/api</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;&quot;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">        </span><span style="color:#999999;">},</span></span>
<span class="line"><span style="color:#393A34;">      </span><span style="color:#999999;">},</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#999999;">},</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">},</span></span>
<span class="line"><span style="color:#999999;">};</span></span></code></pre></div><p>通过 axios 发送请求中，配置请求的根路径：<code>axios.defaults.baseURL = &#39;/api&#39;</code></p><p><strong>方案二</strong>：通过配置 <code>Nginx</code> 实现反向代理</p><h2 id="_19-自定义指令是什么-应用场景有哪些" tabindex="-1">19. 自定义指令是什么？应用场景有哪些？ <a class="header-anchor" href="#_19-自定义指令是什么-应用场景有哪些" aria-label="Permalink to &quot;19. 自定义指令是什么？应用场景有哪些？&quot;">​</a></h2><p>在 <code>Vue</code> 中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统</p><p>不同的指令可以完成或实现不同的功能，除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令</p><h3 id="如何实现自定义指令" tabindex="-1">如何实现自定义指令 <a class="header-anchor" href="#如何实现自定义指令" aria-label="Permalink to &quot;如何实现自定义指令&quot;">​</a></h3><p>全局注册主要是通过 <code>Vue.directive</code> 方法进行注册。第一个参数是指令名称，第二个参数可以是对象，也可以是一个指令函数</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#758575DD;">// 注册一个全局自定义指令 \`v-focus\`</span></span>
<span class="line"><span style="color:#BD976A;">Vue</span><span style="color:#666666;">.</span><span style="color:#80A665;">directive</span><span style="color:#666666;">(</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">focus</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">,</span><span style="color:#DBD7CAEE;"> </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#758575DD;">// 当被绑定的元素插入到 DOM 中时……</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#80A665;">inserted</span><span style="color:#666666;">: </span><span style="color:#CB7676;">function</span><span style="color:#666666;"> (</span><span style="color:#BD976A;">el</span><span style="color:#666666;">) {</span></span>
<span class="line"><span style="color:#666666;">    </span><span style="color:#758575DD;">// 聚焦元素</span></span>
<span class="line"><span style="color:#666666;">    </span><span style="color:#BD976A;">el</span><span style="color:#666666;">.</span><span style="color:#80A665;">focus</span><span style="color:#666666;">(); </span><span style="color:#758575DD;">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span>
<span class="line"><span style="color:#666666;">  },</span></span>
<span class="line"><span style="color:#666666;">});</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#A0ADA0;">// 注册一个全局自定义指令 \`v-focus\`</span></span>
<span class="line"><span style="color:#B07D48;">Vue</span><span style="color:#999999;">.</span><span style="color:#59873A;">directive</span><span style="color:#999999;">(</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">focus</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#A0ADA0;">// 当被绑定的元素插入到 DOM 中时……</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#59873A;">inserted</span><span style="color:#999999;">: </span><span style="color:#AB5959;">function</span><span style="color:#999999;"> (</span><span style="color:#B07D48;">el</span><span style="color:#999999;">) {</span></span>
<span class="line"><span style="color:#999999;">    </span><span style="color:#A0ADA0;">// 聚焦元素</span></span>
<span class="line"><span style="color:#999999;">    </span><span style="color:#B07D48;">el</span><span style="color:#999999;">.</span><span style="color:#59873A;">focus</span><span style="color:#999999;">(); </span><span style="color:#A0ADA0;">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span>
<span class="line"><span style="color:#999999;">  },</span></span>
<span class="line"><span style="color:#999999;">});</span></span></code></pre></div><p>存在如下钩子函数：</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</li><li><code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</li><li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用</li></ul><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><ul><li>一键 Copy 功能</li><li>权限按钮</li><li>防止表单重复提交</li></ul><h2 id="_20-keepalive-缓存组件" tabindex="-1">20. KeepAlive 缓存组件 <a class="header-anchor" href="#_20-keepalive-缓存组件" aria-label="Permalink to &quot;20. KeepAlive 缓存组件&quot;">​</a></h2><p>KeepAlive 组件是 Vue 官方提供的一个内置组件，在开发过程中使用 KeepAlive 包裹动态组件 Component 时，会将不活动的组件实例缓存起来，不会去销毁它们。这样在进行组件切换过程中会将状态保留在内存中，防止反复创建组件，可以保证组件的活性。</p><p>结合 <code>include</code> 和 <code>exclude</code> 可以明确指定缓存哪些组件或排除缓存指定组件</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">template</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">keep-alive</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#666666;">&lt;</span><span style="color:#FDAEB7;">component</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">:is</span><span style="color:#666666;">=</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">view</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">&gt;&lt;/</span><span style="color:#FDAEB7;">component</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">&lt;/</span><span style="color:#4D9375;">keep-alive</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#666666;">&lt;/</span><span style="color:#4D9375;">template</span><span style="color:#666666;">&gt;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">template</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">keep-alive</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#999999;">&lt;</span><span style="color:#B31D28;">component</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">:is</span><span style="color:#999999;">=</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">view</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">&gt;&lt;/</span><span style="color:#B31D28;">component</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">&lt;/</span><span style="color:#1E754F;">keep-alive</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#999999;">&lt;/</span><span style="color:#1E754F;">template</span><span style="color:#999999;">&gt;</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#758575DD;">&lt;!-- 结合 VueRouter --&gt;</span></span>
<span class="line"><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">template</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">router-view</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">v-slot</span><span style="color:#666666;">=</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">{ Component }</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">keep-alive</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">      </span><span style="color:#666666;">&lt;</span><span style="color:#FDAEB7;">component</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">:is</span><span style="color:#666666;">=</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">Component</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#666666;">&gt;&lt;/</span><span style="color:#FDAEB7;">component</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">    </span><span style="color:#666666;">&lt;/</span><span style="color:#4D9375;">keep-alive</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#666666;">&lt;/</span><span style="color:#4D9375;">router-view</span><span style="color:#666666;">&gt;</span></span>
<span class="line"><span style="color:#666666;">&lt;/</span><span style="color:#4D9375;">template</span><span style="color:#666666;">&gt;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#A0ADA0;">&lt;!-- 结合 VueRouter --&gt;</span></span>
<span class="line"><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">template</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">router-view</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">v-slot</span><span style="color:#999999;">=</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">{ Component }</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">keep-alive</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">      </span><span style="color:#999999;">&lt;</span><span style="color:#B31D28;">component</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">:is</span><span style="color:#999999;">=</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">Component</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">&gt;&lt;/</span><span style="color:#B31D28;">component</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#999999;">&lt;/</span><span style="color:#1E754F;">keep-alive</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">&lt;/</span><span style="color:#1E754F;">router-view</span><span style="color:#999999;">&gt;</span></span>
<span class="line"><span style="color:#999999;">&lt;/</span><span style="color:#1E754F;">template</span><span style="color:#999999;">&gt;</span></span></code></pre></div><p>缓存后如果要获取数据，解决方案有两种：</p><ol><li>通过 <code>beforeRouteEnter</code> 函数，在每次进入路由前做具体操作</li><li>通过 <code>actived</code> 钩子函数，在 KeepAlive 缓存组件被激活的时候，都会执行 <code>actived</code> 钩子函数</li></ol><h2 id="_21-关于首屏加载优化处理" tabindex="-1">21. 关于首屏加载优化处理 <a class="header-anchor" href="#_21-关于首屏加载优化处理" aria-label="Permalink to &quot;21. 关于首屏加载优化处理&quot;">​</a></h2><ol><li>压缩打包后文件体积</li><li>开启 GZIP 压缩（需要服务端支持）</li><li>常用包/库使用 CDN 链接加速</li><li>使用路由懒加载来实现动态加载组件</li><li>资源图片压缩或存放到本地</li><li>尽量使用支持按需导入的包和库</li></ol><h2 id="_22-常见修饰符" tabindex="-1">22. 常见修饰符 <a class="header-anchor" href="#_22-常见修饰符" aria-label="Permalink to &quot;22. 常见修饰符&quot;">​</a></h2><h3 id="事件修饰符" tabindex="-1">事件修饰符 <a class="header-anchor" href="#事件修饰符" aria-label="Permalink to &quot;事件修饰符&quot;">​</a></h3><p><code>.stop</code> 阻止事件冒泡 <code>.prevent</code> 阻止默认事件 <code>.capture</code> 事件捕获 <code>.self</code> 只有当事件是从侦听器绑定的元素本身触发时才触发回调 <code>.once</code> 只触发一次事件 <code>.passive</code> 用于提升性能，告诉浏览器你不需要阻止事件的默认行为</p><h3 id="按键修饰符" tabindex="-1">按键修饰符 <a class="header-anchor" href="#按键修饰符" aria-label="Permalink to &quot;按键修饰符&quot;">​</a></h3><p><code>.enter</code> 回车键 <code>.tab</code> 制表键 <code>.delete</code> (捕获“删除”和“退格”键) <code>.esc</code> ESC 键 <code>.space</code> 空格键 <code>.up</code> 向上箭头键 <code>.down</code> 向下箭头键 <code>.left</code> 向左箭头键 <code>.right</code> 向右箭头键</p><h3 id="表单修饰符" tabindex="-1">表单修饰符 <a class="header-anchor" href="#表单修饰符" aria-label="Permalink to &quot;表单修饰符&quot;">​</a></h3><p><code>.lazy</code> 在 <code>change</code> 事件中同步输入框的值 <code>.number</code> 自动将用户的输入值转为 Number 类型 <code>.trim</code> 自动过滤用户输入的首尾空格</p><h2 id="_23-composition-api-相对于-options-api-的优势" tabindex="-1">23. Composition API 相对于 Options API 的优势 <a class="header-anchor" href="#_23-composition-api-相对于-options-api-的优势" aria-label="Permalink to &quot;23. Composition API 相对于 Options API 的优势&quot;">​</a></h2><ol><li>更好的进行逻辑复用</li><li>更灵活的进行代码组织</li><li>更好的进行类型推导</li><li>更小的生产包体积，可以保证打包后的文件体积更小</li></ol><h2 id="_24-ref-和-reactive-的区别" tabindex="-1">24. Ref 和 Reactive 的区别 <a class="header-anchor" href="#_24-ref-和-reactive-的区别" aria-label="Permalink to &quot;24. Ref 和 Reactive 的区别&quot;">​</a></h2><ol><li>Reactive 参数一般接受对象或数组，是深层次的响应式。Ref 参数一般接收基本数据类型，若 Ref 接收对象为参数，本质上会转变为 Reactive 方法</li><li>在 JS 中访问 Ref 的值需要手动添加 <code>.value</code>，访问 Reactive 不需要</li><li>响应式的底层原理都是 Proxy</li></ol><h2 id="_25-异步组件和动态组件" tabindex="-1">25. 异步组件和动态组件 <a class="header-anchor" href="#_25-异步组件和动态组件" aria-label="Permalink to &quot;25. 异步组件和动态组件&quot;">​</a></h2><p>异步组件：需要异步加载某个组件，一般用于性能优化的时候，可以使用异步组件来实现按需加载。</p><p>动态组件：是 Vue 中一个特殊的 Html 元素：<code>&lt;component&gt;</code>，它拥有一个特殊的 is 属性，属性值可以是 已注册组件的名称 或 一个组件的选项对象，它是用于不同组件之间进行动态切换的。</p><h2 id="_26-vue2-和-vue3-的区别" tabindex="-1">26. Vue2 和 Vue3 的区别 <a class="header-anchor" href="#_26-vue2-和-vue3-的区别" aria-label="Permalink to &quot;26. Vue2 和 Vue3 的区别&quot;">​</a></h2><ol><li><p>响应式系统的实现方式不同</p></li><li><p>Vue2 是选项式 API，Vue3 是组合式 API。在写法上思想上都有很大的变化</p></li><li><p>Vue3 中的 Composition API 使得代码更加的简洁，更加的易读</p></li><li><p>Diff 算法的优化</p></li></ol><div class="tip custom-block"><p class="custom-block-title">Vue2</p><p>Diff 算法就是进行虚拟节点对比，并返回一个 patch 对象，用来存储两个节点不同的地方，最后用 patch 记录的消息去局部更新 Dom。 diff 算法会比较每一个 vnode,而对于一些不参与更新的元素，进行比较是有点消耗性能的。</p></div><div class="tip custom-block"><p class="custom-block-title">Vue3</p><p>快速的 Patch 算法：Diff 算法在初始化的时候会给每个虚拟节点添加一个 patchFlags，patchFlags 就是优化的标识。只会比较 patchFlags 发生变化的 vnode,进行更新视图，对于没有变化的元素做静态标记，在渲染的时候直接复用。</p><p>静态提升：Vue3 在编译阶段通过静态提升来优化虚拟 DOM，将静态节点转化为常量，可以避免在每次渲染时重新创建和比较节点，从而提高渲染性能。</p><p>更快的 Diff 算法：Vue3 对 Diff 算法进行了优化，采用了双端指针的方式来进行比较，从而减少了比较的次数，并且将比较结果缓存到了一个位图数组中，以便下次比较时能够快速地获取之前的比较结果。</p></div><ol start="5"><li>Vue3 支持 Tree-Shaking 可以优化打包后的文件体积，并且有了更好的 TS 类型推导</li></ol><h2 id="_27-v-for-中的-key-值有什么作用" tabindex="-1">27. <code>v-for</code> 中的 Key 值有什么作用 <a class="header-anchor" href="#_27-v-for-中的-key-值有什么作用" aria-label="Permalink to &quot;27. \`v-for\` 中的 Key 值有什么作用&quot;">​</a></h2><p><code>v-for</code> 指令在渲染列表的时候需要给每个 DOM 节点标注 Key 值。其作用是告诉 Vue 每个节点的唯一标识，这样 Vue 在下一次页面渲染的时候就可以精确的判断出每一个的节点，而不是遍历整个 DOM 树，从而提高渲染效率。</p><p>如果发现新旧节点的 Key 值相同，那么就认为是相同的节点，不会再去重新渲染，而是复用之前的 DOM 节点。</p><p>如果发现新旧节点的 Key 值不同，那么就认为是不同的节点，会重新渲染。</p><p>作用：</p><ol><li>减少不必要的节点重渲染，提高渲染效率</li><li>为了更好的复用之前的 DOM 节点，提升性能</li></ol><h2 id="_28-vuex-和-pinia-有什么区别" tabindex="-1">28. Vuex 和 Pinia 有什么区别 <a class="header-anchor" href="#_28-vuex-和-pinia-有什么区别" aria-label="Permalink to &quot;28. Vuex 和 Pinia 有什么区别&quot;">​</a></h2><ol><li>Pinia 没有<code>Mutations</code>的概念，只有<code>states</code>，<code>getters</code>，<code>actions</code>使用它来修改数据</li><li>Pinia 有 TypeScript 的支持，利于开发</li><li>Pinia 也没有<code>Modules</code>的概念，而是映射出为<code>Store</code>概念，每一个 Store 都是通过<code>defineStore</code>生成出来的。</li><li>Pinia 更加轻量级、体积较小</li></ol>`,153),e=[p];function t(c,r,y,i,d,D){return n(),a("div",null,e)}const B=s(l,[["render",t]]);export{u as __pageData,B as default};
