import{_ as t,c as l,o as p,X as a}from"./chunks/framework.12317601.js";const u=JSON.parse('{"title":"网络相关知识","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"notes/网络相关知识.md","filePath":"notes/网络相关知识.md"}'),i={name:"notes/网络相关知识.md"},e=a('<h1 id="网络相关知识" tabindex="-1">网络相关知识 <a class="header-anchor" href="#网络相关知识" aria-label="Permalink to &quot;网络相关知识&quot;">​</a></h1><h2 id="osi-七层模型" tabindex="-1">OSI 七层模型 <a class="header-anchor" href="#osi-七层模型" aria-label="Permalink to &quot;OSI 七层模型&quot;">​</a></h2><p>Open System Interconnection 开放式系统互联模型。是国际标准化组织 ISO 制定的理论模型</p><p>用于描述计算机网络中不同层次和协议以便于理解、设计和管理网络通信</p><p>七层模型：</p><ol><li>物理层（Physical Layer）：</li></ol><p>物理层是网络通信的最底层，它负责定义物理媒介和数据传输的方式，如电压、电流、光信号等。主要任务包括数据的传输、编码和解码、物理拓扑和传输介质的规范等。</p><ol start="2"><li>数据链路层（Data Link Layer）：</li></ol><p>数据链路层负责将数据帧从物理层传递到网络层，并提供数据链路的错误检测和纠正。这一层通常包括了MAC地址的管理，以便识别网络中的设备。</p><ol start="3"><li>网络层（Network Layer）：</li></ol><p>网络层是负责路由和寻址的层次。它决定了数据包的传输路径，处理跨网络的数据传输，以及实现不同网络之间的互联。</p><ol start="4"><li>传输层（Transport Layer）：</li></ol><p>传输层负责端到端的通信，它为数据传输提供了错误检测和纠正、数据分段、流量控制和可靠性。常见的传输层协议包括TCP（传输控制协议）和UDP（用户数据报协议）。</p><ol start="5"><li>会话层（Session Layer）：</li></ol><p>会话层负责建立、管理和终止会话，以确保不同应用程序之间的通信能够协同工作。它处理会话的开始和结束、会话恢复和错误处理。</p><ol start="6"><li>表示层（Presentation Layer）：</li></ol><p>表示层负责数据的编码、加密和解密，以确保数据在不同系统之间的兼容性。它还处理数据的压缩和格式转换等。</p><ol start="7"><li>应用层（Application Layer）：</li></ol><p>应用层是 OSI 模型的最高层，它包括了各种应用程序和服务，如电子邮件、Web浏览、文件传输等。应用层协议定义了应用程序如何与网络通信，并提供了各种应用级别的服务。</p><h2 id="tcp-ip-四层模型" tabindex="-1">TCP/IP 四层模型 <a class="header-anchor" href="#tcp-ip-四层模型" aria-label="Permalink to &quot;TCP/IP 四层模型&quot;">​</a></h2><p>基于 OSI 理论模型建立的实际现实模型</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3fdf7695ea54ca0a509dcbb37afd82c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p><ol><li>链路层（Link Layer）：</li></ol><p>功能：链路层位于底层，负责管理物理网络连接和数据链路的通信。它处理数据帧的传输、物理地址（MAC 地址）的分配和数据的物理传输。</p><p>典型协议：以太网、Wi-Fi、PPP（点对点协议）等。</p><p>设备：交换机、网卡、调制解调器等。</p><p>数据单位：数据帧。</p><ol start="2"><li>网络层（Network Layer）：</li></ol><p>功能：网络层负责数据包的路由和转发，以确定数据包如何从源主机传输到目标主机。它还负责跨越不同网络的通信。</p><p>典型协议：IP（Internet 协议）、ICMP（Internet 控制消息协议）等。</p><p>设备：路由器。</p><p>数据单位：数据包。</p><ol start="3"><li>传输层（Transport Layer）：</li></ol><p>功能：传输层提供端到端的通信，负责数据的可靠传输、错误检测和纠正、流量控制以及多路复用和分解。</p><p>典型协议：TCP（传输控制协议）、UDP（用户数据报协议）等。</p><p>数据单位：段（TCP）和数据报（UDP）。</p><ol start="4"><li>应用层（Application Layer）：</li></ol><p>功能：应用层是网络协议栈的最高层，它包括各种应用程序和服务，负责用户和应用程序之间的通信。这些应用程序包括文件传输、电子邮件、Web 浏览、远程登录等。</p><p>典型协议：HTTP、FTP、SMTP、POP3、SSH 等。</p><p>数据单位：消息、请求和响应等。</p><p>TCP/IP 四层模型是实际网络通信中最常见的模型，它在互联网中广泛使用。不同层次的协议和功能之间的分离有助于更好地理解、设计和维护网络。此外，该模型还为不同厂商的网络设备和应用程序提供了一个通用的框架，以确保它们能够互相兼容和协同工作。</p><h2 id="udp-和-tcp-的区别" tabindex="-1">UDP 和 TCP 的区别 <a class="header-anchor" href="#udp-和-tcp-的区别" aria-label="Permalink to &quot;UDP 和 TCP 的区别&quot;">​</a></h2><p>UDP 的三大特点</p><ol><li>简单，不需要与客户端建立连接所以无需握手</li><li>它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以传给多个人数据</li><li>它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样，它该咋发还怎么发</li></ol><p>UDP 的三大使用场景</p><ol><li>需要资源少，在网络情况比较好的内网，或者对应丢包不敏感的引用</li><li>不需要一对一沟通，建立连接，而是可以广播的应用，谁都可以传给它数据，它也可以传给任何人数据，甚至可以传给多个人数据</li><li>需要处理速度快、延时低，可以容忍少数丢包，但是要去即便网络阻塞，也不能减慢发送速度</li></ol><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠运算，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一、一对多、多对一和多得多的交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小，8 字节</td><td>首部最小 20 字节，最大 60 字节</td></tr><tr><td>适用场景</td><td>适用于实时应用，例如视频会议、直播</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h2 id="get-和-post-的区别" tabindex="-1">GET 和 POST 的区别 <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;GET 和 POST 的区别&quot;">​</a></h2><p>都是HTTP协议的请求方式</p><ol><li>GET 会缓存浏览器，只适用于获取数据</li><li>GET 因为是参数明文展示，所以并不适合传输敏感数据</li><li>GET 请求参数传递根据不同的浏览器而异，有长度的限制</li><li>POST 传输可以将参数放在Payload Body当中，可以传输大量数据</li><li>POST 因为可以将参数放置在请求正文中，所以传输更加安全</li></ol><h2 id="tcp-的三次握手" tabindex="-1">TCP 的三次握手 <a class="header-anchor" href="#tcp-的三次握手" aria-label="Permalink to &quot;TCP 的三次握手&quot;">​</a></h2><p>TCP的三次握手是建立在TPC连接的过程中，用于确保双方的收发能力是否正常</p><p>第一次握手（SYN）：（确保客户端发送能力没问题）</p><ul><li>客户端向服务器发送一个TCP报文，其中设置了SYN标志位</li></ul><p>第二次握手（SYN + ACK）：（确保服务端的接受能力、发送能力没问题）</p><ul><li>服务器接收到客户端的SYN报文后，会回复一个带有SYN和ACK标志位的报文</li></ul><p>第三次握手（ACK）：（确保客户端的接收能力没问题）</p><ul><li>客户端接收到服务器的SYN+ACK报文后，会向服务器发送一个带有ACK标志位的报文</li></ul><p>TCP 在建立连接时，在客户端、服务器上要发送三次请求报文来确保双方的收发能力是否正常</p><h2 id="tcp-的四次挥手" tabindex="-1">TCP 的四次挥手 <a class="header-anchor" href="#tcp-的四次挥手" aria-label="Permalink to &quot;TCP 的四次挥手&quot;">​</a></h2><p>TCP的四次挥手是用于关闭一个已经建立的TCP连接的过程。在数据传输完成后，客户端和服务器希望关闭连接时，就会经历四次挥手的过程，来确保安全的断开连接</p><p>第一次挥手（FIN）：</p><ul><li>关闭连接的一方（通常是客户端）向对方发送一个带有FIN（Finish）标志位的TCP报文</li></ul><p>第二次挥手（ACK）：</p><ul><li>接收到关闭请求的一方（通常是服务器）接收到FIN报文后，会发送一个带有ACK标志位的报文作为确认</li></ul><p>第三次挥手（FIN）：</p><ul><li>接收到确认的一方（通常是服务器）可能会继续发送数据，但当它准备好关闭连接时，会发送一个带有FIN标志位的报文</li></ul><p>第四次挥手（ACK）：</p><ul><li>关闭连接的一方接收到第三次挥手的FIN报文后，会发送一个带有ACK标志位的报文作为确认</li></ul><h2 id="http-介绍" tabindex="-1">HTTP 介绍 <a class="header-anchor" href="#http-介绍" aria-label="Permalink to &quot;HTTP 介绍&quot;">​</a></h2><p><code>HTTP</code> 即超文本传输协议，是实现网络通信的一种<strong>规范</strong></p><p>在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等</p><p>而 HTTP 是一个传输协议，即将数据由 A 传到 B 或将 B 传输到 A，并且 A 与 B 之间能够存放很多第三方，如： A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B</p><p>传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如 HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别</p><p>在实际应用中，HTTP 常被用于在 Web 浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密</p><p>特点如下：</p><ul><li>支持客户/服务器模式（C/S）</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快</li><li>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</li><li>无状态：HTTP 协议无法根据之前的状态进行本次的请求处理</li></ul><h2 id="https-介绍" tabindex="-1">HTTPS 介绍 <a class="header-anchor" href="#https-介绍" aria-label="Permalink to &quot;HTTPS 介绍&quot;">​</a></h2><p>为了保证数据的安全性，让 HTTP 运行在安全的 SSL/TLS 协议上，即 HTTPS = HTTP + SSL/TLS，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的通信提供加密方式</p><p>SSL 协议位于 TCP/IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持</p><p><img src="https://static.vue-js.com/0e409fc0-b20c-11eb-85f6-6fac77c0c9b3.png" alt=""></p><ul><li>首先客户端通过 URL 访问服务器建立 SSL 连接</li><li>服务器接收到客户端的请求后，会将网站支持的证书信息（证书中包含的公钥）传输给客户端</li><li>客户端、服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级</li><li>浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话密码进行加密，并传输给网站</li><li>服务器会利用自己的私钥解密出会话秘钥，与客户端之间的通信</li></ul><h2 id="http-和-https-的区别" tabindex="-1">HTTP 和 HTTPS 的区别 <a class="header-anchor" href="#http-和-https-的区别" aria-label="Permalink to &quot;HTTP 和 HTTPS 的区别&quot;">​</a></h2><ul><li>HTTP 是无状态的超文本传输协议，连接简单，数据是明文传输的，端口默认是 80</li><li>HTTPS 是由 HTTP + SSL/TLS 协议构建的可进行数据加密、身份认证的具有安全性的超文本传输协议，端口默认是 443</li></ul><h2 id="http-1-0-1-1-2-0-的区别" tabindex="-1">HTTP 1.0/1.1/2.0 的区别 <a class="header-anchor" href="#http-1-0-1-1-2-0-的区别" aria-label="Permalink to &quot;HTTP 1.0/1.1/2.0 的区别&quot;">​</a></h2><h3 id="http-1-0" tabindex="-1">HTTP/1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP/1.0&quot;">​</a></h3><p><code>HTTP/1.0</code> 浏览器和服务器只保持短暂的连接，每次请求都需要和服务器建立一个 <code>TCP</code> 连接。请求处理完成后都会断开连接</p><p><img src="https://static.vue-js.com/efff4da0-b93a-11eb-85f6-6fac77c0c9b3.png" alt=""></p><p>例如，解析 <code>HTML</code> 文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接</p><p>最终导致，一个 HTML 文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接，这种形式明显造成了性能上的缺陷</p><p>如果需要建立长连接，需要设置一个非标准的 Connection 字段 <code>Connection: keep-alive</code></p><h3 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h3><p>在 <code>HTTP/1.1</code> 中，默认支持长连接 <code>Connection: keep-alive</code>，即在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟</p><p>建立一次连接，多次请求均由这个连接完成</p><p><img src="https://static.vue-js.com/22db2b90-b93b-11eb-ab90-d9ae814b240d.png" alt=""></p><p>同时，<code>HTTP 1.1</code> 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</p><p>同时，<code>HTTP1.1</code> 在 <code>HTTP1.0</code> 的基础上，增加更多的请求头和响应头来完善的功能，并且还添加了其他的请求方法</p><h3 id="http-2-0" tabindex="-1">HTTP/2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP/2.0&quot;">​</a></h3><p><code>HTTP/2.0</code> 与之前版本相对，性能有很大的提升</p><p><strong>多路复用</strong></p><p><code>HTTP/2.0</code> 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或响应，而且不用按照顺序一一对应，这样就避免了队头堵塞</p><p><img src="https://static.vue-js.com/313f1980-b93b-11eb-85f6-6fac77c0c9b3.png" alt=""></p><p><strong>二进制分帧</strong></p><p><code>HTTP/2.0</code> 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，解析起来更高效</p><p><strong>首部压缩</strong></p><p><code>HTTP/2.0</code> 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</p><p>首部表在 HTTP 的连接存续期内始终存在，由客户端和服务器共同渐进地更新</p><p>例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p><p><img src="https://static.vue-js.com/3c536740-b93b-11eb-ab90-d9ae814b240d.png" alt=""></p><p><strong>服务器推送</strong></p><p>引入服务器推送，服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源</p><p>这种方式非常合适加载静态资源</p><p><img src="https://static.vue-js.com/47130550-b93b-11eb-85f6-6fac77c0c9b3.png" alt=""></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>HTTP/1.0</p><ul><li>浏览器与服务器<strong>只保持短暂的连接</strong>，浏览器的每次请求都需要与服务器建立一个 TCP 连接</li></ul><p>HTTP/1.1</p><ul><li>引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用</li><li>在同一个 TCP 连接里面，客户端可以同时发送多个请求</li><li>虽然允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li><li>新增了一些请求方法、一些请求头和响应头</li></ul><p>HTTP/2.0</p><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><h2 id="浏览器输入-url-后-发送了什么" tabindex="-1">浏览器输入 URL 后，发送了什么 <a class="header-anchor" href="#浏览器输入-url-后-发送了什么" aria-label="Permalink to &quot;浏览器输入 URL 后，发送了什么&quot;">​</a></h2><p><strong>1. URL 解析</strong></p><p>首先判断输入的内容是一个合法的 URL 还是搜索的关键词</p><p><strong>2. DNS 域名解析</strong></p><p>然后通过 DNS 解析获取对应目标服务器的 IP 地址</p><p><img src="https://static.developers.pub/be59d8972d2142bf875d0795291fd204.png" alt=""></p><p><strong>3. TCP/IP 链接</strong></p><p>在确认目标服务器的 IP 地址后，浏览器会与服务器经历三次握手建立 TCP 连接</p><p><strong>4. 发送 HTTP 请求</strong></p><p>建立 TCP 连接后，就可以进行通信，浏览器会发送 HTTP 请求到目标服务器</p><p><strong>5. 响应请求</strong></p><p>服务器接收到浏览器发送的请求后，就会响应请求，对资源进行解析</p><p>在服务器响应之后，由于现在 HTTP 默认开始长连接 Keep-alive，当页面关闭之后，TCP 连接则会经过四次挥手完成断开</p><p><strong>6. 页面渲染</strong></p><p>当浏览器接收到服务器响应的资源后，首先会对资源进行解析</p><ul><li>查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储 cookie，解压 gzip，缓存资源等等</li><li>查看响应头的 Content-Type 的值，根据不同的资源类型采用不同的解析方式</li></ul><p>关于页面渲染简要概述如下：</p><ul><li>解析 HTML，构建 DOM 树</li><li>解析 CSS，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则树，得到一颗 render 渲染树</li><li>通过渲染树进行页面的布局，负责对各元素的尺寸大小、位置进行计算</li><li>绘制渲染树，绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成，显示在屏幕上</li></ul><h2 id="常见的状态码有哪些-使用的场景" tabindex="-1">常见的状态码有哪些，使用的场景 <a class="header-anchor" href="#常见的状态码有哪些-使用的场景" aria-label="Permalink to &quot;常见的状态码有哪些，使用的场景&quot;">​</a></h2><p>HTTP 状态码，用来表示网页服务器超文本传输协议响应状态的 3 位数字代码</p><ul><li>1xx 表示消息：代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</li><li>2xx 表示成功：代表请求已成功被服务器接收、理解、并接受</li><li>3xx 表示重定向：表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</li><li>4xx 表示请求错误：代表了客户端看起来可能发生了错误，妨碍了服务器的处理</li><li>5xx 表示服务器错误：表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</li></ul>',141),o=[e];function r(T,d,c,n,s,P){return p(),l("div",null,o)}const b=t(i,[["render",r]]);export{u as __pageData,b as default};
