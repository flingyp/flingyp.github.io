import{_ as s,c as i,o as e,as as n}from"./chunks/framework.B-x_5eXW.js";const k=JSON.parse('{"title":"高效让Cursor改bug的技巧，彻底解放AI编程生产力","description":"","frontmatter":{},"headers":[],"relativePath":"ai_thinking/高效让Cursor改bug的技巧.md","filePath":"ai_thinking/高效让Cursor改bug的技巧.md","lastUpdated":1755930479000}'),t={name:"ai_thinking/高效让Cursor改bug的技巧.md"};function l(p,a,r,h,o,c){return e(),i("div",null,a[0]||(a[0]=[n(`<h1 id="高效让cursor改bug的技巧-彻底解放ai编程生产力" tabindex="-1">高效让Cursor改bug的技巧，彻底解放AI编程生产力 <a class="header-anchor" href="#高效让cursor改bug的技巧-彻底解放ai编程生产力" aria-label="Permalink to &quot;高效让Cursor改bug的技巧，彻底解放AI编程生产力&quot;">​</a></h1><blockquote><p><a href="https://juejin.cn/post/7515379500152946714" target="_blank" rel="noreferrer">原文内容</a></p></blockquote><h2 id="范围控制-最小化改动-小步快跑" tabindex="-1">范围控制：最小化改动，小步快跑 <a class="header-anchor" href="#范围控制-最小化改动-小步快跑" aria-label="Permalink to &quot;范围控制：最小化改动，小步快跑&quot;">​</a></h2><p>这是必须遵守的核心原则！当AI开始胡乱修改，很可能是你给的自由度太高了。也就是说，AI往往会做太多了。</p><p>限定修改范围：在给AI下达指令时，明确告诉它： “只改动xx文件里的xx部分，不要改动其他地方。” 限制它的“表演欲”，避免它为了解决一个表象问题，大范围修改底层代码，导致整个项目崩溃。</p><p>小步迭代：养成 “小步迭代，完成一个小步骤就保存代码” 的习惯。任何一个微小的、正确的进展，立刻 <code>git commit</code>。这样即使AI后面改崩了，你也能轻松回滚，不至于前功尽弃。</p><p><strong>参考实践：</strong></p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>请只修改 src/components/UserProfile.js 这个文件。具体来说，只在 handleUpdate 函数内部添加逻辑，用于在更新成功后弹出一个提示。绝对不要修改组件的 state 结构或任何其他文件。</span></span></code></pre></div><h2 id="测试先行-用测试用例给ai戴上-紧箍咒" tabindex="-1">测试先行：用测试用例给AI戴上“紧箍咒” <a class="header-anchor" href="#测试先行-用测试用例给ai戴上-紧箍咒" aria-label="Permalink to &quot;测试先行：用测试用例给AI戴上“紧箍咒”&quot;">​</a></h2><p>与其事后亡羊补牢，不如采纳“测试先行”（Test-Driven Development）的开发模式。这招太绝了！</p><p>先为你的功能或Bug修复编写好测试用例，然后把这些测试用例交给Cursor，让它生成代码，直到所有测试通过。这就像给孙悟空戴上紧箍咒，AI的所有修改都必须以通过测试为目标，大大降低了“自由发挥”导致的出错概率。</p><p>测试示例也是直接让AI生成就好了</p><p><strong>参考实践：</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// factorial.test.js</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const factorial = require(&#39;./factorial&#39;);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;calculates the factorial of 5&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  expect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">factorial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toBe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">120</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>请在 factorial.js 文件中实现 factorial 函数，使其能通过这个测试。</span></span></code></pre></div><h2 id="文档驱动-先谋后动-设计文档是-圣经" tabindex="-1">文档驱动：先谋后动，设计文档是“圣经” <a class="header-anchor" href="#文档驱动-先谋后动-设计文档是-圣经" aria-label="Permalink to &quot;文档驱动：先谋后动，设计文档是“圣经”&quot;">​</a></h2><p>很多时候，代码越改越乱，根源在于需求和设计本身就不清晰。专业的做法是先谋后动。</p><p>先规划再编码：在动手前，先把需求、技术栈、UI设计、数据结构等想清楚，形成文档。</p><p>拆分文档：一个非常实用的技巧是，可以把前后端的需求分开写在不同的md文件里，比如frontend.md和backend.md。清晰地列出项目目标、技术栈、要解决的问题、参考文档、项目结构等。这样AI的上下文更清晰，犯错率更低。</p><p>参考实践：</p><p>请根据以下Markdown设计文档，实现一个React的 CharacterCounter 组件：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>### 组件：CharacterCounter</span></span>
<span class="line"><span></span></span>
<span class="line"><span>功能: 实时显示输入框中的字符数和最大字符限制。</span></span>
<span class="line"><span>Props:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- \`maxLength\` (number): 最大允许的字符数。</span></span>
<span class="line"><span>  UI:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1. 一个\`textarea\`输入框。</span></span>
<span class="line"><span>2. 输入框下方显示文本，格式为 \`当前字符数 / maxLength\`。</span></span>
<span class="line"><span>3. 当字符数超过 \`maxLength\` 时，计数文本变为红色。</span></span></code></pre></div><h2 id="规则至上-用-cursor-rules给ai立规矩" tabindex="-1">规则至上：用.cursor/rules给AI立规矩 <a class="header-anchor" href="#规则至上-用-cursor-rules给ai立规矩" aria-label="Permalink to &quot;规则至上：用.cursor/rules给AI立规矩&quot;">​</a></h2><h2 id="持续重构-别让ai的-代码屎山-埋了自己" tabindex="-1">持续重构：别让AI的“代码屎山”埋了自己 <a class="header-anchor" href="#持续重构-别让ai的-代码屎山-埋了自己" aria-label="Permalink to &quot;持续重构：别让AI的“代码屎山”埋了自己&quot;">​</a></h2><h2 id="迭代调试-打不过就-换个姿势-再来" tabindex="-1">迭代调试：打不过就“换个姿势”再来 <a class="header-anchor" href="#迭代调试-打不过就-换个姿势-再来" aria-label="Permalink to &quot;迭代调试：打不过就“换个姿势”再来&quot;">​</a></h2><h2 id="全局视野-让ai-通读全文-再动手" tabindex="-1">全局视野：让AI“通读全文”再动手 <a class="header-anchor" href="#全局视野-让ai-通读全文-再动手" aria-label="Permalink to &quot;全局视野：让AI“通读全文”再动手&quot;">​</a></h2><h2 id="人工审查-你才是最终的-代码守门员" tabindex="-1">人工审查：你才是最终的“代码守门员” <a class="header-anchor" href="#人工审查-你才是最终的-代码守门员" aria-label="Permalink to &quot;人工审查：你才是最终的“代码守门员”&quot;">​</a></h2><h2 id="可视化沟通-一张图胜过千言万语" tabindex="-1">可视化沟通：一张图胜过千言万语 <a class="header-anchor" href="#可视化沟通-一张图胜过千言万语" aria-label="Permalink to &quot;可视化沟通：一张图胜过千言万语&quot;">​</a></h2><h2 id="善用工具-用mcp和context7给ai-实时补课" tabindex="-1">善用工具：用MCP和Context7给AI“实时补课” <a class="header-anchor" href="#善用工具-用mcp和context7给ai-实时补课" aria-label="Permalink to &quot;善用工具：用MCP和Context7给AI“实时补课”&quot;">​</a></h2><h2 id="不当傻瓜-敢于追问-白痴-问题" tabindex="-1">不当傻瓜：敢于追问“白痴”问题 <a class="header-anchor" href="#不当傻瓜-敢于追问-白痴-问题" aria-label="Permalink to &quot;不当傻瓜：敢于追问“白痴”问题&quot;">​</a></h2><h2 id="氪金变强-别在生产力工具上-薅羊毛" tabindex="-1">氪金变强：别在生产力工具上“薅羊毛” <a class="header-anchor" href="#氪金变强-别在生产力工具上-薅羊毛" aria-label="Permalink to &quot;氪金变强：别在生产力工具上“薅羊毛”&quot;">​</a></h2>`,31)]))}const u=s(t,[["render",l]]);export{k as __pageData,u as default};
