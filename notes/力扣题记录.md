# LeetCode Record

## 1518. 换酒问题

链接：https://leetcode.cn/problems/water-bottles

思路：通过 `while` 循环记录每次兑换酒后会剩下的空酒瓶，如果剩下的空酒拼不能换酒则终止循环

```ts
function numWaterBottles(numBottles: number, numExchange: number): number {
  // 第一次兑换的酒瓶
  const firstExchangeBottles = Math.floor(numBottles / numExchange);
  // 第一次兑换后剩下的空酒瓶
  let otherBottles =
    numBottles - firstExchangeBottles * numExchange + firstExchangeBottles;
  // 能喝到的总瓶数
  let allBottles = numBottles + firstExchangeBottles;
  while (otherBottles >= numExchange) {
    // 再次兑换的酒瓶数量
    const exchangeNum = Math.floor(otherBottles / numExchange);
    // 剩下的空酒瓶
    otherBottles = otherBottles - exchangeNum * numExchange + exchangeNum;
    // 更新能喝到的总瓶数
    allBottles = allBottles + exchangeNum;
  }
  return allBottles;
}
```

## 506. 相对名次

链接：https://leetcode.cn/problems/relative-ranks/

思路： 使用 map 将 score 数组进行降序排序，所在下标+1 即名次

```ts
var findRelativeRanks = function (score) {
  const result = new Array(score.length).fill(-1);
  const rankArray = score
    .map((item, index) => {
      return {
        value: item, // 得分
        index: index, // 所在下标
      };
    })
    .sort((a, b) => b.value - a.value);

  rankArray.forEach((item, index) => {
    if (index === 0) {
      result[item.index] = "Gold Medal";
    } else if (index === 1) {
      result[item.index] = "Silver Medal";
    } else if (index === 2) {
      result[item.index] = "Bronze Medal";
    } else {
      // item.index 所在下标
      // index 所在名次
      result[item.index] = (index + 1).toString();
    }
  });

  return result;
};
```

## 605. 种花问题

链接：https://leetcode.cn/problems/can-place-flowers/

思路：通过 While 循环来对数组进行遍历，通过 recordN 和 recordIndex 来记录花种的数量和种的花坛的位置。循环条件是花坛的位置<数组的长度。如果花种的数量 等于 n 代表可以种

```ts
function canPlaceFlowers(flowerbed: number[], n: number): boolean {
  if (flowerbed.length === 1 && flowerbed[0] === 0 && n === 1) {
    return true;
  }

  // 记录已经种下去的花的数量
  let recordN = 0;
  // 记录种花的步 下标
  let recordIndex = 0;

  while (recordIndex < flowerbed.length) {
    if (recordN === n) break;

    const place = flowerbed[recordIndex];
    if (place === 1) {
      recordIndex = recordIndex + 1;
    } else {
      // 可以种植
      // 种植两端的情况
      if (
        (recordIndex === 0 && flowerbed[recordIndex + 1] === 0) ||
        (recordIndex === flowerbed.length - 1 &&
          flowerbed[recordIndex - 1] === 0)
      ) {
        recordN = recordN + 1;
        flowerbed[recordIndex] = 1;
      } else if (
        flowerbed[recordIndex - 1] === 0 &&
        flowerbed[recordIndex + 1] === 0
      ) {
        recordN = recordN + 1;
        flowerbed[recordIndex] = 1;
      }

      recordIndex = recordIndex + 1;
    }
  }

  if (recordN === n) {
    return true;
  }

  return false;
}
```
