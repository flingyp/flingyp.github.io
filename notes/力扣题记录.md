# LeetCode Record

## 1518. 换酒问题

链接：https://leetcode.cn/problems/water-bottles

思路：通过 `while` 循环记录每次兑换酒后会剩下的空酒瓶，如果剩下的空酒拼不能换酒则终止循环

```ts
function numWaterBottles(numBottles: number, numExchange: number): number {
  // 第一次兑换的酒瓶
  const firstExchangeBottles = Math.floor(numBottles / numExchange);
  // 第一次兑换后剩下的空酒瓶
  let otherBottles =
    numBottles - firstExchangeBottles * numExchange + firstExchangeBottles;
  // 能喝到的总瓶数
  let allBottles = numBottles + firstExchangeBottles;
  while (otherBottles >= numExchange) {
    // 再次兑换的酒瓶数量
    const exchangeNum = Math.floor(otherBottles / numExchange);
    // 剩下的空酒瓶
    otherBottles = otherBottles - exchangeNum * numExchange + exchangeNum;
    // 更新能喝到的总瓶数
    allBottles = allBottles + exchangeNum;
  }
  return allBottles;
}
```

## 506. 相对名次

链接：https://leetcode.cn/problems/relative-ranks/

思路： 使用 map 将 score 数组进行降序排序，所在下标+1 即名次

```ts
var findRelativeRanks = function (score) {
  const result = new Array(score.length).fill(-1);
  const rankArray = score
    .map((item, index) => {
      return {
        value: item, // 得分
        index: index, // 所在下标
      };
    })
    .sort((a, b) => b.value - a.value);

  rankArray.forEach((item, index) => {
    if (index === 0) {
      result[item.index] = "Gold Medal";
    } else if (index === 1) {
      result[item.index] = "Silver Medal";
    } else if (index === 2) {
      result[item.index] = "Bronze Medal";
    } else {
      // item.index 所在下标
      // index 所在名次
      result[item.index] = (index + 1).toString();
    }
  });

  return result;
};
```

## 605. 种花问题

链接：https://leetcode.cn/problems/can-place-flowers/

思路：通过 While 循环来对数组进行遍历，通过 recordN 和 recordIndex 来记录花种的数量和种的花坛的位置。循环条件是花坛的位置<数组的长度。如果花种的数量 等于 n 代表可以种

```ts
function canPlaceFlowers(flowerbed: number[], n: number): boolean {
  if (flowerbed.length === 1 && flowerbed[0] === 0 && n === 1) {
    return true;
  }

  // 记录已经种下去的花的数量
  let recordN = 0;
  // 记录种花的步 下标
  let recordIndex = 0;

  while (recordIndex < flowerbed.length) {
    if (recordN === n) break;

    const place = flowerbed[recordIndex];
    if (place === 1) {
      recordIndex = recordIndex + 1;
    } else {
      // 可以种植
      // 种植两端的情况
      if (
        (recordIndex === 0 && flowerbed[recordIndex + 1] === 0) ||
        (recordIndex === flowerbed.length - 1 &&
          flowerbed[recordIndex - 1] === 0)
      ) {
        recordN = recordN + 1;
        flowerbed[recordIndex] = 1;
      } else if (
        flowerbed[recordIndex - 1] === 0 &&
        flowerbed[recordIndex + 1] === 0
      ) {
        recordN = recordN + 1;
        flowerbed[recordIndex] = 1;
      }

      recordIndex = recordIndex + 1;
    }
  }

  if (recordN === n) {
    return true;
  }

  return false;
}
```

## 206. 反转链表

链接：https://leetcode.cn/problems/reverse-linked-list/

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function reverseList(head: ListNode | null): ListNode | null {
  if (!head) return null;
  let pre = null;
  let cur = head;

  while (cur) {
    // 当前节点的下一个节点
    const swap = cur.next;
    // 改变节点的指向 指向上一个节点
    cur.next = pre;
    pre = cur;
    cur = swap;
  }
  return pre;
}
```

## 1800. 最大升序子数组和

思路：遍历数组，有遇到比上一项小的数就代表一个升序子数组的结束，然后通过变量记录最大的升序子数组和，以及上一项升序子数组的和，当前的升序子数组的和。最后变量结束后返回最大的升序子数组和就行。

链接：https://leetcode.cn/problems/maximum-ascending-subarray-sum/description/

```ts
function maxAscendingSum(nums: number[]): number {
  // 存储子升序数组的和
  let sumResult = nums[0];
  let preResult = nums[0];
  let maxSumResult = nums[0];
  // 子升序数组的起始下标和终端下标
  let start,
    end = 0;

  for (let index = 1; index < nums.length; index++) {
    const curNum = nums[index];
    if (curNum > nums[index - 1]) {
      sumResult = sumResult + nums[index];
      end = end + 1;
    } else {
      start = index;
      end = index;

      if (sumResult > maxSumResult) {
        maxSumResult = sumResult;
      }

      preResult = sumResult;
      sumResult = nums[index];
    }
  }

  if (sumResult > maxSumResult) {
    maxSumResult = sumResult;
  }

  return maxSumResult;
}
```

## 258. 各位相加

链接：https://leetcode.cn/problems/add-digits/

```ts
function addDigits(num: number): number {
  if (num === 0) return 0;

  let numberArr = [];
  let handleNum = num;

  while (handleNum >= 10) {
    numberArr = handleNum.toString().split("");

    handleNum = numberArr.reduce(
      (preValue: string | number, curValue: string) => {
        return Number(preValue) + Number(curValue);
      },
      0
    );
  }

  return handleNum;
}
```

## 260. 只出现一次的数字 III

链接：https://leetcode.cn/problems/single-number-iii/

```ts
function singleNumber(nums: number[]): number[] {
  if (nums.length === 2) return nums;

  const result = [];
  const handleNums = nums;

  while (nums.length !== 0) {
    const shiftItem = handleNums.shift()!;

    const isExistIndex = handleNums.indexOf(shiftItem);

    if (isExistIndex !== -1) {
      handleNums.splice(isExistIndex, 1);
    } else {
      result.push(shiftItem);
    }
  }
  return result;
}
```

```ts
function singleNumber(nums: number[]): number[] {
  const set: Set<number> = new Set();
  for (const z of nums) {
    if (set.has(z)) set.delete(z);
    else set.add(z);
  }
  return Array.from(set);
}
```

## 1470. 重新排列数组

链接：https://leetcode.cn/problems/shuffle-the-array/

```typescript
function shuffle(nums: number[], n: number): number[] {
  if (n === 1) return nums;
  const result: number[] = [];
  for (let index = 0; index < n; index++) {
    result.push(nums[index], nums[index + n]);
  }
  return result;
}
```

## 704. 二分查找

思路：利用两个变量来限定查找的范围，判断目标值在左区间还是右区间

链接：https://leetcode.cn/problems/binary-search/

```ts
function search(nums: number[], target: number): number {
  if (nums.length === 1 && nums[0] === target) return 0;
  let leftIndex = 0;
  let rightIndex = nums.length - 1;
  let result = null;

  while (leftIndex < rightIndex) {
    let midIndex = Math.floor((leftIndex + rightIndex) / 2);
    if (nums[midIndex] === target) {
      result = midIndex;
      break;
    } else if (nums[midIndex] < target) {
      leftIndex = midIndex + 1;
    } else if (nums[midIndex] > target) {
      rightIndex = midIndex - 1;
    }
  }

  // 找到目标值了
  if (leftIndex === rightIndex && nums[leftIndex] === target) return leftIndex;

  if (result !== null) return result;

  return -1;
}
```

## 35. 搜索插入位置

思路：二分查找法，不断缩小查找区间，返回严格小于或等于目标元素的下标值

链接：https://leetcode.cn/problems/search-insert-position/

```typescript
function searchInsert(nums: number[], target: number): number {
  let len = nums.length;
  if (len === 0) return 0;
  if (nums[len - 1] < target) return len;

  let leftIndex = 0;
  let rightIndex = len - 1;

  while (leftIndex < rightIndex) {
    let midIndex = Math.floor((leftIndex + rightIndex) / 2);
    // 找到 nums[midIndex] 严格小于目标元素
    // 不断缩小范围比较范围
    if (nums[midIndex] < target) {
      leftIndex = midIndex + 1;
    } else {
      rightIndex = midIndex;
    }
  }
  return leftIndex;
}
```

## 34. 在排序数组中查找元素的第一个位置和最后一个位置

链接：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/

```ts
function searchRange(nums: number[], target: number): number[] {
  let left = 0;
  let right = nums.length - 1;
  const result = [];
  // 寻找左边界
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2);
    if (nums[mid] < target) {
      left = mid + 1;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else if (nums[mid] == target) {
      // 不同的点
      right = mid - 1;
    }
  }
  if (left >= nums.length || nums[left] != target) {
    return [-1, -1];
  }
  result.push(left);
  // 寻找右边界
  left = 0;
  right = nums.length - 1;
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2);
    if (nums[mid] < target) {
      left = mid + 1;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else if (nums[mid] == target) {
      // 不同的点
      left = mid + 1;
    }
  }
  if (right < 0 || nums[right] != target) {
    return [-1, -1];
  }
  result.push(right);

  return result;
}
```
