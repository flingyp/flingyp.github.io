# LeetCode Record

## 1518. 换酒问题

链接：https://leetcode.cn/problems/water-bottles

思路：通过 `while` 循环记录每次兑换酒后会剩下的空酒瓶，如果剩下的空酒拼不能换酒则终止循环

```ts
function numWaterBottles(numBottles: number, numExchange: number): number {
  // 第一次兑换的酒瓶
  const firstExchangeBottles = Math.floor(numBottles / numExchange);
  // 第一次兑换后剩下的空酒瓶
  let otherBottles =
    numBottles - firstExchangeBottles * numExchange + firstExchangeBottles;
  // 能喝到的总瓶数
  let allBottles = numBottles + firstExchangeBottles;
  while (otherBottles >= numExchange) {
    // 再次兑换的酒瓶数量
    const exchangeNum = Math.floor(otherBottles / numExchange);
    // 剩下的空酒瓶
    otherBottles = otherBottles - exchangeNum * numExchange + exchangeNum;
    // 更新能喝到的总瓶数
    allBottles = allBottles + exchangeNum;
  }
  return allBottles;
}
```

## 506. 相对名次

链接：https://leetcode.cn/problems/relative-ranks/

思路： 使用 map 将 score 数组进行降序排序，所在下标+1 即名次

```ts
var findRelativeRanks = function (score) {
  const result = new Array(score.length).fill(-1);
  const rankArray = score
    .map((item, index) => {
      return {
        value: item, // 得分
        index: index, // 所在下标
      };
    })
    .sort((a, b) => b.value - a.value);

  rankArray.forEach((item, index) => {
    if (index === 0) {
      result[item.index] = "Gold Medal";
    } else if (index === 1) {
      result[item.index] = "Silver Medal";
    } else if (index === 2) {
      result[item.index] = "Bronze Medal";
    } else {
      // item.index 所在下标
      // index 所在名次
      result[item.index] = (index + 1).toString();
    }
  });

  return result;
};
```

## 605. 种花问题

链接：https://leetcode.cn/problems/can-place-flowers/

思路：通过 While 循环来对数组进行遍历，通过 recordN 和 recordIndex 来记录花种的数量和种的花坛的位置。循环条件是花坛的位置<数组的长度。如果花种的数量 等于 n 代表可以种

```ts
function canPlaceFlowers(flowerbed: number[], n: number): boolean {
  if (flowerbed.length === 1 && flowerbed[0] === 0 && n === 1) {
    return true;
  }

  // 记录已经种下去的花的数量
  let recordN = 0;
  // 记录种花的步 下标
  let recordIndex = 0;

  while (recordIndex < flowerbed.length) {
    if (recordN === n) break;

    const place = flowerbed[recordIndex];
    if (place === 1) {
      recordIndex = recordIndex + 1;
    } else {
      // 可以种植
      // 种植两端的情况
      if (
        (recordIndex === 0 && flowerbed[recordIndex + 1] === 0) ||
        (recordIndex === flowerbed.length - 1 &&
          flowerbed[recordIndex - 1] === 0)
      ) {
        recordN = recordN + 1;
        flowerbed[recordIndex] = 1;
      } else if (
        flowerbed[recordIndex - 1] === 0 &&
        flowerbed[recordIndex + 1] === 0
      ) {
        recordN = recordN + 1;
        flowerbed[recordIndex] = 1;
      }

      recordIndex = recordIndex + 1;
    }
  }

  if (recordN === n) {
    return true;
  }

  return false;
}
```

## 206. 反转链表

链接：https://leetcode.cn/problems/reverse-linked-list/

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function reverseList(head: ListNode | null): ListNode | null {
  if (!head) return null;
  let pre = null;
  let cur = head;

  while (cur) {
    // 当前节点的下一个节点
    const swap = cur.next;
    // 改变节点的指向 指向上一个节点
    cur.next = pre;
    pre = cur;
    cur = swap;
  }
  return pre;
}
```

## 1800. 最大升序子数组和

思路：遍历数组，有遇到比上一项小的数就代表一个升序子数组的结束，然后通过变量记录最大的升序子数组和，以及上一项升序子数组的和，当前的升序子数组的和。最后变量结束后返回最大的升序子数组和就行。

链接：https://leetcode.cn/problems/maximum-ascending-subarray-sum/description/

```ts
function maxAscendingSum(nums: number[]): number {
  // 存储子升序数组的和
  let sumResult = nums[0];
  let preResult = nums[0];
  let maxSumResult = nums[0];
  // 子升序数组的起始下标和终端下标
  let start,
    end = 0;

  for (let index = 1; index < nums.length; index++) {
    const curNum = nums[index];
    if (curNum > nums[index - 1]) {
      sumResult = sumResult + nums[index];
      end = end + 1;
    } else {
      start = index;
      end = index;

      if (sumResult > maxSumResult) {
        maxSumResult = sumResult;
      }

      preResult = sumResult;
      sumResult = nums[index];
    }
  }

  if (sumResult > maxSumResult) {
    maxSumResult = sumResult;
  }

  return maxSumResult;
}
```

## 258. 各位相加

链接：https://leetcode.cn/problems/add-digits/

```ts
function addDigits(num: number): number {
  if (num === 0) return 0;

  let numberArr = [];
  let handleNum = num;

  while (handleNum >= 10) {
    numberArr = handleNum.toString().split("");

    handleNum = numberArr.reduce(
      (preValue: string | number, curValue: string) => {
        return Number(preValue) + Number(curValue);
      },
      0
    );
  }

  return handleNum;
}
```

## 260. 只出现一次的数字 III

链接：https://leetcode.cn/problems/single-number-iii/

```ts
function singleNumber(nums: number[]): number[] {
  if (nums.length === 2) return nums;

  const result = [];
  const handleNums = nums;

  while (nums.length !== 0) {
    const shiftItem = handleNums.shift()!;

    const isExistIndex = handleNums.indexOf(shiftItem);

    if (isExistIndex !== -1) {
      handleNums.splice(isExistIndex, 1);
    } else {
      result.push(shiftItem);
    }
  }
  return result;
}
```

```ts
function singleNumber(nums: number[]): number[] {
  const set: Set<number> = new Set();
  for (const z of nums) {
    if (set.has(z)) set.delete(z);
    else set.add(z);
  }
  return Array.from(set);
}
```

## 1470. 重新排列数组

链接：https://leetcode.cn/problems/shuffle-the-array/

```typescript
function shuffle(nums: number[], n: number): number[] {
  if (n === 1) return nums;
  const result: number[] = [];
  for (let index = 0; index < n; index++) {
    result.push(nums[index], nums[index + n]);
  }
  return result;
}
```

## 704. 二分查找

思路：利用两个变量来限定查找的范围，判断目标值在左区间还是右区间

链接：https://leetcode.cn/problems/binary-search/

```ts
function search(nums: number[], target: number): number {
  if (nums.length === 1 && nums[0] === target) return 0;
  let leftIndex = 0;
  let rightIndex = nums.length - 1;
  let result = null;

  while (leftIndex < rightIndex) {
    let midIndex = Math.floor((leftIndex + rightIndex) / 2);
    if (nums[midIndex] === target) {
      result = midIndex;
      break;
    } else if (nums[midIndex] < target) {
      leftIndex = midIndex + 1;
    } else if (nums[midIndex] > target) {
      rightIndex = midIndex - 1;
    }
  }

  // 找到目标值了
  if (leftIndex === rightIndex && nums[leftIndex] === target) return leftIndex;

  if (result !== null) return result;

  return -1;
}
```

## 35. 搜索插入位置

思路：二分查找法，不断缩小查找区间，返回严格小于或等于目标元素的下标值

链接：https://leetcode.cn/problems/search-insert-position/

```typescript
function searchInsert(nums: number[], target: number): number {
  let len = nums.length;
  if (len === 0) return 0;
  if (nums[len - 1] < target) return len;

  let leftIndex = 0;
  let rightIndex = len - 1;

  while (leftIndex < rightIndex) {
    let midIndex = Math.floor((leftIndex + rightIndex) / 2);
    // 找到 nums[midIndex] 严格小于目标元素
    // 不断缩小范围比较范围
    if (nums[midIndex] < target) {
      leftIndex = midIndex + 1;
    } else {
      rightIndex = midIndex;
    }
  }
  return leftIndex;
}
```

## 34. 在排序数组中查找元素的第一个位置和最后一个位置

链接：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/

```ts
function searchRange(nums: number[], target: number): number[] {
  let left = 0;
  let right = nums.length - 1;
  const result = [];
  // 寻找左边界
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2);
    if (nums[mid] < target) {
      left = mid + 1;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else if (nums[mid] == target) {
      // 不同的点
      right = mid - 1;
    }
  }
  if (left >= nums.length || nums[left] != target) {
    return [-1, -1];
  }
  result.push(left);
  // 寻找右边界
  left = 0;
  right = nums.length - 1;
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2);
    if (nums[mid] < target) {
      left = mid + 1;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else if (nums[mid] == target) {
      // 不同的点
      left = mid + 1;
    }
  }
  if (right < 0 || nums[right] != target) {
    return [-1, -1];
  }
  result.push(right);

  return result;
}
```

## 70. 爬楼梯

规律： Fn = Fn-1 + Fn-2（N 阶楼梯 = N-1 阶 + N-2 阶）

链接：https://leetcode.cn/problems/climbing-stairs/

```ts
function climbStairs(n: number): number {
  // 1级 1种
  // 2级 2种
  // 3级 3种
  // 4级 5种 （1+1+1+1、+1+2、2+1+1、2+2）
  // 5级 8种 （1+1+1+1+1、1+1+1+2、1+1+2+1、1+2+1+1、 2+1+1+1、1+2+2、2+1+2、2+2+1）
  // n级 Fn = F(n-1) + F(n-2)
  const resultClimbStairs = [0, 1, 2, 3];
  let recordNum = 3;

  if (n <= recordNum) return resultClimbStairs[n];

  while (recordNum !== n) {
    recordNum = recordNum + 1;
    resultClimbStairs[recordNum] =
      resultClimbStairs[recordNum - 1] + resultClimbStairs[recordNum - 2];
  }
  return resultClimbStairs[n];
}
```

## 387. 字符串中的第一个唯一字符

思路：使用 Set 数据结构来分别存放单一字符和重复字符，最后遍历字符串，在遍历完字符串后返回单一字符数组的第一个字符去获取它的下标即可

链接：https://leetcode.cn/problems/first-unique-character-in-a-string/

```typescript
function firstUniqChar(s: string): number {
  // [l, t, c, o ,d,e] l
  // [v,t,c,d,e] o
  // []
  // 以队列数据结构返回第一个
  // 遍历每个字符串，挨个添加至数组中，添加前判断数组中是否存在该字符串，如果存在删除数组的那个字母，不存在添加到队列尾部。直到字符串遍历完成
  const singleChar: Set<string> = new Set();
  const repeatChar: Set<string> = new Set();
  for (let i = 0; i < s.length; i++) {
    const isHave = singleChar.has(s[i]) || repeatChar.has(s[i]);
    if (isHave) {
      // 删除Set字符
      singleChar.delete(s[i]);
      // 添加字符串到重复字符串数据中
      repeatChar.add(s[i]);
    } else {
      singleChar.add(s[i]);
    }
  }
  const resultArr = new Array(...singleChar);
  if (resultArr.length === 0) return -1;
  return s.indexOf(resultArr[0]);
}
```

## 面试题 01.06 字符串压缩

链接：https://leetcode.cn/problems/compress-string-lcci/

```ts
function compressString(S: string): string {
  let compressString = "";
  const recordArr: [string, number] = ["-1", -1];
  const SArr = S.split("");

  for (let i = 0; i < SArr.length; i++) {
    const currentRecordChar = recordArr[0];
    if (currentRecordChar === "-1") {
      recordArr[0] = SArr[i];
      recordArr[1] = 1;
    } else if (currentRecordChar === SArr[i]) {
      recordArr[1] += 1;
    } else {
      compressString += `${recordArr[0]}${recordArr[1]}`;
      recordArr[0] = SArr[i];
      recordArr[1] = 1;
    }
  }
  compressString += `${recordArr[0]}${recordArr[1]}`;
  if (compressString.length >= S.length) return S;
  return compressString;
}
```

## 1832. 判断句子是否为全字母句

链接：https://leetcode.cn/problems/check-if-the-sentence-is-pangram/

```typescript
function checkIfPangram(sentence: string): boolean {
  // ASCII 码 [97, 122]
  // 变量每个字符，获取它们的ASCII码，然后分别存储在Set集合中，最后进行升序排列，去比较它们的长度
  const ASCIISet: Set<number> = new Set();
  for (let i = 0; i < sentence.length; i++) {
    const ASCIICharNum = sentence.charCodeAt(i);
    ASCIISet.add(ASCIICharNum);
  }
  const ASCIIArr = Array.from(ASCIISet);
  const result = ASCIIArr.sort((a, b) => a - b);
  if (result.length === 26) return true;
  return false;
}
```

## 459. 重复的子字符串

链接：https://leetcode.cn/problems/repeated-substring-pattern/

```typescript
function repeatedSubstringPattern(s: string): boolean {
  let recordStr = "";
  for (let i = 0; i < s.length; i++) {
    recordStr += s[i];
    const repeatNum = Math.floor(s.length / recordStr.length);
    // repeatNum === 1 证明字符串遍历到尾了 不需要再去找子字符串了
    if (repeatNum === 1) {
      return false;
    } else if (s === recordStr.repeat(repeatNum)) {
      return true;
    }
  }
  return false;
}
```

## 993. 二叉树的堂兄弟节点

思路：递归遍历，记录连个节点的父节点和节点深度，最后进行比较

链接：https://leetcode.cn/problems/cousins-in-binary-tree/

```typescript
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
interface ResultNode {
  parentNode: TreeNode;
  depth: number;
}

function isCousins(root: TreeNode | null, x: number, y: number): boolean {
  let XResultNode: ResultNode = {
    parentNode: null,
    depth: 0,
  };
  let YResultNode: ResultNode = {
    parentNode: null,
    depth: 0,
  };

  function eachTree(eachNode: TreeNode, parentNode: TreeNode, depth: number) {
    let each = eachNode;
    if (each.val === x) {
      XResultNode.parentNode = parentNode;
      XResultNode.depth = depth;
    }
    if (each.val === y) {
      YResultNode.parentNode = parentNode;
      YResultNode.depth = depth;
    }

    if (each.left) {
      eachTree(each.left, each, depth + 1);
    }
    if (each.right) {
      eachTree(each.right, each, depth + 1);
    }
  }

  eachTree(root, null, 0);
  if (
    XResultNode.depth === YResultNode.depth &&
    XResultNode.parentNode !== YResultNode.parentNode
  )
    return true;
  return false;
}
```

## 989. 数组形式的整数加法

思路：将 k 也转换为 `number[]` 的数组，比较之间谁更大更小，填充数字 0，使得两个数组长度相同。进行 while 循环，从末尾元素两两相加，和大于 10 的数进一位即可

链接：https://leetcode.cn/problems/add-to-array-form-of-integer/

```ts
function addToArrayForm(num: number[], k: number): number[] {
  let kNumArr = k
    .toString()
    .split("")
    .map((item) => Number(item));
  const dif = Math.abs(kNumArr.length - num.length);
  if (kNumArr.length > num.length) {
    num = [...new Array(dif).fill(0), ...num];
  } else if (kNumArr.length < num.length) {
    kNumArr = [...new Array(dif).fill(0), ...kNumArr];
  }
  const result = [];
  let currentIndex = num.length - 1;
  // 是否相加进一位
  let isEnterOne = false;
  while (currentIndex >= 0) {
    let sum = kNumArr[currentIndex] + num[currentIndex];
    // 位数的数 + 1
    if (isEnterOne) sum = sum + 1;
    if (sum >= 10) {
      result[currentIndex] = sum % 10;
      isEnterOne = true;
    } else {
      result[currentIndex] = sum;
      isEnterOne = false;
    }
    currentIndex--;
  }
  // 处理第一位元素相加大于10的情况
  if (isEnterOne) result.unshift(1);
  return result;
}
```

## 剑指 Offer 30. 包含 min 函数的栈

链接：https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/

```ts
class MinStack {
  private minValue: number = null;
  private recordArr: number[] = [];

  constructor() {}

  push(x: number): void {
    // 向 recordArrr 入栈 元素x
    // 并且获取最小值
    if (this.recordArr.length === 0) {
      this.minValue = x;
    } else {
      if (x < this.minValue) this.minValue = x;
    }
    this.recordArr.push(x);
  }

  pop(): void {
    // 删除最后一个元素，重新获取最小值
    const deleteNum = this.recordArr.pop();
    if (deleteNum === this.minValue) {
      const copySortRecordArr = [...this.recordArr].sort((a, b) => a - b);
      this.minValue = copySortRecordArr[0];
    }
  }

  top(): number {
    return this.recordArr[this.recordArr.length - 1];
  }

  min(): number {
    return this.minValue;
  }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.min()
 */
```

## 118. 杨辉三角

链接：https://leetcode.cn/problems/pascals-triangle/

```ts
function generate(numRows: number): number[][] {
  // [1] 1
  // [1,1] 2
  // [1, (2_0, 2_1) , 1] 3
  // [1, (3_0, 3_1), (3_1, 3_2) ,1] 4
  // [1, (4_0, 4_1), (4_1,4_2) , (4_2, 4_3) ,1]
  const resultArr: number[][] = [];

  for (let i = 1; i <= numRows; i++) {
    if (i === 1) {
      resultArr.push([1]);
    } else if (i === 2) {
      resultArr.push([1, 1]);
    } else {
      let rowArr: number[] = new Array(i).fill(-1);
      rowArr = rowArr.map((item, index) => {
        if (index === 0 || index === rowArr.length - 1) return 1;
        return resultArr[i - 2][index - 1] + resultArr[i - 2][index];
      });
      resultArr.push(rowArr);
    }
  }

  return resultArr;
}
```

## 剑指 Offer 63. 股票的最大利润

链接：https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/

```ts
function maxProfit(prices: number[]): number {
  let minPrice = Number.MAX_VALUE;
  let maxProfit = 0;
  for (const price of prices) {
    maxProfit = Math.max(price - minPrice, maxProfit);
    minPrice = Math.min(price, minPrice);
  }
  return maxProfit;
}
```

## 20.有效的括号

链接：https://leetcode.cn/problems/valid-parentheses/

```ts
function isValid(s: string): boolean {
  let stack: any[] = [];
  for (let i = 0; i < s.length; i++) {
    // 如果字符串符号是 ( [ { 则需要先入栈
    const currentChar = s[i];
    if (currentChar == "(" || currentChar === "[" || currentChar === "{") {
      stack.push(currentChar);
    } else {
      // 比对符号
      const getRecentChar = stack[stack.length - 1];
      if (
        (getRecentChar === "(" && currentChar === ")") ||
        (getRecentChar === "{" && currentChar === "}") ||
        (getRecentChar === "[" && currentChar === "]")
      ) {
        // 出栈
        stack.pop();
      } else {
        return false;
      }
    }
  }

  return stack.length === 0;
}
```

## 144. 二叉树的前序遍历

思路：先返回当前节点的值，在向下遍历左子节点、遍历右子节点

链接：https://leetcode.cn/problems/binary-tree-preorder-traversal/

```ts
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function preorderTraversal(root: TreeNode | null): number[] {
  const result: number[] = [];
  function eachNode(node: TreeNode) {
    if (node !== null) {
      result.push(node.val);
      if (node.left) eachNode(node.left);
      if (node.right) eachNode(node.right);
    }
  }
  eachNode(root);
  return result;
}
```

## 94. 二叉树的中序遍历

思路：二叉树的中序遍历是先遍历所有的左子节点然后是根节点最后是遍历所有的右子节点

链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/

```ts
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function inorderTraversal(root: TreeNode | null): number[] {
  if (!root) return [];
  const result: number[] = [];
  function eachNode(node: TreeNode) {
    if (node !== null) {
      if (node.left) eachNode(node.left);
      result.push(node.val);
      if (node.right) eachNode(node.right);
    }
  }
  eachNode(root);
  return result;
}
```

## 145. 二叉树的后续遍历

思路：二叉树的后序遍历是先遍历所有的左子节点和右子节点最后才是自己

链接：https://leetcode.cn/problems/binary-tree-postorder-traversal/

```ts
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function postorderTraversal(root: TreeNode | null): number[] {
  const result: number[] = [];
  function eachNode(node: TreeNode) {
    if (node !== null) {
      if (node.left) eachNode(node.left);
      if (node.right) eachNode(node.right);
      result.push(node.val);
    }
  }
  eachNode(root);
  return result;
}
```

## 232. 用栈实现队列

链接：https://leetcode.cn/problems/implement-queue-using-stacks/

```ts
class MyQueue {
  private recordArr: number[] = [];

  constructor() {}
  // [1,2]
  push(x: number): void {
    this.recordArr.push(x);
  }

  pop(): number {
    return this.recordArr.shift();
  }

  peek(): number {
    return this.recordArr[0];
  }

  empty(): boolean {
    return this.recordArr.length === 0;
  }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

## 71. 简化路径

思路：根据规范路径规则，通过 `.split('/')` 进行分割，遇到 `../` 代表返回上一级，就可以出栈一个文件夹，遇到 `.` 不入栈，其他的文件夹名称进行入栈。最后进行字符串拼接

链接：https://leetcode.cn/problems/simplify-path/

```ts
function simplifyPath(path: string): string {
  const stack: string[] = [];
  let arr = path.split("/");
  // console.log('arr->',arr)
  arr.forEach((item) => {
    // 从根目录向上一级是不可行的，因为根目录是你可以到达的最高级
    // 所以使用 ../ 前的目录文件夹均是无效
    if (item && item === "..") {
      stack.pop();
    } else if (item && item !== ".") {
      stack.push(item);
    }
  });
  // console.log('stack->',stack)

  return stack.length === 0 ? "/" : `/${stack.join("/")}`;
}
```
